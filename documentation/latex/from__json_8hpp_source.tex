\hypertarget{from__json_8hpp_source}{}\doxysection{from\+\_\+json.\+hpp}
\label{from__json_8hpp_source}\index{build/\_deps/json-\/src/include/nlohmann/detail/conversions/from\_json.hpp@{build/\_deps/json-\/src/include/nlohmann/detail/conversions/from\_json.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{2 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{7 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// transform}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <forward\_list>} \textcolor{comment}{// forward\_list}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// inserter, front\_inserter, end}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <map>} \textcolor{comment}{// map}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <tuple>} \textcolor{comment}{// tuple, make\_tuple}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// is\_arithmetic, is\_same, is\_enum, underlying\_type, is\_convertible}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <unordered\_map>} \textcolor{comment}{// unordered\_map}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// pair, declval}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <valarray>} \textcolor{comment}{// valarray}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <nlohmann/detail/meta/identity\_tag.hpp>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <nlohmann/detail/meta/std\_fs.hpp>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{33 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{34 \{}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{37 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} std::nullptr\_t\& n)}
\DoxyCodeLine{38 \{}
\DoxyCodeLine{39     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_null()))}
\DoxyCodeLine{40     \{}
\DoxyCodeLine{41         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be null, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{42     \}}
\DoxyCodeLine{43     n = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{44 \}}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{comment}{// overloads for basic\_json template parameters}}
\DoxyCodeLine{47 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ArithmeticType,}
\DoxyCodeLine{48            enable\_if\_t < std::is\_arithmetic<ArithmeticType>::value\&\&}
\DoxyCodeLine{49                          !std::is\_same<ArithmeticType, typename BasicJsonType::boolean\_t>::value,}
\DoxyCodeLine{50                          \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{51 \textcolor{keywordtype}{void} get\_arithmetic\_value(\textcolor{keyword}{const} BasicJsonType\& j, ArithmeticType\& val)}
\DoxyCodeLine{52 \{}
\DoxyCodeLine{53     \textcolor{keywordflow}{switch} (\textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}\textcolor{keyword}{>}(j))}
\DoxyCodeLine{54     \{}
\DoxyCodeLine{55         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{value\_t::number\_unsigned}}:}
\DoxyCodeLine{56         \{}
\DoxyCodeLine{57             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_unsigned\_t*>());}
\DoxyCodeLine{58             \textcolor{keywordflow}{break};}
\DoxyCodeLine{59         \}}
\DoxyCodeLine{60         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{value\_t::number\_integer}}:}
\DoxyCodeLine{61         \{}
\DoxyCodeLine{62             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_integer\_t*>());}
\DoxyCodeLine{63             \textcolor{keywordflow}{break};}
\DoxyCodeLine{64         \}}
\DoxyCodeLine{65         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{value\_t::number\_float}}:}
\DoxyCodeLine{66         \{}
\DoxyCodeLine{67             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_float\_t*>());}
\DoxyCodeLine{68             \textcolor{keywordflow}{break};}
\DoxyCodeLine{69         \}}
\DoxyCodeLine{70 }
\DoxyCodeLine{71         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{value\_t::null}}:}
\DoxyCodeLine{72         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}}:}
\DoxyCodeLine{73         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}}:}
\DoxyCodeLine{74         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}}:}
\DoxyCodeLine{75         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}:}
\DoxyCodeLine{76         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{value\_t::binary}}:}
\DoxyCodeLine{77         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{value\_t::discarded}}:}
\DoxyCodeLine{78         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{79             JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be number, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{80     \}}
\DoxyCodeLine{81 \}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{84 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::boolean\_t\& b)}
\DoxyCodeLine{85 \{}
\DoxyCodeLine{86     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_boolean()))}
\DoxyCodeLine{87     \{}
\DoxyCodeLine{88         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be boolean, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{89     \}}
\DoxyCodeLine{90     b = *j.template get\_ptr<const typename BasicJsonType::boolean\_t*>();}
\DoxyCodeLine{91 \}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{94 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::string\_t\& s)}
\DoxyCodeLine{95 \{}
\DoxyCodeLine{96     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_string()))}
\DoxyCodeLine{97     \{}
\DoxyCodeLine{98         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be string, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{99     \}}
\DoxyCodeLine{100     s = *j.template get\_ptr<const typename BasicJsonType::string\_t*>();}
\DoxyCodeLine{101 \}}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \textcolor{keyword}{template} <}
\DoxyCodeLine{104     \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} StringType,}
\DoxyCodeLine{105     enable\_if\_t <}
\DoxyCodeLine{106         std::is\_assignable<StringType\&, const typename BasicJsonType::string\_t>::value}
\DoxyCodeLine{107         \&\& is\_detected\_exact<typename BasicJsonType::string\_t::value\_type, value\_type\_t, StringType>::value}
\DoxyCodeLine{108         \&\& !std::is\_same<typename BasicJsonType::string\_t, StringType>::value}
\DoxyCodeLine{109         \&\& !\mbox{\hyperlink{structdetail_1_1is__json__ref}{is\_json\_ref<StringType>::value}}, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{110 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, StringType\& s)}
\DoxyCodeLine{111 \{}
\DoxyCodeLine{112     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_string()))}
\DoxyCodeLine{113     \{}
\DoxyCodeLine{114         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be string, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{115     \}}
\DoxyCodeLine{116 }
\DoxyCodeLine{117     s = *j.template get\_ptr<const typename BasicJsonType::string\_t*>();}
\DoxyCodeLine{118 \}}
\DoxyCodeLine{119 }
\DoxyCodeLine{120 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{121 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_float\_t\& val)}
\DoxyCodeLine{122 \{}
\DoxyCodeLine{123     get\_arithmetic\_value(j, val);}
\DoxyCodeLine{124 \}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{127 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t\& val)}
\DoxyCodeLine{128 \{}
\DoxyCodeLine{129     get\_arithmetic\_value(j, val);}
\DoxyCodeLine{130 \}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{133 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t\& val)}
\DoxyCodeLine{134 \{}
\DoxyCodeLine{135     get\_arithmetic\_value(j, val);}
\DoxyCodeLine{136 \}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138 \textcolor{preprocessor}{\#if !JSON\_DISABLE\_ENUM\_SERIALIZATION}}
\DoxyCodeLine{139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} EnumType,}
\DoxyCodeLine{140          enable\_if\_t<std::is\_enum<EnumType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{141 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, EnumType\& e)}
\DoxyCodeLine{142 \{}
\DoxyCodeLine{143     \textcolor{keyword}{typename} std::underlying\_type<EnumType>::type val;}
\DoxyCodeLine{144     get\_arithmetic\_value(j, val);}
\DoxyCodeLine{145     e = \textcolor{keyword}{static\_cast<}EnumType\textcolor{keyword}{>}(val);}
\DoxyCodeLine{146 \}}
\DoxyCodeLine{147 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_DISABLE\_ENUM\_SERIALIZATION}}
\DoxyCodeLine{148 }
\DoxyCodeLine{149 \textcolor{comment}{// forward\_list doesn't have an insert method}}
\DoxyCodeLine{150 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Allocator,}
\DoxyCodeLine{151          enable\_if\_t<is\_getable<BasicJsonType, T>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{152 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std::forward\_list<T, Allocator>\& l)}
\DoxyCodeLine{153 \{}
\DoxyCodeLine{154     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{155     \{}
\DoxyCodeLine{156         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{157     \}}
\DoxyCodeLine{158     l.clear();}
\DoxyCodeLine{159     std::transform(j.rbegin(), j.rend(),}
\DoxyCodeLine{160                    std::front\_inserter(l), [](\textcolor{keyword}{const} BasicJsonType \& i)}
\DoxyCodeLine{161     \{}
\DoxyCodeLine{162         return i.template get<T>();}
\DoxyCodeLine{163     \});}
\DoxyCodeLine{164 \}}
\DoxyCodeLine{165 }
\DoxyCodeLine{166 \textcolor{comment}{// valarray doesn't have an insert method}}
\DoxyCodeLine{167 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{168          enable\_if\_t<is\_getable<BasicJsonType, T>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{169 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std::valarray<T>\& l)}
\DoxyCodeLine{170 \{}
\DoxyCodeLine{171     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{172     \{}
\DoxyCodeLine{173         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{174     \}}
\DoxyCodeLine{175     l.resize(j.size());}
\DoxyCodeLine{176     std::transform(j.begin(), j.end(), std::begin(l),}
\DoxyCodeLine{177                    [](\textcolor{keyword}{const} BasicJsonType \& elem)}
\DoxyCodeLine{178     \{}
\DoxyCodeLine{179         return elem.template get<T>();}
\DoxyCodeLine{180     \});}
\DoxyCodeLine{181 \}}
\DoxyCodeLine{182 }
\DoxyCodeLine{183 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{184 \textcolor{keyword}{auto} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, T (\&arr)[N])  \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{185 -\/> \textcolor{keyword}{decltype}(j.template get<T>(), void())}
\DoxyCodeLine{186 \{}
\DoxyCodeLine{187     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < N; ++i)}
\DoxyCodeLine{188     \{}
\DoxyCodeLine{189         arr[i] = j.at(i).template get<T>();}
\DoxyCodeLine{190     \}}
\DoxyCodeLine{191 \}}
\DoxyCodeLine{192 }
\DoxyCodeLine{193 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{194 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json\_array\_impl(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::array\_t\& arr, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<3>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{195 \{}
\DoxyCodeLine{196     arr = *j.template get\_ptr<const typename BasicJsonType::array\_t*>();}
\DoxyCodeLine{197 \}}
\DoxyCodeLine{198 }
\DoxyCodeLine{199 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{200 \textcolor{keyword}{auto} from\_json\_array\_impl(\textcolor{keyword}{const} BasicJsonType\& j, std::array<T, N>\& arr,}
\DoxyCodeLine{201                           \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<2>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{202 -\/> \textcolor{keyword}{decltype}(j.template get<T>(), void())}
\DoxyCodeLine{203 \{}
\DoxyCodeLine{204     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < N; ++i)}
\DoxyCodeLine{205     \{}
\DoxyCodeLine{206         arr[i] = j.at(i).template get<T>();}
\DoxyCodeLine{207     \}}
\DoxyCodeLine{208 \}}
\DoxyCodeLine{209 }
\DoxyCodeLine{210 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType,}
\DoxyCodeLine{211          enable\_if\_t<}
\DoxyCodeLine{212              std::is\_assignable<ConstructibleArrayType\&, ConstructibleArrayType>::value,}
\DoxyCodeLine{213              \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{214 \textcolor{keyword}{auto} from\_json\_array\_impl(\textcolor{keyword}{const} BasicJsonType\& j, ConstructibleArrayType\& arr, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<1>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{215 -\/> \textcolor{keyword}{decltype}(}
\DoxyCodeLine{216     arr.reserve(std::declval<typename ConstructibleArrayType::size\_type>()),}
\DoxyCodeLine{217     j.template get<typename ConstructibleArrayType::value\_type>(),}
\DoxyCodeLine{218     void())}
\DoxyCodeLine{219 \{}
\DoxyCodeLine{220     \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{221 }
\DoxyCodeLine{222     ConstructibleArrayType ret;}
\DoxyCodeLine{223     ret.reserve(j.size());}
\DoxyCodeLine{224     std::transform(j.begin(), j.end(),}
\DoxyCodeLine{225                    std::inserter(ret, end(ret)), [](\textcolor{keyword}{const} BasicJsonType \& i)}
\DoxyCodeLine{226     \{}
\DoxyCodeLine{227         \textcolor{comment}{// get<BasicJsonType>() returns *this, this won't call a from\_json}}
\DoxyCodeLine{228         \textcolor{comment}{// method when value\_type is BasicJsonType}}
\DoxyCodeLine{229         \textcolor{keywordflow}{return} i.template get<typename ConstructibleArrayType::value\_type>();}
\DoxyCodeLine{230     \});}
\DoxyCodeLine{231     arr = std::move(ret);}
\DoxyCodeLine{232 \}}
\DoxyCodeLine{233 }
\DoxyCodeLine{234 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType,}
\DoxyCodeLine{235          enable\_if\_t<}
\DoxyCodeLine{236              std::is\_assignable<ConstructibleArrayType\&, ConstructibleArrayType>::value,}
\DoxyCodeLine{237              \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{238 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json\_array\_impl(\textcolor{keyword}{const} BasicJsonType\& j, ConstructibleArrayType\& arr,}
\DoxyCodeLine{239                                  \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<0>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{240 \{}
\DoxyCodeLine{241     \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{242 }
\DoxyCodeLine{243     ConstructibleArrayType ret;}
\DoxyCodeLine{244     std::transform(}
\DoxyCodeLine{245         j.begin(), j.end(), std::inserter(ret, end(ret)),}
\DoxyCodeLine{246         [](\textcolor{keyword}{const} BasicJsonType \& i)}
\DoxyCodeLine{247     \{}
\DoxyCodeLine{248         \textcolor{comment}{// get<BasicJsonType>() returns *this, this won't call a from\_json}}
\DoxyCodeLine{249         \textcolor{comment}{// method when value\_type is BasicJsonType}}
\DoxyCodeLine{250         \textcolor{keywordflow}{return} i.template get<typename ConstructibleArrayType::value\_type>();}
\DoxyCodeLine{251     \});}
\DoxyCodeLine{252     arr = std::move(ret);}
\DoxyCodeLine{253 \}}
\DoxyCodeLine{254 }
\DoxyCodeLine{255 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType,}
\DoxyCodeLine{256            enable\_if\_t <}
\DoxyCodeLine{257                \mbox{\hyperlink{structdetail_1_1is__constructible__array__type}{is\_constructible\_array\_type<BasicJsonType, ConstructibleArrayType>::value}}\&\&}
\DoxyCodeLine{258                !\mbox{\hyperlink{structdetail_1_1is__constructible__object__type}{is\_constructible\_object\_type<BasicJsonType, ConstructibleArrayType>::value}}\&\&}
\DoxyCodeLine{259                !\mbox{\hyperlink{structdetail_1_1is__constructible__string__type}{is\_constructible\_string\_type<BasicJsonType, ConstructibleArrayType>::value}}\&\&}
\DoxyCodeLine{260                !std::is\_same<ConstructibleArrayType, typename BasicJsonType::binary\_t>::value\&\&}
\DoxyCodeLine{261                !\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json<ConstructibleArrayType>::value}},}
\DoxyCodeLine{262                \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{263 \textcolor{keyword}{auto} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, ConstructibleArrayType\& arr)}
\DoxyCodeLine{264 -\/> \textcolor{keyword}{decltype}(from\_json\_array\_impl(j, arr, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<3>}} \{\}),}
\DoxyCodeLine{265 j.template get<typename ConstructibleArrayType::value\_type>(),}
\DoxyCodeLine{266 void())}
\DoxyCodeLine{267 \{}
\DoxyCodeLine{268     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{269     \{}
\DoxyCodeLine{270         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{271     \}}
\DoxyCodeLine{272 }
\DoxyCodeLine{273     from\_json\_array\_impl(j, arr, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<3>}} \{\});}
\DoxyCodeLine{274 \}}
\DoxyCodeLine{275 }
\DoxyCodeLine{276 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::size\_t... Idx >}
\DoxyCodeLine{277 std::array<T, \textcolor{keyword}{sizeof}...(Idx)> from\_json\_inplace\_array\_impl(BasicJsonType\&\& j,}
\DoxyCodeLine{278         \mbox{\hyperlink{structdetail_1_1identity__tag}{identity\_tag}}<std::array<T, \textcolor{keyword}{sizeof}...(Idx)>> \textcolor{comment}{/*unused*/}, \mbox{\hyperlink{structdetail_1_1integer__sequence}{index\_sequence}}<Idx...> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{279 \{}
\DoxyCodeLine{280     \textcolor{keywordflow}{return} \{ \{ std::forward<BasicJsonType>(j).at(Idx).template get<T>()... \} \};}
\DoxyCodeLine{281 \}}
\DoxyCodeLine{282 }
\DoxyCodeLine{283 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N >}
\DoxyCodeLine{284 \textcolor{keyword}{auto} from\_json(BasicJsonType\&\& j, \mbox{\hyperlink{structdetail_1_1identity__tag}{identity\_tag}}<std::array<T, N>> tag)}
\DoxyCodeLine{285 -\/> \textcolor{keyword}{decltype}(from\_json\_inplace\_array\_impl(std::forward<BasicJsonType>(j), tag, make\_index\_sequence<N> \{\}))}
\DoxyCodeLine{286 \{}
\DoxyCodeLine{287     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{288     \{}
\DoxyCodeLine{289         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{290     \}}
\DoxyCodeLine{291 }
\DoxyCodeLine{292     \textcolor{keywordflow}{return} from\_json\_inplace\_array\_impl(std::forward<BasicJsonType>(j), tag, make\_index\_sequence<N> \{\});}
\DoxyCodeLine{293 \}}
\DoxyCodeLine{294 }
\DoxyCodeLine{295 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{296 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::binary\_t\& bin)}
\DoxyCodeLine{297 \{}
\DoxyCodeLine{298     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_binary()))}
\DoxyCodeLine{299     \{}
\DoxyCodeLine{300         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be binary, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{301     \}}
\DoxyCodeLine{302 }
\DoxyCodeLine{303     bin = *j.template get\_ptr<const typename BasicJsonType::binary\_t*>();}
\DoxyCodeLine{304 \}}
\DoxyCodeLine{305 }
\DoxyCodeLine{306 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleObjectType,}
\DoxyCodeLine{307          enable\_if\_t<is\_constructible\_object\_type<BasicJsonType, ConstructibleObjectType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{308 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, ConstructibleObjectType\& obj)}
\DoxyCodeLine{309 \{}
\DoxyCodeLine{310     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_object()))}
\DoxyCodeLine{311     \{}
\DoxyCodeLine{312         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be object, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{313     \}}
\DoxyCodeLine{314 }
\DoxyCodeLine{315     ConstructibleObjectType ret;}
\DoxyCodeLine{316     \textcolor{keyword}{const} \textcolor{keyword}{auto}* inner\_object = j.template get\_ptr<const typename BasicJsonType::object\_t*>();}
\DoxyCodeLine{317     \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} ConstructibleObjectType::value\_type;}
\DoxyCodeLine{318     std::transform(}
\DoxyCodeLine{319         inner\_object-\/>begin(), inner\_object-\/>end(),}
\DoxyCodeLine{320         std::inserter(ret, ret.begin()),}
\DoxyCodeLine{321         [](\textcolor{keyword}{typename} BasicJsonType::object\_t::value\_type \textcolor{keyword}{const} \& p)}
\DoxyCodeLine{322     \{}
\DoxyCodeLine{323         return value\_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped\_type>());}
\DoxyCodeLine{324     \});}
\DoxyCodeLine{325     obj = std::move(ret);}
\DoxyCodeLine{326 \}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328 \textcolor{comment}{// overload for arithmetic types, not chosen for basic\_json template arguments}}
\DoxyCodeLine{329 \textcolor{comment}{// (BooleanType, etc..); note: Is it really necessary to provide explicit}}
\DoxyCodeLine{330 \textcolor{comment}{// overloads for boolean\_t etc. in case of a custom BooleanType which is not}}
\DoxyCodeLine{331 \textcolor{comment}{// an arithmetic type?}}
\DoxyCodeLine{332 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ArithmeticType,}
\DoxyCodeLine{333            enable\_if\_t <}
\DoxyCodeLine{334                std::is\_arithmetic<ArithmeticType>::value\&\&}
\DoxyCodeLine{335                !std::is\_same<ArithmeticType, typename BasicJsonType::number\_unsigned\_t>::value\&\&}
\DoxyCodeLine{336                !std::is\_same<ArithmeticType, typename BasicJsonType::number\_integer\_t>::value\&\&}
\DoxyCodeLine{337                !std::is\_same<ArithmeticType, typename BasicJsonType::number\_float\_t>::value\&\&}
\DoxyCodeLine{338                !std::is\_same<ArithmeticType, typename BasicJsonType::boolean\_t>::value,}
\DoxyCodeLine{339                \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{340 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, ArithmeticType\& val)}
\DoxyCodeLine{341 \{}
\DoxyCodeLine{342     \textcolor{keywordflow}{switch} (\textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}\textcolor{keyword}{>}(j))}
\DoxyCodeLine{343     \{}
\DoxyCodeLine{344         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{value\_t::number\_unsigned}}:}
\DoxyCodeLine{345         \{}
\DoxyCodeLine{346             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_unsigned\_t*>());}
\DoxyCodeLine{347             \textcolor{keywordflow}{break};}
\DoxyCodeLine{348         \}}
\DoxyCodeLine{349         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{value\_t::number\_integer}}:}
\DoxyCodeLine{350         \{}
\DoxyCodeLine{351             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_integer\_t*>());}
\DoxyCodeLine{352             \textcolor{keywordflow}{break};}
\DoxyCodeLine{353         \}}
\DoxyCodeLine{354         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{value\_t::number\_float}}:}
\DoxyCodeLine{355         \{}
\DoxyCodeLine{356             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_float\_t*>());}
\DoxyCodeLine{357             \textcolor{keywordflow}{break};}
\DoxyCodeLine{358         \}}
\DoxyCodeLine{359         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}:}
\DoxyCodeLine{360         \{}
\DoxyCodeLine{361             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::boolean\_t*>());}
\DoxyCodeLine{362             \textcolor{keywordflow}{break};}
\DoxyCodeLine{363         \}}
\DoxyCodeLine{364 }
\DoxyCodeLine{365         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{value\_t::null}}:}
\DoxyCodeLine{366         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}}:}
\DoxyCodeLine{367         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}}:}
\DoxyCodeLine{368         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}}:}
\DoxyCodeLine{369         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{value\_t::binary}}:}
\DoxyCodeLine{370         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{value\_t::discarded}}:}
\DoxyCodeLine{371         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{372             JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be number, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{373     \}}
\DoxyCodeLine{374 \}}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename}... Args, std::size\_t... Idx>}
\DoxyCodeLine{377 std::tuple<Args...> from\_json\_tuple\_impl\_base(BasicJsonType\&\& j, \mbox{\hyperlink{structdetail_1_1integer__sequence}{index\_sequence<Idx...>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{378 \{}
\DoxyCodeLine{379     \textcolor{keywordflow}{return} std::make\_tuple(std::forward<BasicJsonType>(j).at(Idx).\textcolor{keyword}{template} get<Args>()...);}
\DoxyCodeLine{380 \}}
\DoxyCodeLine{381 }
\DoxyCodeLine{382 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{class} A1, \textcolor{keyword}{class} A2 >}
\DoxyCodeLine{383 std::pair<A1, A2> from\_json\_tuple\_impl(BasicJsonType\&\& j, \mbox{\hyperlink{structdetail_1_1identity__tag}{identity\_tag}}<std::pair<A1, A2>> \textcolor{comment}{/*unused*/}, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<0>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{384 \{}
\DoxyCodeLine{385     \textcolor{keywordflow}{return} \{std::forward<BasicJsonType>(j).at(0).template get<A1>(),}
\DoxyCodeLine{386             std::forward<BasicJsonType>(j).at(1).template get<A2>()\};}
\DoxyCodeLine{387 \}}
\DoxyCodeLine{388 }
\DoxyCodeLine{389 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} A1, \textcolor{keyword}{typename} A2>}
\DoxyCodeLine{390 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json\_tuple\_impl(BasicJsonType\&\& j, std::pair<A1, A2>\& p, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<1>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{391 \{}
\DoxyCodeLine{392     p = from\_json\_tuple\_impl(std::forward<BasicJsonType>(j), \mbox{\hyperlink{structdetail_1_1identity__tag}{identity\_tag}}<std::pair<A1, A2>> \{\}, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<0>}} \{\});}
\DoxyCodeLine{393 \}}
\DoxyCodeLine{394 }
\DoxyCodeLine{395 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{396 std::tuple<Args...> from\_json\_tuple\_impl(BasicJsonType\&\& j, \mbox{\hyperlink{structdetail_1_1identity__tag}{identity\_tag}}<std::tuple<Args...>> \textcolor{comment}{/*unused*/}, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<2>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{397 \{}
\DoxyCodeLine{398     \textcolor{keywordflow}{return} from\_json\_tuple\_impl\_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index\_sequence\_for<Args...> \{\});}
\DoxyCodeLine{399 \}}
\DoxyCodeLine{400 }
\DoxyCodeLine{401 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{402 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json\_tuple\_impl(BasicJsonType\&\& j, std::tuple<Args...>\& t, \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<3>}} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{403 \{}
\DoxyCodeLine{404     t = from\_json\_tuple\_impl\_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index\_sequence\_for<Args...> \{\});}
\DoxyCodeLine{405 \}}
\DoxyCodeLine{406 }
\DoxyCodeLine{407 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} TupleRelated>}
\DoxyCodeLine{408 \textcolor{keyword}{auto} from\_json(BasicJsonType\&\& j, TupleRelated\&\& t)}
\DoxyCodeLine{409 -\/> \textcolor{keyword}{decltype}(from\_json\_tuple\_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<3>}} \{\}))}
\DoxyCodeLine{410 \{}
\DoxyCodeLine{411     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{412     \{}
\DoxyCodeLine{413         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{414     \}}
\DoxyCodeLine{415 }
\DoxyCodeLine{416     \textcolor{keywordflow}{return} from\_json\_tuple\_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag<3>}} \{\});}
\DoxyCodeLine{417 \}}
\DoxyCodeLine{418 }
\DoxyCodeLine{419 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} Key, \textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Compare, \textcolor{keyword}{typename} Allocator,}
\DoxyCodeLine{420            \textcolor{keyword}{typename} = enable\_if\_t < !std::is\_constructible <}
\DoxyCodeLine{421                                         \textcolor{keyword}{typename} BasicJsonType::string\_t, Key >::value >>}
\DoxyCodeLine{422 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std::map<Key, Value, Compare, Allocator>\& m)}
\DoxyCodeLine{423 \{}
\DoxyCodeLine{424     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{425     \{}
\DoxyCodeLine{426         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{427     \}}
\DoxyCodeLine{428     m.clear();}
\DoxyCodeLine{429     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& p : j)}
\DoxyCodeLine{430     \{}
\DoxyCodeLine{431         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!p.is\_array()))}
\DoxyCodeLine{432         \{}
\DoxyCodeLine{433             JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, p.type\_name()), \&j));}
\DoxyCodeLine{434         \}}
\DoxyCodeLine{435         m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());}
\DoxyCodeLine{436     \}}
\DoxyCodeLine{437 \}}
\DoxyCodeLine{438 }
\DoxyCodeLine{439 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} Key, \textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Hash, \textcolor{keyword}{typename} KeyEqual, \textcolor{keyword}{typename} Allocator,}
\DoxyCodeLine{440            \textcolor{keyword}{typename} = enable\_if\_t < !std::is\_constructible <}
\DoxyCodeLine{441                                         \textcolor{keyword}{typename} BasicJsonType::string\_t, Key >::value >>}
\DoxyCodeLine{442 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std::unordered\_map<Key, Value, Hash, KeyEqual, Allocator>\& m)}
\DoxyCodeLine{443 \{}
\DoxyCodeLine{444     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{445     \{}
\DoxyCodeLine{446         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{447     \}}
\DoxyCodeLine{448     m.clear();}
\DoxyCodeLine{449     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& p : j)}
\DoxyCodeLine{450     \{}
\DoxyCodeLine{451         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!p.is\_array()))}
\DoxyCodeLine{452         \{}
\DoxyCodeLine{453             JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, p.type\_name()), \&j));}
\DoxyCodeLine{454         \}}
\DoxyCodeLine{455         m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());}
\DoxyCodeLine{456     \}}
\DoxyCodeLine{457 \}}
\DoxyCodeLine{458 }
\DoxyCodeLine{459 \textcolor{preprocessor}{\#if JSON\_HAS\_FILESYSTEM || JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{460 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{461 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std\_fs::path\& p)}
\DoxyCodeLine{462 \{}
\DoxyCodeLine{463     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_string()))}
\DoxyCodeLine{464     \{}
\DoxyCodeLine{465         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be string, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{466     \}}
\DoxyCodeLine{467     p = *j.template get\_ptr<const typename BasicJsonType::string\_t*>();}
\DoxyCodeLine{468 \}}
\DoxyCodeLine{469 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{470 }
\DoxyCodeLine{471 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1from__json__fn}{from\_json\_fn}}}
\DoxyCodeLine{472 \{}
\DoxyCodeLine{473     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{474     \textcolor{keyword}{auto} operator()(\textcolor{keyword}{const} BasicJsonType\& j, T\&\& val) \textcolor{keyword}{const}}
\DoxyCodeLine{475     \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(from\_json(j, std::forward<T>(val))))}
\DoxyCodeLine{476     -\/> \textcolor{keyword}{decltype}(from\_json(j, std::forward<T>(val)))}
\DoxyCodeLine{477     \{}
\DoxyCodeLine{478         \textcolor{keywordflow}{return} from\_json(j, std::forward<T>(val));}
\DoxyCodeLine{479     \}}
\DoxyCodeLine{480 \};}
\DoxyCodeLine{481 }
\DoxyCodeLine{482 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{483 }
\DoxyCodeLine{484 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{488 \textcolor{keyword}{namespace }\textcolor{comment}{// NOLINT(cert-\/dcl59-\/cpp,fuchsia-\/header-\/anon-\/namespaces,google-\/build-\/namespaces)}}
\DoxyCodeLine{489 \{}
\DoxyCodeLine{490 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{491 JSON\_INLINE\_VARIABLE \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto}\& from\_json = \textcolor{comment}{// NOLINT(misc-\/definitions-\/in-\/headers)}}
\DoxyCodeLine{492     \mbox{\hyperlink{structdetail_1_1static__const}{detail::static\_const<detail::from\_json\_fn>::value}};}
\DoxyCodeLine{493 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{494 \}  \textcolor{comment}{// namespace}}
\DoxyCodeLine{495 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{496 }
\DoxyCodeLine{497 NLOHMANN\_JSON\_NAMESPACE\_END}

\end{DoxyCode}
