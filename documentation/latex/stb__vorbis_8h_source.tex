\hypertarget{stb__vorbis_8h_source}{}\doxysection{stb\+\_\+vorbis.\+h}
\label{stb__vorbis_8h_source}\index{build/\_deps/raylib-\/src/src/external/stb\_vorbis.h@{build/\_deps/raylib-\/src/src/external/stb\_vorbis.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Ogg Vorbis audio decoder -\/ v1.14 -\/ public domain}}
\DoxyCodeLine{2 \textcolor{comment}{// http://nothings.org/stb\_vorbis/}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Original version written by Sean Barrett in 2007.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// Originally sponsored by RAD Game Tools. Seeking implementation}}
\DoxyCodeLine{7 \textcolor{comment}{// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,}}
\DoxyCodeLine{8 \textcolor{comment}{// Elias Software, Aras Pranckevicius, and Sean Barrett.}}
\DoxyCodeLine{9 \textcolor{comment}{//}}
\DoxyCodeLine{10 \textcolor{comment}{// LICENSE}}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 \textcolor{comment}{//   See end of file for license information.}}
\DoxyCodeLine{13 \textcolor{comment}{//}}
\DoxyCodeLine{14 \textcolor{comment}{// Limitations:}}
\DoxyCodeLine{15 \textcolor{comment}{//}}
\DoxyCodeLine{16 \textcolor{comment}{//   -\/ floor 0 not supported (used in old ogg vorbis files pre-\/2004)}}
\DoxyCodeLine{17 \textcolor{comment}{//   -\/ lossless sample-\/truncation at beginning ignored}}
\DoxyCodeLine{18 \textcolor{comment}{//   -\/ cannot concatenate multiple vorbis streams}}
\DoxyCodeLine{19 \textcolor{comment}{//   -\/ sample positions are 32-\/bit, limiting seekable 192Khz}}
\DoxyCodeLine{20 \textcolor{comment}{//       files to around 6 hours (Ogg supports 64-\/bit)}}
\DoxyCodeLine{21 \textcolor{comment}{//}}
\DoxyCodeLine{22 \textcolor{comment}{// Feature contributors:}}
\DoxyCodeLine{23 \textcolor{comment}{//    Dougall Johnson (sample-\/exact seeking)}}
\DoxyCodeLine{24 \textcolor{comment}{//}}
\DoxyCodeLine{25 \textcolor{comment}{// Bugfix/warning contributors:}}
\DoxyCodeLine{26 \textcolor{comment}{//    Terje Mathisen     Niklas Frykholm     Andy Hill}}
\DoxyCodeLine{27 \textcolor{comment}{//    Casey Muratori     John Bolton         Gargaj}}
\DoxyCodeLine{28 \textcolor{comment}{//    Laurent Gomila     Marc LeBlanc        Ronny Chevalier}}
\DoxyCodeLine{29 \textcolor{comment}{//    Bernhard Wodo      Evan Balster        alxprd@github}}
\DoxyCodeLine{30 \textcolor{comment}{//    Tom Beaumont       Ingo Leitgeb        Nicolas Guillemot}}
\DoxyCodeLine{31 \textcolor{comment}{//    Phillip Bennefall  Rohit               Thiago Goulart}}
\DoxyCodeLine{32 \textcolor{comment}{//    manxorist@github   saga musix          github:infatum}}
\DoxyCodeLine{33 \textcolor{comment}{//    Timur Gagiev       BareRose}}
\DoxyCodeLine{34 \textcolor{comment}{//}}
\DoxyCodeLine{35 \textcolor{comment}{// Partial history:}}
\DoxyCodeLine{36 \textcolor{comment}{//    1.14    -\/ 2018-\/02-\/11 -\/ delete bogus dealloca usage}}
\DoxyCodeLine{37 \textcolor{comment}{//    1.13    -\/ 2018-\/01-\/29 -\/ fix truncation of last frame (hopefully)}}
\DoxyCodeLine{38 \textcolor{comment}{//    1.12    -\/ 2017-\/11-\/21 -\/ limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files}}
\DoxyCodeLine{39 \textcolor{comment}{//    1.11    -\/ 2017-\/07-\/23 -\/ fix MinGW compilation }}
\DoxyCodeLine{40 \textcolor{comment}{//    1.10    -\/ 2017-\/03-\/03 -\/ more robust seeking; fix negative stbv\_ilog(); clear error in open\_memory}}
\DoxyCodeLine{41 \textcolor{comment}{//    1.09    -\/ 2016-\/04-\/04 -\/ back out 'truncation of last frame' fix from previous version}}
\DoxyCodeLine{42 \textcolor{comment}{//    1.08    -\/ 2016-\/04-\/02 -\/ warnings; setup memory leaks; truncation of last frame}}
\DoxyCodeLine{43 \textcolor{comment}{//    1.07    -\/ 2015-\/01-\/16 -\/ fixes for crashes on invalid files; warning fixes; const}}
\DoxyCodeLine{44 \textcolor{comment}{//    1.06    -\/ 2015-\/08-\/31 -\/ full, correct support for seeking API (Dougall Johnson)}}
\DoxyCodeLine{45 \textcolor{comment}{//                           some crash fixes when out of memory or with corrupt files}}
\DoxyCodeLine{46 \textcolor{comment}{//                           fix some inappropriately signed shifts}}
\DoxyCodeLine{47 \textcolor{comment}{//    1.05    -\/ 2015-\/04-\/19 -\/ don't define \_\_forceinline if it's redundant}}
\DoxyCodeLine{48 \textcolor{comment}{//    1.04    -\/ 2014-\/08-\/27 -\/ fix missing const-\/correct case in API}}
\DoxyCodeLine{49 \textcolor{comment}{//    1.03    -\/ 2014-\/08-\/07 -\/ warning fixes}}
\DoxyCodeLine{50 \textcolor{comment}{//    1.02    -\/ 2014-\/07-\/09 -\/ declare qsort comparison as explicitly \_cdecl in Windows}}
\DoxyCodeLine{51 \textcolor{comment}{//    1.01    -\/ 2014-\/06-\/18 -\/ fix stb\_vorbis\_get\_samples\_float (interleaved was correct)}}
\DoxyCodeLine{52 \textcolor{comment}{//    1.0     -\/ 2014-\/05-\/26 -\/ fix memory leaks; fix warnings; fix bugs in >2-\/channel;}}
\DoxyCodeLine{53 \textcolor{comment}{//                           (API change) report sample rate for decode-\/full-\/file funcs}}
\DoxyCodeLine{54 \textcolor{comment}{//}}
\DoxyCodeLine{55 \textcolor{comment}{// See end of file for full version history.}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 }
\DoxyCodeLine{59 \textcolor{comment}{//}}
\DoxyCodeLine{60 \textcolor{comment}{//  HEADER BEGINS HERE}}
\DoxyCodeLine{61 \textcolor{comment}{//}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#define STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{preprocessor}{\#if defined(STB\_VORBIS\_NO\_CRT) \&\& !defined(STB\_VORBIS\_NO\_STDIO)}}
\DoxyCodeLine{67 \textcolor{preprocessor}{\#define STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{68 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#include <stdio.h>}}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{73 }
\DoxyCodeLine{74 \textcolor{comment}{// NOTE: Added to work with raylib on Android}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#if defined(PLATFORM\_ANDROID)}}
\DoxyCodeLine{76 \textcolor{preprocessor}{    \#include "{}utils.h"{}}  \textcolor{comment}{// Android fopen function map}}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{78 }
\DoxyCodeLine{79 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{80 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_STATIC}}
\DoxyCodeLine{84 \textcolor{preprocessor}{\#define STBVDEF static}}
\DoxyCodeLine{85 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{86 \textcolor{preprocessor}{\#define STBVDEF extern}}
\DoxyCodeLine{87 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{88 }
\DoxyCodeLine{90 }
\DoxyCodeLine{91 \textcolor{comment}{// Individual stb\_vorbis* handles are not thread-\/safe; you cannot decode from}}
\DoxyCodeLine{92 \textcolor{comment}{// them from multiple threads at the same time. However, you can have multiple}}
\DoxyCodeLine{93 \textcolor{comment}{// stb\_vorbis* handles and decode from them independently in multiple thrads.}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 }
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{comment}{// normally stb\_vorbis uses malloc() to allocate memory at startup,}}
\DoxyCodeLine{99 \textcolor{comment}{// and alloca() to allocate temporary memory during a frame on the}}
\DoxyCodeLine{100 \textcolor{comment}{// stack. (Memory consumption will depend on the amount of setup}}
\DoxyCodeLine{101 \textcolor{comment}{// data in the file and how you set the compile flags for speed}}
\DoxyCodeLine{102 \textcolor{comment}{// vs. size. In my test files the maximal-\/size usage is \string~150KB.)}}
\DoxyCodeLine{103 \textcolor{comment}{//}}
\DoxyCodeLine{104 \textcolor{comment}{// You can modify the wrapper functions in the source (stbv\_setup\_malloc,}}
\DoxyCodeLine{105 \textcolor{comment}{// stbv\_setup\_temp\_malloc, temp\_malloc) to change this behavior, or you}}
\DoxyCodeLine{106 \textcolor{comment}{// can use a simpler allocation model: you pass in a buffer from}}
\DoxyCodeLine{107 \textcolor{comment}{// which stb\_vorbis will allocate \_all\_ its memory (including the}}
\DoxyCodeLine{108 \textcolor{comment}{// temp memory). "{}open"{} may fail with a VORBIS\_outofmem if you}}
\DoxyCodeLine{109 \textcolor{comment}{// do not pass in enough data; there is no way to determine how}}
\DoxyCodeLine{110 \textcolor{comment}{// much you do need except to succeed (at which point you can}}
\DoxyCodeLine{111 \textcolor{comment}{// query get\_info to find the exact amount required. yes I know}}
\DoxyCodeLine{112 \textcolor{comment}{// this is lame).}}
\DoxyCodeLine{113 \textcolor{comment}{//}}
\DoxyCodeLine{114 \textcolor{comment}{// If you pass in a non-\/NULL buffer of the type below, allocation}}
\DoxyCodeLine{115 \textcolor{comment}{// will occur from it as described above. Otherwise just pass NULL}}
\DoxyCodeLine{116 \textcolor{comment}{// to use malloc()/alloca()}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{119 \{}
\DoxyCodeLine{120    \textcolor{keywordtype}{char} *alloc\_buffer;}
\DoxyCodeLine{121    \textcolor{keywordtype}{int}   alloc\_buffer\_length\_in\_bytes;}
\DoxyCodeLine{122 \} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}};}
\DoxyCodeLine{123 }
\DoxyCodeLine{124 }
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }stb\_vorbis stb\_vorbis;}
\DoxyCodeLine{128 }
\DoxyCodeLine{129 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{130 \{}
\DoxyCodeLine{131    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sample\_rate;}
\DoxyCodeLine{132    \textcolor{keywordtype}{int} channels;}
\DoxyCodeLine{133 }
\DoxyCodeLine{134    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} setup\_memory\_required;}
\DoxyCodeLine{135    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} setup\_temp\_memory\_required;}
\DoxyCodeLine{136    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} temp\_memory\_required;}
\DoxyCodeLine{137 }
\DoxyCodeLine{138    \textcolor{keywordtype}{int} max\_frame\_size;}
\DoxyCodeLine{139 \} \mbox{\hyperlink{structstb__vorbis__info}{stb\_vorbis\_info}};}
\DoxyCodeLine{140 }
\DoxyCodeLine{141 \textcolor{comment}{// get general information about the file}}
\DoxyCodeLine{142 STBVDEF \mbox{\hyperlink{structstb__vorbis__info}{stb\_vorbis\_info}} stb\_vorbis\_get\_info(stb\_vorbis *f);}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 \textcolor{comment}{// get the last error detected (clears it, too)}}
\DoxyCodeLine{145 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_error(stb\_vorbis *f);}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{comment}{// close an ogg vorbis file and free all memory in use}}
\DoxyCodeLine{148 STBVDEF \textcolor{keywordtype}{void} stb\_vorbis\_close(stb\_vorbis *f);}
\DoxyCodeLine{149 }
\DoxyCodeLine{150 \textcolor{comment}{// this function returns the offset (in samples) from the beginning of the}}
\DoxyCodeLine{151 \textcolor{comment}{// file that will be returned by the next decode, if it is known, or -\/1}}
\DoxyCodeLine{152 \textcolor{comment}{// otherwise. after a flush\_pushdata() call, this may take a while before}}
\DoxyCodeLine{153 \textcolor{comment}{// it becomes valid again.}}
\DoxyCodeLine{154 \textcolor{comment}{// NOT WORKING YET after a seek with PULLDATA API}}
\DoxyCodeLine{155 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_sample\_offset(stb\_vorbis *f);}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{comment}{// returns the current seek point within the file, or offset from the beginning}}
\DoxyCodeLine{158 \textcolor{comment}{// of the memory buffer. In pushdata mode it returns 0.}}
\DoxyCodeLine{159 STBVDEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} stb\_vorbis\_get\_file\_offset(stb\_vorbis *f);}
\DoxyCodeLine{160 }
\DoxyCodeLine{162 }
\DoxyCodeLine{163 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{164 }
\DoxyCodeLine{165 \textcolor{comment}{// this API allows you to get blocks of data from any source and hand}}
\DoxyCodeLine{166 \textcolor{comment}{// them to stb\_vorbis. you have to buffer them; stb\_vorbis will tell}}
\DoxyCodeLine{167 \textcolor{comment}{// you how much it used, and you have to give it the rest next time;}}
\DoxyCodeLine{168 \textcolor{comment}{// and stb\_vorbis may not have enough data to work with and you will}}
\DoxyCodeLine{169 \textcolor{comment}{// need to give it the same data again PLUS more. Note that the Vorbis}}
\DoxyCodeLine{170 \textcolor{comment}{// specification does not bound the size of an individual frame.}}
\DoxyCodeLine{171 }
\DoxyCodeLine{172 STBVDEF stb\_vorbis *stb\_vorbis\_open\_pushdata(}
\DoxyCodeLine{173          \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} * datablock, \textcolor{keywordtype}{int} datablock\_length\_in\_bytes,}
\DoxyCodeLine{174          \textcolor{keywordtype}{int} *datablock\_memory\_consumed\_in\_bytes,}
\DoxyCodeLine{175          \textcolor{keywordtype}{int} *error,}
\DoxyCodeLine{176          \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc\_buffer);}
\DoxyCodeLine{177 \textcolor{comment}{// create a vorbis decoder by passing in the initial data block containing}}
\DoxyCodeLine{178 \textcolor{comment}{//    the ogg\&vorbis headers (you don't need to do parse them, just provide}}
\DoxyCodeLine{179 \textcolor{comment}{//    the first N bytes of the file-\/-\/you're told if it's not enough, see below)}}
\DoxyCodeLine{180 \textcolor{comment}{// on success, returns an stb\_vorbis *, does not set error, returns the amount of}}
\DoxyCodeLine{181 \textcolor{comment}{//    data parsed/consumed on this call in *datablock\_memory\_consumed\_in\_bytes;}}
\DoxyCodeLine{182 \textcolor{comment}{// on failure, returns NULL on error and sets *error, does not change *datablock\_memory\_consumed}}
\DoxyCodeLine{183 \textcolor{comment}{// if returns NULL and *error is VORBIS\_need\_more\_data, then the input block was}}
\DoxyCodeLine{184 \textcolor{comment}{//       incomplete and you need to pass in a larger block from the start of the file}}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_decode\_frame\_pushdata(}
\DoxyCodeLine{187          stb\_vorbis *f,}
\DoxyCodeLine{188          \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *datablock, \textcolor{keywordtype}{int} datablock\_length\_in\_bytes,}
\DoxyCodeLine{189          \textcolor{keywordtype}{int} *channels,             \textcolor{comment}{// place to write number of float * buffers}}
\DoxyCodeLine{190          \textcolor{keywordtype}{float} ***output,           \textcolor{comment}{// place to write float ** array of float * buffers}}
\DoxyCodeLine{191          \textcolor{keywordtype}{int} *samples               \textcolor{comment}{// place to write number of output samples}}
\DoxyCodeLine{192      );}
\DoxyCodeLine{193 \textcolor{comment}{// decode a frame of audio sample data if possible from the passed-\/in data block}}
\DoxyCodeLine{194 \textcolor{comment}{//}}
\DoxyCodeLine{195 \textcolor{comment}{// return value: number of bytes we used from datablock}}
\DoxyCodeLine{196 \textcolor{comment}{//}}
\DoxyCodeLine{197 \textcolor{comment}{// possible cases:}}
\DoxyCodeLine{198 \textcolor{comment}{//     0 bytes used, 0 samples output (need more data)}}
\DoxyCodeLine{199 \textcolor{comment}{//     N bytes used, 0 samples output (resynching the stream, keep going)}}
\DoxyCodeLine{200 \textcolor{comment}{//     N bytes used, M samples output (one frame of data)}}
\DoxyCodeLine{201 \textcolor{comment}{// note that after opening a file, you will ALWAYS get one N-\/bytes,0-\/sample}}
\DoxyCodeLine{202 \textcolor{comment}{// frame, because Vorbis always "{}discards"{} the first frame.}}
\DoxyCodeLine{203 \textcolor{comment}{//}}
\DoxyCodeLine{204 \textcolor{comment}{// Note that on resynch, stb\_vorbis will rarely consume all of the buffer,}}
\DoxyCodeLine{205 \textcolor{comment}{// instead only datablock\_length\_in\_bytes-\/3 or less. This is because it wants}}
\DoxyCodeLine{206 \textcolor{comment}{// to avoid missing parts of a page header if they cross a datablock boundary,}}
\DoxyCodeLine{207 \textcolor{comment}{// without writing state-\/machiney code to record a partial detection.}}
\DoxyCodeLine{208 \textcolor{comment}{//}}
\DoxyCodeLine{209 \textcolor{comment}{// The number of channels returned are stored in *channels (which can be}}
\DoxyCodeLine{210 \textcolor{comment}{// NULL-\/-\/it is always the same as the number of channels reported by}}
\DoxyCodeLine{211 \textcolor{comment}{// get\_info). *output will contain an array of float* buffers, one per}}
\DoxyCodeLine{212 \textcolor{comment}{// channel. In other words, (*output)[0][0] contains the first sample from}}
\DoxyCodeLine{213 \textcolor{comment}{// the first channel, and (*output)[1][0] contains the first sample from}}
\DoxyCodeLine{214 \textcolor{comment}{// the second channel.}}
\DoxyCodeLine{215 }
\DoxyCodeLine{216 STBVDEF \textcolor{keywordtype}{void} stb\_vorbis\_flush\_pushdata(stb\_vorbis *f);}
\DoxyCodeLine{217 \textcolor{comment}{// inform stb\_vorbis that your next datablock will not be contiguous with}}
\DoxyCodeLine{218 \textcolor{comment}{// previous ones (e.g. you've seeked in the data); future attempts to decode}}
\DoxyCodeLine{219 \textcolor{comment}{// frames will cause stb\_vorbis to resynchronize (as noted above), and}}
\DoxyCodeLine{220 \textcolor{comment}{// once it sees a valid Ogg page (typically 4-\/8KB, as large as 64KB), it}}
\DoxyCodeLine{221 \textcolor{comment}{// will begin decoding the \_next\_ frame.}}
\DoxyCodeLine{222 \textcolor{comment}{//}}
\DoxyCodeLine{223 \textcolor{comment}{// if you want to seek using pushdata, you need to seek in your file, then}}
\DoxyCodeLine{224 \textcolor{comment}{// call stb\_vorbis\_flush\_pushdata(), then start calling decoding, then once}}
\DoxyCodeLine{225 \textcolor{comment}{// decoding is returning you data, call stb\_vorbis\_get\_sample\_offset, and}}
\DoxyCodeLine{226 \textcolor{comment}{// if you don't like the result, seek your file again and repeat.}}
\DoxyCodeLine{227 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{228 }
\DoxyCodeLine{229 }
\DoxyCodeLine{231 }
\DoxyCodeLine{232 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_PULLDATA\_API}}
\DoxyCodeLine{233 \textcolor{comment}{// This API assumes stb\_vorbis is allowed to pull data from a source-\/-\/}}
\DoxyCodeLine{234 \textcolor{comment}{// either a block of memory containing the \_entire\_ vorbis stream, or a}}
\DoxyCodeLine{235 \textcolor{comment}{// FILE * that you or it create, or possibly some other reading mechanism}}
\DoxyCodeLine{236 \textcolor{comment}{// if you go modify the source to replace the FILE * case with some kind}}
\DoxyCodeLine{237 \textcolor{comment}{// of callback to your code. (But if you don't support seeking, you may}}
\DoxyCodeLine{238 \textcolor{comment}{// just want to go ahead and use pushdata.)}}
\DoxyCodeLine{239 }
\DoxyCodeLine{240 \textcolor{preprocessor}{\#if !defined(STB\_VORBIS\_NO\_STDIO) \&\& !defined(STB\_VORBIS\_NO\_INTEGER\_CONVERSION)}}
\DoxyCodeLine{241 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_decode\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename, \textcolor{keywordtype}{int} *channels, \textcolor{keywordtype}{int} *sample\_rate, \textcolor{keywordtype}{short} **output);}
\DoxyCodeLine{242 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{243 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{244 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_decode\_memory(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *mem, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} *channels, \textcolor{keywordtype}{int} *sample\_rate, \textcolor{keywordtype}{short} **output);}
\DoxyCodeLine{245 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{246 \textcolor{comment}{// decode an entire file and output the data interleaved into a malloc()ed}}
\DoxyCodeLine{247 \textcolor{comment}{// buffer stored in *output. The return value is the number of samples}}
\DoxyCodeLine{248 \textcolor{comment}{// decoded, or -\/1 if the file could not be opened or was not an ogg vorbis file.}}
\DoxyCodeLine{249 \textcolor{comment}{// When you're done with it, just free() the pointer returned in *output.}}
\DoxyCodeLine{250 }
\DoxyCodeLine{251 STBVDEF stb\_vorbis * stb\_vorbis\_open\_memory(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} len,}
\DoxyCodeLine{252                                   \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc\_buffer);}
\DoxyCodeLine{253 \textcolor{comment}{// create an ogg vorbis decoder from an ogg vorbis stream in memory (note}}
\DoxyCodeLine{254 \textcolor{comment}{// this must be the entire stream!). on failure, returns NULL and sets *error}}
\DoxyCodeLine{255 }
\DoxyCodeLine{256 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{257 STBVDEF stb\_vorbis * stb\_vorbis\_open\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename,}
\DoxyCodeLine{258                                   \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc\_buffer);}
\DoxyCodeLine{259 \textcolor{comment}{// create an ogg vorbis decoder from a filename via fopen(). on failure,}}
\DoxyCodeLine{260 \textcolor{comment}{// returns NULL and sets *error (possibly to VORBIS\_file\_open\_failure).}}
\DoxyCodeLine{261 }
\DoxyCodeLine{262 STBVDEF stb\_vorbis * stb\_vorbis\_open\_file(FILE *f, \textcolor{keywordtype}{int} close\_handle\_on\_close,}
\DoxyCodeLine{263                                   \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc\_buffer);}
\DoxyCodeLine{264 \textcolor{comment}{// create an ogg vorbis decoder from an open FILE *, looking for a stream at}}
\DoxyCodeLine{265 \textcolor{comment}{// the \_current\_ seek point (ftell). on failure, returns NULL and sets *error.}}
\DoxyCodeLine{266 \textcolor{comment}{// note that stb\_vorbis must "{}own"{} this stream; if you seek it in between}}
\DoxyCodeLine{267 \textcolor{comment}{// calls to stb\_vorbis, it will become confused. Morever, if you attempt to}}
\DoxyCodeLine{268 \textcolor{comment}{// perform stb\_vorbis\_seek\_*() operations on this file, it will assume it}}
\DoxyCodeLine{269 \textcolor{comment}{// owns the \_entire\_ rest of the file after the start point. Use the next}}
\DoxyCodeLine{270 \textcolor{comment}{// function, stb\_vorbis\_open\_file\_section(), to limit it.}}
\DoxyCodeLine{271 }
\DoxyCodeLine{272 STBVDEF stb\_vorbis * stb\_vorbis\_open\_file\_section(FILE *f, \textcolor{keywordtype}{int} close\_handle\_on\_close,}
\DoxyCodeLine{273                 \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc\_buffer, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len);}
\DoxyCodeLine{274 \textcolor{comment}{// create an ogg vorbis decoder from an open FILE *, looking for a stream at}}
\DoxyCodeLine{275 \textcolor{comment}{// the \_current\_ seek point (ftell); the stream will be of length 'len' bytes.}}
\DoxyCodeLine{276 \textcolor{comment}{// on failure, returns NULL and sets *error. note that stb\_vorbis must "{}own"{}}}
\DoxyCodeLine{277 \textcolor{comment}{// this stream; if you seek it in between calls to stb\_vorbis, it will become}}
\DoxyCodeLine{278 \textcolor{comment}{// confused.}}
\DoxyCodeLine{279 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_seek\_frame(stb\_vorbis *f, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sample\_number);}
\DoxyCodeLine{282 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_seek(stb\_vorbis *f, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sample\_number);}
\DoxyCodeLine{283 \textcolor{comment}{// these functions seek in the Vorbis file to (approximately) 'sample\_number'.}}
\DoxyCodeLine{284 \textcolor{comment}{// after calling seek\_frame(), the next call to get\_frame\_*() will include}}
\DoxyCodeLine{285 \textcolor{comment}{// the specified sample. after calling stb\_vorbis\_seek(), the next call to}}
\DoxyCodeLine{286 \textcolor{comment}{// stb\_vorbis\_get\_samples\_* will start with the specified sample. If you}}
\DoxyCodeLine{287 \textcolor{comment}{// do not need to seek to EXACTLY the target sample when using get\_samples\_*,}}
\DoxyCodeLine{288 \textcolor{comment}{// you can also use seek\_frame().}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_seek\_start(stb\_vorbis *f);}
\DoxyCodeLine{291 \textcolor{comment}{// this function is equivalent to stb\_vorbis\_seek(f,0)}}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 STBVDEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} stb\_vorbis\_stream\_length\_in\_samples(stb\_vorbis *f);}
\DoxyCodeLine{294 STBVDEF \textcolor{keywordtype}{float}        stb\_vorbis\_stream\_length\_in\_seconds(stb\_vorbis *f);}
\DoxyCodeLine{295 \textcolor{comment}{// these functions return the total length of the vorbis stream}}
\DoxyCodeLine{296 }
\DoxyCodeLine{297 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_frame\_float(stb\_vorbis *f, \textcolor{keywordtype}{int} *channels, \textcolor{keywordtype}{float} ***output);}
\DoxyCodeLine{298 \textcolor{comment}{// decode the next frame and return the number of samples. the number of}}
\DoxyCodeLine{299 \textcolor{comment}{// channels returned are stored in *channels (which can be NULL-\/-\/it is always}}
\DoxyCodeLine{300 \textcolor{comment}{// the same as the number of channels reported by get\_info). *output will}}
\DoxyCodeLine{301 \textcolor{comment}{// contain an array of float* buffers, one per channel. These outputs will}}
\DoxyCodeLine{302 \textcolor{comment}{// be overwritten on the next call to stb\_vorbis\_get\_frame\_*.}}
\DoxyCodeLine{303 \textcolor{comment}{//}}
\DoxyCodeLine{304 \textcolor{comment}{// You generally should not intermix calls to stb\_vorbis\_get\_frame\_*()}}
\DoxyCodeLine{305 \textcolor{comment}{// and stb\_vorbis\_get\_samples\_*(), since the latter calls the former.}}
\DoxyCodeLine{306 }
\DoxyCodeLine{307 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{308 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_frame\_short\_interleaved(stb\_vorbis *f, \textcolor{keywordtype}{int} num\_c, \textcolor{keywordtype}{short} *buffer, \textcolor{keywordtype}{int} num\_shorts);}
\DoxyCodeLine{309 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_frame\_short            (stb\_vorbis *f, \textcolor{keywordtype}{int} num\_c, \textcolor{keywordtype}{short} **buffer, \textcolor{keywordtype}{int} num\_samples);}
\DoxyCodeLine{310 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{311 \textcolor{comment}{// decode the next frame and return the number of *samples* per channel.}}
\DoxyCodeLine{312 \textcolor{comment}{// Note that for interleaved data, you pass in the number of shorts (the}}
\DoxyCodeLine{313 \textcolor{comment}{// size of your array), but the return value is the number of samples per}}
\DoxyCodeLine{314 \textcolor{comment}{// channel, not the total number of samples.}}
\DoxyCodeLine{315 \textcolor{comment}{//}}
\DoxyCodeLine{316 \textcolor{comment}{// The data is coerced to the number of channels you request according to the}}
\DoxyCodeLine{317 \textcolor{comment}{// channel coercion rules (see below). You must pass in the size of your}}
\DoxyCodeLine{318 \textcolor{comment}{// buffer(s) so that stb\_vorbis will not overwrite the end of the buffer.}}
\DoxyCodeLine{319 \textcolor{comment}{// The maximum buffer size needed can be gotten from get\_info(); however,}}
\DoxyCodeLine{320 \textcolor{comment}{// the Vorbis I specification implies an absolute maximum of 4096 samples}}
\DoxyCodeLine{321 \textcolor{comment}{// per channel.}}
\DoxyCodeLine{322 }
\DoxyCodeLine{323 \textcolor{comment}{// Channel coercion rules:}}
\DoxyCodeLine{324 \textcolor{comment}{//    Let M be the number of channels requested, and N the number of channels present,}}
\DoxyCodeLine{325 \textcolor{comment}{//    and Cn be the nth channel; let stereo L be the sum of all L and center channels,}}
\DoxyCodeLine{326 \textcolor{comment}{//    and stereo R be the sum of all R and center channels (channel assignment from the}}
\DoxyCodeLine{327 \textcolor{comment}{//    vorbis spec).}}
\DoxyCodeLine{328 \textcolor{comment}{//        M    N       output}}
\DoxyCodeLine{329 \textcolor{comment}{//        1    k      sum(Ck) for all k}}
\DoxyCodeLine{330 \textcolor{comment}{//        2    *      stereo L, stereo R}}
\DoxyCodeLine{331 \textcolor{comment}{//        k    l      k > l, the first l channels, then 0s}}
\DoxyCodeLine{332 \textcolor{comment}{//        k    l      k <= l, the first k channels}}
\DoxyCodeLine{333 \textcolor{comment}{//    Note that this is not \_good\_ surround etc. mixing at all! It's just so}}
\DoxyCodeLine{334 \textcolor{comment}{//    you get something useful.}}
\DoxyCodeLine{335 }
\DoxyCodeLine{336 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_samples\_float\_interleaved(stb\_vorbis *f, \textcolor{keywordtype}{int} channels, \textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} num\_floats);}
\DoxyCodeLine{337 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_samples\_float(stb\_vorbis *f, \textcolor{keywordtype}{int} channels, \textcolor{keywordtype}{float} **buffer, \textcolor{keywordtype}{int} num\_samples);}
\DoxyCodeLine{338 \textcolor{comment}{// gets num\_samples samples, not necessarily on a frame boundary-\/-\/this requires}}
\DoxyCodeLine{339 \textcolor{comment}{// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.}}
\DoxyCodeLine{340 \textcolor{comment}{// Returns the number of samples stored per channel; it may be less than requested}}
\DoxyCodeLine{341 \textcolor{comment}{// at the end of the file. If there are no more samples in the file, returns 0.}}
\DoxyCodeLine{342 }
\DoxyCodeLine{343 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{344 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_samples\_short\_interleaved(stb\_vorbis *f, \textcolor{keywordtype}{int} channels, \textcolor{keywordtype}{short} *buffer, \textcolor{keywordtype}{int} num\_shorts);}
\DoxyCodeLine{345 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_samples\_short(stb\_vorbis *f, \textcolor{keywordtype}{int} channels, \textcolor{keywordtype}{short} **buffer, \textcolor{keywordtype}{int} num\_samples);}
\DoxyCodeLine{346 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{347 \textcolor{comment}{// gets num\_samples samples, not necessarily on a frame boundary-\/-\/this requires}}
\DoxyCodeLine{348 \textcolor{comment}{// buffering so you have to supply the buffers. Applies the coercion rules above}}
\DoxyCodeLine{349 \textcolor{comment}{// to produce 'channels' channels. Returns the number of samples stored per channel;}}
\DoxyCodeLine{350 \textcolor{comment}{// it may be less than requested at the end of the file. If there are no more}}
\DoxyCodeLine{351 \textcolor{comment}{// samples in the file, returns 0.}}
\DoxyCodeLine{352 }
\DoxyCodeLine{353 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{354 }
\DoxyCodeLine{356 }
\DoxyCodeLine{357 \textcolor{keyword}{enum} STBVorbisError}
\DoxyCodeLine{358 \{}
\DoxyCodeLine{359    VORBIS\_\_no\_error,}
\DoxyCodeLine{360 }
\DoxyCodeLine{361    VORBIS\_need\_more\_data=1,             \textcolor{comment}{// not a real error}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363    VORBIS\_invalid\_api\_mixing,           \textcolor{comment}{// can't mix API modes}}
\DoxyCodeLine{364    VORBIS\_outofmem,                     \textcolor{comment}{// not enough memory}}
\DoxyCodeLine{365    VORBIS\_feature\_not\_supported,        \textcolor{comment}{// uses floor 0}}
\DoxyCodeLine{366    VORBIS\_too\_many\_channels,            \textcolor{comment}{// STB\_VORBIS\_MAX\_CHANNELS is too small}}
\DoxyCodeLine{367    VORBIS\_file\_open\_failure,            \textcolor{comment}{// fopen() failed}}
\DoxyCodeLine{368    VORBIS\_seek\_without\_length,          \textcolor{comment}{// can't seek in unknown-\/length file}}
\DoxyCodeLine{369 }
\DoxyCodeLine{370    VORBIS\_unexpected\_eof=10,            \textcolor{comment}{// file is truncated?}}
\DoxyCodeLine{371    VORBIS\_seek\_invalid,                 \textcolor{comment}{// seek past EOF}}
\DoxyCodeLine{372 }
\DoxyCodeLine{373    \textcolor{comment}{// decoding errors (corrupt/invalid stream) -\/-\/ you probably}}
\DoxyCodeLine{374    \textcolor{comment}{// don't care about the exact details of these}}
\DoxyCodeLine{375 }
\DoxyCodeLine{376    \textcolor{comment}{// vorbis errors:}}
\DoxyCodeLine{377    VORBIS\_invalid\_setup=20,}
\DoxyCodeLine{378    VORBIS\_invalid\_stream,}
\DoxyCodeLine{379 }
\DoxyCodeLine{380    \textcolor{comment}{// ogg errors:}}
\DoxyCodeLine{381    VORBIS\_missing\_capture\_pattern=30,}
\DoxyCodeLine{382    VORBIS\_invalid\_stream\_structure\_version,}
\DoxyCodeLine{383    VORBIS\_continued\_packet\_flag\_invalid,}
\DoxyCodeLine{384    VORBIS\_incorrect\_stream\_serial\_number,}
\DoxyCodeLine{385    VORBIS\_invalid\_first\_page,}
\DoxyCodeLine{386    VORBIS\_bad\_packet\_type,}
\DoxyCodeLine{387    VORBIS\_cant\_find\_last\_page,}
\DoxyCodeLine{388    VORBIS\_seek\_failed}
\DoxyCodeLine{389 \};}
\DoxyCodeLine{390 }
\DoxyCodeLine{391 }
\DoxyCodeLine{392 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{393 \}}
\DoxyCodeLine{394 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{395 }
\DoxyCodeLine{396 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// STB\_VORBIS\_INCLUDE\_STB\_VORBIS\_H}}
\DoxyCodeLine{397 \textcolor{comment}{//}}
\DoxyCodeLine{398 \textcolor{comment}{//  HEADER ENDS HERE}}
\DoxyCodeLine{399 \textcolor{comment}{//}}
\DoxyCodeLine{401 \textcolor{comment}{}}
\DoxyCodeLine{402 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_IMPLEMENTATION}}
\DoxyCodeLine{403 }
\DoxyCodeLine{404 \textcolor{comment}{// global configuration settings (e.g. set these in the project/makefile),}}
\DoxyCodeLine{405 \textcolor{comment}{// or just set them in this file at the top (although ideally the first few}}
\DoxyCodeLine{406 \textcolor{comment}{// should be visible when the header file is compiled too, although it's not}}
\DoxyCodeLine{407 \textcolor{comment}{// crucial)}}
\DoxyCodeLine{408 }
\DoxyCodeLine{409 \textcolor{comment}{// STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{410 \textcolor{comment}{//     does not compile the code for the various stb\_vorbis\_*\_pushdata()}}
\DoxyCodeLine{411 \textcolor{comment}{//     functions}}
\DoxyCodeLine{412 \textcolor{comment}{// \#define STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{413 }
\DoxyCodeLine{414 \textcolor{comment}{// STB\_VORBIS\_NO\_PULLDATA\_API}}
\DoxyCodeLine{415 \textcolor{comment}{//     does not compile the code for the non-\/pushdata APIs}}
\DoxyCodeLine{416 \textcolor{comment}{// \#define STB\_VORBIS\_NO\_PULLDATA\_API}}
\DoxyCodeLine{417 }
\DoxyCodeLine{418 \textcolor{comment}{// STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{419 \textcolor{comment}{//     does not compile the code for the APIs that use FILE *s internally}}
\DoxyCodeLine{420 \textcolor{comment}{//     or externally (implied by STB\_VORBIS\_NO\_PULLDATA\_API)}}
\DoxyCodeLine{421 \textcolor{comment}{// \#define STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{422 }
\DoxyCodeLine{423 \textcolor{comment}{// STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{424 \textcolor{comment}{//     does not compile the code for converting audio sample data from}}
\DoxyCodeLine{425 \textcolor{comment}{//     float to integer (implied by STB\_VORBIS\_NO\_PULLDATA\_API)}}
\DoxyCodeLine{426 \textcolor{comment}{// \#define STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{427 }
\DoxyCodeLine{428 \textcolor{comment}{// STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT}}
\DoxyCodeLine{429 \textcolor{comment}{//      does not use a fast float-\/to-\/int trick to accelerate float-\/to-\/int on}}
\DoxyCodeLine{430 \textcolor{comment}{//      most platforms which requires endianness be defined correctly.}}
\DoxyCodeLine{431 \textcolor{comment}{// \#define STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433 }
\DoxyCodeLine{434 \textcolor{comment}{// STB\_VORBIS\_MAX\_CHANNELS [number]}}
\DoxyCodeLine{435 \textcolor{comment}{//     globally define this to the maximum number of channels you need.}}
\DoxyCodeLine{436 \textcolor{comment}{//     The spec does not put a restriction on channels except that}}
\DoxyCodeLine{437 \textcolor{comment}{//     the count is stored in a byte, so 255 is the hard limit.}}
\DoxyCodeLine{438 \textcolor{comment}{//     Reducing this saves about 16 bytes per value, so using 16 saves}}
\DoxyCodeLine{439 \textcolor{comment}{//     (255-\/16)*16 or around 4KB. Plus anything other memory usage}}
\DoxyCodeLine{440 \textcolor{comment}{//     I forgot to account for. Can probably go as low as 8 (7.1 audio),}}
\DoxyCodeLine{441 \textcolor{comment}{//     6 (5.1 audio), or 2 (stereo only).}}
\DoxyCodeLine{442 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_MAX\_CHANNELS}}
\DoxyCodeLine{443 \textcolor{preprocessor}{\#define STB\_VORBIS\_MAX\_CHANNELS    16  }\textcolor{comment}{// enough for anyone?}}
\DoxyCodeLine{444 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{445 }
\DoxyCodeLine{446 \textcolor{comment}{// STB\_VORBIS\_PUSHDATA\_CRC\_COUNT [number]}}
\DoxyCodeLine{447 \textcolor{comment}{//     after a flush\_pushdata(), stb\_vorbis begins scanning for the}}
\DoxyCodeLine{448 \textcolor{comment}{//     next valid page, without backtracking. when it finds something}}
\DoxyCodeLine{449 \textcolor{comment}{//     that looks like a page, it streams through it and verifies its}}
\DoxyCodeLine{450 \textcolor{comment}{//     CRC32. Should that validation fail, it keeps scanning. But it's}}
\DoxyCodeLine{451 \textcolor{comment}{//     possible that \_while\_ streaming through to check the CRC32 of}}
\DoxyCodeLine{452 \textcolor{comment}{//     one candidate page, it sees another candidate page. This \#define}}
\DoxyCodeLine{453 \textcolor{comment}{//     determines how many "{}overlapping"{} candidate pages it can search}}
\DoxyCodeLine{454 \textcolor{comment}{//     at once. Note that "{}real"{} pages are typically \string~4KB to \string~8KB, whereas}}
\DoxyCodeLine{455 \textcolor{comment}{//     garbage pages could be as big as 64KB, but probably average \string~16KB.}}
\DoxyCodeLine{456 \textcolor{comment}{//     So don't hose ourselves by scanning an apparent 64KB page and}}
\DoxyCodeLine{457 \textcolor{comment}{//     missing a ton of real ones in the interim; so minimum of 2}}
\DoxyCodeLine{458 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_PUSHDATA\_CRC\_COUNT}}
\DoxyCodeLine{459 \textcolor{preprocessor}{\#define STB\_VORBIS\_PUSHDATA\_CRC\_COUNT  4}}
\DoxyCodeLine{460 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462 \textcolor{comment}{// STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH [number]}}
\DoxyCodeLine{463 \textcolor{comment}{//     sets the log size of the huffman-\/acceleration table.  Maximum}}
\DoxyCodeLine{464 \textcolor{comment}{//     supported value is 24. with larger numbers, more decodings are O(1),}}
\DoxyCodeLine{465 \textcolor{comment}{//     but the table size is larger so worse cache missing, so you'll have}}
\DoxyCodeLine{466 \textcolor{comment}{//     to probe (and try multiple ogg vorbis files) to find the sweet spot.}}
\DoxyCodeLine{467 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH}}
\DoxyCodeLine{468 \textcolor{preprocessor}{\#define STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH   10}}
\DoxyCodeLine{469 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{470 }
\DoxyCodeLine{471 \textcolor{comment}{// STB\_VORBIS\_FAST\_BINARY\_LENGTH [number]}}
\DoxyCodeLine{472 \textcolor{comment}{//     sets the log size of the binary-\/search acceleration table. this}}
\DoxyCodeLine{473 \textcolor{comment}{//     is used in similar fashion to the fast-\/huffman size to set initial}}
\DoxyCodeLine{474 \textcolor{comment}{//     parameters for the binary search}}
\DoxyCodeLine{475 }
\DoxyCodeLine{476 \textcolor{comment}{// STB\_VORBIS\_FAST\_HUFFMAN\_INT}}
\DoxyCodeLine{477 \textcolor{comment}{//     The fast huffman tables are much more efficient if they can be}}
\DoxyCodeLine{478 \textcolor{comment}{//     stored as 16-\/bit results instead of 32-\/bit results. This restricts}}
\DoxyCodeLine{479 \textcolor{comment}{//     the codebooks to having only 65535 possible outcomes, though.}}
\DoxyCodeLine{480 \textcolor{comment}{//     (At least, accelerated by the huffman table.)}}
\DoxyCodeLine{481 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_FAST\_HUFFMAN\_INT}}
\DoxyCodeLine{482 \textcolor{preprocessor}{\#define STB\_VORBIS\_FAST\_HUFFMAN\_SHORT}}
\DoxyCodeLine{483 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{484 }
\DoxyCodeLine{485 \textcolor{comment}{// STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH}}
\DoxyCodeLine{486 \textcolor{comment}{//     If the 'fast huffman' search doesn't succeed, then stb\_vorbis falls}}
\DoxyCodeLine{487 \textcolor{comment}{//     back on binary searching for the correct one. This requires storing}}
\DoxyCodeLine{488 \textcolor{comment}{//     extra tables with the huffman codes in sorted order. Defining this}}
\DoxyCodeLine{489 \textcolor{comment}{//     symbol trades off space for speed by forcing a linear search in the}}
\DoxyCodeLine{490 \textcolor{comment}{//     non-\/fast case, except for "{}sparse"{} codebooks.}}
\DoxyCodeLine{491 \textcolor{comment}{// \#define STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH}}
\DoxyCodeLine{492 }
\DoxyCodeLine{493 \textcolor{comment}{// STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{494 \textcolor{comment}{//     stb\_vorbis precomputes the result of the scalar residue decoding}}
\DoxyCodeLine{495 \textcolor{comment}{//     that would otherwise require a divide per chunk. you can trade off}}
\DoxyCodeLine{496 \textcolor{comment}{//     space for time by defining this symbol.}}
\DoxyCodeLine{497 \textcolor{comment}{// \#define STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{498 }
\DoxyCodeLine{499 \textcolor{comment}{// STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{500 \textcolor{comment}{//     vorbis VQ codebooks can be encoded two ways: with every case explicitly}}
\DoxyCodeLine{501 \textcolor{comment}{//     stored, or with all elements being chosen from a small range of values,}}
\DoxyCodeLine{502 \textcolor{comment}{//     and all values possible in all elements. By default, stb\_vorbis expands}}
\DoxyCodeLine{503 \textcolor{comment}{//     this latter kind out to look like the former kind for ease of decoding,}}
\DoxyCodeLine{504 \textcolor{comment}{//     because otherwise an integer divide-\/per-\/vector-\/element is required to}}
\DoxyCodeLine{505 \textcolor{comment}{//     unpack the index. If you define STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK, you can}}
\DoxyCodeLine{506 \textcolor{comment}{//     trade off storage for speed.}}
\DoxyCodeLine{507 \textcolor{comment}{//\#define STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_CODEBOOK\_SHORTS}}
\DoxyCodeLine{510 \textcolor{preprocessor}{\#error "{}STB\_VORBIS\_CODEBOOK\_SHORTS is no longer supported as it produced incorrect results for some input formats"{}}}
\DoxyCodeLine{511 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{512 }
\DoxyCodeLine{513 \textcolor{comment}{// STB\_VORBIS\_DIVIDE\_TABLE}}
\DoxyCodeLine{514 \textcolor{comment}{//     this replaces small integer divides in the floor decode loop with}}
\DoxyCodeLine{515 \textcolor{comment}{//     table lookups. made less than 1\% difference, so disabled by default.}}
\DoxyCodeLine{516 }
\DoxyCodeLine{517 \textcolor{comment}{// STB\_VORBIS\_NO\_INLINE\_DECODE}}
\DoxyCodeLine{518 \textcolor{comment}{//     disables the inlining of the scalar codebook fast-\/huffman decode.}}
\DoxyCodeLine{519 \textcolor{comment}{//     might save a little codespace; useful for debugging}}
\DoxyCodeLine{520 \textcolor{comment}{// \#define STB\_VORBIS\_NO\_INLINE\_DECODE}}
\DoxyCodeLine{521 }
\DoxyCodeLine{522 \textcolor{comment}{// STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{523 \textcolor{comment}{//     Normally we only decode the floor without synthesizing the actual}}
\DoxyCodeLine{524 \textcolor{comment}{//     full curve. We can instead synthesize the curve immediately. This}}
\DoxyCodeLine{525 \textcolor{comment}{//     requires more memory and is very likely slower, so I don't think}}
\DoxyCodeLine{526 \textcolor{comment}{//     you'd ever want to do it except for debugging.}}
\DoxyCodeLine{527 \textcolor{comment}{// \#define STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{528 }
\DoxyCodeLine{529 }
\DoxyCodeLine{530 }
\DoxyCodeLine{531 }
\DoxyCodeLine{533 }
\DoxyCodeLine{534 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_NO\_PULLDATA\_API}}
\DoxyCodeLine{535 \textcolor{preprocessor}{   \#define STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{536 \textcolor{preprocessor}{   \#define STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{537 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{538 }
\DoxyCodeLine{539 \textcolor{preprocessor}{\#if defined(STB\_VORBIS\_NO\_CRT) \&\& !defined(STB\_VORBIS\_NO\_STDIO)}}
\DoxyCodeLine{540 \textcolor{preprocessor}{   \#define STB\_VORBIS\_NO\_STDIO 1}}
\DoxyCodeLine{541 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{542 }
\DoxyCodeLine{543 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{544 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT}}
\DoxyCodeLine{545 }
\DoxyCodeLine{546    \textcolor{comment}{// only need endianness for fast-\/float-\/to-\/int, which we don't}}
\DoxyCodeLine{547    \textcolor{comment}{// use for pushdata}}
\DoxyCodeLine{548 }
\DoxyCodeLine{549 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_BIG\_ENDIAN}}
\DoxyCodeLine{550 \textcolor{preprocessor}{     \#define STB\_VORBIS\_ENDIAN  0}}
\DoxyCodeLine{551 \textcolor{preprocessor}{   \#else}}
\DoxyCodeLine{552 \textcolor{preprocessor}{     \#define STB\_VORBIS\_ENDIAN  1}}
\DoxyCodeLine{553 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{554 }
\DoxyCodeLine{555 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{556 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{557 }
\DoxyCodeLine{558 }
\DoxyCodeLine{559 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{560 \textcolor{preprocessor}{\#include <stdio.h>}}
\DoxyCodeLine{561 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{562 }
\DoxyCodeLine{563 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_CRT}}
\DoxyCodeLine{564 \textcolor{preprocessor}{   \#include <stdlib.h>}}
\DoxyCodeLine{565 \textcolor{preprocessor}{   \#include <string.h>}}
\DoxyCodeLine{566 \textcolor{preprocessor}{   \#include <assert.h>}}
\DoxyCodeLine{567 \textcolor{preprocessor}{   \#include <math.h>}}
\DoxyCodeLine{568 }
\DoxyCodeLine{569    \textcolor{comment}{// find definition of alloca if it's not in stdlib.h:}}
\DoxyCodeLine{570 \textcolor{preprocessor}{   \#if defined(\_MSC\_VER) || defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{571 \textcolor{preprocessor}{      \#include <malloc.h>}}
\DoxyCodeLine{572 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{573 \textcolor{preprocessor}{   \#if defined(\_\_linux\_\_) || defined(\_\_linux) || defined(\_\_EMSCRIPTEN\_\_) || defined(\_\_APPLE\_\_) || defined(\_\_CYGWIN\_\_)}}
\DoxyCodeLine{574 \textcolor{preprocessor}{      \#include <alloca.h>}}
\DoxyCodeLine{575 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{576 \textcolor{preprocessor}{\#else }\textcolor{comment}{// STB\_VORBIS\_NO\_CRT}}
\DoxyCodeLine{577 \textcolor{preprocessor}{   \#define NULL 0}}
\DoxyCodeLine{578 \textcolor{preprocessor}{   \#define malloc(s)   0}}
\DoxyCodeLine{579 \textcolor{preprocessor}{   \#define free(s)     ((void) 0)}}
\DoxyCodeLine{580 \textcolor{preprocessor}{   \#define realloc(s)  0}}
\DoxyCodeLine{581 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// STB\_VORBIS\_NO\_CRT}}
\DoxyCodeLine{582 }
\DoxyCodeLine{583 \textcolor{preprocessor}{\#include <limits.h>}}
\DoxyCodeLine{584 }
\DoxyCodeLine{585 \textcolor{preprocessor}{\#ifdef \_\_MINGW32\_\_}}
\DoxyCodeLine{586    \textcolor{comment}{// eff you mingw:}}
\DoxyCodeLine{587    \textcolor{comment}{//     "{}fixed"{}:}}
\DoxyCodeLine{588    \textcolor{comment}{//         http://sourceforge.net/p/mingw-\/w64/mailman/message/32882927/}}
\DoxyCodeLine{589    \textcolor{comment}{//     "{}no that broke the build, reverted, who cares about C"{}:}}
\DoxyCodeLine{590    \textcolor{comment}{//         http://sourceforge.net/p/mingw-\/w64/mailman/message/32890381/}}
\DoxyCodeLine{591 \textcolor{preprocessor}{   \#ifdef \_\_forceinline}}
\DoxyCodeLine{592 \textcolor{preprocessor}{   \#undef \_\_forceinline}}
\DoxyCodeLine{593 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{594 \textcolor{preprocessor}{   \#define \_\_forceinline}}
\DoxyCodeLine{595 \textcolor{preprocessor}{   \#ifndef alloca}}
\DoxyCodeLine{596 \textcolor{preprocessor}{   \#define alloca(s) \_\_builtin\_alloca(s)}}
\DoxyCodeLine{597 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{598 \textcolor{preprocessor}{\#elif !defined(\_MSC\_VER)}}
\DoxyCodeLine{599 \textcolor{preprocessor}{   \#if \_\_GNUC\_\_}}
\DoxyCodeLine{600 \textcolor{preprocessor}{      \#define \_\_forceinline inline}}
\DoxyCodeLine{601 \textcolor{preprocessor}{   \#else}}
\DoxyCodeLine{602 \textcolor{preprocessor}{      \#define \_\_forceinline}}
\DoxyCodeLine{603 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{604 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{605 }
\DoxyCodeLine{606 \textcolor{preprocessor}{\#if STB\_VORBIS\_MAX\_CHANNELS > 256}}
\DoxyCodeLine{607 \textcolor{preprocessor}{\#error "{}Value of STB\_VORBIS\_MAX\_CHANNELS outside of allowed range"{}}}
\DoxyCodeLine{608 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{609 }
\DoxyCodeLine{610 \textcolor{preprocessor}{\#if STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH > 24}}
\DoxyCodeLine{611 \textcolor{preprocessor}{\#error "{}Value of STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH outside of allowed range"{}}}
\DoxyCodeLine{612 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{613 }
\DoxyCodeLine{614 }
\DoxyCodeLine{615 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{616 \textcolor{preprocessor}{\#include <crtdbg.h>}}
\DoxyCodeLine{617 \textcolor{preprocessor}{\#define STBV\_CHECK(f)   \_CrtIsValidHeapPointer(f-\/>channel\_buffers[1])}}
\DoxyCodeLine{618 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{619 \textcolor{preprocessor}{\#define STBV\_CHECK(f)   ((void) 0)}}
\DoxyCodeLine{620 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{621 }
\DoxyCodeLine{622 \textcolor{preprocessor}{\#define STBV\_MAX\_BLOCKSIZE\_LOG  13   }\textcolor{comment}{// from specification}}
\DoxyCodeLine{623 \textcolor{preprocessor}{\#define STBV\_MAX\_BLOCKSIZE      (1 << STBV\_MAX\_BLOCKSIZE\_LOG)}}
\DoxyCodeLine{624 }
\DoxyCodeLine{625 }
\DoxyCodeLine{626 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}  stbv\_uint8;}
\DoxyCodeLine{627 \textcolor{keyword}{typedef}   \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}  stbv\_int8;}
\DoxyCodeLine{628 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} stbv\_uint16;}
\DoxyCodeLine{629 \textcolor{keyword}{typedef}   \textcolor{keywordtype}{signed} \textcolor{keywordtype}{short} stbv\_int16;}
\DoxyCodeLine{630 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}   stbv\_uint32;}
\DoxyCodeLine{631 \textcolor{keyword}{typedef}   \textcolor{keywordtype}{signed} \textcolor{keywordtype}{int}   stbv\_int32;}
\DoxyCodeLine{632 }
\DoxyCodeLine{633 \textcolor{preprocessor}{\#ifndef TRUE}}
\DoxyCodeLine{634 \textcolor{preprocessor}{\#define TRUE 1}}
\DoxyCodeLine{635 \textcolor{preprocessor}{\#define FALSE 0}}
\DoxyCodeLine{636 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{637 }
\DoxyCodeLine{638 \textcolor{keyword}{typedef} \textcolor{keywordtype}{float} stbv\_codetype;}
\DoxyCodeLine{639 }
\DoxyCodeLine{640 \textcolor{comment}{// @NOTE}}
\DoxyCodeLine{641 \textcolor{comment}{//}}
\DoxyCodeLine{642 \textcolor{comment}{// Some arrays below are tagged "{}//varies"{}, which means it's actually}}
\DoxyCodeLine{643 \textcolor{comment}{// a variable-\/sized piece of data, but rather than malloc I assume it's}}
\DoxyCodeLine{644 \textcolor{comment}{// small enough it's better to just allocate it all together with the}}
\DoxyCodeLine{645 \textcolor{comment}{// main thing}}
\DoxyCodeLine{646 \textcolor{comment}{//}}
\DoxyCodeLine{647 \textcolor{comment}{// Most of the variables are specified with the smallest size I could pack}}
\DoxyCodeLine{648 \textcolor{comment}{// them into. It might give better performance to make them all full-\/sized}}
\DoxyCodeLine{649 \textcolor{comment}{// integers. It should be safe to freely rearrange the structures or change}}
\DoxyCodeLine{650 \textcolor{comment}{// the sizes larger-\/-\/nothing relies on silently truncating etc., nor the}}
\DoxyCodeLine{651 \textcolor{comment}{// order of variables.}}
\DoxyCodeLine{652 }
\DoxyCodeLine{653 \textcolor{preprocessor}{\#define STBV\_FAST\_HUFFMAN\_TABLE\_SIZE   (1 << STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH)}}
\DoxyCodeLine{654 \textcolor{preprocessor}{\#define STBV\_FAST\_HUFFMAN\_TABLE\_MASK   (STBV\_FAST\_HUFFMAN\_TABLE\_SIZE -\/ 1)}}
\DoxyCodeLine{655 }
\DoxyCodeLine{656 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{657 \{}
\DoxyCodeLine{658    \textcolor{keywordtype}{int} dimensions, entries;}
\DoxyCodeLine{659    stbv\_uint8 *codeword\_lengths;}
\DoxyCodeLine{660    \textcolor{keywordtype}{float}  minimum\_value;}
\DoxyCodeLine{661    \textcolor{keywordtype}{float}  delta\_value;}
\DoxyCodeLine{662    stbv\_uint8  value\_bits;}
\DoxyCodeLine{663    stbv\_uint8  lookup\_type;}
\DoxyCodeLine{664    stbv\_uint8  sequence\_p;}
\DoxyCodeLine{665    stbv\_uint8  sparse;}
\DoxyCodeLine{666    stbv\_uint32 lookup\_values;}
\DoxyCodeLine{667    stbv\_codetype *multiplicands;}
\DoxyCodeLine{668    stbv\_uint32 *codewords;}
\DoxyCodeLine{669 \textcolor{preprocessor}{   \#ifdef STB\_VORBIS\_FAST\_HUFFMAN\_SHORT}}
\DoxyCodeLine{670     stbv\_int16  fast\_huffman[STBV\_FAST\_HUFFMAN\_TABLE\_SIZE];}
\DoxyCodeLine{671 \textcolor{preprocessor}{   \#else}}
\DoxyCodeLine{672     stbv\_int32  fast\_huffman[STBV\_FAST\_HUFFMAN\_TABLE\_SIZE];}
\DoxyCodeLine{673 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{674    stbv\_uint32 *sorted\_codewords;}
\DoxyCodeLine{675    \textcolor{keywordtype}{int}    *sorted\_values;}
\DoxyCodeLine{676    \textcolor{keywordtype}{int}     sorted\_entries;}
\DoxyCodeLine{677 \} StbvCodebook;}
\DoxyCodeLine{678 }
\DoxyCodeLine{679 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{680 \{}
\DoxyCodeLine{681    stbv\_uint8 order;}
\DoxyCodeLine{682    stbv\_uint16 rate;}
\DoxyCodeLine{683    stbv\_uint16 bark\_map\_size;}
\DoxyCodeLine{684    stbv\_uint8 amplitude\_bits;}
\DoxyCodeLine{685    stbv\_uint8 amplitude\_offset;}
\DoxyCodeLine{686    stbv\_uint8 number\_of\_books;}
\DoxyCodeLine{687    stbv\_uint8 book\_list[16]; \textcolor{comment}{// varies}}
\DoxyCodeLine{688 \} StbvFloor0;}
\DoxyCodeLine{689 }
\DoxyCodeLine{690 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{691 \{}
\DoxyCodeLine{692    stbv\_uint8 partitions;}
\DoxyCodeLine{693    stbv\_uint8 partition\_class\_list[32]; \textcolor{comment}{// varies}}
\DoxyCodeLine{694    stbv\_uint8 class\_dimensions[16]; \textcolor{comment}{// varies}}
\DoxyCodeLine{695    stbv\_uint8 class\_subclasses[16]; \textcolor{comment}{// varies}}
\DoxyCodeLine{696    stbv\_uint8 class\_masterbooks[16]; \textcolor{comment}{// varies}}
\DoxyCodeLine{697    stbv\_int16 subclass\_books[16][8]; \textcolor{comment}{// varies}}
\DoxyCodeLine{698    stbv\_uint16 Xlist[31*8+2]; \textcolor{comment}{// varies}}
\DoxyCodeLine{699    stbv\_uint8 sorted\_order[31*8+2];}
\DoxyCodeLine{700    stbv\_uint8 stbv\_neighbors[31*8+2][2];}
\DoxyCodeLine{701    stbv\_uint8 floor1\_multiplier;}
\DoxyCodeLine{702    stbv\_uint8 rangebits;}
\DoxyCodeLine{703    \textcolor{keywordtype}{int} values;}
\DoxyCodeLine{704 \} StbvFloor1;}
\DoxyCodeLine{705 }
\DoxyCodeLine{706 \textcolor{keyword}{typedef} \textcolor{keyword}{union}}
\DoxyCodeLine{707 \{}
\DoxyCodeLine{708    StbvFloor0 floor0;}
\DoxyCodeLine{709    StbvFloor1 floor1;}
\DoxyCodeLine{710 \} StbvFloor;}
\DoxyCodeLine{711 }
\DoxyCodeLine{712 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{713 \{}
\DoxyCodeLine{714    stbv\_uint32 begin, end;}
\DoxyCodeLine{715    stbv\_uint32 part\_size;}
\DoxyCodeLine{716    stbv\_uint8 classifications;}
\DoxyCodeLine{717    stbv\_uint8 classbook;}
\DoxyCodeLine{718    stbv\_uint8 **classdata;}
\DoxyCodeLine{719    stbv\_int16 (*residue\_books)[8];}
\DoxyCodeLine{720 \} StbvResidue;}
\DoxyCodeLine{721 }
\DoxyCodeLine{722 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{723 \{}
\DoxyCodeLine{724    stbv\_uint8 magnitude;}
\DoxyCodeLine{725    stbv\_uint8 angle;}
\DoxyCodeLine{726    stbv\_uint8 mux;}
\DoxyCodeLine{727 \} StbvMappingChannel;}
\DoxyCodeLine{728 }
\DoxyCodeLine{729 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{730 \{}
\DoxyCodeLine{731    stbv\_uint16 coupling\_steps;}
\DoxyCodeLine{732    StbvMappingChannel *chan;}
\DoxyCodeLine{733    stbv\_uint8  submaps;}
\DoxyCodeLine{734    stbv\_uint8  submap\_floor[15]; \textcolor{comment}{// varies}}
\DoxyCodeLine{735    stbv\_uint8  submap\_residue[15]; \textcolor{comment}{// varies}}
\DoxyCodeLine{736 \} StbvMapping;}
\DoxyCodeLine{737 }
\DoxyCodeLine{738 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{739 \{}
\DoxyCodeLine{740    stbv\_uint8 blockflag;}
\DoxyCodeLine{741    stbv\_uint8 mapping;}
\DoxyCodeLine{742    stbv\_uint16 windowtype;}
\DoxyCodeLine{743    stbv\_uint16 transformtype;}
\DoxyCodeLine{744 \} StbvMode;}
\DoxyCodeLine{745 }
\DoxyCodeLine{746 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{747 \{}
\DoxyCodeLine{748    stbv\_uint32  goal\_crc;    \textcolor{comment}{// expected crc if match}}
\DoxyCodeLine{749    \textcolor{keywordtype}{int}     bytes\_left;  \textcolor{comment}{// bytes left in packet}}
\DoxyCodeLine{750    stbv\_uint32  crc\_so\_far;  \textcolor{comment}{// running crc}}
\DoxyCodeLine{751    \textcolor{keywordtype}{int}     bytes\_done;  \textcolor{comment}{// bytes processed in \_current\_ chunk}}
\DoxyCodeLine{752    stbv\_uint32  sample\_loc;  \textcolor{comment}{// granule pos encoded in page}}
\DoxyCodeLine{753 \} StbvCRCscan;}
\DoxyCodeLine{754 }
\DoxyCodeLine{755 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{756 \{}
\DoxyCodeLine{757    stbv\_uint32 page\_start, page\_end;}
\DoxyCodeLine{758    stbv\_uint32 last\_decoded\_sample;}
\DoxyCodeLine{759 \} StbvProbedPage;}
\DoxyCodeLine{760 }
\DoxyCodeLine{761 \textcolor{keyword}{struct }stb\_vorbis}
\DoxyCodeLine{762 \{}
\DoxyCodeLine{763   \textcolor{comment}{// user-\/accessible info}}
\DoxyCodeLine{764    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sample\_rate;}
\DoxyCodeLine{765    \textcolor{keywordtype}{int} channels;}
\DoxyCodeLine{766 }
\DoxyCodeLine{767    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} setup\_memory\_required;}
\DoxyCodeLine{768    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} temp\_memory\_required;}
\DoxyCodeLine{769    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} setup\_temp\_memory\_required;}
\DoxyCodeLine{770 }
\DoxyCodeLine{771   \textcolor{comment}{// input config}}
\DoxyCodeLine{772 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{773    FILE *f;}
\DoxyCodeLine{774    stbv\_uint32 f\_start;}
\DoxyCodeLine{775    \textcolor{keywordtype}{int} close\_on\_free;}
\DoxyCodeLine{776 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{777 }
\DoxyCodeLine{778    stbv\_uint8 *stream;}
\DoxyCodeLine{779    stbv\_uint8 *stream\_start;}
\DoxyCodeLine{780    stbv\_uint8 *stream\_end;}
\DoxyCodeLine{781 }
\DoxyCodeLine{782    stbv\_uint32 stream\_len;}
\DoxyCodeLine{783 }
\DoxyCodeLine{784    stbv\_uint8  push\_mode;}
\DoxyCodeLine{785 }
\DoxyCodeLine{786    stbv\_uint32 first\_audio\_page\_offset;}
\DoxyCodeLine{787 }
\DoxyCodeLine{788    StbvProbedPage p\_first, p\_last;}
\DoxyCodeLine{789 }
\DoxyCodeLine{790   \textcolor{comment}{// memory management}}
\DoxyCodeLine{791    \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} alloc;}
\DoxyCodeLine{792    \textcolor{keywordtype}{int} setup\_offset;}
\DoxyCodeLine{793    \textcolor{keywordtype}{int} temp\_offset;}
\DoxyCodeLine{794 }
\DoxyCodeLine{795   \textcolor{comment}{// run-\/time results}}
\DoxyCodeLine{796    \textcolor{keywordtype}{int} eof;}
\DoxyCodeLine{797    \textcolor{keyword}{enum} STBVorbisError \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{798 }
\DoxyCodeLine{799   \textcolor{comment}{// user-\/useful data}}
\DoxyCodeLine{800 }
\DoxyCodeLine{801   \textcolor{comment}{// header info}}
\DoxyCodeLine{802    \textcolor{keywordtype}{int} blocksize[2];}
\DoxyCodeLine{803    \textcolor{keywordtype}{int} blocksize\_0, blocksize\_1;}
\DoxyCodeLine{804    \textcolor{keywordtype}{int} codebook\_count;}
\DoxyCodeLine{805    StbvCodebook *codebooks;}
\DoxyCodeLine{806    \textcolor{keywordtype}{int} floor\_count;}
\DoxyCodeLine{807    stbv\_uint16 floor\_types[64]; \textcolor{comment}{// varies}}
\DoxyCodeLine{808    StbvFloor *floor\_config;}
\DoxyCodeLine{809    \textcolor{keywordtype}{int} residue\_count;}
\DoxyCodeLine{810    stbv\_uint16 residue\_types[64]; \textcolor{comment}{// varies}}
\DoxyCodeLine{811    StbvResidue *residue\_config;}
\DoxyCodeLine{812    \textcolor{keywordtype}{int} mapping\_count;}
\DoxyCodeLine{813    StbvMapping *mapping;}
\DoxyCodeLine{814    \textcolor{keywordtype}{int} mode\_count;}
\DoxyCodeLine{815    StbvMode mode\_config[64];  \textcolor{comment}{// varies}}
\DoxyCodeLine{816 }
\DoxyCodeLine{817    stbv\_uint32 total\_samples;}
\DoxyCodeLine{818 }
\DoxyCodeLine{819   \textcolor{comment}{// decode buffer}}
\DoxyCodeLine{820    \textcolor{keywordtype}{float} *channel\_buffers[STB\_VORBIS\_MAX\_CHANNELS];}
\DoxyCodeLine{821    \textcolor{keywordtype}{float} *outputs        [STB\_VORBIS\_MAX\_CHANNELS];}
\DoxyCodeLine{822 }
\DoxyCodeLine{823    \textcolor{keywordtype}{float} *previous\_window[STB\_VORBIS\_MAX\_CHANNELS];}
\DoxyCodeLine{824    \textcolor{keywordtype}{int} previous\_length;}
\DoxyCodeLine{825 }
\DoxyCodeLine{826 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{827    stbv\_int16 *finalY[STB\_VORBIS\_MAX\_CHANNELS];}
\DoxyCodeLine{828 \textcolor{preprocessor}{   \#else}}
\DoxyCodeLine{829    \textcolor{keywordtype}{float} *floor\_buffers[STB\_VORBIS\_MAX\_CHANNELS];}
\DoxyCodeLine{830 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{831 }
\DoxyCodeLine{832    stbv\_uint32 current\_loc; \textcolor{comment}{// sample location of next frame to decode}}
\DoxyCodeLine{833    \textcolor{keywordtype}{int}    current\_loc\_valid;}
\DoxyCodeLine{834 }
\DoxyCodeLine{835   \textcolor{comment}{// per-\/blocksize precomputed data}}
\DoxyCodeLine{836    }
\DoxyCodeLine{837    \textcolor{comment}{// twiddle factors}}
\DoxyCodeLine{838    \textcolor{keywordtype}{float} *A[2],*B[2],*C[2];}
\DoxyCodeLine{839    \textcolor{keywordtype}{float} *window[2];}
\DoxyCodeLine{840    stbv\_uint16 *stbv\_bit\_reverse[2];}
\DoxyCodeLine{841 }
\DoxyCodeLine{842   \textcolor{comment}{// current page/packet/segment streaming info}}
\DoxyCodeLine{843    stbv\_uint32 serial; \textcolor{comment}{// stream serial number for verification}}
\DoxyCodeLine{844    \textcolor{keywordtype}{int} last\_page;}
\DoxyCodeLine{845    \textcolor{keywordtype}{int} segment\_count;}
\DoxyCodeLine{846    stbv\_uint8 segments[255];}
\DoxyCodeLine{847    stbv\_uint8 page\_flag;}
\DoxyCodeLine{848    stbv\_uint8 bytes\_in\_seg;}
\DoxyCodeLine{849    stbv\_uint8 first\_decode;}
\DoxyCodeLine{850    \textcolor{keywordtype}{int} next\_seg;}
\DoxyCodeLine{851    \textcolor{keywordtype}{int} last\_seg;  \textcolor{comment}{// flag that we're on the last segment}}
\DoxyCodeLine{852    \textcolor{keywordtype}{int} last\_seg\_which; \textcolor{comment}{// what was the segment number of the last seg?}}
\DoxyCodeLine{853    stbv\_uint32 acc;}
\DoxyCodeLine{854    \textcolor{keywordtype}{int} valid\_bits;}
\DoxyCodeLine{855    \textcolor{keywordtype}{int} packet\_bytes;}
\DoxyCodeLine{856    \textcolor{keywordtype}{int} end\_seg\_with\_known\_loc;}
\DoxyCodeLine{857    stbv\_uint32 known\_loc\_for\_packet;}
\DoxyCodeLine{858    \textcolor{keywordtype}{int} discard\_samples\_deferred;}
\DoxyCodeLine{859    stbv\_uint32 samples\_output;}
\DoxyCodeLine{860 }
\DoxyCodeLine{861   \textcolor{comment}{// push mode scanning}}
\DoxyCodeLine{862    \textcolor{keywordtype}{int} page\_crc\_tests; \textcolor{comment}{// only in push\_mode: number of tests active; -\/1 if not searching}}
\DoxyCodeLine{863 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{864    StbvCRCscan scan[STB\_VORBIS\_PUSHDATA\_CRC\_COUNT];}
\DoxyCodeLine{865 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{866 }
\DoxyCodeLine{867   \textcolor{comment}{// sample-\/access}}
\DoxyCodeLine{868    \textcolor{keywordtype}{int} channel\_buffer\_start;}
\DoxyCodeLine{869    \textcolor{keywordtype}{int} channel\_buffer\_end;}
\DoxyCodeLine{870 \};}
\DoxyCodeLine{871 }
\DoxyCodeLine{872 \textcolor{preprocessor}{\#if defined(STB\_VORBIS\_NO\_PUSHDATA\_API)}}
\DoxyCodeLine{873 \textcolor{preprocessor}{   \#define STBV\_IS\_PUSH\_MODE(f)   FALSE}}
\DoxyCodeLine{874 \textcolor{preprocessor}{\#elif defined(STB\_VORBIS\_NO\_PULLDATA\_API)}}
\DoxyCodeLine{875 \textcolor{preprocessor}{   \#define STBV\_IS\_PUSH\_MODE(f)   TRUE}}
\DoxyCodeLine{876 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{877 \textcolor{preprocessor}{   \#define STBV\_IS\_PUSH\_MODE(f)   ((f)-\/>push\_mode)}}
\DoxyCodeLine{878 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{879 }
\DoxyCodeLine{880 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }stb\_vorbis stbv\_vorb;}
\DoxyCodeLine{881 }
\DoxyCodeLine{882 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_error(stbv\_vorb *f, \textcolor{keyword}{enum} STBVorbisError e)}
\DoxyCodeLine{883 \{}
\DoxyCodeLine{884    f-\/>error = e;}
\DoxyCodeLine{885    \textcolor{keywordflow}{if} (!f-\/>eof \&\& e != VORBIS\_need\_more\_data) \{}
\DoxyCodeLine{886       f-\/>error=e; \textcolor{comment}{// breakpoint for debugging}}
\DoxyCodeLine{887    \}}
\DoxyCodeLine{888    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{889 \}}
\DoxyCodeLine{890 }
\DoxyCodeLine{891 }
\DoxyCodeLine{892 \textcolor{comment}{// these functions are used for allocating temporary memory}}
\DoxyCodeLine{893 \textcolor{comment}{// while decoding. if you can afford the stack space, use}}
\DoxyCodeLine{894 \textcolor{comment}{// alloca(); otherwise, provide a temp buffer and it will}}
\DoxyCodeLine{895 \textcolor{comment}{// allocate out of those.}}
\DoxyCodeLine{896 }
\DoxyCodeLine{897 \textcolor{preprocessor}{\#define stbv\_array\_size\_required(count,size)  (count*(sizeof(void *)+(size)))}}
\DoxyCodeLine{898 }
\DoxyCodeLine{899 \textcolor{preprocessor}{\#define stbv\_temp\_alloc(f,size)              (f-\/>alloc.alloc\_buffer ? stbv\_setup\_temp\_malloc(f,size) : alloca(size))}}
\DoxyCodeLine{900 \textcolor{preprocessor}{\#define stbv\_temp\_free(f,p)                  0}}
\DoxyCodeLine{901 \textcolor{preprocessor}{\#define stbv\_temp\_alloc\_save(f)              ((f)-\/>temp\_offset)}}
\DoxyCodeLine{902 \textcolor{preprocessor}{\#define stbv\_temp\_alloc\_restore(f,p)         ((f)-\/>temp\_offset = (p))}}
\DoxyCodeLine{903 }
\DoxyCodeLine{904 \textcolor{preprocessor}{\#define stbv\_temp\_block\_array(f,count,size)  stbv\_make\_block\_array(stbv\_temp\_alloc(f,stbv\_array\_size\_required(count,size)), count, size)}}
\DoxyCodeLine{905 }
\DoxyCodeLine{906 \textcolor{comment}{// given a sufficiently large block of memory, make an array of pointers to subblocks of it}}
\DoxyCodeLine{907 \textcolor{keyword}{static} \textcolor{keywordtype}{void} *stbv\_make\_block\_array(\textcolor{keywordtype}{void} *mem, \textcolor{keywordtype}{int} count, \textcolor{keywordtype}{int} size)}
\DoxyCodeLine{908 \{}
\DoxyCodeLine{909    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{910    \textcolor{keywordtype}{void} ** p = (\textcolor{keywordtype}{void} **) mem;}
\DoxyCodeLine{911    \textcolor{keywordtype}{char} *q = (\textcolor{keywordtype}{char} *) (p + count);}
\DoxyCodeLine{912    \textcolor{keywordflow}{for} (i=0; i < count; ++i) \{}
\DoxyCodeLine{913       p[i] = q;}
\DoxyCodeLine{914       q += size;}
\DoxyCodeLine{915    \}}
\DoxyCodeLine{916    \textcolor{keywordflow}{return} p;}
\DoxyCodeLine{917 \}}
\DoxyCodeLine{918 }
\DoxyCodeLine{919 \textcolor{keyword}{static} \textcolor{keywordtype}{void} *stbv\_setup\_malloc(stbv\_vorb *f, \textcolor{keywordtype}{int} sz)}
\DoxyCodeLine{920 \{}
\DoxyCodeLine{921    sz = (sz+3) \& \string~3;}
\DoxyCodeLine{922    f-\/>setup\_memory\_required += sz;}
\DoxyCodeLine{923    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer) \{}
\DoxyCodeLine{924       \textcolor{keywordtype}{void} *p = (\textcolor{keywordtype}{char} *) f-\/>alloc.alloc\_buffer + f-\/>setup\_offset;}
\DoxyCodeLine{925       if (f-\/>setup\_offset + sz > f-\/>temp\_offset) \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{926       f-\/>setup\_offset += sz;}
\DoxyCodeLine{927       \textcolor{keywordflow}{return} p;}
\DoxyCodeLine{928    \}}
\DoxyCodeLine{929    \textcolor{keywordflow}{return} sz ? malloc(sz) : NULL;}
\DoxyCodeLine{930 \}}
\DoxyCodeLine{931 }
\DoxyCodeLine{932 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_setup\_free(stbv\_vorb *f, \textcolor{keywordtype}{void} *p)}
\DoxyCodeLine{933 \{}
\DoxyCodeLine{934    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer) \textcolor{keywordflow}{return}; \textcolor{comment}{// do nothing; setup mem is a stack}}
\DoxyCodeLine{935    free(p);}
\DoxyCodeLine{936 \}}
\DoxyCodeLine{937 }
\DoxyCodeLine{938 \textcolor{keyword}{static} \textcolor{keywordtype}{void} *stbv\_setup\_temp\_malloc(stbv\_vorb *f, \textcolor{keywordtype}{int} sz)}
\DoxyCodeLine{939 \{}
\DoxyCodeLine{940    sz = (sz+3) \& \string~3;}
\DoxyCodeLine{941    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer) \{}
\DoxyCodeLine{942       \textcolor{keywordflow}{if} (f-\/>temp\_offset -\/ sz < f-\/>setup\_offset) \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{943       f-\/>temp\_offset -\/= sz;}
\DoxyCodeLine{944       \textcolor{keywordflow}{return} (\textcolor{keywordtype}{char} *) f-\/>alloc.alloc\_buffer + f-\/>temp\_offset;}
\DoxyCodeLine{945    \}}
\DoxyCodeLine{946    \textcolor{keywordflow}{return} malloc(sz);}
\DoxyCodeLine{947 \}}
\DoxyCodeLine{948 }
\DoxyCodeLine{949 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_setup\_temp\_free(stbv\_vorb *f, \textcolor{keywordtype}{void} *p, \textcolor{keywordtype}{int} sz)}
\DoxyCodeLine{950 \{}
\DoxyCodeLine{951    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer) \{}
\DoxyCodeLine{952       f-\/>temp\_offset += (sz+3)\&\string~3;}
\DoxyCodeLine{953       \textcolor{keywordflow}{return};}
\DoxyCodeLine{954    \}}
\DoxyCodeLine{955    free(p);}
\DoxyCodeLine{956 \}}
\DoxyCodeLine{957 }
\DoxyCodeLine{958 \textcolor{preprocessor}{\#define STBV\_CRC32\_POLY    0x04c11db7   }\textcolor{comment}{// from spec}}
\DoxyCodeLine{959 }
\DoxyCodeLine{960 \textcolor{keyword}{static} stbv\_uint32 stbv\_crc\_table[256];}
\DoxyCodeLine{961 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_crc32\_init(\textcolor{keywordtype}{void})}
\DoxyCodeLine{962 \{}
\DoxyCodeLine{963    \textcolor{keywordtype}{int} i,j;}
\DoxyCodeLine{964    stbv\_uint32 s;}
\DoxyCodeLine{965    \textcolor{keywordflow}{for}(i=0; i < 256; i++) \{}
\DoxyCodeLine{966       \textcolor{keywordflow}{for} (s=(stbv\_uint32) i << 24, j=0; j < 8; ++j)}
\DoxyCodeLine{967          s = (s << 1) \string^ (s >= (1U<<31) ? STBV\_CRC32\_POLY : 0);}
\DoxyCodeLine{968       stbv\_crc\_table[i] = s;}
\DoxyCodeLine{969    \}}
\DoxyCodeLine{970 \}}
\DoxyCodeLine{971 }
\DoxyCodeLine{972 \textcolor{keyword}{static} \_\_forceinline stbv\_uint32 stbv\_crc32\_update(stbv\_uint32 crc, stbv\_uint8 \textcolor{keywordtype}{byte})}
\DoxyCodeLine{973 \{}
\DoxyCodeLine{974    \textcolor{keywordflow}{return} (crc << 8) \string^ stbv\_crc\_table[\textcolor{keywordtype}{byte} \string^ (crc >> 24)];}
\DoxyCodeLine{975 \}}
\DoxyCodeLine{976 }
\DoxyCodeLine{977 }
\DoxyCodeLine{978 \textcolor{comment}{// used in setup, and for huffman that doesn't go fast path}}
\DoxyCodeLine{979 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} stbv\_bit\_reverse(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{980 \{}
\DoxyCodeLine{981   n = ((n \& 0xAAAAAAAA) >>  1) | ((n \& 0x55555555) << 1);}
\DoxyCodeLine{982   n = ((n \& 0xCCCCCCCC) >>  2) | ((n \& 0x33333333) << 2);}
\DoxyCodeLine{983   n = ((n \& 0xF0F0F0F0) >>  4) | ((n \& 0x0F0F0F0F) << 4);}
\DoxyCodeLine{984   n = ((n \& 0xFF00FF00) >>  8) | ((n \& 0x00FF00FF) << 8);}
\DoxyCodeLine{985   \textcolor{keywordflow}{return} (n >> 16) | (n << 16);}
\DoxyCodeLine{986 \}}
\DoxyCodeLine{987 }
\DoxyCodeLine{988 \textcolor{keyword}{static} \textcolor{keywordtype}{float} stbv\_square(\textcolor{keywordtype}{float} x)}
\DoxyCodeLine{989 \{}
\DoxyCodeLine{990    \textcolor{keywordflow}{return} x*x;}
\DoxyCodeLine{991 \}}
\DoxyCodeLine{992 }
\DoxyCodeLine{993 \textcolor{comment}{// this is a weird definition of log2() for which log2(1) = 1, log2(2) = 2, log2(4) = 3}}
\DoxyCodeLine{994 \textcolor{comment}{// as required by the specification. fast(?) implementation from stb.h}}
\DoxyCodeLine{995 \textcolor{comment}{// @OPTIMIZE: called multiple times per-\/packet with "{}constants"{}; move to setup}}
\DoxyCodeLine{996 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_ilog(stbv\_int32 n)}
\DoxyCodeLine{997 \{}
\DoxyCodeLine{998    \textcolor{keyword}{static} \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} log2\_4[16] = \{ 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 \};}
\DoxyCodeLine{999 }
\DoxyCodeLine{1000    \textcolor{keywordflow}{if} (n < 0) \textcolor{keywordflow}{return} 0; \textcolor{comment}{// signed n returns 0}}
\DoxyCodeLine{1001 }
\DoxyCodeLine{1002    \textcolor{comment}{// 2 compares if n < 16, 3 compares otherwise (4 if signed or n > 1<<29)}}
\DoxyCodeLine{1003    \textcolor{keywordflow}{if} (n < (1 << 14))}
\DoxyCodeLine{1004         \textcolor{keywordflow}{if} (n < (1 <<  4))            \textcolor{keywordflow}{return}  0 + log2\_4[n      ];}
\DoxyCodeLine{1005         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n < (1 <<  9))       \textcolor{keywordflow}{return}  5 + log2\_4[n >>  5];}
\DoxyCodeLine{1006              \textcolor{keywordflow}{else}                     \textcolor{keywordflow}{return} 10 + log2\_4[n >> 10];}
\DoxyCodeLine{1007    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n < (1 << 24))}
\DoxyCodeLine{1008              \textcolor{keywordflow}{if} (n < (1 << 19))       \textcolor{keywordflow}{return} 15 + log2\_4[n >> 15];}
\DoxyCodeLine{1009              \textcolor{keywordflow}{else}                     \textcolor{keywordflow}{return} 20 + log2\_4[n >> 20];}
\DoxyCodeLine{1010         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n < (1 << 29))       \textcolor{keywordflow}{return} 25 + log2\_4[n >> 25];}
\DoxyCodeLine{1011              \textcolor{keywordflow}{else}                     \textcolor{keywordflow}{return} 30 + log2\_4[n >> 30];}
\DoxyCodeLine{1012 \}}
\DoxyCodeLine{1013 }
\DoxyCodeLine{1014 \textcolor{preprocessor}{\#ifndef M\_PI}}
\DoxyCodeLine{1015 \textcolor{preprocessor}{  \#define M\_PI  3.14159265358979323846264f  }\textcolor{comment}{// from CRC}}
\DoxyCodeLine{1016 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1017 }
\DoxyCodeLine{1018 \textcolor{comment}{// code length assigned to a value with no huffman encoding}}
\DoxyCodeLine{1019 \textcolor{preprocessor}{\#define NO\_CODE   255}}
\DoxyCodeLine{1020 }
\DoxyCodeLine{1022 \textcolor{comment}{//}}
\DoxyCodeLine{1023 \textcolor{comment}{// these functions are only called at setup, and only a few times}}
\DoxyCodeLine{1024 \textcolor{comment}{// per file}}
\DoxyCodeLine{1025 }
\DoxyCodeLine{1026 \textcolor{keyword}{static} \textcolor{keywordtype}{float} stbv\_float32\_unpack(stbv\_uint32 x)}
\DoxyCodeLine{1027 \{}
\DoxyCodeLine{1028    \textcolor{comment}{// from the specification}}
\DoxyCodeLine{1029    stbv\_uint32 mantissa = x \& 0x1fffff;}
\DoxyCodeLine{1030    stbv\_uint32 sign = x \& 0x80000000;}
\DoxyCodeLine{1031    stbv\_uint32 exp = (x \& 0x7fe00000) >> 21;}
\DoxyCodeLine{1032    \textcolor{keywordtype}{double} res = sign ? -\/(double)mantissa : (\textcolor{keywordtype}{double})mantissa;}
\DoxyCodeLine{1033    \textcolor{keywordflow}{return} (\textcolor{keywordtype}{float}) ldexp((\textcolor{keywordtype}{float})res, exp-\/788);}
\DoxyCodeLine{1034 \}}
\DoxyCodeLine{1035 }
\DoxyCodeLine{1036 }
\DoxyCodeLine{1037 \textcolor{comment}{// zlib \& jpeg huffman tables assume that the output symbols}}
\DoxyCodeLine{1038 \textcolor{comment}{// can either be arbitrarily arranged, or have monotonically}}
\DoxyCodeLine{1039 \textcolor{comment}{// increasing frequencies-\/-\/they rely on the lengths being sorted;}}
\DoxyCodeLine{1040 \textcolor{comment}{// this makes for a very simple generation algorithm.}}
\DoxyCodeLine{1041 \textcolor{comment}{// vorbis allows a huffman table with non-\/sorted lengths. This}}
\DoxyCodeLine{1042 \textcolor{comment}{// requires a more sophisticated construction, since symbols in}}
\DoxyCodeLine{1043 \textcolor{comment}{// order do not map to huffman codes "{}in order"{}.}}
\DoxyCodeLine{1044 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_add\_entry(StbvCodebook *c, stbv\_uint32 huff\_code, \textcolor{keywordtype}{int} symbol, \textcolor{keywordtype}{int} count, \textcolor{keywordtype}{int} len, stbv\_uint32 *values)}
\DoxyCodeLine{1045 \{}
\DoxyCodeLine{1046    \textcolor{keywordflow}{if} (!c-\/>sparse) \{}
\DoxyCodeLine{1047       c-\/>codewords      [symbol] = huff\_code;}
\DoxyCodeLine{1048    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1049       c-\/>codewords       [count] = huff\_code;}
\DoxyCodeLine{1050       c-\/>codeword\_lengths[count] = len;}
\DoxyCodeLine{1051       values             [count] = symbol;}
\DoxyCodeLine{1052    \}}
\DoxyCodeLine{1053 \}}
\DoxyCodeLine{1054 }
\DoxyCodeLine{1055 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_compute\_codewords(StbvCodebook *c, stbv\_uint8 *len, \textcolor{keywordtype}{int} n, stbv\_uint32 *values)}
\DoxyCodeLine{1056 \{}
\DoxyCodeLine{1057    \textcolor{keywordtype}{int} i,k,m=0;}
\DoxyCodeLine{1058    stbv\_uint32 available[32];}
\DoxyCodeLine{1059 }
\DoxyCodeLine{1060    memset(available, 0, \textcolor{keyword}{sizeof}(available));}
\DoxyCodeLine{1061    \textcolor{comment}{// find the first entry}}
\DoxyCodeLine{1062    \textcolor{keywordflow}{for} (k=0; k < n; ++k) \textcolor{keywordflow}{if} (len[k] < NO\_CODE) \textcolor{keywordflow}{break};}
\DoxyCodeLine{1063    \textcolor{keywordflow}{if} (k == n) \{ assert(c-\/>sorted\_entries == 0); \textcolor{keywordflow}{return} TRUE; \}}
\DoxyCodeLine{1064    \textcolor{comment}{// add to the list}}
\DoxyCodeLine{1065    stbv\_add\_entry(c, 0, k, m++, len[k], values);}
\DoxyCodeLine{1066    \textcolor{comment}{// add all available leaves}}
\DoxyCodeLine{1067    \textcolor{keywordflow}{for} (i=1; i <= len[k]; ++i)}
\DoxyCodeLine{1068       available[i] = 1U << (32-\/i);}
\DoxyCodeLine{1069    \textcolor{comment}{// note that the above code treats the first case specially,}}
\DoxyCodeLine{1070    \textcolor{comment}{// but it's really the same as the following code, so they}}
\DoxyCodeLine{1071    \textcolor{comment}{// could probably be combined (except the initial code is 0,}}
\DoxyCodeLine{1072    \textcolor{comment}{// and I use 0 in available[] to mean 'empty')}}
\DoxyCodeLine{1073    \textcolor{keywordflow}{for} (i=k+1; i < n; ++i) \{}
\DoxyCodeLine{1074       stbv\_uint32 res;}
\DoxyCodeLine{1075       \textcolor{keywordtype}{int} z = len[i], y;}
\DoxyCodeLine{1076       \textcolor{keywordflow}{if} (z == NO\_CODE) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{1077       \textcolor{comment}{// find lowest available leaf (should always be earliest,}}
\DoxyCodeLine{1078       \textcolor{comment}{// which is what the specification calls for)}}
\DoxyCodeLine{1079       \textcolor{comment}{// note that this property, and the fact we can never have}}
\DoxyCodeLine{1080       \textcolor{comment}{// more than one free leaf at a given level, isn't totally}}
\DoxyCodeLine{1081       \textcolor{comment}{// trivial to prove, but it seems true and the assert never}}
\DoxyCodeLine{1082       \textcolor{comment}{// fires, so!}}
\DoxyCodeLine{1083       \textcolor{keywordflow}{while} (z > 0 \&\& !available[z]) -\/-\/z;}
\DoxyCodeLine{1084       \textcolor{keywordflow}{if} (z == 0) \{ \textcolor{keywordflow}{return} FALSE; \}}
\DoxyCodeLine{1085       res = available[z];}
\DoxyCodeLine{1086       assert(z >= 0 \&\& z < 32);}
\DoxyCodeLine{1087       available[z] = 0;}
\DoxyCodeLine{1088       stbv\_add\_entry(c, stbv\_bit\_reverse(res), i, m++, len[i], values);}
\DoxyCodeLine{1089       \textcolor{comment}{// propogate availability up the tree}}
\DoxyCodeLine{1090       \textcolor{keywordflow}{if} (z != len[i]) \{}
\DoxyCodeLine{1091          assert(len[i] >= 0 \&\& len[i] < 32);}
\DoxyCodeLine{1092          \textcolor{keywordflow}{for} (y=len[i]; y > z; -\/-\/y) \{}
\DoxyCodeLine{1093             assert(available[y] == 0);}
\DoxyCodeLine{1094             available[y] = res + (1 << (32-\/y));}
\DoxyCodeLine{1095          \}}
\DoxyCodeLine{1096       \}}
\DoxyCodeLine{1097    \}}
\DoxyCodeLine{1098    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1099 \}}
\DoxyCodeLine{1100 }
\DoxyCodeLine{1101 \textcolor{comment}{// accelerated huffman table allows fast O(1) match of all symbols}}
\DoxyCodeLine{1102 \textcolor{comment}{// of length <= STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH}}
\DoxyCodeLine{1103 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_compute\_accelerated\_huffman(StbvCodebook *c)}
\DoxyCodeLine{1104 \{}
\DoxyCodeLine{1105    \textcolor{keywordtype}{int} i, len;}
\DoxyCodeLine{1106    \textcolor{keywordflow}{for} (i=0; i < STBV\_FAST\_HUFFMAN\_TABLE\_SIZE; ++i)}
\DoxyCodeLine{1107       c-\/>fast\_huffman[i] = -\/1;}
\DoxyCodeLine{1108 }
\DoxyCodeLine{1109    len = c-\/>sparse ? c-\/>sorted\_entries : c-\/>entries;}
\DoxyCodeLine{1110    \#ifdef STB\_VORBIS\_FAST\_HUFFMAN\_SHORT}
\DoxyCodeLine{1111    if (len > 32767) len = 32767; \textcolor{comment}{// largest possible value we can encode!}}
\DoxyCodeLine{1112 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{1113    \textcolor{keywordflow}{for} (i=0; i < len; ++i) \{}
\DoxyCodeLine{1114       \textcolor{keywordflow}{if} (c-\/>codeword\_lengths[i] <= STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH) \{}
\DoxyCodeLine{1115          stbv\_uint32 z = c-\/>sparse ? stbv\_bit\_reverse(c-\/>sorted\_codewords[i]) : c-\/>codewords[i];}
\DoxyCodeLine{1116          \textcolor{comment}{// set table entries for all bit combinations in the higher bits}}
\DoxyCodeLine{1117          \textcolor{keywordflow}{while} (z < STBV\_FAST\_HUFFMAN\_TABLE\_SIZE) \{}
\DoxyCodeLine{1118              c-\/>fast\_huffman[z] = i;}
\DoxyCodeLine{1119              z += 1 << c-\/>codeword\_lengths[i];}
\DoxyCodeLine{1120          \}}
\DoxyCodeLine{1121       \}}
\DoxyCodeLine{1122    \}}
\DoxyCodeLine{1123 \}}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{1126 \textcolor{preprocessor}{\#define STBV\_CDECL \_\_cdecl}}
\DoxyCodeLine{1127 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1128 \textcolor{preprocessor}{\#define STBV\_CDECL}}
\DoxyCodeLine{1129 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1130 }
\DoxyCodeLine{1131 \textcolor{keyword}{static} \textcolor{keywordtype}{int} STBV\_CDECL stbv\_uint32\_compare(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *p, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *q)}
\DoxyCodeLine{1132 \{}
\DoxyCodeLine{1133    stbv\_uint32 x = * (stbv\_uint32 *) p;}
\DoxyCodeLine{1134    stbv\_uint32 y = * (stbv\_uint32 *) q;}
\DoxyCodeLine{1135    \textcolor{keywordflow}{return} x < y ? -\/1 : x > y;}
\DoxyCodeLine{1136 \}}
\DoxyCodeLine{1137 }
\DoxyCodeLine{1138 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_include\_in\_sort(StbvCodebook *c, stbv\_uint8 len)}
\DoxyCodeLine{1139 \{}
\DoxyCodeLine{1140    \textcolor{keywordflow}{if} (c-\/>sparse) \{ assert(len != NO\_CODE); \textcolor{keywordflow}{return} TRUE; \}}
\DoxyCodeLine{1141    \textcolor{keywordflow}{if} (len == NO\_CODE) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1142    \textcolor{keywordflow}{if} (len > STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH) \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1143    \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1144 \}}
\DoxyCodeLine{1145 }
\DoxyCodeLine{1146 \textcolor{comment}{// if the fast table above doesn't work, we want to binary}}
\DoxyCodeLine{1147 \textcolor{comment}{// search them... need to reverse the bits}}
\DoxyCodeLine{1148 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_compute\_sorted\_huffman(StbvCodebook *c, stbv\_uint8 *lengths, stbv\_uint32 *values)}
\DoxyCodeLine{1149 \{}
\DoxyCodeLine{1150    \textcolor{keywordtype}{int} i, len;}
\DoxyCodeLine{1151    \textcolor{comment}{// build a list of all the entries}}
\DoxyCodeLine{1152    \textcolor{comment}{// OPTIMIZATION: don't include the short ones, since they'll be caught by FAST\_HUFFMAN.}}
\DoxyCodeLine{1153    \textcolor{comment}{// this is kind of a frivolous optimization-\/-\/I don't see any performance improvement,}}
\DoxyCodeLine{1154    \textcolor{comment}{// but it's like 4 extra lines of code, so.}}
\DoxyCodeLine{1155    \textcolor{keywordflow}{if} (!c-\/>sparse) \{}
\DoxyCodeLine{1156       \textcolor{keywordtype}{int} k = 0;}
\DoxyCodeLine{1157       \textcolor{keywordflow}{for} (i=0; i < c-\/>entries; ++i)}
\DoxyCodeLine{1158          \textcolor{keywordflow}{if} (stbv\_include\_in\_sort(c, lengths[i])) }
\DoxyCodeLine{1159             c-\/>sorted\_codewords[k++] = stbv\_bit\_reverse(c-\/>codewords[i]);}
\DoxyCodeLine{1160       assert(k == c-\/>sorted\_entries);}
\DoxyCodeLine{1161    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1162       \textcolor{keywordflow}{for} (i=0; i < c-\/>sorted\_entries; ++i)}
\DoxyCodeLine{1163          c-\/>sorted\_codewords[i] = stbv\_bit\_reverse(c-\/>codewords[i]);}
\DoxyCodeLine{1164    \}}
\DoxyCodeLine{1165 }
\DoxyCodeLine{1166    qsort(c-\/>sorted\_codewords, c-\/>sorted\_entries, \textcolor{keyword}{sizeof}(c-\/>sorted\_codewords[0]), stbv\_uint32\_compare);}
\DoxyCodeLine{1167    c-\/>sorted\_codewords[c-\/>sorted\_entries] = 0xffffffff;}
\DoxyCodeLine{1168 }
\DoxyCodeLine{1169    len = c-\/>sparse ? c-\/>sorted\_entries : c-\/>entries;}
\DoxyCodeLine{1170    \textcolor{comment}{// now we need to indicate how they correspond; we could either}}
\DoxyCodeLine{1171    \textcolor{comment}{//   \#1: sort a different data structure that says who they correspond to}}
\DoxyCodeLine{1172    \textcolor{comment}{//   \#2: for each sorted entry, search the original list to find who corresponds}}
\DoxyCodeLine{1173    \textcolor{comment}{//   \#3: for each original entry, find the sorted entry}}
\DoxyCodeLine{1174    \textcolor{comment}{// \#1 requires extra storage, \#2 is slow, \#3 can use binary search!}}
\DoxyCodeLine{1175    \textcolor{keywordflow}{for} (i=0; i < len; ++i) \{}
\DoxyCodeLine{1176       \textcolor{keywordtype}{int} huff\_len = c-\/>sparse ? lengths[values[i]] : lengths[i];}
\DoxyCodeLine{1177       \textcolor{keywordflow}{if} (stbv\_include\_in\_sort(c,huff\_len)) \{}
\DoxyCodeLine{1178          stbv\_uint32 code = stbv\_bit\_reverse(c-\/>codewords[i]);}
\DoxyCodeLine{1179          \textcolor{keywordtype}{int} x=0, n=c-\/>sorted\_entries;}
\DoxyCodeLine{1180          \textcolor{keywordflow}{while} (n > 1) \{}
\DoxyCodeLine{1181             \textcolor{comment}{// invariant: sc[x] <= code < sc[x+n]}}
\DoxyCodeLine{1182             \textcolor{keywordtype}{int} m = x + (n >> 1);}
\DoxyCodeLine{1183             \textcolor{keywordflow}{if} (c-\/>sorted\_codewords[m] <= code) \{}
\DoxyCodeLine{1184                x = m;}
\DoxyCodeLine{1185                n -\/= (n>>1);}
\DoxyCodeLine{1186             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1187                n >>= 1;}
\DoxyCodeLine{1188             \}}
\DoxyCodeLine{1189          \}}
\DoxyCodeLine{1190          assert(c-\/>sorted\_codewords[x] == code);}
\DoxyCodeLine{1191          \textcolor{keywordflow}{if} (c-\/>sparse) \{}
\DoxyCodeLine{1192             c-\/>sorted\_values[x] = values[i];}
\DoxyCodeLine{1193             c-\/>codeword\_lengths[x] = huff\_len;}
\DoxyCodeLine{1194          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1195             c-\/>sorted\_values[x] = i;}
\DoxyCodeLine{1196          \}}
\DoxyCodeLine{1197       \}}
\DoxyCodeLine{1198    \}}
\DoxyCodeLine{1199 \}}
\DoxyCodeLine{1200 }
\DoxyCodeLine{1201 \textcolor{comment}{// only run while parsing the header (3 times)}}
\DoxyCodeLine{1202 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_vorbis\_validate(stbv\_uint8 *data)}
\DoxyCodeLine{1203 \{}
\DoxyCodeLine{1204    \textcolor{keyword}{static} stbv\_uint8 vorbis[6] = \{ \textcolor{charliteral}{'v'}, \textcolor{charliteral}{'o'}, \textcolor{charliteral}{'r'}, \textcolor{charliteral}{'b'}, \textcolor{charliteral}{'i'}, \textcolor{charliteral}{'s'} \};}
\DoxyCodeLine{1205    \textcolor{keywordflow}{return} memcmp(data, vorbis, 6) == 0;}
\DoxyCodeLine{1206 \}}
\DoxyCodeLine{1207 }
\DoxyCodeLine{1208 \textcolor{comment}{// called from setup only, once per code book}}
\DoxyCodeLine{1209 \textcolor{comment}{// (formula implied by specification)}}
\DoxyCodeLine{1210 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_lookup1\_values(\textcolor{keywordtype}{int} entries, \textcolor{keywordtype}{int} dim)}
\DoxyCodeLine{1211 \{}
\DoxyCodeLine{1212    \textcolor{keywordtype}{int} r = (int) floor(exp((\textcolor{keywordtype}{float}) log((\textcolor{keywordtype}{float}) entries) / dim));}
\DoxyCodeLine{1213    \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int}) floor(pow((\textcolor{keywordtype}{float}) r+1, dim)) <= entries)   \textcolor{comment}{// (int) cast for MinGW warning;}}
\DoxyCodeLine{1214       ++r;                                              \textcolor{comment}{// floor() to avoid \_ftol() when non-\/CRT}}
\DoxyCodeLine{1215    assert(pow((\textcolor{keywordtype}{float}) r+1, dim) > entries);}
\DoxyCodeLine{1216    assert((\textcolor{keywordtype}{int}) floor(pow((\textcolor{keywordtype}{float}) r, dim)) <= entries); \textcolor{comment}{// (int),floor() as above}}
\DoxyCodeLine{1217    \textcolor{keywordflow}{return} r;}
\DoxyCodeLine{1218 \}}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220 \textcolor{comment}{// called twice per file}}
\DoxyCodeLine{1221 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_compute\_twiddle\_factors(\textcolor{keywordtype}{int} n, \textcolor{keywordtype}{float} *A, \textcolor{keywordtype}{float} *B, \textcolor{keywordtype}{float} *C)}
\DoxyCodeLine{1222 \{}
\DoxyCodeLine{1223    \textcolor{keywordtype}{int} n4 = n >> 2, n8 = n >> 3;}
\DoxyCodeLine{1224    \textcolor{keywordtype}{int} k,k2;}
\DoxyCodeLine{1225 }
\DoxyCodeLine{1226    \textcolor{keywordflow}{for} (k=k2=0; k < n4; ++k,k2+=2) \{}
\DoxyCodeLine{1227       A[k2  ] = (float)  cos(4*k*M\_PI/n);}
\DoxyCodeLine{1228       A[k2+1] = (float) -\/sin(4*k*M\_PI/n);}
\DoxyCodeLine{1229       B[k2  ] = (float)  cos((k2+1)*M\_PI/n/2) * 0.5f;}
\DoxyCodeLine{1230       B[k2+1] = (float)  sin((k2+1)*M\_PI/n/2) * 0.5f;}
\DoxyCodeLine{1231    \}}
\DoxyCodeLine{1232    \textcolor{keywordflow}{for} (k=k2=0; k < n8; ++k,k2+=2) \{}
\DoxyCodeLine{1233       C[k2  ] = (float)  cos(2*(k2+1)*M\_PI/n);}
\DoxyCodeLine{1234       C[k2+1] = (float) -\/sin(2*(k2+1)*M\_PI/n);}
\DoxyCodeLine{1235    \}}
\DoxyCodeLine{1236 \}}
\DoxyCodeLine{1237 }
\DoxyCodeLine{1238 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_compute\_window(\textcolor{keywordtype}{int} n, \textcolor{keywordtype}{float} *window)}
\DoxyCodeLine{1239 \{}
\DoxyCodeLine{1240    \textcolor{keywordtype}{int} n2 = n >> 1, i;}
\DoxyCodeLine{1241    \textcolor{keywordflow}{for} (i=0; i < n2; ++i)}
\DoxyCodeLine{1242       window[i] = (\textcolor{keywordtype}{float}) sin(0.5 * M\_PI * stbv\_square((\textcolor{keywordtype}{float}) sin((i -\/ 0 + 0.5) / n2 * 0.5 * M\_PI)));}
\DoxyCodeLine{1243 \}}
\DoxyCodeLine{1244 }
\DoxyCodeLine{1245 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_compute\_bitreverse(\textcolor{keywordtype}{int} n, stbv\_uint16 *rev)}
\DoxyCodeLine{1246 \{}
\DoxyCodeLine{1247    \textcolor{keywordtype}{int} ld = stbv\_ilog(n) -\/ 1; \textcolor{comment}{// stbv\_ilog is off-\/by-\/one from normal definitions}}
\DoxyCodeLine{1248    \textcolor{keywordtype}{int} i, n8 = n >> 3;}
\DoxyCodeLine{1249    \textcolor{keywordflow}{for} (i=0; i < n8; ++i)}
\DoxyCodeLine{1250       rev[i] = (stbv\_bit\_reverse(i) >> (32-\/ld+3)) << 2;}
\DoxyCodeLine{1251 \}}
\DoxyCodeLine{1252 }
\DoxyCodeLine{1253 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_init\_blocksize(stbv\_vorb *f, \textcolor{keywordtype}{int} b, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{1254 \{}
\DoxyCodeLine{1255    \textcolor{keywordtype}{int} n2 = n >> 1, n4 = n >> 2, n8 = n >> 3;}
\DoxyCodeLine{1256    f-\/>A[b] = (\textcolor{keywordtype}{float} *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * n2);}
\DoxyCodeLine{1257    f-\/>B[b] = (\textcolor{keywordtype}{float} *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * n2);}
\DoxyCodeLine{1258    f-\/>C[b] = (\textcolor{keywordtype}{float} *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * n4);}
\DoxyCodeLine{1259    \textcolor{keywordflow}{if} (!f-\/>A[b] || !f-\/>B[b] || !f-\/>C[b]) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{1260    stbv\_compute\_twiddle\_factors(n, f-\/>A[b], f-\/>B[b], f-\/>C[b]);}
\DoxyCodeLine{1261    f-\/>window[b] = (\textcolor{keywordtype}{float} *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * n2);}
\DoxyCodeLine{1262    \textcolor{keywordflow}{if} (!f-\/>window[b]) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{1263    stbv\_compute\_window(n, f-\/>window[b]);}
\DoxyCodeLine{1264    f-\/>stbv\_bit\_reverse[b] = (stbv\_uint16 *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(stbv\_uint16) * n8);}
\DoxyCodeLine{1265    \textcolor{keywordflow}{if} (!f-\/>stbv\_bit\_reverse[b]) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{1266    stbv\_compute\_bitreverse(n, f-\/>stbv\_bit\_reverse[b]);}
\DoxyCodeLine{1267    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1268 \}}
\DoxyCodeLine{1269 }
\DoxyCodeLine{1270 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_neighbors(stbv\_uint16 *x, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} *plow, \textcolor{keywordtype}{int} *phigh)}
\DoxyCodeLine{1271 \{}
\DoxyCodeLine{1272    \textcolor{keywordtype}{int} low = -\/1;}
\DoxyCodeLine{1273    \textcolor{keywordtype}{int} high = 65536;}
\DoxyCodeLine{1274    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{1275    \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{1276       \textcolor{keywordflow}{if} (x[i] > low  \&\& x[i] < x[n]) \{ *plow  = i; low = x[i]; \}}
\DoxyCodeLine{1277       \textcolor{keywordflow}{if} (x[i] < high \&\& x[i] > x[n]) \{ *phigh = i; high = x[i]; \}}
\DoxyCodeLine{1278    \}}
\DoxyCodeLine{1279 \}}
\DoxyCodeLine{1280 }
\DoxyCodeLine{1281 \textcolor{comment}{// this has been repurposed so y is now the original index instead of y}}
\DoxyCodeLine{1282 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{1283 \{}
\DoxyCodeLine{1284    stbv\_uint16 x,id;}
\DoxyCodeLine{1285 \} stbv\_floor\_ordering;}
\DoxyCodeLine{1286 }
\DoxyCodeLine{1287 \textcolor{keyword}{static} \textcolor{keywordtype}{int} STBV\_CDECL stbv\_point\_compare(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *p, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *q)}
\DoxyCodeLine{1288 \{}
\DoxyCodeLine{1289    stbv\_floor\_ordering *a = (stbv\_floor\_ordering *) p;}
\DoxyCodeLine{1290    stbv\_floor\_ordering *b = (stbv\_floor\_ordering *) q;}
\DoxyCodeLine{1291    \textcolor{keywordflow}{return} a-\/>x < b-\/>x ? -\/1 : a-\/>x > b-\/>x;}
\DoxyCodeLine{1292 \}}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294 \textcolor{comment}{//}}
\DoxyCodeLine{1296 \textcolor{comment}{}}
\DoxyCodeLine{1297 }
\DoxyCodeLine{1298 \textcolor{preprocessor}{\#if defined(STB\_VORBIS\_NO\_STDIO)}}
\DoxyCodeLine{1299 \textcolor{preprocessor}{   \#define STBV\_USE\_MEMORY(z)    TRUE}}
\DoxyCodeLine{1300 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1301 \textcolor{preprocessor}{   \#define STBV\_USE\_MEMORY(z)    ((z)-\/>stream)}}
\DoxyCodeLine{1302 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1303 }
\DoxyCodeLine{1304 \textcolor{keyword}{static} stbv\_uint8 stbv\_get8(stbv\_vorb *z)}
\DoxyCodeLine{1305 \{}
\DoxyCodeLine{1306    \textcolor{keywordflow}{if} (STBV\_USE\_MEMORY(z)) \{}
\DoxyCodeLine{1307       \textcolor{keywordflow}{if} (z-\/>stream >= z-\/>stream\_end) \{ z-\/>eof = TRUE; \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{1308       \textcolor{keywordflow}{return} *z-\/>stream++;}
\DoxyCodeLine{1309    \}}
\DoxyCodeLine{1310 }
\DoxyCodeLine{1311 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{1312    \{}
\DoxyCodeLine{1313    \textcolor{keywordtype}{int} c = fgetc(z-\/>f);}
\DoxyCodeLine{1314    \textcolor{keywordflow}{if} (c == EOF) \{ z-\/>eof = TRUE; \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{1315    \textcolor{keywordflow}{return} c;}
\DoxyCodeLine{1316    \}}
\DoxyCodeLine{1317 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{1318 \}}
\DoxyCodeLine{1319 }
\DoxyCodeLine{1320 \textcolor{keyword}{static} stbv\_uint32 stbv\_get32(stbv\_vorb *f)}
\DoxyCodeLine{1321 \{}
\DoxyCodeLine{1322    stbv\_uint32 x;}
\DoxyCodeLine{1323    x = stbv\_get8(f);}
\DoxyCodeLine{1324    x += stbv\_get8(f) << 8;}
\DoxyCodeLine{1325    x += stbv\_get8(f) << 16;}
\DoxyCodeLine{1326    x += (stbv\_uint32) stbv\_get8(f) << 24;}
\DoxyCodeLine{1327    \textcolor{keywordflow}{return} x;}
\DoxyCodeLine{1328 \}}
\DoxyCodeLine{1329 }
\DoxyCodeLine{1330 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_getn(stbv\_vorb *z, stbv\_uint8 *data, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{1331 \{}
\DoxyCodeLine{1332    \textcolor{keywordflow}{if} (STBV\_USE\_MEMORY(z)) \{}
\DoxyCodeLine{1333       \textcolor{keywordflow}{if} (z-\/>stream+n > z-\/>stream\_end) \{ z-\/>eof = 1; \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{1334       memcpy(data, z-\/>stream, n);}
\DoxyCodeLine{1335       z-\/>stream += n;}
\DoxyCodeLine{1336       \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1337    \}}
\DoxyCodeLine{1338 }
\DoxyCodeLine{1339 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_STDIO   }}
\DoxyCodeLine{1340    \textcolor{keywordflow}{if} (fread(data, n, 1, z-\/>f) == 1)}
\DoxyCodeLine{1341       \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1342    \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1343       z-\/>eof = 1;}
\DoxyCodeLine{1344       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1345    \}}
\DoxyCodeLine{1346 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{1347 \}}
\DoxyCodeLine{1348 }
\DoxyCodeLine{1349 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_skip(stbv\_vorb *z, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{1350 \{}
\DoxyCodeLine{1351    \textcolor{keywordflow}{if} (STBV\_USE\_MEMORY(z)) \{}
\DoxyCodeLine{1352       z-\/>stream += n;}
\DoxyCodeLine{1353       \textcolor{keywordflow}{if} (z-\/>stream >= z-\/>stream\_end) z-\/>eof = 1;}
\DoxyCodeLine{1354       \textcolor{keywordflow}{return};}
\DoxyCodeLine{1355    \}}
\DoxyCodeLine{1356 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{1357    \{}
\DoxyCodeLine{1358       \textcolor{keywordtype}{long} x = ftell(z-\/>f);}
\DoxyCodeLine{1359       fseek(z-\/>f, x+n, SEEK\_SET);}
\DoxyCodeLine{1360    \}}
\DoxyCodeLine{1361 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{1362 \}}
\DoxyCodeLine{1363 }
\DoxyCodeLine{1364 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_set\_file\_offset(stb\_vorbis *f, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} loc)}
\DoxyCodeLine{1365 \{}
\DoxyCodeLine{1366 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{1367    \textcolor{keywordflow}{if} (f-\/>push\_mode) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1368 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{1369    f-\/>eof = 0;}
\DoxyCodeLine{1370    \textcolor{keywordflow}{if} (STBV\_USE\_MEMORY(f)) \{}
\DoxyCodeLine{1371       \textcolor{keywordflow}{if} (f-\/>stream\_start + loc >= f-\/>stream\_end || f-\/>stream\_start + loc < f-\/>stream\_start) \{}
\DoxyCodeLine{1372          f-\/>stream = f-\/>stream\_end;}
\DoxyCodeLine{1373          f-\/>eof = 1;}
\DoxyCodeLine{1374          \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1375       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1376          f-\/>stream = f-\/>stream\_start + loc;}
\DoxyCodeLine{1377          \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1378       \}}
\DoxyCodeLine{1379    \}}
\DoxyCodeLine{1380 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{1381    \textcolor{keywordflow}{if} (loc + f-\/>f\_start < loc || loc >= 0x80000000) \{}
\DoxyCodeLine{1382       loc = 0x7fffffff;}
\DoxyCodeLine{1383       f-\/>eof = 1;}
\DoxyCodeLine{1384    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1385       loc += f-\/>f\_start;}
\DoxyCodeLine{1386    \}}
\DoxyCodeLine{1387    \textcolor{keywordflow}{if} (!fseek(f-\/>f, loc, SEEK\_SET))}
\DoxyCodeLine{1388       \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1389    f-\/>eof = 1;}
\DoxyCodeLine{1390    fseek(f-\/>f, f-\/>f\_start, SEEK\_END);}
\DoxyCodeLine{1391    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1392 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{1393 \}}
\DoxyCodeLine{1394 }
\DoxyCodeLine{1395 }
\DoxyCodeLine{1396 \textcolor{keyword}{static} stbv\_uint8 stbv\_ogg\_page\_header[4] = \{ 0x4f, 0x67, 0x67, 0x53 \};}
\DoxyCodeLine{1397 }
\DoxyCodeLine{1398 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_capture\_pattern(stbv\_vorb *f)}
\DoxyCodeLine{1399 \{}
\DoxyCodeLine{1400    \textcolor{keywordflow}{if} (0x4f != stbv\_get8(f)) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1401    \textcolor{keywordflow}{if} (0x67 != stbv\_get8(f)) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1402    \textcolor{keywordflow}{if} (0x67 != stbv\_get8(f)) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1403    \textcolor{keywordflow}{if} (0x53 != stbv\_get8(f)) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1404    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1405 \}}
\DoxyCodeLine{1406 }
\DoxyCodeLine{1407 \textcolor{preprocessor}{\#define STBV\_PAGEFLAG\_continued\_packet   1}}
\DoxyCodeLine{1408 \textcolor{preprocessor}{\#define STBV\_PAGEFLAG\_first\_page         2}}
\DoxyCodeLine{1409 \textcolor{preprocessor}{\#define STBV\_PAGEFLAG\_last\_page          4}}
\DoxyCodeLine{1410 }
\DoxyCodeLine{1411 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_start\_page\_no\_capturepattern(stbv\_vorb *f)}
\DoxyCodeLine{1412 \{}
\DoxyCodeLine{1413    stbv\_uint32 loc0,loc1,n;}
\DoxyCodeLine{1414    \textcolor{comment}{// stream structure version}}
\DoxyCodeLine{1415    \textcolor{keywordflow}{if} (0 != stbv\_get8(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream\_structure\_version);}
\DoxyCodeLine{1416    \textcolor{comment}{// header flag}}
\DoxyCodeLine{1417    f-\/>page\_flag = stbv\_get8(f);}
\DoxyCodeLine{1418    \textcolor{comment}{// absolute granule position}}
\DoxyCodeLine{1419    loc0 = stbv\_get32(f); }
\DoxyCodeLine{1420    loc1 = stbv\_get32(f);}
\DoxyCodeLine{1421    \textcolor{comment}{// @TODO: validate loc0,loc1 as valid positions?}}
\DoxyCodeLine{1422    \textcolor{comment}{// stream serial number -\/-\/ vorbis doesn't interleave, so discard}}
\DoxyCodeLine{1423    stbv\_get32(f);}
\DoxyCodeLine{1424    \textcolor{comment}{//if (f-\/>serial != stbv\_get32(f)) return stbv\_error(f, VORBIS\_incorrect\_stream\_serial\_number);}}
\DoxyCodeLine{1425    \textcolor{comment}{// page sequence number}}
\DoxyCodeLine{1426    n = stbv\_get32(f);}
\DoxyCodeLine{1427    f-\/>last\_page = n;}
\DoxyCodeLine{1428    \textcolor{comment}{// CRC32}}
\DoxyCodeLine{1429    stbv\_get32(f);}
\DoxyCodeLine{1430    \textcolor{comment}{// page\_segments}}
\DoxyCodeLine{1431    f-\/>segment\_count = stbv\_get8(f);}
\DoxyCodeLine{1432    \textcolor{keywordflow}{if} (!stbv\_getn(f, f-\/>segments, f-\/>segment\_count))}
\DoxyCodeLine{1433       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_unexpected\_eof);}
\DoxyCodeLine{1434    \textcolor{comment}{// assume we \_don't\_ know any the sample position of any segments}}
\DoxyCodeLine{1435    f-\/>end\_seg\_with\_known\_loc = -\/2;}
\DoxyCodeLine{1436    \textcolor{keywordflow}{if} (loc0 != \string~0U || loc1 != \string~0U) \{}
\DoxyCodeLine{1437       \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{1438       \textcolor{comment}{// determine which packet is the last one that will complete}}
\DoxyCodeLine{1439       \textcolor{keywordflow}{for} (i=f-\/>segment\_count-\/1; i >= 0; -\/-\/i)}
\DoxyCodeLine{1440          \textcolor{keywordflow}{if} (f-\/>segments[i] < 255)}
\DoxyCodeLine{1441             \textcolor{keywordflow}{break};}
\DoxyCodeLine{1442       \textcolor{comment}{// 'i' is now the index of the \_last\_ segment of a packet that ends}}
\DoxyCodeLine{1443       \textcolor{keywordflow}{if} (i >= 0) \{}
\DoxyCodeLine{1444          f-\/>end\_seg\_with\_known\_loc = i;}
\DoxyCodeLine{1445          f-\/>known\_loc\_for\_packet   = loc0;}
\DoxyCodeLine{1446       \}}
\DoxyCodeLine{1447    \}}
\DoxyCodeLine{1448    \textcolor{keywordflow}{if} (f-\/>first\_decode) \{}
\DoxyCodeLine{1449       \textcolor{keywordtype}{int} i,len;}
\DoxyCodeLine{1450       StbvProbedPage p;}
\DoxyCodeLine{1451       len = 0;}
\DoxyCodeLine{1452       \textcolor{keywordflow}{for} (i=0; i < f-\/>segment\_count; ++i)}
\DoxyCodeLine{1453          len += f-\/>segments[i];}
\DoxyCodeLine{1454       len += 27 + f-\/>segment\_count;}
\DoxyCodeLine{1455       p.page\_start = f-\/>first\_audio\_page\_offset;}
\DoxyCodeLine{1456       p.page\_end = p.page\_start + len;}
\DoxyCodeLine{1457       p.last\_decoded\_sample = loc0;}
\DoxyCodeLine{1458       f-\/>p\_first = p;}
\DoxyCodeLine{1459    \}}
\DoxyCodeLine{1460    f-\/>next\_seg = 0;}
\DoxyCodeLine{1461    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1462 \}}
\DoxyCodeLine{1463 }
\DoxyCodeLine{1464 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_start\_page(stbv\_vorb *f)}
\DoxyCodeLine{1465 \{}
\DoxyCodeLine{1466    \textcolor{keywordflow}{if} (!stbv\_capture\_pattern(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_missing\_capture\_pattern);}
\DoxyCodeLine{1467    \textcolor{keywordflow}{return} stbv\_start\_page\_no\_capturepattern(f);}
\DoxyCodeLine{1468 \}}
\DoxyCodeLine{1469 }
\DoxyCodeLine{1470 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_start\_packet(stbv\_vorb *f)}
\DoxyCodeLine{1471 \{}
\DoxyCodeLine{1472    \textcolor{keywordflow}{while} (f-\/>next\_seg == -\/1) \{}
\DoxyCodeLine{1473       \textcolor{keywordflow}{if} (!stbv\_start\_page(f)) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1474       \textcolor{keywordflow}{if} (f-\/>page\_flag \& STBV\_PAGEFLAG\_continued\_packet)}
\DoxyCodeLine{1475          \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_continued\_packet\_flag\_invalid);}
\DoxyCodeLine{1476    \}}
\DoxyCodeLine{1477    f-\/>last\_seg = FALSE;}
\DoxyCodeLine{1478    f-\/>valid\_bits = 0;}
\DoxyCodeLine{1479    f-\/>packet\_bytes = 0;}
\DoxyCodeLine{1480    f-\/>bytes\_in\_seg = 0;}
\DoxyCodeLine{1481    \textcolor{comment}{// f-\/>next\_seg is now valid}}
\DoxyCodeLine{1482    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1483 \}}
\DoxyCodeLine{1484 }
\DoxyCodeLine{1485 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_maybe\_start\_packet(stbv\_vorb *f)}
\DoxyCodeLine{1486 \{}
\DoxyCodeLine{1487    \textcolor{keywordflow}{if} (f-\/>next\_seg == -\/1) \{}
\DoxyCodeLine{1488       \textcolor{keywordtype}{int} x = stbv\_get8(f);}
\DoxyCodeLine{1489       \textcolor{keywordflow}{if} (f-\/>eof) \textcolor{keywordflow}{return} FALSE; \textcolor{comment}{// EOF at page boundary is not an error!}}
\DoxyCodeLine{1490       \textcolor{keywordflow}{if} (0x4f != x      ) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_missing\_capture\_pattern);}
\DoxyCodeLine{1491       \textcolor{keywordflow}{if} (0x67 != stbv\_get8(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_missing\_capture\_pattern);}
\DoxyCodeLine{1492       \textcolor{keywordflow}{if} (0x67 != stbv\_get8(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_missing\_capture\_pattern);}
\DoxyCodeLine{1493       \textcolor{keywordflow}{if} (0x53 != stbv\_get8(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_missing\_capture\_pattern);}
\DoxyCodeLine{1494       \textcolor{keywordflow}{if} (!stbv\_start\_page\_no\_capturepattern(f)) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1495       \textcolor{keywordflow}{if} (f-\/>page\_flag \& STBV\_PAGEFLAG\_continued\_packet) \{}
\DoxyCodeLine{1496          \textcolor{comment}{// set up enough state that we can read this packet if we want,}}
\DoxyCodeLine{1497          \textcolor{comment}{// e.g. during recovery}}
\DoxyCodeLine{1498          f-\/>last\_seg = FALSE;}
\DoxyCodeLine{1499          f-\/>bytes\_in\_seg = 0;}
\DoxyCodeLine{1500          \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_continued\_packet\_flag\_invalid);}
\DoxyCodeLine{1501       \}}
\DoxyCodeLine{1502    \}}
\DoxyCodeLine{1503    \textcolor{keywordflow}{return} stbv\_start\_packet(f);}
\DoxyCodeLine{1504 \}}
\DoxyCodeLine{1505 }
\DoxyCodeLine{1506 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_next\_segment(stbv\_vorb *f)}
\DoxyCodeLine{1507 \{}
\DoxyCodeLine{1508    \textcolor{keywordtype}{int} len;}
\DoxyCodeLine{1509    \textcolor{keywordflow}{if} (f-\/>last\_seg) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1510    \textcolor{keywordflow}{if} (f-\/>next\_seg == -\/1) \{}
\DoxyCodeLine{1511       f-\/>last\_seg\_which = f-\/>segment\_count-\/1; \textcolor{comment}{// in case stbv\_start\_page fails}}
\DoxyCodeLine{1512       \textcolor{keywordflow}{if} (!stbv\_start\_page(f)) \{ f-\/>last\_seg = 1; \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{1513       \textcolor{keywordflow}{if} (!(f-\/>page\_flag \& STBV\_PAGEFLAG\_continued\_packet)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_continued\_packet\_flag\_invalid);}
\DoxyCodeLine{1514    \}}
\DoxyCodeLine{1515    len = f-\/>segments[f-\/>next\_seg++];}
\DoxyCodeLine{1516    \textcolor{keywordflow}{if} (len < 255) \{}
\DoxyCodeLine{1517       f-\/>last\_seg = TRUE;}
\DoxyCodeLine{1518       f-\/>last\_seg\_which = f-\/>next\_seg-\/1;}
\DoxyCodeLine{1519    \}}
\DoxyCodeLine{1520    \textcolor{keywordflow}{if} (f-\/>next\_seg >= f-\/>segment\_count)}
\DoxyCodeLine{1521       f-\/>next\_seg = -\/1;}
\DoxyCodeLine{1522    assert(f-\/>bytes\_in\_seg == 0);}
\DoxyCodeLine{1523    f-\/>bytes\_in\_seg = len;}
\DoxyCodeLine{1524    \textcolor{keywordflow}{return} len;}
\DoxyCodeLine{1525 \}}
\DoxyCodeLine{1526 }
\DoxyCodeLine{1527 \textcolor{preprocessor}{\#define STBV\_EOP    (-\/1)}}
\DoxyCodeLine{1528 \textcolor{preprocessor}{\#define STBV\_INVALID\_BITS  (-\/1)}}
\DoxyCodeLine{1529 }
\DoxyCodeLine{1530 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_get8\_packet\_raw(stbv\_vorb *f)}
\DoxyCodeLine{1531 \{}
\DoxyCodeLine{1532    \textcolor{keywordflow}{if} (!f-\/>bytes\_in\_seg) \{  \textcolor{comment}{// CLANG!}}
\DoxyCodeLine{1533       \textcolor{keywordflow}{if} (f-\/>last\_seg) \textcolor{keywordflow}{return} STBV\_EOP;}
\DoxyCodeLine{1534       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!stbv\_next\_segment(f)) \textcolor{keywordflow}{return} STBV\_EOP;}
\DoxyCodeLine{1535    \}}
\DoxyCodeLine{1536    assert(f-\/>bytes\_in\_seg > 0);}
\DoxyCodeLine{1537    -\/-\/f-\/>bytes\_in\_seg;}
\DoxyCodeLine{1538    ++f-\/>packet\_bytes;}
\DoxyCodeLine{1539    \textcolor{keywordflow}{return} stbv\_get8(f);}
\DoxyCodeLine{1540 \}}
\DoxyCodeLine{1541 }
\DoxyCodeLine{1542 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_get8\_packet(stbv\_vorb *f)}
\DoxyCodeLine{1543 \{}
\DoxyCodeLine{1544    \textcolor{keywordtype}{int} x = stbv\_get8\_packet\_raw(f);}
\DoxyCodeLine{1545    f-\/>valid\_bits = 0;}
\DoxyCodeLine{1546    \textcolor{keywordflow}{return} x;}
\DoxyCodeLine{1547 \}}
\DoxyCodeLine{1548 }
\DoxyCodeLine{1549 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_flush\_packet(stbv\_vorb *f)}
\DoxyCodeLine{1550 \{}
\DoxyCodeLine{1551    \textcolor{keywordflow}{while} (stbv\_get8\_packet\_raw(f) != STBV\_EOP);}
\DoxyCodeLine{1552 \}}
\DoxyCodeLine{1553 }
\DoxyCodeLine{1554 \textcolor{comment}{// @OPTIMIZE: this is the secondary bit decoder, so it's probably not as important}}
\DoxyCodeLine{1555 \textcolor{comment}{// as the huffman decoder?}}
\DoxyCodeLine{1556 \textcolor{keyword}{static} stbv\_uint32 stbv\_get\_bits(stbv\_vorb *f, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{1557 \{}
\DoxyCodeLine{1558    stbv\_uint32 z;}
\DoxyCodeLine{1559 }
\DoxyCodeLine{1560    \textcolor{keywordflow}{if} (f-\/>valid\_bits < 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1561    \textcolor{keywordflow}{if} (f-\/>valid\_bits < n) \{}
\DoxyCodeLine{1562       \textcolor{keywordflow}{if} (n > 24) \{}
\DoxyCodeLine{1563          \textcolor{comment}{// the accumulator technique below would not work correctly in this case}}
\DoxyCodeLine{1564          z = stbv\_get\_bits(f, 24);}
\DoxyCodeLine{1565          z += stbv\_get\_bits(f, n-\/24) << 24;}
\DoxyCodeLine{1566          \textcolor{keywordflow}{return} z;}
\DoxyCodeLine{1567       \}}
\DoxyCodeLine{1568       \textcolor{keywordflow}{if} (f-\/>valid\_bits == 0) f-\/>acc = 0;}
\DoxyCodeLine{1569       \textcolor{keywordflow}{while} (f-\/>valid\_bits < n) \{}
\DoxyCodeLine{1570          \textcolor{keywordtype}{int} z = stbv\_get8\_packet\_raw(f);}
\DoxyCodeLine{1571          \textcolor{keywordflow}{if} (z == STBV\_EOP) \{}
\DoxyCodeLine{1572             f-\/>valid\_bits = STBV\_INVALID\_BITS;}
\DoxyCodeLine{1573             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1574          \}}
\DoxyCodeLine{1575          f-\/>acc += z << f-\/>valid\_bits;}
\DoxyCodeLine{1576          f-\/>valid\_bits += 8;}
\DoxyCodeLine{1577       \}}
\DoxyCodeLine{1578    \}}
\DoxyCodeLine{1579    \textcolor{keywordflow}{if} (f-\/>valid\_bits < 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1580    z = f-\/>acc \& ((1 << n)-\/1);}
\DoxyCodeLine{1581    f-\/>acc >>= n;}
\DoxyCodeLine{1582    f-\/>valid\_bits -\/= n;}
\DoxyCodeLine{1583    \textcolor{keywordflow}{return} z;}
\DoxyCodeLine{1584 \}}
\DoxyCodeLine{1585 }
\DoxyCodeLine{1586 \textcolor{comment}{// @OPTIMIZE: primary accumulator for huffman}}
\DoxyCodeLine{1587 \textcolor{comment}{// expand the buffer to as many bits as possible without reading off end of packet}}
\DoxyCodeLine{1588 \textcolor{comment}{// it might be nice to allow f-\/>valid\_bits and f-\/>acc to be stored in registers,}}
\DoxyCodeLine{1589 \textcolor{comment}{// e.g. cache them locally and decode locally}}
\DoxyCodeLine{1590 \textcolor{keyword}{static} \_\_forceinline \textcolor{keywordtype}{void} stbv\_prep\_huffman(stbv\_vorb *f)}
\DoxyCodeLine{1591 \{}
\DoxyCodeLine{1592    \textcolor{keywordflow}{if} (f-\/>valid\_bits <= 24) \{}
\DoxyCodeLine{1593       \textcolor{keywordflow}{if} (f-\/>valid\_bits == 0) f-\/>acc = 0;}
\DoxyCodeLine{1594       \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1595          \textcolor{keywordtype}{int} z;}
\DoxyCodeLine{1596          \textcolor{keywordflow}{if} (f-\/>last\_seg \&\& !f-\/>bytes\_in\_seg) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1597          z = stbv\_get8\_packet\_raw(f);}
\DoxyCodeLine{1598          \textcolor{keywordflow}{if} (z == STBV\_EOP) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1599          f-\/>acc += (unsigned) z << f-\/>valid\_bits;}
\DoxyCodeLine{1600          f-\/>valid\_bits += 8;}
\DoxyCodeLine{1601       \} \textcolor{keywordflow}{while} (f-\/>valid\_bits <= 24);}
\DoxyCodeLine{1602    \}}
\DoxyCodeLine{1603 \}}
\DoxyCodeLine{1604 }
\DoxyCodeLine{1605 \textcolor{keyword}{enum}}
\DoxyCodeLine{1606 \{}
\DoxyCodeLine{1607    STBV\_VORBIS\_packet\_id = 1,}
\DoxyCodeLine{1608    STBV\_VORBIS\_packet\_comment = 3,}
\DoxyCodeLine{1609    STBV\_VORBIS\_packet\_setup = 5}
\DoxyCodeLine{1610 \};}
\DoxyCodeLine{1611 }
\DoxyCodeLine{1612 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_codebook\_decode\_scalar\_raw(stbv\_vorb *f, StbvCodebook *c)}
\DoxyCodeLine{1613 \{}
\DoxyCodeLine{1614    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{1615    stbv\_prep\_huffman(f);}
\DoxyCodeLine{1616 }
\DoxyCodeLine{1617    \textcolor{keywordflow}{if} (c-\/>codewords == NULL \&\& c-\/>sorted\_codewords == NULL)}
\DoxyCodeLine{1618       \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{1619 }
\DoxyCodeLine{1620    \textcolor{comment}{// cases to use binary search: sorted\_codewords \&\& !c-\/>codewords}}
\DoxyCodeLine{1621    \textcolor{comment}{//                             sorted\_codewords \&\& c-\/>entries > 8}}
\DoxyCodeLine{1622    \textcolor{keywordflow}{if} (c-\/>entries > 8 ? c-\/>sorted\_codewords!=NULL : !c-\/>codewords) \{}
\DoxyCodeLine{1623       \textcolor{comment}{// binary search}}
\DoxyCodeLine{1624       stbv\_uint32 code = stbv\_bit\_reverse(f-\/>acc);}
\DoxyCodeLine{1625       \textcolor{keywordtype}{int} x=0, n=c-\/>sorted\_entries, len;}
\DoxyCodeLine{1626 }
\DoxyCodeLine{1627       \textcolor{keywordflow}{while} (n > 1) \{}
\DoxyCodeLine{1628          \textcolor{comment}{// invariant: sc[x] <= code < sc[x+n]}}
\DoxyCodeLine{1629          \textcolor{keywordtype}{int} m = x + (n >> 1);}
\DoxyCodeLine{1630          \textcolor{keywordflow}{if} (c-\/>sorted\_codewords[m] <= code) \{}
\DoxyCodeLine{1631             x = m;}
\DoxyCodeLine{1632             n -\/= (n>>1);}
\DoxyCodeLine{1633          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1634             n >>= 1;}
\DoxyCodeLine{1635          \}}
\DoxyCodeLine{1636       \}}
\DoxyCodeLine{1637       \textcolor{comment}{// x is now the sorted index}}
\DoxyCodeLine{1638       \textcolor{keywordflow}{if} (!c-\/>sparse) x = c-\/>sorted\_values[x];}
\DoxyCodeLine{1639       \textcolor{comment}{// x is now sorted index if sparse, or symbol otherwise}}
\DoxyCodeLine{1640       len = c-\/>codeword\_lengths[x];}
\DoxyCodeLine{1641       \textcolor{keywordflow}{if} (f-\/>valid\_bits >= len) \{}
\DoxyCodeLine{1642          f-\/>acc >>= len;}
\DoxyCodeLine{1643          f-\/>valid\_bits -\/= len;}
\DoxyCodeLine{1644          \textcolor{keywordflow}{return} x;}
\DoxyCodeLine{1645       \}}
\DoxyCodeLine{1646 }
\DoxyCodeLine{1647       f-\/>valid\_bits = 0;}
\DoxyCodeLine{1648       \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{1649    \}}
\DoxyCodeLine{1650 }
\DoxyCodeLine{1651    \textcolor{comment}{// if small, linear search}}
\DoxyCodeLine{1652    assert(!c-\/>sparse);}
\DoxyCodeLine{1653    \textcolor{keywordflow}{for} (i=0; i < c-\/>entries; ++i) \{}
\DoxyCodeLine{1654       \textcolor{keywordflow}{if} (c-\/>codeword\_lengths[i] == NO\_CODE) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{1655       \textcolor{keywordflow}{if} (c-\/>codewords[i] == (f-\/>acc \& ((1 << c-\/>codeword\_lengths[i])-\/1))) \{}
\DoxyCodeLine{1656          \textcolor{keywordflow}{if} (f-\/>valid\_bits >= c-\/>codeword\_lengths[i]) \{}
\DoxyCodeLine{1657             f-\/>acc >>= c-\/>codeword\_lengths[i];}
\DoxyCodeLine{1658             f-\/>valid\_bits -\/= c-\/>codeword\_lengths[i];}
\DoxyCodeLine{1659             \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{1660          \}}
\DoxyCodeLine{1661          f-\/>valid\_bits = 0;}
\DoxyCodeLine{1662          \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{1663       \}}
\DoxyCodeLine{1664    \}}
\DoxyCodeLine{1665 }
\DoxyCodeLine{1666    stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{1667    f-\/>valid\_bits = 0;}
\DoxyCodeLine{1668    \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{1669 \}}
\DoxyCodeLine{1670 }
\DoxyCodeLine{1671 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_INLINE\_DECODE}}
\DoxyCodeLine{1672 }
\DoxyCodeLine{1673 \textcolor{preprocessor}{\#define STBV\_DECODE\_RAW(var, f,c)                                  \(\backslash\)}}
\DoxyCodeLine{1674 \textcolor{preprocessor}{   if (f-\/>valid\_bits < STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH)        \(\backslash\)}}
\DoxyCodeLine{1675 \textcolor{preprocessor}{      stbv\_prep\_huffman(f);                                        \(\backslash\)}}
\DoxyCodeLine{1676 \textcolor{preprocessor}{   var = f-\/>acc \& STBV\_FAST\_HUFFMAN\_TABLE\_MASK;                    \(\backslash\)}}
\DoxyCodeLine{1677 \textcolor{preprocessor}{   var = c-\/>fast\_huffman[var];                                \(\backslash\)}}
\DoxyCodeLine{1678 \textcolor{preprocessor}{   if (var >= 0) \{                                            \(\backslash\)}}
\DoxyCodeLine{1679 \textcolor{preprocessor}{      int n = c-\/>codeword\_lengths[var];                       \(\backslash\)}}
\DoxyCodeLine{1680 \textcolor{preprocessor}{      f-\/>acc >>= n;                                           \(\backslash\)}}
\DoxyCodeLine{1681 \textcolor{preprocessor}{      f-\/>valid\_bits -\/= n;                                     \(\backslash\)}}
\DoxyCodeLine{1682 \textcolor{preprocessor}{      if (f-\/>valid\_bits < 0) \{ f-\/>valid\_bits = 0; var = -\/1; \} \(\backslash\)}}
\DoxyCodeLine{1683 \textcolor{preprocessor}{   \} else \{                                                   \(\backslash\)}}
\DoxyCodeLine{1684 \textcolor{preprocessor}{      var = stbv\_codebook\_decode\_scalar\_raw(f,c);                  \(\backslash\)}}
\DoxyCodeLine{1685 \textcolor{preprocessor}{   \}}}
\DoxyCodeLine{1686 }
\DoxyCodeLine{1687 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1688 }
\DoxyCodeLine{1689 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_codebook\_decode\_scalar(stbv\_vorb *f, StbvCodebook *c)}
\DoxyCodeLine{1690 \{}
\DoxyCodeLine{1691    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{1692    \textcolor{keywordflow}{if} (f-\/>valid\_bits < STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH)}
\DoxyCodeLine{1693       stbv\_prep\_huffman(f);}
\DoxyCodeLine{1694    \textcolor{comment}{// fast huffman table lookup}}
\DoxyCodeLine{1695    i = f-\/>acc \& STBV\_FAST\_HUFFMAN\_TABLE\_MASK;}
\DoxyCodeLine{1696    i = c-\/>fast\_huffman[i];}
\DoxyCodeLine{1697    \textcolor{keywordflow}{if} (i >= 0) \{}
\DoxyCodeLine{1698       f-\/>acc >>= c-\/>codeword\_lengths[i];}
\DoxyCodeLine{1699       f-\/>valid\_bits -\/= c-\/>codeword\_lengths[i];}
\DoxyCodeLine{1700       \textcolor{keywordflow}{if} (f-\/>valid\_bits < 0) \{ f-\/>valid\_bits = 0; \textcolor{keywordflow}{return} -\/1; \}}
\DoxyCodeLine{1701       \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{1702    \}}
\DoxyCodeLine{1703    \textcolor{keywordflow}{return} stbv\_codebook\_decode\_scalar\_raw(f,c);}
\DoxyCodeLine{1704 \}}
\DoxyCodeLine{1705 }
\DoxyCodeLine{1706 \textcolor{preprocessor}{\#define STBV\_DECODE\_RAW(var,f,c)    var = stbv\_codebook\_decode\_scalar(f,c);}}
\DoxyCodeLine{1707 }
\DoxyCodeLine{1708 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1709 }
\DoxyCodeLine{1710 \textcolor{preprocessor}{\#define STBV\_DECODE(var,f,c)                                       \(\backslash\)}}
\DoxyCodeLine{1711 \textcolor{preprocessor}{   STBV\_DECODE\_RAW(var,f,c)                                        \(\backslash\)}}
\DoxyCodeLine{1712 \textcolor{preprocessor}{   if (c-\/>sparse) var = c-\/>sorted\_values[var];}}
\DoxyCodeLine{1713 }
\DoxyCodeLine{1714 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{1715 \textcolor{preprocessor}{  \#define DECODE\_VQ(var,f,c)   STBV\_DECODE\_RAW(var,f,c)}}
\DoxyCodeLine{1716 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1717 \textcolor{preprocessor}{  \#define DECODE\_VQ(var,f,c)   STBV\_DECODE(var,f,c)}}
\DoxyCodeLine{1718 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1719 }
\DoxyCodeLine{1720 }
\DoxyCodeLine{1721 }
\DoxyCodeLine{1722 }
\DoxyCodeLine{1723 }
\DoxyCodeLine{1724 }
\DoxyCodeLine{1725 \textcolor{comment}{// STBV\_CODEBOOK\_ELEMENT\_FAST is an optimization for the CODEBOOK\_FLOATS case}}
\DoxyCodeLine{1726 \textcolor{comment}{// where we avoid one addition}}
\DoxyCodeLine{1727 \textcolor{preprocessor}{\#define STBV\_CODEBOOK\_ELEMENT(c,off)          (c-\/>multiplicands[off])}}
\DoxyCodeLine{1728 \textcolor{preprocessor}{\#define STBV\_CODEBOOK\_ELEMENT\_FAST(c,off)     (c-\/>multiplicands[off])}}
\DoxyCodeLine{1729 \textcolor{preprocessor}{\#define STBV\_CODEBOOK\_ELEMENT\_BASE(c)         (0)}}
\DoxyCodeLine{1730 }
\DoxyCodeLine{1731 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_codebook\_decode\_start(stbv\_vorb *f, StbvCodebook *c)}
\DoxyCodeLine{1732 \{}
\DoxyCodeLine{1733    \textcolor{keywordtype}{int} z = -\/1;}
\DoxyCodeLine{1734 }
\DoxyCodeLine{1735    \textcolor{comment}{// type 0 is only legal in a scalar context}}
\DoxyCodeLine{1736    \textcolor{keywordflow}{if} (c-\/>lookup\_type == 0)}
\DoxyCodeLine{1737       stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{1738    \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1739       DECODE\_VQ(z,f,c);}
\DoxyCodeLine{1740       \textcolor{keywordflow}{if} (c-\/>sparse) assert(z < c-\/>sorted\_entries);}
\DoxyCodeLine{1741       \textcolor{keywordflow}{if} (z < 0) \{  \textcolor{comment}{// check for STBV\_EOP}}
\DoxyCodeLine{1742          \textcolor{keywordflow}{if} (!f-\/>bytes\_in\_seg)}
\DoxyCodeLine{1743             \textcolor{keywordflow}{if} (f-\/>last\_seg)}
\DoxyCodeLine{1744                \textcolor{keywordflow}{return} z;}
\DoxyCodeLine{1745          stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{1746       \}}
\DoxyCodeLine{1747    \}}
\DoxyCodeLine{1748    \textcolor{keywordflow}{return} z;}
\DoxyCodeLine{1749 \}}
\DoxyCodeLine{1750 }
\DoxyCodeLine{1751 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_codebook\_decode(stbv\_vorb *f, StbvCodebook *c, \textcolor{keywordtype}{float} *output, \textcolor{keywordtype}{int} len)}
\DoxyCodeLine{1752 \{}
\DoxyCodeLine{1753    \textcolor{keywordtype}{int} i,z = stbv\_codebook\_decode\_start(f,c);}
\DoxyCodeLine{1754    \textcolor{keywordflow}{if} (z < 0) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1755    \textcolor{keywordflow}{if} (len > c-\/>dimensions) len = c-\/>dimensions;}
\DoxyCodeLine{1756 }
\DoxyCodeLine{1757 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{1758    \textcolor{keywordflow}{if} (c-\/>lookup\_type == 1) \{}
\DoxyCodeLine{1759       \textcolor{keywordtype}{float} last = STBV\_CODEBOOK\_ELEMENT\_BASE(c);}
\DoxyCodeLine{1760       \textcolor{keywordtype}{int} div = 1;}
\DoxyCodeLine{1761       \textcolor{keywordflow}{for} (i=0; i < len; ++i) \{}
\DoxyCodeLine{1762          \textcolor{keywordtype}{int} off = (z / div) \% c-\/>lookup\_values;}
\DoxyCodeLine{1763          \textcolor{keywordtype}{float} val = STBV\_CODEBOOK\_ELEMENT\_FAST(c,off) + last;}
\DoxyCodeLine{1764          output[i] += val;}
\DoxyCodeLine{1765          \textcolor{keywordflow}{if} (c-\/>sequence\_p) last = val + c-\/>minimum\_value;}
\DoxyCodeLine{1766          div *= c-\/>lookup\_values;}
\DoxyCodeLine{1767       \}}
\DoxyCodeLine{1768       \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1769    \}}
\DoxyCodeLine{1770 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1771 }
\DoxyCodeLine{1772    z *= c-\/>dimensions;}
\DoxyCodeLine{1773    \textcolor{keywordflow}{if} (c-\/>sequence\_p) \{}
\DoxyCodeLine{1774       \textcolor{keywordtype}{float} last = STBV\_CODEBOOK\_ELEMENT\_BASE(c);}
\DoxyCodeLine{1775       \textcolor{keywordflow}{for} (i=0; i < len; ++i) \{}
\DoxyCodeLine{1776          \textcolor{keywordtype}{float} val = STBV\_CODEBOOK\_ELEMENT\_FAST(c,z+i) + last;}
\DoxyCodeLine{1777          output[i] += val;}
\DoxyCodeLine{1778          last = val + c-\/>minimum\_value;}
\DoxyCodeLine{1779       \}}
\DoxyCodeLine{1780    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1781       \textcolor{keywordtype}{float} last = STBV\_CODEBOOK\_ELEMENT\_BASE(c);}
\DoxyCodeLine{1782       \textcolor{keywordflow}{for} (i=0; i < len; ++i) \{}
\DoxyCodeLine{1783          output[i] += STBV\_CODEBOOK\_ELEMENT\_FAST(c,z+i) + last;}
\DoxyCodeLine{1784       \}}
\DoxyCodeLine{1785    \}}
\DoxyCodeLine{1786 }
\DoxyCodeLine{1787    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1788 \}}
\DoxyCodeLine{1789 }
\DoxyCodeLine{1790 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_codebook\_decode\_step(stbv\_vorb *f, StbvCodebook *c, \textcolor{keywordtype}{float} *output, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} step)}
\DoxyCodeLine{1791 \{}
\DoxyCodeLine{1792    \textcolor{keywordtype}{int} i,z = stbv\_codebook\_decode\_start(f,c);}
\DoxyCodeLine{1793    \textcolor{keywordtype}{float} last = STBV\_CODEBOOK\_ELEMENT\_BASE(c);}
\DoxyCodeLine{1794    \textcolor{keywordflow}{if} (z < 0) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1795    \textcolor{keywordflow}{if} (len > c-\/>dimensions) len = c-\/>dimensions;}
\DoxyCodeLine{1796 }
\DoxyCodeLine{1797 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{1798    \textcolor{keywordflow}{if} (c-\/>lookup\_type == 1) \{}
\DoxyCodeLine{1799       \textcolor{keywordtype}{int} div = 1;}
\DoxyCodeLine{1800       \textcolor{keywordflow}{for} (i=0; i < len; ++i) \{}
\DoxyCodeLine{1801          \textcolor{keywordtype}{int} off = (z / div) \% c-\/>lookup\_values;}
\DoxyCodeLine{1802          \textcolor{keywordtype}{float} val = STBV\_CODEBOOK\_ELEMENT\_FAST(c,off) + last;}
\DoxyCodeLine{1803          output[i*step] += val;}
\DoxyCodeLine{1804          \textcolor{keywordflow}{if} (c-\/>sequence\_p) last = val;}
\DoxyCodeLine{1805          div *= c-\/>lookup\_values;}
\DoxyCodeLine{1806       \}}
\DoxyCodeLine{1807       \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1808    \}}
\DoxyCodeLine{1809 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1810 }
\DoxyCodeLine{1811    z *= c-\/>dimensions;}
\DoxyCodeLine{1812    \textcolor{keywordflow}{for} (i=0; i < len; ++i) \{}
\DoxyCodeLine{1813       \textcolor{keywordtype}{float} val = STBV\_CODEBOOK\_ELEMENT\_FAST(c,z+i) + last;}
\DoxyCodeLine{1814       output[i*step] += val;}
\DoxyCodeLine{1815       \textcolor{keywordflow}{if} (c-\/>sequence\_p) last = val;}
\DoxyCodeLine{1816    \}}
\DoxyCodeLine{1817 }
\DoxyCodeLine{1818    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1819 \}}
\DoxyCodeLine{1820 }
\DoxyCodeLine{1821 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_codebook\_decode\_deinterleave\_repeat(stbv\_vorb *f, StbvCodebook *c, \textcolor{keywordtype}{float} **outputs, \textcolor{keywordtype}{int} ch, \textcolor{keywordtype}{int} *c\_inter\_p, \textcolor{keywordtype}{int} *p\_inter\_p, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} total\_decode)}
\DoxyCodeLine{1822 \{}
\DoxyCodeLine{1823    \textcolor{keywordtype}{int} c\_inter = *c\_inter\_p;}
\DoxyCodeLine{1824    \textcolor{keywordtype}{int} p\_inter = *p\_inter\_p;}
\DoxyCodeLine{1825    \textcolor{keywordtype}{int} i,z, effective = c-\/>dimensions;}
\DoxyCodeLine{1826 }
\DoxyCodeLine{1827    \textcolor{comment}{// type 0 is only legal in a scalar context}}
\DoxyCodeLine{1828    \textcolor{keywordflow}{if} (c-\/>lookup\_type == 0)   \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{1829 }
\DoxyCodeLine{1830    \textcolor{keywordflow}{while} (total\_decode > 0) \{}
\DoxyCodeLine{1831       \textcolor{keywordtype}{float} last = STBV\_CODEBOOK\_ELEMENT\_BASE(c);}
\DoxyCodeLine{1832       DECODE\_VQ(z,f,c);}
\DoxyCodeLine{1833 \textcolor{preprocessor}{      \#ifndef STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{1834       assert(!c-\/>sparse || z < c-\/>sorted\_entries);}
\DoxyCodeLine{1835 \textcolor{preprocessor}{      \#endif}}
\DoxyCodeLine{1836       \textcolor{keywordflow}{if} (z < 0) \{}
\DoxyCodeLine{1837          \textcolor{keywordflow}{if} (!f-\/>bytes\_in\_seg)}
\DoxyCodeLine{1838             \textcolor{keywordflow}{if} (f-\/>last\_seg) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{1839          \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{1840       \}}
\DoxyCodeLine{1841 }
\DoxyCodeLine{1842       \textcolor{comment}{// if this will take us off the end of the buffers, stop short!}}
\DoxyCodeLine{1843       \textcolor{comment}{// we check by computing the length of the virtual interleaved}}
\DoxyCodeLine{1844       \textcolor{comment}{// buffer (len*ch), our current offset within it (p\_inter*ch)+(c\_inter),}}
\DoxyCodeLine{1845       \textcolor{comment}{// and the length we'll be using (effective)}}
\DoxyCodeLine{1846       \textcolor{keywordflow}{if} (c\_inter + p\_inter*ch + effective > len * ch) \{}
\DoxyCodeLine{1847          effective = len*ch -\/ (p\_inter*ch -\/ c\_inter);}
\DoxyCodeLine{1848       \}}
\DoxyCodeLine{1849 }
\DoxyCodeLine{1850 \textcolor{preprocessor}{   \#ifdef STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{1851       \textcolor{keywordflow}{if} (c-\/>lookup\_type == 1) \{}
\DoxyCodeLine{1852          \textcolor{keywordtype}{int} div = 1;}
\DoxyCodeLine{1853          \textcolor{keywordflow}{for} (i=0; i < effective; ++i) \{}
\DoxyCodeLine{1854             \textcolor{keywordtype}{int} off = (z / div) \% c-\/>lookup\_values;}
\DoxyCodeLine{1855             \textcolor{keywordtype}{float} val = STBV\_CODEBOOK\_ELEMENT\_FAST(c,off) + last;}
\DoxyCodeLine{1856             \textcolor{keywordflow}{if} (outputs[c\_inter])}
\DoxyCodeLine{1857                outputs[c\_inter][p\_inter] += val;}
\DoxyCodeLine{1858             \textcolor{keywordflow}{if} (++c\_inter == ch) \{ c\_inter = 0; ++p\_inter; \}}
\DoxyCodeLine{1859             \textcolor{keywordflow}{if} (c-\/>sequence\_p) last = val;}
\DoxyCodeLine{1860             div *= c-\/>lookup\_values;}
\DoxyCodeLine{1861          \}}
\DoxyCodeLine{1862       \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{1863 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{1864       \{}
\DoxyCodeLine{1865          z *= c-\/>dimensions;}
\DoxyCodeLine{1866          \textcolor{keywordflow}{if} (c-\/>sequence\_p) \{}
\DoxyCodeLine{1867             \textcolor{keywordflow}{for} (i=0; i < effective; ++i) \{}
\DoxyCodeLine{1868                \textcolor{keywordtype}{float} val = STBV\_CODEBOOK\_ELEMENT\_FAST(c,z+i) + last;}
\DoxyCodeLine{1869                \textcolor{keywordflow}{if} (outputs[c\_inter])}
\DoxyCodeLine{1870                   outputs[c\_inter][p\_inter] += val;}
\DoxyCodeLine{1871                \textcolor{keywordflow}{if} (++c\_inter == ch) \{ c\_inter = 0; ++p\_inter; \}}
\DoxyCodeLine{1872                last = val;}
\DoxyCodeLine{1873             \}}
\DoxyCodeLine{1874          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1875             \textcolor{keywordflow}{for} (i=0; i < effective; ++i) \{}
\DoxyCodeLine{1876                \textcolor{keywordtype}{float} val = STBV\_CODEBOOK\_ELEMENT\_FAST(c,z+i) + last;}
\DoxyCodeLine{1877                \textcolor{keywordflow}{if} (outputs[c\_inter])}
\DoxyCodeLine{1878                   outputs[c\_inter][p\_inter] += val;}
\DoxyCodeLine{1879                \textcolor{keywordflow}{if} (++c\_inter == ch) \{ c\_inter = 0; ++p\_inter; \}}
\DoxyCodeLine{1880             \}}
\DoxyCodeLine{1881          \}}
\DoxyCodeLine{1882       \}}
\DoxyCodeLine{1883 }
\DoxyCodeLine{1884       total\_decode -\/= effective;}
\DoxyCodeLine{1885    \}}
\DoxyCodeLine{1886    *c\_inter\_p = c\_inter;}
\DoxyCodeLine{1887    *p\_inter\_p = p\_inter;}
\DoxyCodeLine{1888    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{1889 \}}
\DoxyCodeLine{1890 }
\DoxyCodeLine{1891 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_predict\_point(\textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} x0, \textcolor{keywordtype}{int} x1, \textcolor{keywordtype}{int} y0, \textcolor{keywordtype}{int} y1)}
\DoxyCodeLine{1892 \{}
\DoxyCodeLine{1893    \textcolor{keywordtype}{int} dy = y1 -\/ y0;}
\DoxyCodeLine{1894    \textcolor{keywordtype}{int} adx = x1 -\/ x0;}
\DoxyCodeLine{1895    \textcolor{comment}{// @OPTIMIZE: force int division to round in the right direction... is this necessary on x86?}}
\DoxyCodeLine{1896    \textcolor{keywordtype}{int} err = abs(dy) * (x -\/ x0);}
\DoxyCodeLine{1897    \textcolor{keywordtype}{int} off = err / adx;}
\DoxyCodeLine{1898    \textcolor{keywordflow}{return} dy < 0 ? y0 -\/ off : y0 + off;}
\DoxyCodeLine{1899 \}}
\DoxyCodeLine{1900 }
\DoxyCodeLine{1901 \textcolor{comment}{// the following table is block-\/copied from the specification}}
\DoxyCodeLine{1902 \textcolor{keyword}{static} \textcolor{keywordtype}{float} stbv\_inverse\_db\_table[256] =}
\DoxyCodeLine{1903 \{}
\DoxyCodeLine{1904   1.0649863e-\/07f, 1.1341951e-\/07f, 1.2079015e-\/07f, 1.2863978e-\/07f, }
\DoxyCodeLine{1905   1.3699951e-\/07f, 1.4590251e-\/07f, 1.5538408e-\/07f, 1.6548181e-\/07f, }
\DoxyCodeLine{1906   1.7623575e-\/07f, 1.8768855e-\/07f, 1.9988561e-\/07f, 2.1287530e-\/07f, }
\DoxyCodeLine{1907   2.2670913e-\/07f, 2.4144197e-\/07f, 2.5713223e-\/07f, 2.7384213e-\/07f, }
\DoxyCodeLine{1908   2.9163793e-\/07f, 3.1059021e-\/07f, 3.3077411e-\/07f, 3.5226968e-\/07f, }
\DoxyCodeLine{1909   3.7516214e-\/07f, 3.9954229e-\/07f, 4.2550680e-\/07f, 4.5315863e-\/07f, }
\DoxyCodeLine{1910   4.8260743e-\/07f, 5.1396998e-\/07f, 5.4737065e-\/07f, 5.8294187e-\/07f, }
\DoxyCodeLine{1911   6.2082472e-\/07f, 6.6116941e-\/07f, 7.0413592e-\/07f, 7.4989464e-\/07f, }
\DoxyCodeLine{1912   7.9862701e-\/07f, 8.5052630e-\/07f, 9.0579828e-\/07f, 9.6466216e-\/07f, }
\DoxyCodeLine{1913   1.0273513e-\/06f, 1.0941144e-\/06f, 1.1652161e-\/06f, 1.2409384e-\/06f, }
\DoxyCodeLine{1914   1.3215816e-\/06f, 1.4074654e-\/06f, 1.4989305e-\/06f, 1.5963394e-\/06f, }
\DoxyCodeLine{1915   1.7000785e-\/06f, 1.8105592e-\/06f, 1.9282195e-\/06f, 2.0535261e-\/06f, }
\DoxyCodeLine{1916   2.1869758e-\/06f, 2.3290978e-\/06f, 2.4804557e-\/06f, 2.6416497e-\/06f, }
\DoxyCodeLine{1917   2.8133190e-\/06f, 2.9961443e-\/06f, 3.1908506e-\/06f, 3.3982101e-\/06f, }
\DoxyCodeLine{1918   3.6190449e-\/06f, 3.8542308e-\/06f, 4.1047004e-\/06f, 4.3714470e-\/06f, }
\DoxyCodeLine{1919   4.6555282e-\/06f, 4.9580707e-\/06f, 5.2802740e-\/06f, 5.6234160e-\/06f, }
\DoxyCodeLine{1920   5.9888572e-\/06f, 6.3780469e-\/06f, 6.7925283e-\/06f, 7.2339451e-\/06f, }
\DoxyCodeLine{1921   7.7040476e-\/06f, 8.2047000e-\/06f, 8.7378876e-\/06f, 9.3057248e-\/06f, }
\DoxyCodeLine{1922   9.9104632e-\/06f, 1.0554501e-\/05f, 1.1240392e-\/05f, 1.1970856e-\/05f, }
\DoxyCodeLine{1923   1.2748789e-\/05f, 1.3577278e-\/05f, 1.4459606e-\/05f, 1.5399272e-\/05f, }
\DoxyCodeLine{1924   1.6400004e-\/05f, 1.7465768e-\/05f, 1.8600792e-\/05f, 1.9809576e-\/05f, }
\DoxyCodeLine{1925   2.1096914e-\/05f, 2.2467911e-\/05f, 2.3928002e-\/05f, 2.5482978e-\/05f, }
\DoxyCodeLine{1926   2.7139006e-\/05f, 2.8902651e-\/05f, 3.0780908e-\/05f, 3.2781225e-\/05f, }
\DoxyCodeLine{1927   3.4911534e-\/05f, 3.7180282e-\/05f, 3.9596466e-\/05f, 4.2169667e-\/05f, }
\DoxyCodeLine{1928   4.4910090e-\/05f, 4.7828601e-\/05f, 5.0936773e-\/05f, 5.4246931e-\/05f, }
\DoxyCodeLine{1929   5.7772202e-\/05f, 6.1526565e-\/05f, 6.5524908e-\/05f, 6.9783085e-\/05f, }
\DoxyCodeLine{1930   7.4317983e-\/05f, 7.9147585e-\/05f, 8.4291040e-\/05f, 8.9768747e-\/05f, }
\DoxyCodeLine{1931   9.5602426e-\/05f, 0.00010181521f, 0.00010843174f, 0.00011547824f, }
\DoxyCodeLine{1932   0.00012298267f, 0.00013097477f, 0.00013948625f, 0.00014855085f, }
\DoxyCodeLine{1933   0.00015820453f, 0.00016848555f, 0.00017943469f, 0.00019109536f, }
\DoxyCodeLine{1934   0.00020351382f, 0.00021673929f, 0.00023082423f, 0.00024582449f, }
\DoxyCodeLine{1935   0.00026179955f, 0.00027881276f, 0.00029693158f, 0.00031622787f, }
\DoxyCodeLine{1936   0.00033677814f, 0.00035866388f, 0.00038197188f, 0.00040679456f, }
\DoxyCodeLine{1937   0.00043323036f, 0.00046138411f, 0.00049136745f, 0.00052329927f, }
\DoxyCodeLine{1938   0.00055730621f, 0.00059352311f, 0.00063209358f, 0.00067317058f, }
\DoxyCodeLine{1939   0.00071691700f, 0.00076350630f, 0.00081312324f, 0.00086596457f, }
\DoxyCodeLine{1940   0.00092223983f, 0.00098217216f, 0.0010459992f,  0.0011139742f, }
\DoxyCodeLine{1941   0.0011863665f,  0.0012634633f,  0.0013455702f,  0.0014330129f, }
\DoxyCodeLine{1942   0.0015261382f,  0.0016253153f,  0.0017309374f,  0.0018434235f, }
\DoxyCodeLine{1943   0.0019632195f,  0.0020908006f,  0.0022266726f,  0.0023713743f, }
\DoxyCodeLine{1944   0.0025254795f,  0.0026895994f,  0.0028643847f,  0.0030505286f, }
\DoxyCodeLine{1945   0.0032487691f,  0.0034598925f,  0.0036847358f,  0.0039241906f, }
\DoxyCodeLine{1946   0.0041792066f,  0.0044507950f,  0.0047400328f,  0.0050480668f, }
\DoxyCodeLine{1947   0.0053761186f,  0.0057254891f,  0.0060975636f,  0.0064938176f, }
\DoxyCodeLine{1948   0.0069158225f,  0.0073652516f,  0.0078438871f,  0.0083536271f, }
\DoxyCodeLine{1949   0.0088964928f,  0.009474637f,   0.010090352f,   0.010746080f, }
\DoxyCodeLine{1950   0.011444421f,   0.012188144f,   0.012980198f,   0.013823725f, }
\DoxyCodeLine{1951   0.014722068f,   0.015678791f,   0.016697687f,   0.017782797f, }
\DoxyCodeLine{1952   0.018938423f,   0.020169149f,   0.021479854f,   0.022875735f, }
\DoxyCodeLine{1953   0.024362330f,   0.025945531f,   0.027631618f,   0.029427276f, }
\DoxyCodeLine{1954   0.031339626f,   0.033376252f,   0.035545228f,   0.037855157f, }
\DoxyCodeLine{1955   0.040315199f,   0.042935108f,   0.045725273f,   0.048696758f, }
\DoxyCodeLine{1956   0.051861348f,   0.055231591f,   0.058820850f,   0.062643361f, }
\DoxyCodeLine{1957   0.066714279f,   0.071049749f,   0.075666962f,   0.080584227f, }
\DoxyCodeLine{1958   0.085821044f,   0.091398179f,   0.097337747f,   0.10366330f, }
\DoxyCodeLine{1959   0.11039993f,    0.11757434f,    0.12521498f,    0.13335215f, }
\DoxyCodeLine{1960   0.14201813f,    0.15124727f,    0.16107617f,    0.17154380f, }
\DoxyCodeLine{1961   0.18269168f,    0.19456402f,    0.20720788f,    0.22067342f, }
\DoxyCodeLine{1962   0.23501402f,    0.25028656f,    0.26655159f,    0.28387361f, }
\DoxyCodeLine{1963   0.30232132f,    0.32196786f,    0.34289114f,    0.36517414f, }
\DoxyCodeLine{1964   0.38890521f,    0.41417847f,    0.44109412f,    0.46975890f, }
\DoxyCodeLine{1965   0.50028648f,    0.53279791f,    0.56742212f,    0.60429640f, }
\DoxyCodeLine{1966   0.64356699f,    0.68538959f,    0.72993007f,    0.77736504f, }
\DoxyCodeLine{1967   0.82788260f,    0.88168307f,    0.9389798f,     1.0f}
\DoxyCodeLine{1968 \};}
\DoxyCodeLine{1969 }
\DoxyCodeLine{1970 }
\DoxyCodeLine{1971 \textcolor{comment}{// @OPTIMIZE: if you want to replace this bresenham line-\/drawing routine,}}
\DoxyCodeLine{1972 \textcolor{comment}{// note that you must produce bit-\/identical output to decode correctly;}}
\DoxyCodeLine{1973 \textcolor{comment}{// this specific sequence of operations is specified in the spec (it's}}
\DoxyCodeLine{1974 \textcolor{comment}{// drawing integer-\/quantized frequency-\/space lines that the encoder}}
\DoxyCodeLine{1975 \textcolor{comment}{// expects to be exactly the same)}}
\DoxyCodeLine{1976 \textcolor{comment}{//     ... also, isn't the whole point of Bresenham's algorithm to NOT}}
\DoxyCodeLine{1977 \textcolor{comment}{// have to divide in the setup? sigh.}}
\DoxyCodeLine{1978 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{1979 \textcolor{preprocessor}{\#define STBV\_LINE\_OP(a,b)   a *= b}}
\DoxyCodeLine{1980 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1981 \textcolor{preprocessor}{\#define STBV\_LINE\_OP(a,b)   a = b}}
\DoxyCodeLine{1982 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1983 }
\DoxyCodeLine{1984 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_DIVIDE\_TABLE}}
\DoxyCodeLine{1985 \textcolor{preprocessor}{\#define STBV\_DIVTAB\_NUMER   32}}
\DoxyCodeLine{1986 \textcolor{preprocessor}{\#define STBV\_DIVTAB\_DENOM   64}}
\DoxyCodeLine{1987 stbv\_int8 stbv\_integer\_divide\_table[STBV\_DIVTAB\_NUMER][STBV\_DIVTAB\_DENOM]; \textcolor{comment}{// 2KB}}
\DoxyCodeLine{1988 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1989 }
\DoxyCodeLine{1990 \textcolor{keyword}{static} \_\_forceinline \textcolor{keywordtype}{void} stbv\_draw\_line(\textcolor{keywordtype}{float} *output, \textcolor{keywordtype}{int} x0, \textcolor{keywordtype}{int} y0, \textcolor{keywordtype}{int} x1, \textcolor{keywordtype}{int} y1, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{1991 \{}
\DoxyCodeLine{1992    \textcolor{keywordtype}{int} dy = y1 -\/ y0;}
\DoxyCodeLine{1993    \textcolor{keywordtype}{int} adx = x1 -\/ x0;}
\DoxyCodeLine{1994    \textcolor{keywordtype}{int} ady = abs(dy);}
\DoxyCodeLine{1995    \textcolor{keywordtype}{int} base;}
\DoxyCodeLine{1996    \textcolor{keywordtype}{int} x=x0,y=y0;}
\DoxyCodeLine{1997    \textcolor{keywordtype}{int} err = 0;}
\DoxyCodeLine{1998    \textcolor{keywordtype}{int} sy;}
\DoxyCodeLine{1999 }
\DoxyCodeLine{2000 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_DIVIDE\_TABLE}}
\DoxyCodeLine{2001    \textcolor{keywordflow}{if} (adx < STBV\_DIVTAB\_DENOM \&\& ady < STBV\_DIVTAB\_NUMER) \{}
\DoxyCodeLine{2002       \textcolor{keywordflow}{if} (dy < 0) \{}
\DoxyCodeLine{2003          base = -\/stbv\_integer\_divide\_table[ady][adx];}
\DoxyCodeLine{2004          sy = base-\/1;}
\DoxyCodeLine{2005       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2006          base =  stbv\_integer\_divide\_table[ady][adx];}
\DoxyCodeLine{2007          sy = base+1;}
\DoxyCodeLine{2008       \}}
\DoxyCodeLine{2009    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2010       base = dy / adx;}
\DoxyCodeLine{2011       \textcolor{keywordflow}{if} (dy < 0)}
\DoxyCodeLine{2012          sy = base -\/ 1;}
\DoxyCodeLine{2013       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2014          sy = base+1;}
\DoxyCodeLine{2015    \}}
\DoxyCodeLine{2016 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2017    base = dy / adx;}
\DoxyCodeLine{2018    \textcolor{keywordflow}{if} (dy < 0)}
\DoxyCodeLine{2019       sy = base -\/ 1;}
\DoxyCodeLine{2020    \textcolor{keywordflow}{else}}
\DoxyCodeLine{2021       sy = base+1;}
\DoxyCodeLine{2022 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2023    ady -\/= abs(base) * adx;}
\DoxyCodeLine{2024    \textcolor{keywordflow}{if} (x1 > n) x1 = n;}
\DoxyCodeLine{2025    \textcolor{keywordflow}{if} (x < x1) \{}
\DoxyCodeLine{2026       STBV\_LINE\_OP(output[x], stbv\_inverse\_db\_table[y]);}
\DoxyCodeLine{2027       \textcolor{keywordflow}{for} (++x; x < x1; ++x) \{}
\DoxyCodeLine{2028          err += ady;}
\DoxyCodeLine{2029          \textcolor{keywordflow}{if} (err >= adx) \{}
\DoxyCodeLine{2030             err -\/= adx;}
\DoxyCodeLine{2031             y += sy;}
\DoxyCodeLine{2032          \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{2033             y += base;}
\DoxyCodeLine{2034          STBV\_LINE\_OP(output[x], stbv\_inverse\_db\_table[y]);}
\DoxyCodeLine{2035       \}}
\DoxyCodeLine{2036    \}}
\DoxyCodeLine{2037 \}}
\DoxyCodeLine{2038 }
\DoxyCodeLine{2039 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_residue\_decode(stbv\_vorb *f, StbvCodebook *book, \textcolor{keywordtype}{float} *target, \textcolor{keywordtype}{int} offset, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} rtype)}
\DoxyCodeLine{2040 \{}
\DoxyCodeLine{2041    \textcolor{keywordtype}{int} k;}
\DoxyCodeLine{2042    \textcolor{keywordflow}{if} (rtype == 0) \{}
\DoxyCodeLine{2043       \textcolor{keywordtype}{int} step = n / book-\/>dimensions;}
\DoxyCodeLine{2044       \textcolor{keywordflow}{for} (k=0; k < step; ++k)}
\DoxyCodeLine{2045          \textcolor{keywordflow}{if} (!stbv\_codebook\_decode\_step(f, book, target+offset+k, n-\/offset-\/k, step))}
\DoxyCodeLine{2046             \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{2047    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2048       \textcolor{keywordflow}{for} (k=0; k < n; ) \{}
\DoxyCodeLine{2049          \textcolor{keywordflow}{if} (!stbv\_codebook\_decode(f, book, target+offset, n-\/k))}
\DoxyCodeLine{2050             \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{2051          k += book-\/>dimensions;}
\DoxyCodeLine{2052          offset += book-\/>dimensions;}
\DoxyCodeLine{2053       \}}
\DoxyCodeLine{2054    \}}
\DoxyCodeLine{2055    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{2056 \}}
\DoxyCodeLine{2057 }
\DoxyCodeLine{2058 \textcolor{comment}{// n is 1/2 of the blocksize -\/-\/}}
\DoxyCodeLine{2059 \textcolor{comment}{// specification: "{}Correct per-\/vector decode length is [n]/2"{}}}
\DoxyCodeLine{2060 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_decode\_residue(stbv\_vorb *f, \textcolor{keywordtype}{float} *residue\_buffers[], \textcolor{keywordtype}{int} ch, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} rn, stbv\_uint8 *do\_not\_decode)}
\DoxyCodeLine{2061 \{}
\DoxyCodeLine{2062    \textcolor{keywordtype}{int} i,j,pass;}
\DoxyCodeLine{2063    StbvResidue *r = f-\/>residue\_config + rn;}
\DoxyCodeLine{2064    \textcolor{keywordtype}{int} rtype = f-\/>residue\_types[rn];}
\DoxyCodeLine{2065    \textcolor{keywordtype}{int} c = r-\/>classbook;}
\DoxyCodeLine{2066    \textcolor{keywordtype}{int} classwords = f-\/>codebooks[c].dimensions;}
\DoxyCodeLine{2067    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} actual\_size = rtype == 2 ? n*2 : n;}
\DoxyCodeLine{2068    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit\_r\_begin = (r-\/>begin < actual\_size ? r-\/>begin : actual\_size);}
\DoxyCodeLine{2069    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit\_r\_end   = (r-\/>end   < actual\_size ? r-\/>end   : actual\_size);}
\DoxyCodeLine{2070    \textcolor{keywordtype}{int} n\_read = limit\_r\_end -\/ limit\_r\_begin;}
\DoxyCodeLine{2071    \textcolor{keywordtype}{int} part\_read = n\_read / r-\/>part\_size;}
\DoxyCodeLine{2072    \textcolor{keywordtype}{int} temp\_alloc\_point = stbv\_temp\_alloc\_save(f);}
\DoxyCodeLine{2073 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2074    stbv\_uint8 ***part\_classdata = (stbv\_uint8 ***) stbv\_temp\_block\_array(f,f-\/>channels, part\_read * \textcolor{keyword}{sizeof}(**part\_classdata));}
\DoxyCodeLine{2075 \textcolor{preprocessor}{   \#else}}
\DoxyCodeLine{2076    \textcolor{keywordtype}{int} **classifications = (\textcolor{keywordtype}{int} **) stbv\_temp\_block\_array(f,f-\/>channels, part\_read * \textcolor{keyword}{sizeof}(**classifications));}
\DoxyCodeLine{2077 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{2078 }
\DoxyCodeLine{2079    STBV\_CHECK(f);}
\DoxyCodeLine{2080 }
\DoxyCodeLine{2081    \textcolor{keywordflow}{for} (i=0; i < ch; ++i)}
\DoxyCodeLine{2082       \textcolor{keywordflow}{if} (!do\_not\_decode[i])}
\DoxyCodeLine{2083          memset(residue\_buffers[i], 0, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * n);}
\DoxyCodeLine{2084 }
\DoxyCodeLine{2085    \textcolor{keywordflow}{if} (rtype == 2 \&\& ch != 1) \{}
\DoxyCodeLine{2086       \textcolor{keywordflow}{for} (j=0; j < ch; ++j)}
\DoxyCodeLine{2087          \textcolor{keywordflow}{if} (!do\_not\_decode[j])}
\DoxyCodeLine{2088             \textcolor{keywordflow}{break};}
\DoxyCodeLine{2089       \textcolor{keywordflow}{if} (j == ch)}
\DoxyCodeLine{2090          \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2091 }
\DoxyCodeLine{2092       \textcolor{keywordflow}{for} (pass=0; pass < 8; ++pass) \{}
\DoxyCodeLine{2093          \textcolor{keywordtype}{int} pcount = 0, class\_set = 0;}
\DoxyCodeLine{2094          \textcolor{keywordflow}{if} (ch == 2) \{}
\DoxyCodeLine{2095             \textcolor{keywordflow}{while} (pcount < part\_read) \{}
\DoxyCodeLine{2096                \textcolor{keywordtype}{int} z = r-\/>begin + pcount*r-\/>part\_size;}
\DoxyCodeLine{2097                \textcolor{keywordtype}{int} c\_inter = (z \& 1), p\_inter = z>>1;}
\DoxyCodeLine{2098                \textcolor{keywordflow}{if} (pass == 0) \{}
\DoxyCodeLine{2099                   StbvCodebook *c = f-\/>codebooks+r-\/>classbook;}
\DoxyCodeLine{2100                   \textcolor{keywordtype}{int} q;}
\DoxyCodeLine{2101                   STBV\_DECODE(q,f,c);}
\DoxyCodeLine{2102                   \textcolor{keywordflow}{if} (q == STBV\_EOP) \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2103 \textcolor{preprocessor}{                  \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2104                   part\_classdata[0][class\_set] = r-\/>classdata[q];}
\DoxyCodeLine{2105 \textcolor{preprocessor}{                  \#else}}
\DoxyCodeLine{2106                   \textcolor{keywordflow}{for} (i=classwords-\/1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{2107                      classifications[0][i+pcount] = q \% r-\/>classifications;}
\DoxyCodeLine{2108                      q /= r-\/>classifications;}
\DoxyCodeLine{2109                   \}}
\DoxyCodeLine{2110 \textcolor{preprocessor}{                  \#endif}}
\DoxyCodeLine{2111                \}}
\DoxyCodeLine{2112                \textcolor{keywordflow}{for} (i=0; i < classwords \&\& pcount < part\_read; ++i, ++pcount) \{}
\DoxyCodeLine{2113                   \textcolor{keywordtype}{int} z = r-\/>begin + pcount*r-\/>part\_size;}
\DoxyCodeLine{2114 \textcolor{preprocessor}{                  \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2115                   \textcolor{keywordtype}{int} c = part\_classdata[0][class\_set][i];}
\DoxyCodeLine{2116 \textcolor{preprocessor}{                  \#else}}
\DoxyCodeLine{2117                   \textcolor{keywordtype}{int} c = classifications[0][pcount];}
\DoxyCodeLine{2118 \textcolor{preprocessor}{                  \#endif}}
\DoxyCodeLine{2119                   \textcolor{keywordtype}{int} b = r-\/>residue\_books[c][pass];}
\DoxyCodeLine{2120                   \textcolor{keywordflow}{if} (b >= 0) \{}
\DoxyCodeLine{2121                      StbvCodebook *book = f-\/>codebooks + b;}
\DoxyCodeLine{2122 \textcolor{preprocessor}{                     \#ifdef STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{2123                      \textcolor{keywordflow}{if} (!stbv\_codebook\_decode\_deinterleave\_repeat(f, book, residue\_buffers, ch, \&c\_inter, \&p\_inter, n, r-\/>part\_size))}
\DoxyCodeLine{2124                         \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2125 \textcolor{preprocessor}{                     \#else}}
\DoxyCodeLine{2126                      \textcolor{comment}{// saves 1\%}}
\DoxyCodeLine{2127                      \textcolor{keywordflow}{if} (!stbv\_codebook\_decode\_deinterleave\_repeat(f, book, residue\_buffers, ch, \&c\_inter, \&p\_inter, n, r-\/>part\_size))}
\DoxyCodeLine{2128                         \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2129 \textcolor{preprocessor}{                     \#endif}}
\DoxyCodeLine{2130                   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2131                      z += r-\/>part\_size;}
\DoxyCodeLine{2132                      c\_inter = z \& 1;}
\DoxyCodeLine{2133                      p\_inter = z >> 1;}
\DoxyCodeLine{2134                   \}}
\DoxyCodeLine{2135                \}}
\DoxyCodeLine{2136 \textcolor{preprocessor}{               \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2137                ++class\_set;}
\DoxyCodeLine{2138 \textcolor{preprocessor}{               \#endif}}
\DoxyCodeLine{2139             \}}
\DoxyCodeLine{2140          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch == 1) \{}
\DoxyCodeLine{2141             \textcolor{keywordflow}{while} (pcount < part\_read) \{}
\DoxyCodeLine{2142                \textcolor{keywordtype}{int} z = r-\/>begin + pcount*r-\/>part\_size;}
\DoxyCodeLine{2143                \textcolor{keywordtype}{int} c\_inter = 0, p\_inter = z;}
\DoxyCodeLine{2144                \textcolor{keywordflow}{if} (pass == 0) \{}
\DoxyCodeLine{2145                   StbvCodebook *c = f-\/>codebooks+r-\/>classbook;}
\DoxyCodeLine{2146                   \textcolor{keywordtype}{int} q;}
\DoxyCodeLine{2147                   STBV\_DECODE(q,f,c);}
\DoxyCodeLine{2148                   \textcolor{keywordflow}{if} (q == STBV\_EOP) \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2149 \textcolor{preprocessor}{                  \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2150                   part\_classdata[0][class\_set] = r-\/>classdata[q];}
\DoxyCodeLine{2151 \textcolor{preprocessor}{                  \#else}}
\DoxyCodeLine{2152                   \textcolor{keywordflow}{for} (i=classwords-\/1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{2153                      classifications[0][i+pcount] = q \% r-\/>classifications;}
\DoxyCodeLine{2154                      q /= r-\/>classifications;}
\DoxyCodeLine{2155                   \}}
\DoxyCodeLine{2156 \textcolor{preprocessor}{                  \#endif}}
\DoxyCodeLine{2157                \}}
\DoxyCodeLine{2158                \textcolor{keywordflow}{for} (i=0; i < classwords \&\& pcount < part\_read; ++i, ++pcount) \{}
\DoxyCodeLine{2159                   \textcolor{keywordtype}{int} z = r-\/>begin + pcount*r-\/>part\_size;}
\DoxyCodeLine{2160 \textcolor{preprocessor}{                  \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2161                   \textcolor{keywordtype}{int} c = part\_classdata[0][class\_set][i];}
\DoxyCodeLine{2162 \textcolor{preprocessor}{                  \#else}}
\DoxyCodeLine{2163                   \textcolor{keywordtype}{int} c = classifications[0][pcount];}
\DoxyCodeLine{2164 \textcolor{preprocessor}{                  \#endif}}
\DoxyCodeLine{2165                   \textcolor{keywordtype}{int} b = r-\/>residue\_books[c][pass];}
\DoxyCodeLine{2166                   \textcolor{keywordflow}{if} (b >= 0) \{}
\DoxyCodeLine{2167                      StbvCodebook *book = f-\/>codebooks + b;}
\DoxyCodeLine{2168                      \textcolor{keywordflow}{if} (!stbv\_codebook\_decode\_deinterleave\_repeat(f, book, residue\_buffers, ch, \&c\_inter, \&p\_inter, n, r-\/>part\_size))}
\DoxyCodeLine{2169                         \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2170                   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2171                      z += r-\/>part\_size;}
\DoxyCodeLine{2172                      c\_inter = 0;}
\DoxyCodeLine{2173                      p\_inter = z;}
\DoxyCodeLine{2174                   \}}
\DoxyCodeLine{2175                \}}
\DoxyCodeLine{2176 \textcolor{preprocessor}{               \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2177                ++class\_set;}
\DoxyCodeLine{2178 \textcolor{preprocessor}{               \#endif}}
\DoxyCodeLine{2179             \}}
\DoxyCodeLine{2180          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2181             \textcolor{keywordflow}{while} (pcount < part\_read) \{}
\DoxyCodeLine{2182                \textcolor{keywordtype}{int} z = r-\/>begin + pcount*r-\/>part\_size;}
\DoxyCodeLine{2183                \textcolor{keywordtype}{int} c\_inter = z \% ch, p\_inter = z/ch;}
\DoxyCodeLine{2184                \textcolor{keywordflow}{if} (pass == 0) \{}
\DoxyCodeLine{2185                   StbvCodebook *c = f-\/>codebooks+r-\/>classbook;}
\DoxyCodeLine{2186                   \textcolor{keywordtype}{int} q;}
\DoxyCodeLine{2187                   STBV\_DECODE(q,f,c);}
\DoxyCodeLine{2188                   \textcolor{keywordflow}{if} (q == STBV\_EOP) \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2189 \textcolor{preprocessor}{                  \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2190                   part\_classdata[0][class\_set] = r-\/>classdata[q];}
\DoxyCodeLine{2191 \textcolor{preprocessor}{                  \#else}}
\DoxyCodeLine{2192                   \textcolor{keywordflow}{for} (i=classwords-\/1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{2193                      classifications[0][i+pcount] = q \% r-\/>classifications;}
\DoxyCodeLine{2194                      q /= r-\/>classifications;}
\DoxyCodeLine{2195                   \}}
\DoxyCodeLine{2196 \textcolor{preprocessor}{                  \#endif}}
\DoxyCodeLine{2197                \}}
\DoxyCodeLine{2198                \textcolor{keywordflow}{for} (i=0; i < classwords \&\& pcount < part\_read; ++i, ++pcount) \{}
\DoxyCodeLine{2199                   \textcolor{keywordtype}{int} z = r-\/>begin + pcount*r-\/>part\_size;}
\DoxyCodeLine{2200 \textcolor{preprocessor}{                  \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2201                   \textcolor{keywordtype}{int} c = part\_classdata[0][class\_set][i];}
\DoxyCodeLine{2202 \textcolor{preprocessor}{                  \#else}}
\DoxyCodeLine{2203                   \textcolor{keywordtype}{int} c = classifications[0][pcount];}
\DoxyCodeLine{2204 \textcolor{preprocessor}{                  \#endif}}
\DoxyCodeLine{2205                   \textcolor{keywordtype}{int} b = r-\/>residue\_books[c][pass];}
\DoxyCodeLine{2206                   \textcolor{keywordflow}{if} (b >= 0) \{}
\DoxyCodeLine{2207                      StbvCodebook *book = f-\/>codebooks + b;}
\DoxyCodeLine{2208                      \textcolor{keywordflow}{if} (!stbv\_codebook\_decode\_deinterleave\_repeat(f, book, residue\_buffers, ch, \&c\_inter, \&p\_inter, n, r-\/>part\_size))}
\DoxyCodeLine{2209                         \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2210                   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2211                      z += r-\/>part\_size;}
\DoxyCodeLine{2212                      c\_inter = z \% ch;}
\DoxyCodeLine{2213                      p\_inter = z / ch;}
\DoxyCodeLine{2214                   \}}
\DoxyCodeLine{2215                \}}
\DoxyCodeLine{2216 \textcolor{preprocessor}{               \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2217                ++class\_set;}
\DoxyCodeLine{2218 \textcolor{preprocessor}{               \#endif}}
\DoxyCodeLine{2219             \}}
\DoxyCodeLine{2220          \}}
\DoxyCodeLine{2221       \}}
\DoxyCodeLine{2222       \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2223    \}}
\DoxyCodeLine{2224    STBV\_CHECK(f);}
\DoxyCodeLine{2225 }
\DoxyCodeLine{2226    \textcolor{keywordflow}{for} (pass=0; pass < 8; ++pass) \{}
\DoxyCodeLine{2227       \textcolor{keywordtype}{int} pcount = 0, class\_set=0;}
\DoxyCodeLine{2228       \textcolor{keywordflow}{while} (pcount < part\_read) \{}
\DoxyCodeLine{2229          \textcolor{keywordflow}{if} (pass == 0) \{}
\DoxyCodeLine{2230             \textcolor{keywordflow}{for} (j=0; j < ch; ++j) \{}
\DoxyCodeLine{2231                \textcolor{keywordflow}{if} (!do\_not\_decode[j]) \{}
\DoxyCodeLine{2232                   StbvCodebook *c = f-\/>codebooks+r-\/>classbook;}
\DoxyCodeLine{2233                   \textcolor{keywordtype}{int} temp;}
\DoxyCodeLine{2234                   STBV\_DECODE(temp,f,c);}
\DoxyCodeLine{2235                   \textcolor{keywordflow}{if} (temp == STBV\_EOP) \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2236 \textcolor{preprocessor}{                  \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2237                   part\_classdata[j][class\_set] = r-\/>classdata[temp];}
\DoxyCodeLine{2238 \textcolor{preprocessor}{                  \#else}}
\DoxyCodeLine{2239                   \textcolor{keywordflow}{for} (i=classwords-\/1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{2240                      classifications[j][i+pcount] = temp \% r-\/>classifications;}
\DoxyCodeLine{2241                      temp /= r-\/>classifications;}
\DoxyCodeLine{2242                   \}}
\DoxyCodeLine{2243 \textcolor{preprocessor}{                  \#endif}}
\DoxyCodeLine{2244                \}}
\DoxyCodeLine{2245             \}}
\DoxyCodeLine{2246          \}}
\DoxyCodeLine{2247          \textcolor{keywordflow}{for} (i=0; i < classwords \&\& pcount < part\_read; ++i, ++pcount) \{}
\DoxyCodeLine{2248             \textcolor{keywordflow}{for} (j=0; j < ch; ++j) \{}
\DoxyCodeLine{2249                \textcolor{keywordflow}{if} (!do\_not\_decode[j]) \{}
\DoxyCodeLine{2250 \textcolor{preprocessor}{                  \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2251                   \textcolor{keywordtype}{int} c = part\_classdata[j][class\_set][i];}
\DoxyCodeLine{2252 \textcolor{preprocessor}{                  \#else}}
\DoxyCodeLine{2253                   \textcolor{keywordtype}{int} c = classifications[j][pcount];}
\DoxyCodeLine{2254 \textcolor{preprocessor}{                  \#endif}}
\DoxyCodeLine{2255                   \textcolor{keywordtype}{int} b = r-\/>residue\_books[c][pass];}
\DoxyCodeLine{2256                   \textcolor{keywordflow}{if} (b >= 0) \{}
\DoxyCodeLine{2257                      \textcolor{keywordtype}{float} *target = residue\_buffers[j];}
\DoxyCodeLine{2258                      \textcolor{keywordtype}{int} offset = r-\/>begin + pcount * r-\/>part\_size;}
\DoxyCodeLine{2259                      \textcolor{keywordtype}{int} n = r-\/>part\_size;}
\DoxyCodeLine{2260                      StbvCodebook *book = f-\/>codebooks + b;}
\DoxyCodeLine{2261                      \textcolor{keywordflow}{if} (!stbv\_residue\_decode(f, book, target, offset, n, rtype))}
\DoxyCodeLine{2262                         \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{2263                   \}}
\DoxyCodeLine{2264                \}}
\DoxyCodeLine{2265             \}}
\DoxyCodeLine{2266          \}}
\DoxyCodeLine{2267 \textcolor{preprocessor}{         \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2268          ++class\_set;}
\DoxyCodeLine{2269 \textcolor{preprocessor}{         \#endif}}
\DoxyCodeLine{2270       \}}
\DoxyCodeLine{2271    \}}
\DoxyCodeLine{2272   done:}
\DoxyCodeLine{2273    STBV\_CHECK(f);}
\DoxyCodeLine{2274 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{2275    stbv\_temp\_free(f,part\_classdata);}
\DoxyCodeLine{2276 \textcolor{preprocessor}{   \#else}}
\DoxyCodeLine{2277    stbv\_temp\_free(f,classifications);}
\DoxyCodeLine{2278 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{2279    stbv\_temp\_alloc\_restore(f,temp\_alloc\_point);}
\DoxyCodeLine{2280 \}}
\DoxyCodeLine{2281 }
\DoxyCodeLine{2282 }
\DoxyCodeLine{2283 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{2284 \textcolor{comment}{// slow way for debugging}}
\DoxyCodeLine{2285 \textcolor{keywordtype}{void} inverse\_mdct\_slow(\textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{2286 \{}
\DoxyCodeLine{2287    \textcolor{keywordtype}{int} i,j;}
\DoxyCodeLine{2288    \textcolor{keywordtype}{int} n2 = n >> 1;}
\DoxyCodeLine{2289    \textcolor{keywordtype}{float} *x = (\textcolor{keywordtype}{float} *) malloc(\textcolor{keyword}{sizeof}(*x) * n2);}
\DoxyCodeLine{2290    memcpy(x, buffer, \textcolor{keyword}{sizeof}(*x) * n2);}
\DoxyCodeLine{2291    \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{2292       \textcolor{keywordtype}{float} acc = 0;}
\DoxyCodeLine{2293       \textcolor{keywordflow}{for} (j=0; j < n2; ++j)}
\DoxyCodeLine{2294          \textcolor{comment}{// formula from paper:}}
\DoxyCodeLine{2295          \textcolor{comment}{//acc += n/4.0f * x[j] * (float) cos(M\_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));}}
\DoxyCodeLine{2296          \textcolor{comment}{// formula from wikipedia}}
\DoxyCodeLine{2297          \textcolor{comment}{//acc += 2.0f / n2 * x[j] * (float) cos(M\_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));}}
\DoxyCodeLine{2298          \textcolor{comment}{// these are equivalent, except the formula from the paper inverts the multiplier!}}
\DoxyCodeLine{2299          \textcolor{comment}{// however, what actually works is NO MULTIPLIER!?!}}
\DoxyCodeLine{2300          \textcolor{comment}{//acc += 64 * 2.0f / n2 * x[j] * (float) cos(M\_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));}}
\DoxyCodeLine{2301          acc += x[j] * (\textcolor{keywordtype}{float}) cos(M\_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));}
\DoxyCodeLine{2302       buffer[i] = acc;}
\DoxyCodeLine{2303    \}}
\DoxyCodeLine{2304    free(x);}
\DoxyCodeLine{2305 \}}
\DoxyCodeLine{2306 \textcolor{preprocessor}{\#elif 0}}
\DoxyCodeLine{2307 \textcolor{comment}{// same as above, but just barely able to run in real time on modern machines}}
\DoxyCodeLine{2308 \textcolor{keywordtype}{void} inverse\_mdct\_slow(\textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} n, stbv\_vorb *f, \textcolor{keywordtype}{int} blocktype)}
\DoxyCodeLine{2309 \{}
\DoxyCodeLine{2310    \textcolor{keywordtype}{float} mcos[16384];}
\DoxyCodeLine{2311    \textcolor{keywordtype}{int} i,j;}
\DoxyCodeLine{2312    \textcolor{keywordtype}{int} n2 = n >> 1, nmask = (n << 2) -\/1;}
\DoxyCodeLine{2313    \textcolor{keywordtype}{float} *x = (\textcolor{keywordtype}{float} *) malloc(\textcolor{keyword}{sizeof}(*x) * n2);}
\DoxyCodeLine{2314    memcpy(x, buffer, \textcolor{keyword}{sizeof}(*x) * n2);}
\DoxyCodeLine{2315    \textcolor{keywordflow}{for} (i=0; i < 4*n; ++i)}
\DoxyCodeLine{2316       mcos[i] = (\textcolor{keywordtype}{float}) cos(M\_PI / 2 * i / n);}
\DoxyCodeLine{2317 }
\DoxyCodeLine{2318    \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{2319       \textcolor{keywordtype}{float} acc = 0;}
\DoxyCodeLine{2320       \textcolor{keywordflow}{for} (j=0; j < n2; ++j)}
\DoxyCodeLine{2321          acc += x[j] * mcos[(2 * i + 1 + n2)*(2*j+1) \& nmask];}
\DoxyCodeLine{2322       buffer[i] = acc;}
\DoxyCodeLine{2323    \}}
\DoxyCodeLine{2324    free(x);}
\DoxyCodeLine{2325 \}}
\DoxyCodeLine{2326 \textcolor{preprocessor}{\#elif 0}}
\DoxyCodeLine{2327 \textcolor{comment}{// transform to use a slow dct-\/iv; this is STILL basically trivial,}}
\DoxyCodeLine{2328 \textcolor{comment}{// but only requires half as many ops}}
\DoxyCodeLine{2329 \textcolor{keywordtype}{void} dct\_iv\_slow(\textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{2330 \{}
\DoxyCodeLine{2331    \textcolor{keywordtype}{float} mcos[16384];}
\DoxyCodeLine{2332    \textcolor{keywordtype}{float} x[2048];}
\DoxyCodeLine{2333    \textcolor{keywordtype}{int} i,j;}
\DoxyCodeLine{2334    \textcolor{keywordtype}{int} n2 = n >> 1, nmask = (n << 3) -\/ 1;}
\DoxyCodeLine{2335    memcpy(x, buffer, \textcolor{keyword}{sizeof}(*x) * n);}
\DoxyCodeLine{2336    \textcolor{keywordflow}{for} (i=0; i < 8*n; ++i)}
\DoxyCodeLine{2337       mcos[i] = (\textcolor{keywordtype}{float}) cos(M\_PI / 4 * i / n);}
\DoxyCodeLine{2338    \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{2339       \textcolor{keywordtype}{float} acc = 0;}
\DoxyCodeLine{2340       \textcolor{keywordflow}{for} (j=0; j < n; ++j)}
\DoxyCodeLine{2341          acc += x[j] * mcos[((2 * i + 1)*(2*j+1)) \& nmask];}
\DoxyCodeLine{2342       buffer[i] = acc;}
\DoxyCodeLine{2343    \}}
\DoxyCodeLine{2344 \}}
\DoxyCodeLine{2345 }
\DoxyCodeLine{2346 \textcolor{keywordtype}{void} inverse\_mdct\_slow(\textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} n, stbv\_vorb *f, \textcolor{keywordtype}{int} blocktype)}
\DoxyCodeLine{2347 \{}
\DoxyCodeLine{2348    \textcolor{keywordtype}{int} i, n4 = n >> 2, n2 = n >> 1, n3\_4 = n -\/ n4;}
\DoxyCodeLine{2349    \textcolor{keywordtype}{float} temp[4096];}
\DoxyCodeLine{2350 }
\DoxyCodeLine{2351    memcpy(temp, buffer, n2 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));}
\DoxyCodeLine{2352    dct\_iv\_slow(temp, n2);  \textcolor{comment}{// returns -\/c'-\/d, a-\/b'}}
\DoxyCodeLine{2353 }
\DoxyCodeLine{2354    \textcolor{keywordflow}{for} (i=0; i < n4  ; ++i) buffer[i] = temp[i+n4];            \textcolor{comment}{// a-\/b'}}
\DoxyCodeLine{2355    \textcolor{keywordflow}{for} (   ; i < n3\_4; ++i) buffer[i] = -\/temp[n3\_4 -\/ i -\/ 1];   \textcolor{comment}{// b-\/a', c+d'}}
\DoxyCodeLine{2356    \textcolor{keywordflow}{for} (   ; i < n   ; ++i) buffer[i] = -\/temp[i -\/ n3\_4];       \textcolor{comment}{// c'+d}}
\DoxyCodeLine{2357 \}}
\DoxyCodeLine{2358 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2359 }
\DoxyCodeLine{2360 \textcolor{preprocessor}{\#ifndef LIBVORBIS\_MDCT}}
\DoxyCodeLine{2361 \textcolor{preprocessor}{\#define LIBVORBIS\_MDCT 0}}
\DoxyCodeLine{2362 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2363 }
\DoxyCodeLine{2364 \textcolor{preprocessor}{\#if LIBVORBIS\_MDCT}}
\DoxyCodeLine{2365 \textcolor{comment}{// directly call the vorbis MDCT using an interface documented}}
\DoxyCodeLine{2366 \textcolor{comment}{// by Jeff Roberts... useful for performance comparison}}
\DoxyCodeLine{2367 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }}
\DoxyCodeLine{2368 \{}
\DoxyCodeLine{2369   \textcolor{keywordtype}{int} n;}
\DoxyCodeLine{2370   \textcolor{keywordtype}{int} log2n;}
\DoxyCodeLine{2371   }
\DoxyCodeLine{2372   \textcolor{keywordtype}{float} *trig;}
\DoxyCodeLine{2373   \textcolor{keywordtype}{int}   *bitrev;}
\DoxyCodeLine{2374 }
\DoxyCodeLine{2375   \textcolor{keywordtype}{float} scale;}
\DoxyCodeLine{2376 \} mdct\_lookup;}
\DoxyCodeLine{2377 }
\DoxyCodeLine{2378 \textcolor{keyword}{extern} \textcolor{keywordtype}{void} mdct\_init(mdct\_lookup *lookup, \textcolor{keywordtype}{int} n);}
\DoxyCodeLine{2379 \textcolor{keyword}{extern} \textcolor{keywordtype}{void} mdct\_clear(mdct\_lookup *l);}
\DoxyCodeLine{2380 \textcolor{keyword}{extern} \textcolor{keywordtype}{void} mdct\_backward(mdct\_lookup *init, \textcolor{keywordtype}{float} *in, \textcolor{keywordtype}{float} *out);}
\DoxyCodeLine{2381 }
\DoxyCodeLine{2382 mdct\_lookup M1,M2;}
\DoxyCodeLine{2383 }
\DoxyCodeLine{2384 \textcolor{keywordtype}{void} stbv\_inverse\_mdct(\textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} n, stbv\_vorb *f, \textcolor{keywordtype}{int} blocktype)}
\DoxyCodeLine{2385 \{}
\DoxyCodeLine{2386    mdct\_lookup *M;}
\DoxyCodeLine{2387    \textcolor{keywordflow}{if} (M1.n == n) M = \&M1;}
\DoxyCodeLine{2388    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (M2.n == n) M = \&M2;}
\DoxyCodeLine{2389    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (M1.n == 0) \{ mdct\_init(\&M1, n); M = \&M1; \}}
\DoxyCodeLine{2390    \textcolor{keywordflow}{else} \{ }
\DoxyCodeLine{2391       \textcolor{keywordflow}{if} (M2.n) \_\_asm \textcolor{keywordtype}{int} 3;}
\DoxyCodeLine{2392       mdct\_init(\&M2, n);}
\DoxyCodeLine{2393       M = \&M2;}
\DoxyCodeLine{2394    \}}
\DoxyCodeLine{2395 }
\DoxyCodeLine{2396    mdct\_backward(M, buffer, buffer);}
\DoxyCodeLine{2397 \}}
\DoxyCodeLine{2398 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2399 }
\DoxyCodeLine{2400 }
\DoxyCodeLine{2401 \textcolor{comment}{// the following were split out into separate functions while optimizing;}}
\DoxyCodeLine{2402 \textcolor{comment}{// they could be pushed back up but eh. \_\_forceinline showed no change;}}
\DoxyCodeLine{2403 \textcolor{comment}{// they're probably already being inlined.}}
\DoxyCodeLine{2404 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_imdct\_step3\_iter0\_loop(\textcolor{keywordtype}{int} n, \textcolor{keywordtype}{float} *e, \textcolor{keywordtype}{int} i\_off, \textcolor{keywordtype}{int} k\_off, \textcolor{keywordtype}{float} *A)}
\DoxyCodeLine{2405 \{}
\DoxyCodeLine{2406    \textcolor{keywordtype}{float} *ee0 = e + i\_off;}
\DoxyCodeLine{2407    \textcolor{keywordtype}{float} *ee2 = ee0 + k\_off;}
\DoxyCodeLine{2408    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{2409 }
\DoxyCodeLine{2410    assert((n \& 3) == 0);}
\DoxyCodeLine{2411    \textcolor{keywordflow}{for} (i=(n>>2); i > 0; -\/-\/i) \{}
\DoxyCodeLine{2412       \textcolor{keywordtype}{float} k00\_20, k01\_21;}
\DoxyCodeLine{2413       k00\_20  = ee0[ 0] -\/ ee2[ 0];}
\DoxyCodeLine{2414       k01\_21  = ee0[-\/1] -\/ ee2[-\/1];}
\DoxyCodeLine{2415       ee0[ 0] += ee2[ 0];\textcolor{comment}{//ee0[ 0] = ee0[ 0] + ee2[ 0];}}
\DoxyCodeLine{2416       ee0[-\/1] += ee2[-\/1];\textcolor{comment}{//ee0[-\/1] = ee0[-\/1] + ee2[-\/1];}}
\DoxyCodeLine{2417       ee2[ 0] = k00\_20 * A[0] -\/ k01\_21 * A[1];}
\DoxyCodeLine{2418       ee2[-\/1] = k01\_21 * A[0] + k00\_20 * A[1];}
\DoxyCodeLine{2419       A += 8;}
\DoxyCodeLine{2420 }
\DoxyCodeLine{2421       k00\_20  = ee0[-\/2] -\/ ee2[-\/2];}
\DoxyCodeLine{2422       k01\_21  = ee0[-\/3] -\/ ee2[-\/3];}
\DoxyCodeLine{2423       ee0[-\/2] += ee2[-\/2];\textcolor{comment}{//ee0[-\/2] = ee0[-\/2] + ee2[-\/2];}}
\DoxyCodeLine{2424       ee0[-\/3] += ee2[-\/3];\textcolor{comment}{//ee0[-\/3] = ee0[-\/3] + ee2[-\/3];}}
\DoxyCodeLine{2425       ee2[-\/2] = k00\_20 * A[0] -\/ k01\_21 * A[1];}
\DoxyCodeLine{2426       ee2[-\/3] = k01\_21 * A[0] + k00\_20 * A[1];}
\DoxyCodeLine{2427       A += 8;}
\DoxyCodeLine{2428 }
\DoxyCodeLine{2429       k00\_20  = ee0[-\/4] -\/ ee2[-\/4];}
\DoxyCodeLine{2430       k01\_21  = ee0[-\/5] -\/ ee2[-\/5];}
\DoxyCodeLine{2431       ee0[-\/4] += ee2[-\/4];\textcolor{comment}{//ee0[-\/4] = ee0[-\/4] + ee2[-\/4];}}
\DoxyCodeLine{2432       ee0[-\/5] += ee2[-\/5];\textcolor{comment}{//ee0[-\/5] = ee0[-\/5] + ee2[-\/5];}}
\DoxyCodeLine{2433       ee2[-\/4] = k00\_20 * A[0] -\/ k01\_21 * A[1];}
\DoxyCodeLine{2434       ee2[-\/5] = k01\_21 * A[0] + k00\_20 * A[1];}
\DoxyCodeLine{2435       A += 8;}
\DoxyCodeLine{2436 }
\DoxyCodeLine{2437       k00\_20  = ee0[-\/6] -\/ ee2[-\/6];}
\DoxyCodeLine{2438       k01\_21  = ee0[-\/7] -\/ ee2[-\/7];}
\DoxyCodeLine{2439       ee0[-\/6] += ee2[-\/6];\textcolor{comment}{//ee0[-\/6] = ee0[-\/6] + ee2[-\/6];}}
\DoxyCodeLine{2440       ee0[-\/7] += ee2[-\/7];\textcolor{comment}{//ee0[-\/7] = ee0[-\/7] + ee2[-\/7];}}
\DoxyCodeLine{2441       ee2[-\/6] = k00\_20 * A[0] -\/ k01\_21 * A[1];}
\DoxyCodeLine{2442       ee2[-\/7] = k01\_21 * A[0] + k00\_20 * A[1];}
\DoxyCodeLine{2443       A += 8;}
\DoxyCodeLine{2444       ee0 -\/= 8;}
\DoxyCodeLine{2445       ee2 -\/= 8;}
\DoxyCodeLine{2446    \}}
\DoxyCodeLine{2447 \}}
\DoxyCodeLine{2448 }
\DoxyCodeLine{2449 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_imdct\_step3\_inner\_r\_loop(\textcolor{keywordtype}{int} lim, \textcolor{keywordtype}{float} *e, \textcolor{keywordtype}{int} d0, \textcolor{keywordtype}{int} k\_off, \textcolor{keywordtype}{float} *A, \textcolor{keywordtype}{int} k1)}
\DoxyCodeLine{2450 \{}
\DoxyCodeLine{2451    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{2452    \textcolor{keywordtype}{float} k00\_20, k01\_21;}
\DoxyCodeLine{2453 }
\DoxyCodeLine{2454    \textcolor{keywordtype}{float} *e0 = e + d0;}
\DoxyCodeLine{2455    \textcolor{keywordtype}{float} *e2 = e0 + k\_off;}
\DoxyCodeLine{2456 }
\DoxyCodeLine{2457    \textcolor{keywordflow}{for} (i=lim >> 2; i > 0; -\/-\/i) \{}
\DoxyCodeLine{2458       k00\_20 = e0[-\/0] -\/ e2[-\/0];}
\DoxyCodeLine{2459       k01\_21 = e0[-\/1] -\/ e2[-\/1];}
\DoxyCodeLine{2460       e0[-\/0] += e2[-\/0];\textcolor{comment}{//e0[-\/0] = e0[-\/0] + e2[-\/0];}}
\DoxyCodeLine{2461       e0[-\/1] += e2[-\/1];\textcolor{comment}{//e0[-\/1] = e0[-\/1] + e2[-\/1];}}
\DoxyCodeLine{2462       e2[-\/0] = (k00\_20)*A[0] -\/ (k01\_21) * A[1];}
\DoxyCodeLine{2463       e2[-\/1] = (k01\_21)*A[0] + (k00\_20) * A[1];}
\DoxyCodeLine{2464 }
\DoxyCodeLine{2465       A += k1;}
\DoxyCodeLine{2466 }
\DoxyCodeLine{2467       k00\_20 = e0[-\/2] -\/ e2[-\/2];}
\DoxyCodeLine{2468       k01\_21 = e0[-\/3] -\/ e2[-\/3];}
\DoxyCodeLine{2469       e0[-\/2] += e2[-\/2];\textcolor{comment}{//e0[-\/2] = e0[-\/2] + e2[-\/2];}}
\DoxyCodeLine{2470       e0[-\/3] += e2[-\/3];\textcolor{comment}{//e0[-\/3] = e0[-\/3] + e2[-\/3];}}
\DoxyCodeLine{2471       e2[-\/2] = (k00\_20)*A[0] -\/ (k01\_21) * A[1];}
\DoxyCodeLine{2472       e2[-\/3] = (k01\_21)*A[0] + (k00\_20) * A[1];}
\DoxyCodeLine{2473 }
\DoxyCodeLine{2474       A += k1;}
\DoxyCodeLine{2475 }
\DoxyCodeLine{2476       k00\_20 = e0[-\/4] -\/ e2[-\/4];}
\DoxyCodeLine{2477       k01\_21 = e0[-\/5] -\/ e2[-\/5];}
\DoxyCodeLine{2478       e0[-\/4] += e2[-\/4];\textcolor{comment}{//e0[-\/4] = e0[-\/4] + e2[-\/4];}}
\DoxyCodeLine{2479       e0[-\/5] += e2[-\/5];\textcolor{comment}{//e0[-\/5] = e0[-\/5] + e2[-\/5];}}
\DoxyCodeLine{2480       e2[-\/4] = (k00\_20)*A[0] -\/ (k01\_21) * A[1];}
\DoxyCodeLine{2481       e2[-\/5] = (k01\_21)*A[0] + (k00\_20) * A[1];}
\DoxyCodeLine{2482 }
\DoxyCodeLine{2483       A += k1;}
\DoxyCodeLine{2484 }
\DoxyCodeLine{2485       k00\_20 = e0[-\/6] -\/ e2[-\/6];}
\DoxyCodeLine{2486       k01\_21 = e0[-\/7] -\/ e2[-\/7];}
\DoxyCodeLine{2487       e0[-\/6] += e2[-\/6];\textcolor{comment}{//e0[-\/6] = e0[-\/6] + e2[-\/6];}}
\DoxyCodeLine{2488       e0[-\/7] += e2[-\/7];\textcolor{comment}{//e0[-\/7] = e0[-\/7] + e2[-\/7];}}
\DoxyCodeLine{2489       e2[-\/6] = (k00\_20)*A[0] -\/ (k01\_21) * A[1];}
\DoxyCodeLine{2490       e2[-\/7] = (k01\_21)*A[0] + (k00\_20) * A[1];}
\DoxyCodeLine{2491 }
\DoxyCodeLine{2492       e0 -\/= 8;}
\DoxyCodeLine{2493       e2 -\/= 8;}
\DoxyCodeLine{2494 }
\DoxyCodeLine{2495       A += k1;}
\DoxyCodeLine{2496    \}}
\DoxyCodeLine{2497 \}}
\DoxyCodeLine{2498 }
\DoxyCodeLine{2499 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_imdct\_step3\_inner\_s\_loop(\textcolor{keywordtype}{int} n, \textcolor{keywordtype}{float} *e, \textcolor{keywordtype}{int} i\_off, \textcolor{keywordtype}{int} k\_off, \textcolor{keywordtype}{float} *A, \textcolor{keywordtype}{int} a\_off, \textcolor{keywordtype}{int} k0)}
\DoxyCodeLine{2500 \{}
\DoxyCodeLine{2501    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{2502    \textcolor{keywordtype}{float} A0 = A[0];}
\DoxyCodeLine{2503    \textcolor{keywordtype}{float} A1 = A[0+1];}
\DoxyCodeLine{2504    \textcolor{keywordtype}{float} A2 = A[0+a\_off];}
\DoxyCodeLine{2505    \textcolor{keywordtype}{float} A3 = A[0+a\_off+1];}
\DoxyCodeLine{2506    \textcolor{keywordtype}{float} A4 = A[0+a\_off*2+0];}
\DoxyCodeLine{2507    \textcolor{keywordtype}{float} A5 = A[0+a\_off*2+1];}
\DoxyCodeLine{2508    \textcolor{keywordtype}{float} A6 = A[0+a\_off*3+0];}
\DoxyCodeLine{2509    \textcolor{keywordtype}{float} A7 = A[0+a\_off*3+1];}
\DoxyCodeLine{2510 }
\DoxyCodeLine{2511    \textcolor{keywordtype}{float} k00,k11;}
\DoxyCodeLine{2512 }
\DoxyCodeLine{2513    \textcolor{keywordtype}{float} *ee0 = e  +i\_off;}
\DoxyCodeLine{2514    \textcolor{keywordtype}{float} *ee2 = ee0+k\_off;}
\DoxyCodeLine{2515 }
\DoxyCodeLine{2516    \textcolor{keywordflow}{for} (i=n; i > 0; -\/-\/i) \{}
\DoxyCodeLine{2517       k00     = ee0[ 0] -\/ ee2[ 0];}
\DoxyCodeLine{2518       k11     = ee0[-\/1] -\/ ee2[-\/1];}
\DoxyCodeLine{2519       ee0[ 0] =  ee0[ 0] + ee2[ 0];}
\DoxyCodeLine{2520       ee0[-\/1] =  ee0[-\/1] + ee2[-\/1];}
\DoxyCodeLine{2521       ee2[ 0] = (k00) * A0 -\/ (k11) * A1;}
\DoxyCodeLine{2522       ee2[-\/1] = (k11) * A0 + (k00) * A1;}
\DoxyCodeLine{2523 }
\DoxyCodeLine{2524       k00     = ee0[-\/2] -\/ ee2[-\/2];}
\DoxyCodeLine{2525       k11     = ee0[-\/3] -\/ ee2[-\/3];}
\DoxyCodeLine{2526       ee0[-\/2] =  ee0[-\/2] + ee2[-\/2];}
\DoxyCodeLine{2527       ee0[-\/3] =  ee0[-\/3] + ee2[-\/3];}
\DoxyCodeLine{2528       ee2[-\/2] = (k00) * A2 -\/ (k11) * A3;}
\DoxyCodeLine{2529       ee2[-\/3] = (k11) * A2 + (k00) * A3;}
\DoxyCodeLine{2530 }
\DoxyCodeLine{2531       k00     = ee0[-\/4] -\/ ee2[-\/4];}
\DoxyCodeLine{2532       k11     = ee0[-\/5] -\/ ee2[-\/5];}
\DoxyCodeLine{2533       ee0[-\/4] =  ee0[-\/4] + ee2[-\/4];}
\DoxyCodeLine{2534       ee0[-\/5] =  ee0[-\/5] + ee2[-\/5];}
\DoxyCodeLine{2535       ee2[-\/4] = (k00) * A4 -\/ (k11) * A5;}
\DoxyCodeLine{2536       ee2[-\/5] = (k11) * A4 + (k00) * A5;}
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538       k00     = ee0[-\/6] -\/ ee2[-\/6];}
\DoxyCodeLine{2539       k11     = ee0[-\/7] -\/ ee2[-\/7];}
\DoxyCodeLine{2540       ee0[-\/6] =  ee0[-\/6] + ee2[-\/6];}
\DoxyCodeLine{2541       ee0[-\/7] =  ee0[-\/7] + ee2[-\/7];}
\DoxyCodeLine{2542       ee2[-\/6] = (k00) * A6 -\/ (k11) * A7;}
\DoxyCodeLine{2543       ee2[-\/7] = (k11) * A6 + (k00) * A7;}
\DoxyCodeLine{2544 }
\DoxyCodeLine{2545       ee0 -\/= k0;}
\DoxyCodeLine{2546       ee2 -\/= k0;}
\DoxyCodeLine{2547    \}}
\DoxyCodeLine{2548 \}}
\DoxyCodeLine{2549 }
\DoxyCodeLine{2550 \textcolor{keyword}{static} \_\_forceinline \textcolor{keywordtype}{void} stbv\_iter\_54(\textcolor{keywordtype}{float} *z)}
\DoxyCodeLine{2551 \{}
\DoxyCodeLine{2552    \textcolor{keywordtype}{float} k00,k11,k22,k33;}
\DoxyCodeLine{2553    \textcolor{keywordtype}{float} y0,y1,y2,y3;}
\DoxyCodeLine{2554 }
\DoxyCodeLine{2555    k00  = z[ 0] -\/ z[-\/4];}
\DoxyCodeLine{2556    y0   = z[ 0] + z[-\/4];}
\DoxyCodeLine{2557    y2   = z[-\/2] + z[-\/6];}
\DoxyCodeLine{2558    k22  = z[-\/2] -\/ z[-\/6];}
\DoxyCodeLine{2559 }
\DoxyCodeLine{2560    z[-\/0] = y0 + y2;      \textcolor{comment}{// z0 + z4 + z2 + z6}}
\DoxyCodeLine{2561    z[-\/2] = y0 -\/ y2;      \textcolor{comment}{// z0 + z4 -\/ z2 -\/ z6}}
\DoxyCodeLine{2562 }
\DoxyCodeLine{2563    \textcolor{comment}{// done with y0,y2}}
\DoxyCodeLine{2564 }
\DoxyCodeLine{2565    k33  = z[-\/3] -\/ z[-\/7];}
\DoxyCodeLine{2566 }
\DoxyCodeLine{2567    z[-\/4] = k00 + k33;    \textcolor{comment}{// z0 -\/ z4 + z3 -\/ z7}}
\DoxyCodeLine{2568    z[-\/6] = k00 -\/ k33;    \textcolor{comment}{// z0 -\/ z4 -\/ z3 + z7}}
\DoxyCodeLine{2569 }
\DoxyCodeLine{2570    \textcolor{comment}{// done with k33}}
\DoxyCodeLine{2571 }
\DoxyCodeLine{2572    k11  = z[-\/1] -\/ z[-\/5];}
\DoxyCodeLine{2573    y1   = z[-\/1] + z[-\/5];}
\DoxyCodeLine{2574    y3   = z[-\/3] + z[-\/7];}
\DoxyCodeLine{2575 }
\DoxyCodeLine{2576    z[-\/1] = y1 + y3;      \textcolor{comment}{// z1 + z5 + z3 + z7}}
\DoxyCodeLine{2577    z[-\/3] = y1 -\/ y3;      \textcolor{comment}{// z1 + z5 -\/ z3 -\/ z7}}
\DoxyCodeLine{2578    z[-\/5] = k11 -\/ k22;    \textcolor{comment}{// z1 -\/ z5 + z2 -\/ z6}}
\DoxyCodeLine{2579    z[-\/7] = k11 + k22;    \textcolor{comment}{// z1 -\/ z5 -\/ z2 + z6}}
\DoxyCodeLine{2580 \}}
\DoxyCodeLine{2581 }
\DoxyCodeLine{2582 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_imdct\_step3\_inner\_s\_loop\_ld654(\textcolor{keywordtype}{int} n, \textcolor{keywordtype}{float} *e, \textcolor{keywordtype}{int} i\_off, \textcolor{keywordtype}{float} *A, \textcolor{keywordtype}{int} base\_n)}
\DoxyCodeLine{2583 \{}
\DoxyCodeLine{2584    \textcolor{keywordtype}{int} a\_off = base\_n >> 3;}
\DoxyCodeLine{2585    \textcolor{keywordtype}{float} A2 = A[0+a\_off];}
\DoxyCodeLine{2586    \textcolor{keywordtype}{float} *z = e + i\_off;}
\DoxyCodeLine{2587    \textcolor{keywordtype}{float} *base = z -\/ 16 * n;}
\DoxyCodeLine{2588 }
\DoxyCodeLine{2589    \textcolor{keywordflow}{while} (z > base) \{}
\DoxyCodeLine{2590       \textcolor{keywordtype}{float} k00,k11;}
\DoxyCodeLine{2591 }
\DoxyCodeLine{2592       k00   = z[-\/0] -\/ z[-\/8];}
\DoxyCodeLine{2593       k11   = z[-\/1] -\/ z[-\/9];}
\DoxyCodeLine{2594       z[-\/0] = z[-\/0] + z[-\/8];}
\DoxyCodeLine{2595       z[-\/1] = z[-\/1] + z[-\/9];}
\DoxyCodeLine{2596       z[-\/8] =  k00;}
\DoxyCodeLine{2597       z[-\/9] =  k11 ;}
\DoxyCodeLine{2598 }
\DoxyCodeLine{2599       k00    = z[ -\/2] -\/ z[-\/10];}
\DoxyCodeLine{2600       k11    = z[ -\/3] -\/ z[-\/11];}
\DoxyCodeLine{2601       z[ -\/2] = z[ -\/2] + z[-\/10];}
\DoxyCodeLine{2602       z[ -\/3] = z[ -\/3] + z[-\/11];}
\DoxyCodeLine{2603       z[-\/10] = (k00+k11) * A2;}
\DoxyCodeLine{2604       z[-\/11] = (k11-\/k00) * A2;}
\DoxyCodeLine{2605 }
\DoxyCodeLine{2606       k00    = z[-\/12] -\/ z[ -\/4];  \textcolor{comment}{// reverse to avoid a unary negation}}
\DoxyCodeLine{2607       k11    = z[ -\/5] -\/ z[-\/13];}
\DoxyCodeLine{2608       z[ -\/4] = z[ -\/4] + z[-\/12];}
\DoxyCodeLine{2609       z[ -\/5] = z[ -\/5] + z[-\/13];}
\DoxyCodeLine{2610       z[-\/12] = k11;}
\DoxyCodeLine{2611       z[-\/13] = k00;}
\DoxyCodeLine{2612 }
\DoxyCodeLine{2613       k00    = z[-\/14] -\/ z[ -\/6];  \textcolor{comment}{// reverse to avoid a unary negation}}
\DoxyCodeLine{2614       k11    = z[ -\/7] -\/ z[-\/15];}
\DoxyCodeLine{2615       z[ -\/6] = z[ -\/6] + z[-\/14];}
\DoxyCodeLine{2616       z[ -\/7] = z[ -\/7] + z[-\/15];}
\DoxyCodeLine{2617       z[-\/14] = (k00+k11) * A2;}
\DoxyCodeLine{2618       z[-\/15] = (k00-\/k11) * A2;}
\DoxyCodeLine{2619 }
\DoxyCodeLine{2620       stbv\_iter\_54(z);}
\DoxyCodeLine{2621       stbv\_iter\_54(z-\/8);}
\DoxyCodeLine{2622       z -\/= 16;}
\DoxyCodeLine{2623    \}}
\DoxyCodeLine{2624 \}}
\DoxyCodeLine{2625 }
\DoxyCodeLine{2626 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_inverse\_mdct(\textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} n, stbv\_vorb *f, \textcolor{keywordtype}{int} blocktype)}
\DoxyCodeLine{2627 \{}
\DoxyCodeLine{2628    \textcolor{keywordtype}{int} n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;}
\DoxyCodeLine{2629    \textcolor{keywordtype}{int} ld;}
\DoxyCodeLine{2630    \textcolor{comment}{// @OPTIMIZE: reduce register pressure by using fewer variables?}}
\DoxyCodeLine{2631    \textcolor{keywordtype}{int} save\_point = stbv\_temp\_alloc\_save(f);}
\DoxyCodeLine{2632    \textcolor{keywordtype}{float} *buf2 = (\textcolor{keywordtype}{float} *) stbv\_temp\_alloc(f, n2 * \textcolor{keyword}{sizeof}(*buf2));}
\DoxyCodeLine{2633    \textcolor{keywordtype}{float} *u=NULL,*v=NULL;}
\DoxyCodeLine{2634    \textcolor{comment}{// twiddle factors}}
\DoxyCodeLine{2635    \textcolor{keywordtype}{float} *A = f-\/>A[blocktype];}
\DoxyCodeLine{2636 }
\DoxyCodeLine{2637    \textcolor{comment}{// IMDCT algorithm from "{}The use of multirate filter banks for coding of high quality digital audio"{}}}
\DoxyCodeLine{2638    \textcolor{comment}{// See notes about bugs in that paper in less-\/optimal implementation 'inverse\_mdct\_old' after this function.}}
\DoxyCodeLine{2639 }
\DoxyCodeLine{2640    \textcolor{comment}{// kernel from paper}}
\DoxyCodeLine{2641 }
\DoxyCodeLine{2642 }
\DoxyCodeLine{2643    \textcolor{comment}{// merged:}}
\DoxyCodeLine{2644    \textcolor{comment}{//   copy and reflect spectral data}}
\DoxyCodeLine{2645    \textcolor{comment}{//   step 0}}
\DoxyCodeLine{2646 }
\DoxyCodeLine{2647    \textcolor{comment}{// note that it turns out that the items added together during}}
\DoxyCodeLine{2648    \textcolor{comment}{// this step are, in fact, being added to themselves (as reflected}}
\DoxyCodeLine{2649    \textcolor{comment}{// by step 0). inexplicable inefficiency! this became obvious}}
\DoxyCodeLine{2650    \textcolor{comment}{// once I combined the passes.}}
\DoxyCodeLine{2651 }
\DoxyCodeLine{2652    \textcolor{comment}{// so there's a missing 'times 2' here (for adding X to itself).}}
\DoxyCodeLine{2653    \textcolor{comment}{// this propogates through linearly to the end, where the numbers}}
\DoxyCodeLine{2654    \textcolor{comment}{// are 1/2 too small, and need to be compensated for.}}
\DoxyCodeLine{2655 }
\DoxyCodeLine{2656    \{}
\DoxyCodeLine{2657       \textcolor{keywordtype}{float} *d,*e, *AA, *e\_stop;}
\DoxyCodeLine{2658       d = \&buf2[n2-\/2];}
\DoxyCodeLine{2659       AA = A;}
\DoxyCodeLine{2660       e = \&buffer[0];}
\DoxyCodeLine{2661       e\_stop = \&buffer[n2];}
\DoxyCodeLine{2662       \textcolor{keywordflow}{while} (e != e\_stop) \{}
\DoxyCodeLine{2663          d[1] = (e[0] * AA[0] -\/ e[2]*AA[1]);}
\DoxyCodeLine{2664          d[0] = (e[0] * AA[1] + e[2]*AA[0]);}
\DoxyCodeLine{2665          d -\/= 2;}
\DoxyCodeLine{2666          AA += 2;}
\DoxyCodeLine{2667          e += 4;}
\DoxyCodeLine{2668       \}}
\DoxyCodeLine{2669 }
\DoxyCodeLine{2670       e = \&buffer[n2-\/3];}
\DoxyCodeLine{2671       \textcolor{keywordflow}{while} (d >= buf2) \{}
\DoxyCodeLine{2672          d[1] = (-\/e[2] * AA[0] -\/ -\/e[0]*AA[1]);}
\DoxyCodeLine{2673          d[0] = (-\/e[2] * AA[1] + -\/e[0]*AA[0]);}
\DoxyCodeLine{2674          d -\/= 2;}
\DoxyCodeLine{2675          AA += 2;}
\DoxyCodeLine{2676          e -\/= 4;}
\DoxyCodeLine{2677       \}}
\DoxyCodeLine{2678    \}}
\DoxyCodeLine{2679 }
\DoxyCodeLine{2680    \textcolor{comment}{// now we use symbolic names for these, so that we can}}
\DoxyCodeLine{2681    \textcolor{comment}{// possibly swap their meaning as we change which operations}}
\DoxyCodeLine{2682    \textcolor{comment}{// are in place}}
\DoxyCodeLine{2683 }
\DoxyCodeLine{2684    u = buffer;}
\DoxyCodeLine{2685    v = buf2;}
\DoxyCodeLine{2686 }
\DoxyCodeLine{2687    \textcolor{comment}{// step 2    (paper output is w, now u)}}
\DoxyCodeLine{2688    \textcolor{comment}{// this could be in place, but the data ends up in the wrong}}
\DoxyCodeLine{2689    \textcolor{comment}{// place... \_somebody\_'s got to swap it, so this is nominated}}
\DoxyCodeLine{2690    \{}
\DoxyCodeLine{2691       \textcolor{keywordtype}{float} *AA = \&A[n2-\/8];}
\DoxyCodeLine{2692       \textcolor{keywordtype}{float} *d0,*d1, *e0, *e1;}
\DoxyCodeLine{2693 }
\DoxyCodeLine{2694       e0 = \&v[n4];}
\DoxyCodeLine{2695       e1 = \&v[0];}
\DoxyCodeLine{2696 }
\DoxyCodeLine{2697       d0 = \&u[n4];}
\DoxyCodeLine{2698       d1 = \&u[0];}
\DoxyCodeLine{2699 }
\DoxyCodeLine{2700       \textcolor{keywordflow}{while} (AA >= A) \{}
\DoxyCodeLine{2701          \textcolor{keywordtype}{float} v40\_20, v41\_21;}
\DoxyCodeLine{2702 }
\DoxyCodeLine{2703          v41\_21 = e0[1] -\/ e1[1];}
\DoxyCodeLine{2704          v40\_20 = e0[0] -\/ e1[0];}
\DoxyCodeLine{2705          d0[1]  = e0[1] + e1[1];}
\DoxyCodeLine{2706          d0[0]  = e0[0] + e1[0];}
\DoxyCodeLine{2707          d1[1]  = v41\_21*AA[4] -\/ v40\_20*AA[5];}
\DoxyCodeLine{2708          d1[0]  = v40\_20*AA[4] + v41\_21*AA[5];}
\DoxyCodeLine{2709 }
\DoxyCodeLine{2710          v41\_21 = e0[3] -\/ e1[3];}
\DoxyCodeLine{2711          v40\_20 = e0[2] -\/ e1[2];}
\DoxyCodeLine{2712          d0[3]  = e0[3] + e1[3];}
\DoxyCodeLine{2713          d0[2]  = e0[2] + e1[2];}
\DoxyCodeLine{2714          d1[3]  = v41\_21*AA[0] -\/ v40\_20*AA[1];}
\DoxyCodeLine{2715          d1[2]  = v40\_20*AA[0] + v41\_21*AA[1];}
\DoxyCodeLine{2716 }
\DoxyCodeLine{2717          AA -\/= 8;}
\DoxyCodeLine{2718 }
\DoxyCodeLine{2719          d0 += 4;}
\DoxyCodeLine{2720          d1 += 4;}
\DoxyCodeLine{2721          e0 += 4;}
\DoxyCodeLine{2722          e1 += 4;}
\DoxyCodeLine{2723       \}}
\DoxyCodeLine{2724    \}}
\DoxyCodeLine{2725 }
\DoxyCodeLine{2726    \textcolor{comment}{// step 3}}
\DoxyCodeLine{2727    ld = stbv\_ilog(n) -\/ 1; \textcolor{comment}{// stbv\_ilog is off-\/by-\/one from normal definitions}}
\DoxyCodeLine{2728 }
\DoxyCodeLine{2729    \textcolor{comment}{// optimized step 3:}}
\DoxyCodeLine{2730 }
\DoxyCodeLine{2731    \textcolor{comment}{// the original step3 loop can be nested r inside s or s inside r;}}
\DoxyCodeLine{2732    \textcolor{comment}{// it's written originally as s inside r, but this is dumb when r}}
\DoxyCodeLine{2733    \textcolor{comment}{// iterates many times, and s few. So I have two copies of it and}}
\DoxyCodeLine{2734    \textcolor{comment}{// switch between them halfway.}}
\DoxyCodeLine{2735 }
\DoxyCodeLine{2736    \textcolor{comment}{// this is iteration 0 of step 3}}
\DoxyCodeLine{2737    stbv\_imdct\_step3\_iter0\_loop(n >> 4, u, n2-\/1-\/n4*0, -\/(n >> 3), A);}
\DoxyCodeLine{2738    stbv\_imdct\_step3\_iter0\_loop(n >> 4, u, n2-\/1-\/n4*1, -\/(n >> 3), A);}
\DoxyCodeLine{2739 }
\DoxyCodeLine{2740    \textcolor{comment}{// this is iteration 1 of step 3}}
\DoxyCodeLine{2741    stbv\_imdct\_step3\_inner\_r\_loop(n >> 5, u, n2-\/1 -\/ n8*0, -\/(n >> 4), A, 16);}
\DoxyCodeLine{2742    stbv\_imdct\_step3\_inner\_r\_loop(n >> 5, u, n2-\/1 -\/ n8*1, -\/(n >> 4), A, 16);}
\DoxyCodeLine{2743    stbv\_imdct\_step3\_inner\_r\_loop(n >> 5, u, n2-\/1 -\/ n8*2, -\/(n >> 4), A, 16);}
\DoxyCodeLine{2744    stbv\_imdct\_step3\_inner\_r\_loop(n >> 5, u, n2-\/1 -\/ n8*3, -\/(n >> 4), A, 16);}
\DoxyCodeLine{2745 }
\DoxyCodeLine{2746    l=2;}
\DoxyCodeLine{2747    \textcolor{keywordflow}{for} (; l < (ld-\/3)>>1; ++l) \{}
\DoxyCodeLine{2748       \textcolor{keywordtype}{int} k0 = n >> (l+2), k0\_2 = k0>>1;}
\DoxyCodeLine{2749       \textcolor{keywordtype}{int} lim = 1 << (l+1);}
\DoxyCodeLine{2750       \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{2751       \textcolor{keywordflow}{for} (i=0; i < lim; ++i)}
\DoxyCodeLine{2752          stbv\_imdct\_step3\_inner\_r\_loop(n >> (l+4), u, n2-\/1 -\/ k0*i, -\/k0\_2, A, 1 << (l+3));}
\DoxyCodeLine{2753    \}}
\DoxyCodeLine{2754 }
\DoxyCodeLine{2755    \textcolor{keywordflow}{for} (; l < ld-\/6; ++l) \{}
\DoxyCodeLine{2756       \textcolor{keywordtype}{int} k0 = n >> (l+2), k1 = 1 << (l+3), k0\_2 = k0>>1;}
\DoxyCodeLine{2757       \textcolor{keywordtype}{int} rlim = n >> (l+6), r;}
\DoxyCodeLine{2758       \textcolor{keywordtype}{int} lim = 1 << (l+1);}
\DoxyCodeLine{2759       \textcolor{keywordtype}{int} i\_off;}
\DoxyCodeLine{2760       \textcolor{keywordtype}{float} *A0 = A;}
\DoxyCodeLine{2761       i\_off = n2-\/1;}
\DoxyCodeLine{2762       \textcolor{keywordflow}{for} (r=rlim; r > 0; -\/-\/r) \{}
\DoxyCodeLine{2763          stbv\_imdct\_step3\_inner\_s\_loop(lim, u, i\_off, -\/k0\_2, A0, k1, k0);}
\DoxyCodeLine{2764          A0 += k1*4;}
\DoxyCodeLine{2765          i\_off -\/= 8;}
\DoxyCodeLine{2766       \}}
\DoxyCodeLine{2767    \}}
\DoxyCodeLine{2768 }
\DoxyCodeLine{2769    \textcolor{comment}{// iterations with count:}}
\DoxyCodeLine{2770    \textcolor{comment}{//   ld-\/6,-\/5,-\/4 all interleaved together}}
\DoxyCodeLine{2771    \textcolor{comment}{//       the big win comes from getting rid of needless flops}}
\DoxyCodeLine{2772    \textcolor{comment}{//         due to the constants on pass 5 \& 4 being all 1 and 0;}}
\DoxyCodeLine{2773    \textcolor{comment}{//       combining them to be simultaneous to improve cache made little difference}}
\DoxyCodeLine{2774    stbv\_imdct\_step3\_inner\_s\_loop\_ld654(n >> 5, u, n2-\/1, A, n);}
\DoxyCodeLine{2775 }
\DoxyCodeLine{2776    \textcolor{comment}{// output is u}}
\DoxyCodeLine{2777 }
\DoxyCodeLine{2778    \textcolor{comment}{// step 4, 5, and 6}}
\DoxyCodeLine{2779    \textcolor{comment}{// cannot be in-\/place because of step 5}}
\DoxyCodeLine{2780    \{}
\DoxyCodeLine{2781       stbv\_uint16 *bitrev = f-\/>stbv\_bit\_reverse[blocktype];}
\DoxyCodeLine{2782       \textcolor{comment}{// weirdly, I'd have thought reading sequentially and writing}}
\DoxyCodeLine{2783       \textcolor{comment}{// erratically would have been better than vice-\/versa, but in}}
\DoxyCodeLine{2784       \textcolor{comment}{// fact that's not what my testing showed. (That is, with}}
\DoxyCodeLine{2785       \textcolor{comment}{// j = bitreverse(i), do you read i and write j, or read j and write i.)}}
\DoxyCodeLine{2786 }
\DoxyCodeLine{2787       \textcolor{keywordtype}{float} *d0 = \&v[n4-\/4];}
\DoxyCodeLine{2788       \textcolor{keywordtype}{float} *d1 = \&v[n2-\/4];}
\DoxyCodeLine{2789       \textcolor{keywordflow}{while} (d0 >= v) \{}
\DoxyCodeLine{2790          \textcolor{keywordtype}{int} k4;}
\DoxyCodeLine{2791 }
\DoxyCodeLine{2792          k4 = bitrev[0];}
\DoxyCodeLine{2793          d1[3] = u[k4+0];}
\DoxyCodeLine{2794          d1[2] = u[k4+1];}
\DoxyCodeLine{2795          d0[3] = u[k4+2];}
\DoxyCodeLine{2796          d0[2] = u[k4+3];}
\DoxyCodeLine{2797 }
\DoxyCodeLine{2798          k4 = bitrev[1];}
\DoxyCodeLine{2799          d1[1] = u[k4+0];}
\DoxyCodeLine{2800          d1[0] = u[k4+1];}
\DoxyCodeLine{2801          d0[1] = u[k4+2];}
\DoxyCodeLine{2802          d0[0] = u[k4+3];}
\DoxyCodeLine{2803          }
\DoxyCodeLine{2804          d0 -\/= 4;}
\DoxyCodeLine{2805          d1 -\/= 4;}
\DoxyCodeLine{2806          bitrev += 2;}
\DoxyCodeLine{2807       \}}
\DoxyCodeLine{2808    \}}
\DoxyCodeLine{2809    \textcolor{comment}{// (paper output is u, now v)}}
\DoxyCodeLine{2810 }
\DoxyCodeLine{2811 }
\DoxyCodeLine{2812    \textcolor{comment}{// data must be in buf2}}
\DoxyCodeLine{2813    assert(v == buf2);}
\DoxyCodeLine{2814 }
\DoxyCodeLine{2815    \textcolor{comment}{// step 7   (paper output is v, now v)}}
\DoxyCodeLine{2816    \textcolor{comment}{// this is now in place}}
\DoxyCodeLine{2817    \{}
\DoxyCodeLine{2818       \textcolor{keywordtype}{float} *C = f-\/>C[blocktype];}
\DoxyCodeLine{2819       \textcolor{keywordtype}{float} *d, *e;}
\DoxyCodeLine{2820 }
\DoxyCodeLine{2821       d = v;}
\DoxyCodeLine{2822       e = v + n2 -\/ 4;}
\DoxyCodeLine{2823 }
\DoxyCodeLine{2824       \textcolor{keywordflow}{while} (d < e) \{}
\DoxyCodeLine{2825          \textcolor{keywordtype}{float} a02,a11,b0,b1,b2,b3;}
\DoxyCodeLine{2826 }
\DoxyCodeLine{2827          a02 = d[0] -\/ e[2];}
\DoxyCodeLine{2828          a11 = d[1] + e[3];}
\DoxyCodeLine{2829 }
\DoxyCodeLine{2830          b0 = C[1]*a02 + C[0]*a11;}
\DoxyCodeLine{2831          b1 = C[1]*a11 -\/ C[0]*a02;}
\DoxyCodeLine{2832 }
\DoxyCodeLine{2833          b2 = d[0] + e[ 2];}
\DoxyCodeLine{2834          b3 = d[1] -\/ e[ 3];}
\DoxyCodeLine{2835 }
\DoxyCodeLine{2836          d[0] = b2 + b0;}
\DoxyCodeLine{2837          d[1] = b3 + b1;}
\DoxyCodeLine{2838          e[2] = b2 -\/ b0;}
\DoxyCodeLine{2839          e[3] = b1 -\/ b3;}
\DoxyCodeLine{2840 }
\DoxyCodeLine{2841          a02 = d[2] -\/ e[0];}
\DoxyCodeLine{2842          a11 = d[3] + e[1];}
\DoxyCodeLine{2843 }
\DoxyCodeLine{2844          b0 = C[3]*a02 + C[2]*a11;}
\DoxyCodeLine{2845          b1 = C[3]*a11 -\/ C[2]*a02;}
\DoxyCodeLine{2846 }
\DoxyCodeLine{2847          b2 = d[2] + e[ 0];}
\DoxyCodeLine{2848          b3 = d[3] -\/ e[ 1];}
\DoxyCodeLine{2849 }
\DoxyCodeLine{2850          d[2] = b2 + b0;}
\DoxyCodeLine{2851          d[3] = b3 + b1;}
\DoxyCodeLine{2852          e[0] = b2 -\/ b0;}
\DoxyCodeLine{2853          e[1] = b1 -\/ b3;}
\DoxyCodeLine{2854 }
\DoxyCodeLine{2855          C += 4;}
\DoxyCodeLine{2856          d += 4;}
\DoxyCodeLine{2857          e -\/= 4;}
\DoxyCodeLine{2858       \}}
\DoxyCodeLine{2859    \}}
\DoxyCodeLine{2860 }
\DoxyCodeLine{2861    \textcolor{comment}{// data must be in buf2}}
\DoxyCodeLine{2862 }
\DoxyCodeLine{2863 }
\DoxyCodeLine{2864    \textcolor{comment}{// step 8+decode   (paper output is X, now buffer)}}
\DoxyCodeLine{2865    \textcolor{comment}{// this generates pairs of data a la 8 and pushes them directly through}}
\DoxyCodeLine{2866    \textcolor{comment}{// the decode kernel (pushing rather than pulling) to avoid having}}
\DoxyCodeLine{2867    \textcolor{comment}{// to make another pass later}}
\DoxyCodeLine{2868 }
\DoxyCodeLine{2869    \textcolor{comment}{// this cannot POSSIBLY be in place, so we refer to the buffers directly}}
\DoxyCodeLine{2870 }
\DoxyCodeLine{2871    \{}
\DoxyCodeLine{2872       \textcolor{keywordtype}{float} *d0,*d1,*d2,*d3;}
\DoxyCodeLine{2873 }
\DoxyCodeLine{2874       \textcolor{keywordtype}{float} *B = f-\/>B[blocktype] + n2 -\/ 8;}
\DoxyCodeLine{2875       \textcolor{keywordtype}{float} *e = buf2 + n2 -\/ 8;}
\DoxyCodeLine{2876       d0 = \&buffer[0];}
\DoxyCodeLine{2877       d1 = \&buffer[n2-\/4];}
\DoxyCodeLine{2878       d2 = \&buffer[n2];}
\DoxyCodeLine{2879       d3 = \&buffer[n-\/4];}
\DoxyCodeLine{2880       \textcolor{keywordflow}{while} (e >= v) \{}
\DoxyCodeLine{2881          \textcolor{keywordtype}{float} p0,p1,p2,p3;}
\DoxyCodeLine{2882 }
\DoxyCodeLine{2883          p3 =  e[6]*B[7] -\/ e[7]*B[6];}
\DoxyCodeLine{2884          p2 = -\/e[6]*B[6] -\/ e[7]*B[7]; }
\DoxyCodeLine{2885 }
\DoxyCodeLine{2886          d0[0] =   p3;}
\DoxyCodeLine{2887          d1[3] = -\/ p3;}
\DoxyCodeLine{2888          d2[0] =   p2;}
\DoxyCodeLine{2889          d3[3] =   p2;}
\DoxyCodeLine{2890 }
\DoxyCodeLine{2891          p1 =  e[4]*B[5] -\/ e[5]*B[4];}
\DoxyCodeLine{2892          p0 = -\/e[4]*B[4] -\/ e[5]*B[5]; }
\DoxyCodeLine{2893 }
\DoxyCodeLine{2894          d0[1] =   p1;}
\DoxyCodeLine{2895          d1[2] = -\/ p1;}
\DoxyCodeLine{2896          d2[1] =   p0;}
\DoxyCodeLine{2897          d3[2] =   p0;}
\DoxyCodeLine{2898 }
\DoxyCodeLine{2899          p3 =  e[2]*B[3] -\/ e[3]*B[2];}
\DoxyCodeLine{2900          p2 = -\/e[2]*B[2] -\/ e[3]*B[3]; }
\DoxyCodeLine{2901 }
\DoxyCodeLine{2902          d0[2] =   p3;}
\DoxyCodeLine{2903          d1[1] = -\/ p3;}
\DoxyCodeLine{2904          d2[2] =   p2;}
\DoxyCodeLine{2905          d3[1] =   p2;}
\DoxyCodeLine{2906 }
\DoxyCodeLine{2907          p1 =  e[0]*B[1] -\/ e[1]*B[0];}
\DoxyCodeLine{2908          p0 = -\/e[0]*B[0] -\/ e[1]*B[1]; }
\DoxyCodeLine{2909 }
\DoxyCodeLine{2910          d0[3] =   p1;}
\DoxyCodeLine{2911          d1[0] = -\/ p1;}
\DoxyCodeLine{2912          d2[3] =   p0;}
\DoxyCodeLine{2913          d3[0] =   p0;}
\DoxyCodeLine{2914 }
\DoxyCodeLine{2915          B -\/= 8;}
\DoxyCodeLine{2916          e -\/= 8;}
\DoxyCodeLine{2917          d0 += 4;}
\DoxyCodeLine{2918          d2 += 4;}
\DoxyCodeLine{2919          d1 -\/= 4;}
\DoxyCodeLine{2920          d3 -\/= 4;}
\DoxyCodeLine{2921       \}}
\DoxyCodeLine{2922    \}}
\DoxyCodeLine{2923 }
\DoxyCodeLine{2924    stbv\_temp\_free(f,buf2);}
\DoxyCodeLine{2925    stbv\_temp\_alloc\_restore(f,save\_point);}
\DoxyCodeLine{2926 \}}
\DoxyCodeLine{2927 }
\DoxyCodeLine{2928 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{2929 \textcolor{comment}{// this is the original version of the above code, if you want to optimize it from scratch}}
\DoxyCodeLine{2930 \textcolor{keywordtype}{void} inverse\_mdct\_naive(\textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{2931 \{}
\DoxyCodeLine{2932    \textcolor{keywordtype}{float} s;}
\DoxyCodeLine{2933    \textcolor{keywordtype}{float} A[1 << 12], B[1 << 12], C[1 << 11];}
\DoxyCodeLine{2934    \textcolor{keywordtype}{int} i,k,k2,k4, n2 = n >> 1, n4 = n >> 2, n8 = n >> 3, l;}
\DoxyCodeLine{2935    \textcolor{keywordtype}{int} n3\_4 = n -\/ n4, ld;}
\DoxyCodeLine{2936    \textcolor{comment}{// how can they claim this only uses N words?!}}
\DoxyCodeLine{2937    \textcolor{comment}{// oh, because they're only used sparsely, whoops}}
\DoxyCodeLine{2938    \textcolor{keywordtype}{float} u[1 << 13], X[1 << 13], v[1 << 13], w[1 << 13];}
\DoxyCodeLine{2939    \textcolor{comment}{// set up twiddle factors}}
\DoxyCodeLine{2940 }
\DoxyCodeLine{2941    \textcolor{keywordflow}{for} (k=k2=0; k < n4; ++k,k2+=2) \{}
\DoxyCodeLine{2942       A[k2  ] = (float)  cos(4*k*M\_PI/n);}
\DoxyCodeLine{2943       A[k2+1] = (float) -\/sin(4*k*M\_PI/n);}
\DoxyCodeLine{2944       B[k2  ] = (float)  cos((k2+1)*M\_PI/n/2);}
\DoxyCodeLine{2945       B[k2+1] = (float)  sin((k2+1)*M\_PI/n/2);}
\DoxyCodeLine{2946    \}}
\DoxyCodeLine{2947    \textcolor{keywordflow}{for} (k=k2=0; k < n8; ++k,k2+=2) \{}
\DoxyCodeLine{2948       C[k2  ] = (float)  cos(2*(k2+1)*M\_PI/n);}
\DoxyCodeLine{2949       C[k2+1] = (float) -\/sin(2*(k2+1)*M\_PI/n);}
\DoxyCodeLine{2950    \}}
\DoxyCodeLine{2951 }
\DoxyCodeLine{2952    \textcolor{comment}{// IMDCT algorithm from "{}The use of multirate filter banks for coding of high quality digital audio"{}}}
\DoxyCodeLine{2953    \textcolor{comment}{// Note there are bugs in that pseudocode, presumably due to them attempting}}
\DoxyCodeLine{2954    \textcolor{comment}{// to rename the arrays nicely rather than representing the way their actual}}
\DoxyCodeLine{2955    \textcolor{comment}{// implementation bounces buffers back and forth. As a result, even in the}}
\DoxyCodeLine{2956    \textcolor{comment}{// "{}some formulars corrected"{} version, a direct implementation fails. These}}
\DoxyCodeLine{2957    \textcolor{comment}{// are noted below as "{}paper bug"{}.}}
\DoxyCodeLine{2958 }
\DoxyCodeLine{2959    \textcolor{comment}{// copy and reflect spectral data}}
\DoxyCodeLine{2960    \textcolor{keywordflow}{for} (k=0; k < n2; ++k) u[k] = buffer[k];}
\DoxyCodeLine{2961    \textcolor{keywordflow}{for} (   ; k < n ; ++k) u[k] = -\/buffer[n -\/ k -\/ 1];}
\DoxyCodeLine{2962    \textcolor{comment}{// kernel from paper}}
\DoxyCodeLine{2963    \textcolor{comment}{// step 1}}
\DoxyCodeLine{2964    \textcolor{keywordflow}{for} (k=k2=k4=0; k < n4; k+=1, k2+=2, k4+=4) \{}
\DoxyCodeLine{2965       v[n-\/k4-\/1] = (u[k4] -\/ u[n-\/k4-\/1]) * A[k2]   -\/ (u[k4+2] -\/ u[n-\/k4-\/3])*A[k2+1];}
\DoxyCodeLine{2966       v[n-\/k4-\/3] = (u[k4] -\/ u[n-\/k4-\/1]) * A[k2+1] + (u[k4+2] -\/ u[n-\/k4-\/3])*A[k2];}
\DoxyCodeLine{2967    \}}
\DoxyCodeLine{2968    \textcolor{comment}{// step 2}}
\DoxyCodeLine{2969    \textcolor{keywordflow}{for} (k=k4=0; k < n8; k+=1, k4+=4) \{}
\DoxyCodeLine{2970       w[n2+3+k4] = v[n2+3+k4] + v[k4+3];}
\DoxyCodeLine{2971       w[n2+1+k4] = v[n2+1+k4] + v[k4+1];}
\DoxyCodeLine{2972       w[k4+3]    = (v[n2+3+k4] -\/ v[k4+3])*A[n2-\/4-\/k4] -\/ (v[n2+1+k4]-\/v[k4+1])*A[n2-\/3-\/k4];}
\DoxyCodeLine{2973       w[k4+1]    = (v[n2+1+k4] -\/ v[k4+1])*A[n2-\/4-\/k4] + (v[n2+3+k4]-\/v[k4+3])*A[n2-\/3-\/k4];}
\DoxyCodeLine{2974    \}}
\DoxyCodeLine{2975    \textcolor{comment}{// step 3}}
\DoxyCodeLine{2976    ld = stbv\_ilog(n) -\/ 1; \textcolor{comment}{// stbv\_ilog is off-\/by-\/one from normal definitions}}
\DoxyCodeLine{2977    \textcolor{keywordflow}{for} (l=0; l < ld-\/3; ++l) \{}
\DoxyCodeLine{2978       \textcolor{keywordtype}{int} k0 = n >> (l+2), k1 = 1 << (l+3);}
\DoxyCodeLine{2979       \textcolor{keywordtype}{int} rlim = n >> (l+4), r4, r;}
\DoxyCodeLine{2980       \textcolor{keywordtype}{int} s2lim = 1 << (l+2), s2;}
\DoxyCodeLine{2981       \textcolor{keywordflow}{for} (r=r4=0; r < rlim; r4+=4,++r) \{}
\DoxyCodeLine{2982          \textcolor{keywordflow}{for} (s2=0; s2 < s2lim; s2+=2) \{}
\DoxyCodeLine{2983             u[n-\/1-\/k0*s2-\/r4] = w[n-\/1-\/k0*s2-\/r4] + w[n-\/1-\/k0*(s2+1)-\/r4];}
\DoxyCodeLine{2984             u[n-\/3-\/k0*s2-\/r4] = w[n-\/3-\/k0*s2-\/r4] + w[n-\/3-\/k0*(s2+1)-\/r4];}
\DoxyCodeLine{2985             u[n-\/1-\/k0*(s2+1)-\/r4] = (w[n-\/1-\/k0*s2-\/r4] -\/ w[n-\/1-\/k0*(s2+1)-\/r4]) * A[r*k1]}
\DoxyCodeLine{2986                                 -\/ (w[n-\/3-\/k0*s2-\/r4] -\/ w[n-\/3-\/k0*(s2+1)-\/r4]) * A[r*k1+1];}
\DoxyCodeLine{2987             u[n-\/3-\/k0*(s2+1)-\/r4] = (w[n-\/3-\/k0*s2-\/r4] -\/ w[n-\/3-\/k0*(s2+1)-\/r4]) * A[r*k1]}
\DoxyCodeLine{2988                                 + (w[n-\/1-\/k0*s2-\/r4] -\/ w[n-\/1-\/k0*(s2+1)-\/r4]) * A[r*k1+1];}
\DoxyCodeLine{2989          \}}
\DoxyCodeLine{2990       \}}
\DoxyCodeLine{2991       \textcolor{keywordflow}{if} (l+1 < ld-\/3) \{}
\DoxyCodeLine{2992          \textcolor{comment}{// paper bug: ping-\/ponging of u\&w here is omitted}}
\DoxyCodeLine{2993          memcpy(w, u, \textcolor{keyword}{sizeof}(u));}
\DoxyCodeLine{2994       \}}
\DoxyCodeLine{2995    \}}
\DoxyCodeLine{2996 }
\DoxyCodeLine{2997    \textcolor{comment}{// step 4}}
\DoxyCodeLine{2998    \textcolor{keywordflow}{for} (i=0; i < n8; ++i) \{}
\DoxyCodeLine{2999       \textcolor{keywordtype}{int} j = stbv\_bit\_reverse(i) >> (32-\/ld+3);}
\DoxyCodeLine{3000       assert(j < n8);}
\DoxyCodeLine{3001       \textcolor{keywordflow}{if} (i == j) \{}
\DoxyCodeLine{3002          \textcolor{comment}{// paper bug: original code probably swapped in place; if copying,}}
\DoxyCodeLine{3003          \textcolor{comment}{//            need to directly copy in this case}}
\DoxyCodeLine{3004          \textcolor{keywordtype}{int} i8 = i << 3;}
\DoxyCodeLine{3005          v[i8+1] = u[i8+1];}
\DoxyCodeLine{3006          v[i8+3] = u[i8+3];}
\DoxyCodeLine{3007          v[i8+5] = u[i8+5];}
\DoxyCodeLine{3008          v[i8+7] = u[i8+7];}
\DoxyCodeLine{3009       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i < j) \{}
\DoxyCodeLine{3010          \textcolor{keywordtype}{int} i8 = i << 3, j8 = j << 3;}
\DoxyCodeLine{3011          v[j8+1] = u[i8+1], v[i8+1] = u[j8 + 1];}
\DoxyCodeLine{3012          v[j8+3] = u[i8+3], v[i8+3] = u[j8 + 3];}
\DoxyCodeLine{3013          v[j8+5] = u[i8+5], v[i8+5] = u[j8 + 5];}
\DoxyCodeLine{3014          v[j8+7] = u[i8+7], v[i8+7] = u[j8 + 7];}
\DoxyCodeLine{3015       \}}
\DoxyCodeLine{3016    \}}
\DoxyCodeLine{3017    \textcolor{comment}{// step 5}}
\DoxyCodeLine{3018    \textcolor{keywordflow}{for} (k=0; k < n2; ++k) \{}
\DoxyCodeLine{3019       w[k] = v[k*2+1];}
\DoxyCodeLine{3020    \}}
\DoxyCodeLine{3021    \textcolor{comment}{// step 6}}
\DoxyCodeLine{3022    \textcolor{keywordflow}{for} (k=k2=k4=0; k < n8; ++k, k2 += 2, k4 += 4) \{}
\DoxyCodeLine{3023       u[n-\/1-\/k2] = w[k4];}
\DoxyCodeLine{3024       u[n-\/2-\/k2] = w[k4+1];}
\DoxyCodeLine{3025       u[n3\_4 -\/ 1 -\/ k2] = w[k4+2];}
\DoxyCodeLine{3026       u[n3\_4 -\/ 2 -\/ k2] = w[k4+3];}
\DoxyCodeLine{3027    \}}
\DoxyCodeLine{3028    \textcolor{comment}{// step 7}}
\DoxyCodeLine{3029    \textcolor{keywordflow}{for} (k=k2=0; k < n8; ++k, k2 += 2) \{}
\DoxyCodeLine{3030       v[n2 + k2 ] = ( u[n2 + k2] + u[n-\/2-\/k2] + C[k2+1]*(u[n2+k2]-\/u[n-\/2-\/k2]) + C[k2]*(u[n2+k2+1]+u[n-\/2-\/k2+1]))/2;}
\DoxyCodeLine{3031       v[n-\/2 -\/ k2] = ( u[n2 + k2] + u[n-\/2-\/k2] -\/ C[k2+1]*(u[n2+k2]-\/u[n-\/2-\/k2]) -\/ C[k2]*(u[n2+k2+1]+u[n-\/2-\/k2+1]))/2;}
\DoxyCodeLine{3032       v[n2+1+ k2] = ( u[n2+1+k2] -\/ u[n-\/1-\/k2] + C[k2+1]*(u[n2+1+k2]+u[n-\/1-\/k2]) -\/ C[k2]*(u[n2+k2]-\/u[n-\/2-\/k2]))/2;}
\DoxyCodeLine{3033       v[n-\/1 -\/ k2] = (-\/u[n2+1+k2] + u[n-\/1-\/k2] + C[k2+1]*(u[n2+1+k2]+u[n-\/1-\/k2]) -\/ C[k2]*(u[n2+k2]-\/u[n-\/2-\/k2]))/2;}
\DoxyCodeLine{3034    \}}
\DoxyCodeLine{3035    \textcolor{comment}{// step 8}}
\DoxyCodeLine{3036    \textcolor{keywordflow}{for} (k=k2=0; k < n4; ++k,k2 += 2) \{}
\DoxyCodeLine{3037       X[k]      = v[k2+n2]*B[k2  ] + v[k2+1+n2]*B[k2+1];}
\DoxyCodeLine{3038       X[n2-\/1-\/k] = v[k2+n2]*B[k2+1] -\/ v[k2+1+n2]*B[k2  ];}
\DoxyCodeLine{3039    \}}
\DoxyCodeLine{3040 }
\DoxyCodeLine{3041    \textcolor{comment}{// decode kernel to output}}
\DoxyCodeLine{3042    \textcolor{comment}{// determined the following value experimentally}}
\DoxyCodeLine{3043    \textcolor{comment}{// (by first figuring out what made inverse\_mdct\_slow work); then matching that here}}
\DoxyCodeLine{3044    \textcolor{comment}{// (probably vorbis encoder premultiplies by n or n/2, to save it on the decoder?)}}
\DoxyCodeLine{3045    s = 0.5; \textcolor{comment}{// theoretically would be n4}}
\DoxyCodeLine{3046 }
\DoxyCodeLine{3047    \textcolor{comment}{// [[[ note! the s value of 0.5 is compensated for by the B[] in the current code,}}
\DoxyCodeLine{3048    \textcolor{comment}{//     so it needs to use the "{}old"{} B values to behave correctly, or else}}
\DoxyCodeLine{3049    \textcolor{comment}{//     set s to 1.0 ]]]}}
\DoxyCodeLine{3050    \textcolor{keywordflow}{for} (i=0; i < n4  ; ++i) buffer[i] = s * X[i+n4];}
\DoxyCodeLine{3051    \textcolor{keywordflow}{for} (   ; i < n3\_4; ++i) buffer[i] = -\/s * X[n3\_4 -\/ i -\/ 1];}
\DoxyCodeLine{3052    \textcolor{keywordflow}{for} (   ; i < n   ; ++i) buffer[i] = -\/s * X[i -\/ n3\_4];}
\DoxyCodeLine{3053 \}}
\DoxyCodeLine{3054 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3055 }
\DoxyCodeLine{3056 \textcolor{keyword}{static} \textcolor{keywordtype}{float} *stbv\_get\_window(stbv\_vorb *f, \textcolor{keywordtype}{int} len)}
\DoxyCodeLine{3057 \{}
\DoxyCodeLine{3058    len <<= 1;}
\DoxyCodeLine{3059    \textcolor{keywordflow}{if} (len == f-\/>blocksize\_0) \textcolor{keywordflow}{return} f-\/>window[0];}
\DoxyCodeLine{3060    \textcolor{keywordflow}{if} (len == f-\/>blocksize\_1) \textcolor{keywordflow}{return} f-\/>window[1];}
\DoxyCodeLine{3061    assert(0);}
\DoxyCodeLine{3062    \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{3063 \}}
\DoxyCodeLine{3064 }
\DoxyCodeLine{3065 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{3066 \textcolor{keyword}{typedef} stbv\_int16 STBV\_YTYPE;}
\DoxyCodeLine{3067 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3068 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} STBV\_YTYPE;}
\DoxyCodeLine{3069 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3070 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_do\_floor(stbv\_vorb *f, StbvMapping *map, \textcolor{keywordtype}{int} i, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{float} *target, STBV\_YTYPE *finalY, stbv\_uint8 *step2\_flag)}
\DoxyCodeLine{3071 \{}
\DoxyCodeLine{3072    \textcolor{keywordtype}{int} n2 = n >> 1;}
\DoxyCodeLine{3073    \textcolor{keywordtype}{int} s = map-\/>chan[i].mux, floor;}
\DoxyCodeLine{3074    floor = map-\/>submap\_floor[s];}
\DoxyCodeLine{3075    \textcolor{keywordflow}{if} (f-\/>floor\_types[floor] == 0) \{}
\DoxyCodeLine{3076       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{3077    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3078       StbvFloor1 *g = \&f-\/>floor\_config[floor].floor1;}
\DoxyCodeLine{3079       \textcolor{keywordtype}{int} j,q;}
\DoxyCodeLine{3080       \textcolor{keywordtype}{int} lx = 0, ly = finalY[0] * g-\/>floor1\_multiplier;}
\DoxyCodeLine{3081       \textcolor{keywordflow}{for} (q=1; q < g-\/>values; ++q) \{}
\DoxyCodeLine{3082          j = g-\/>sorted\_order[q];}
\DoxyCodeLine{3083 \textcolor{preprocessor}{         \#ifndef STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{3084          \textcolor{keywordflow}{if} (finalY[j] >= 0)}
\DoxyCodeLine{3085 \textcolor{preprocessor}{         \#else}}
\DoxyCodeLine{3086          \textcolor{keywordflow}{if} (step2\_flag[j])}
\DoxyCodeLine{3087 \textcolor{preprocessor}{         \#endif}}
\DoxyCodeLine{3088          \{}
\DoxyCodeLine{3089             \textcolor{keywordtype}{int} hy = finalY[j] * g-\/>floor1\_multiplier;}
\DoxyCodeLine{3090             \textcolor{keywordtype}{int} hx = g-\/>Xlist[j];}
\DoxyCodeLine{3091             \textcolor{keywordflow}{if} (lx != hx)}
\DoxyCodeLine{3092                stbv\_draw\_line(target, lx,ly, hx,hy, n2);}
\DoxyCodeLine{3093             STBV\_CHECK(f);}
\DoxyCodeLine{3094             lx = hx, ly = hy;}
\DoxyCodeLine{3095          \}}
\DoxyCodeLine{3096       \}}
\DoxyCodeLine{3097       \textcolor{keywordflow}{if} (lx < n2) \{}
\DoxyCodeLine{3098          \textcolor{comment}{// optimization of: stbv\_draw\_line(target, lx,ly, n,ly, n2);}}
\DoxyCodeLine{3099          \textcolor{keywordflow}{for} (j=lx; j < n2; ++j)}
\DoxyCodeLine{3100             STBV\_LINE\_OP(target[j], stbv\_inverse\_db\_table[ly]);}
\DoxyCodeLine{3101          STBV\_CHECK(f);}
\DoxyCodeLine{3102       \}}
\DoxyCodeLine{3103    \}}
\DoxyCodeLine{3104    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{3105 \}}
\DoxyCodeLine{3106 }
\DoxyCodeLine{3107 \textcolor{comment}{// The meaning of "{}left"{} and "{}right"{}}}
\DoxyCodeLine{3108 \textcolor{comment}{//}}
\DoxyCodeLine{3109 \textcolor{comment}{// For a given frame:}}
\DoxyCodeLine{3110 \textcolor{comment}{//     we compute samples from 0..n}}
\DoxyCodeLine{3111 \textcolor{comment}{//     window\_center is n/2}}
\DoxyCodeLine{3112 \textcolor{comment}{//     we'll window and mix the samples from left\_start to left\_end with data from the previous frame}}
\DoxyCodeLine{3113 \textcolor{comment}{//     all of the samples from left\_end to right\_start can be output without mixing; however,}}
\DoxyCodeLine{3114 \textcolor{comment}{//        this interval is 0-\/length except when transitioning between short and long frames}}
\DoxyCodeLine{3115 \textcolor{comment}{//     all of the samples from right\_start to right\_end need to be mixed with the next frame,}}
\DoxyCodeLine{3116 \textcolor{comment}{//        which we don't have, so those get saved in a buffer}}
\DoxyCodeLine{3117 \textcolor{comment}{//     frame N's right\_end-\/right\_start, the number of samples to mix with the next frame,}}
\DoxyCodeLine{3118 \textcolor{comment}{//        has to be the same as frame N+1's left\_end-\/left\_start (which they are by}}
\DoxyCodeLine{3119 \textcolor{comment}{//        construction)}}
\DoxyCodeLine{3120 }
\DoxyCodeLine{3121 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_vorbis\_decode\_initial(stbv\_vorb *f, \textcolor{keywordtype}{int} *p\_left\_start, \textcolor{keywordtype}{int} *p\_left\_end, \textcolor{keywordtype}{int} *p\_right\_start, \textcolor{keywordtype}{int} *p\_right\_end, \textcolor{keywordtype}{int} *mode)}
\DoxyCodeLine{3122 \{}
\DoxyCodeLine{3123    StbvMode *m;}
\DoxyCodeLine{3124    \textcolor{keywordtype}{int} i, n, prev, next, window\_center;}
\DoxyCodeLine{3125    f-\/>channel\_buffer\_start = f-\/>channel\_buffer\_end = 0;}
\DoxyCodeLine{3126 }
\DoxyCodeLine{3127   retry:}
\DoxyCodeLine{3128    \textcolor{keywordflow}{if} (f-\/>eof) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3129    \textcolor{keywordflow}{if} (!stbv\_maybe\_start\_packet(f))}
\DoxyCodeLine{3130       \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3131    \textcolor{comment}{// check packet type}}
\DoxyCodeLine{3132    \textcolor{keywordflow}{if} (stbv\_get\_bits(f,1) != 0) \{}
\DoxyCodeLine{3133       \textcolor{keywordflow}{if} (STBV\_IS\_PUSH\_MODE(f))}
\DoxyCodeLine{3134          \textcolor{keywordflow}{return} stbv\_error(f,VORBIS\_bad\_packet\_type);}
\DoxyCodeLine{3135       \textcolor{keywordflow}{while} (STBV\_EOP != stbv\_get8\_packet(f));}
\DoxyCodeLine{3136       \textcolor{keywordflow}{goto} retry;}
\DoxyCodeLine{3137    \}}
\DoxyCodeLine{3138 }
\DoxyCodeLine{3139    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer)}
\DoxyCodeLine{3140       assert(f-\/>alloc.alloc\_buffer\_length\_in\_bytes == f-\/>temp\_offset);}
\DoxyCodeLine{3141 }
\DoxyCodeLine{3142    i = stbv\_get\_bits(f, stbv\_ilog(f-\/>mode\_count-\/1));}
\DoxyCodeLine{3143    \textcolor{keywordflow}{if} (i == STBV\_EOP) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3144    \textcolor{keywordflow}{if} (i >= f-\/>mode\_count) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3145    *mode = i;}
\DoxyCodeLine{3146    m = f-\/>mode\_config + i;}
\DoxyCodeLine{3147    \textcolor{keywordflow}{if} (m-\/>blockflag) \{}
\DoxyCodeLine{3148       n = f-\/>blocksize\_1;}
\DoxyCodeLine{3149       prev = stbv\_get\_bits(f,1);}
\DoxyCodeLine{3150       next = stbv\_get\_bits(f,1);}
\DoxyCodeLine{3151    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3152       prev = next = 0;}
\DoxyCodeLine{3153       n = f-\/>blocksize\_0;}
\DoxyCodeLine{3154    \}}
\DoxyCodeLine{3155 }
\DoxyCodeLine{3156 \textcolor{comment}{// WINDOWING}}
\DoxyCodeLine{3157 }
\DoxyCodeLine{3158    window\_center = n >> 1;}
\DoxyCodeLine{3159    \textcolor{keywordflow}{if} (m-\/>blockflag \&\& !prev) \{}
\DoxyCodeLine{3160       *p\_left\_start = (n -\/ f-\/>blocksize\_0) >> 2;}
\DoxyCodeLine{3161       *p\_left\_end   = (n + f-\/>blocksize\_0) >> 2;}
\DoxyCodeLine{3162    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3163       *p\_left\_start = 0;}
\DoxyCodeLine{3164       *p\_left\_end   = window\_center;}
\DoxyCodeLine{3165    \}}
\DoxyCodeLine{3166    \textcolor{keywordflow}{if} (m-\/>blockflag \&\& !next) \{}
\DoxyCodeLine{3167       *p\_right\_start = (n*3 -\/ f-\/>blocksize\_0) >> 2;}
\DoxyCodeLine{3168       *p\_right\_end   = (n*3 + f-\/>blocksize\_0) >> 2;}
\DoxyCodeLine{3169    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3170       *p\_right\_start = window\_center;}
\DoxyCodeLine{3171       *p\_right\_end   = n;}
\DoxyCodeLine{3172    \}}
\DoxyCodeLine{3173 }
\DoxyCodeLine{3174    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{3175 \}}
\DoxyCodeLine{3176 }
\DoxyCodeLine{3177 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_vorbis\_decode\_packet\_rest(stbv\_vorb *f, \textcolor{keywordtype}{int} *len, StbvMode *m, \textcolor{keywordtype}{int} left\_start, \textcolor{keywordtype}{int} left\_end, \textcolor{keywordtype}{int} right\_start, \textcolor{keywordtype}{int} right\_end, \textcolor{keywordtype}{int} *p\_left)}
\DoxyCodeLine{3178 \{}
\DoxyCodeLine{3179    StbvMapping *map;}
\DoxyCodeLine{3180    \textcolor{keywordtype}{int} i,j,k,n,n2;}
\DoxyCodeLine{3181    \textcolor{keywordtype}{int} zero\_channel[256];}
\DoxyCodeLine{3182    \textcolor{keywordtype}{int} really\_zero\_channel[256];}
\DoxyCodeLine{3183 }
\DoxyCodeLine{3184 \textcolor{comment}{// WINDOWING}}
\DoxyCodeLine{3185 }
\DoxyCodeLine{3186    n = f-\/>blocksize[m-\/>blockflag];}
\DoxyCodeLine{3187    map = \&f-\/>mapping[m-\/>mapping];}
\DoxyCodeLine{3188 }
\DoxyCodeLine{3189 \textcolor{comment}{// FLOORS}}
\DoxyCodeLine{3190    n2 = n >> 1;}
\DoxyCodeLine{3191 }
\DoxyCodeLine{3192    STBV\_CHECK(f);}
\DoxyCodeLine{3193 }
\DoxyCodeLine{3194    \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i) \{}
\DoxyCodeLine{3195       \textcolor{keywordtype}{int} s = map-\/>chan[i].mux, floor;}
\DoxyCodeLine{3196       zero\_channel[i] = FALSE;}
\DoxyCodeLine{3197       floor = map-\/>submap\_floor[s];}
\DoxyCodeLine{3198       \textcolor{keywordflow}{if} (f-\/>floor\_types[floor] == 0) \{}
\DoxyCodeLine{3199          \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{3200       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3201          StbvFloor1 *g = \&f-\/>floor\_config[floor].floor1;}
\DoxyCodeLine{3202          \textcolor{keywordflow}{if} (stbv\_get\_bits(f, 1)) \{}
\DoxyCodeLine{3203             \textcolor{keywordtype}{short} *finalY;}
\DoxyCodeLine{3204             stbv\_uint8 step2\_flag[256];}
\DoxyCodeLine{3205             \textcolor{keyword}{static} \textcolor{keywordtype}{int} range\_list[4] = \{ 256, 128, 86, 64 \};}
\DoxyCodeLine{3206             \textcolor{keywordtype}{int} range = range\_list[g-\/>floor1\_multiplier-\/1];}
\DoxyCodeLine{3207             \textcolor{keywordtype}{int} offset = 2;}
\DoxyCodeLine{3208             finalY = f-\/>finalY[i];}
\DoxyCodeLine{3209             finalY[0] = stbv\_get\_bits(f, stbv\_ilog(range)-\/1);}
\DoxyCodeLine{3210             finalY[1] = stbv\_get\_bits(f, stbv\_ilog(range)-\/1);}
\DoxyCodeLine{3211             \textcolor{keywordflow}{for} (j=0; j < g-\/>partitions; ++j) \{}
\DoxyCodeLine{3212                \textcolor{keywordtype}{int} pclass = g-\/>partition\_class\_list[j];}
\DoxyCodeLine{3213                \textcolor{keywordtype}{int} cdim = g-\/>class\_dimensions[pclass];}
\DoxyCodeLine{3214                \textcolor{keywordtype}{int} cbits = g-\/>class\_subclasses[pclass];}
\DoxyCodeLine{3215                \textcolor{keywordtype}{int} csub = (1 << cbits)-\/1;}
\DoxyCodeLine{3216                \textcolor{keywordtype}{int} cval = 0;}
\DoxyCodeLine{3217                \textcolor{keywordflow}{if} (cbits) \{}
\DoxyCodeLine{3218                   StbvCodebook *c = f-\/>codebooks + g-\/>class\_masterbooks[pclass];}
\DoxyCodeLine{3219                   STBV\_DECODE(cval,f,c);}
\DoxyCodeLine{3220                \}}
\DoxyCodeLine{3221                \textcolor{keywordflow}{for} (k=0; k < cdim; ++k) \{}
\DoxyCodeLine{3222                   \textcolor{keywordtype}{int} book = g-\/>subclass\_books[pclass][cval \& csub];}
\DoxyCodeLine{3223                   cval = cval >> cbits;}
\DoxyCodeLine{3224                   \textcolor{keywordflow}{if} (book >= 0) \{}
\DoxyCodeLine{3225                      \textcolor{keywordtype}{int} temp;}
\DoxyCodeLine{3226                      StbvCodebook *c = f-\/>codebooks + book;}
\DoxyCodeLine{3227                      STBV\_DECODE(temp,f,c);}
\DoxyCodeLine{3228                      finalY[offset++] = temp;}
\DoxyCodeLine{3229                   \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{3230                      finalY[offset++] = 0;}
\DoxyCodeLine{3231                \}}
\DoxyCodeLine{3232             \}}
\DoxyCodeLine{3233             \textcolor{keywordflow}{if} (f-\/>valid\_bits == STBV\_INVALID\_BITS) \textcolor{keywordflow}{goto} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}}; \textcolor{comment}{// behavior according to spec}}
\DoxyCodeLine{3234             step2\_flag[0] = step2\_flag[1] = 1;}
\DoxyCodeLine{3235             \textcolor{keywordflow}{for} (j=2; j < g-\/>values; ++j) \{}
\DoxyCodeLine{3236                \textcolor{keywordtype}{int} low, high, pred, highroom, lowroom, room, val;}
\DoxyCodeLine{3237                low = g-\/>stbv\_neighbors[j][0];}
\DoxyCodeLine{3238                high = g-\/>stbv\_neighbors[j][1];}
\DoxyCodeLine{3239                \textcolor{comment}{//stbv\_neighbors(g-\/>Xlist, j, \&low, \&high);}}
\DoxyCodeLine{3240                pred = stbv\_predict\_point(g-\/>Xlist[j], g-\/>Xlist[low], g-\/>Xlist[high], finalY[low], finalY[high]);}
\DoxyCodeLine{3241                val = finalY[j];}
\DoxyCodeLine{3242                highroom = range -\/ pred;}
\DoxyCodeLine{3243                lowroom = pred;}
\DoxyCodeLine{3244                \textcolor{keywordflow}{if} (highroom < lowroom)}
\DoxyCodeLine{3245                   room = highroom * 2;}
\DoxyCodeLine{3246                \textcolor{keywordflow}{else}}
\DoxyCodeLine{3247                   room = lowroom * 2;}
\DoxyCodeLine{3248                \textcolor{keywordflow}{if} (val) \{}
\DoxyCodeLine{3249                   step2\_flag[low] = step2\_flag[high] = 1;}
\DoxyCodeLine{3250                   step2\_flag[j] = 1;}
\DoxyCodeLine{3251                   \textcolor{keywordflow}{if} (val >= room)}
\DoxyCodeLine{3252                      \textcolor{keywordflow}{if} (highroom > lowroom)}
\DoxyCodeLine{3253                         finalY[j] = val -\/ lowroom + pred;}
\DoxyCodeLine{3254                      \textcolor{keywordflow}{else}}
\DoxyCodeLine{3255                         finalY[j] = pred -\/ val + highroom -\/ 1;}
\DoxyCodeLine{3256                   \textcolor{keywordflow}{else}}
\DoxyCodeLine{3257                      \textcolor{keywordflow}{if} (val \& 1)}
\DoxyCodeLine{3258                         finalY[j] = pred -\/ ((val+1)>>1);}
\DoxyCodeLine{3259                      \textcolor{keywordflow}{else}}
\DoxyCodeLine{3260                         finalY[j] = pred + (val>>1);}
\DoxyCodeLine{3261                \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3262                   step2\_flag[j] = 0;}
\DoxyCodeLine{3263                   finalY[j] = pred;}
\DoxyCodeLine{3264                \}}
\DoxyCodeLine{3265             \}}
\DoxyCodeLine{3266 }
\DoxyCodeLine{3267 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{3268             stbv\_do\_floor(f, map, i, n, f-\/>floor\_buffers[i], finalY, step2\_flag);}
\DoxyCodeLine{3269 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3270             \textcolor{comment}{// defer final floor computation until \_after\_ residue}}
\DoxyCodeLine{3271             \textcolor{keywordflow}{for} (j=0; j < g-\/>values; ++j) \{}
\DoxyCodeLine{3272                \textcolor{keywordflow}{if} (!step2\_flag[j])}
\DoxyCodeLine{3273                   finalY[j] = -\/1;}
\DoxyCodeLine{3274             \}}
\DoxyCodeLine{3275 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3276          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3277            \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}}:}
\DoxyCodeLine{3278             zero\_channel[i] = TRUE;}
\DoxyCodeLine{3279          \}}
\DoxyCodeLine{3280          \textcolor{comment}{// So we just defer everything else to later}}
\DoxyCodeLine{3281 }
\DoxyCodeLine{3282          \textcolor{comment}{// at this point we've decoded the floor into buffer}}
\DoxyCodeLine{3283       \}}
\DoxyCodeLine{3284    \}}
\DoxyCodeLine{3285    STBV\_CHECK(f);}
\DoxyCodeLine{3286    \textcolor{comment}{// at this point we've decoded all floors}}
\DoxyCodeLine{3287 }
\DoxyCodeLine{3288    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer)}
\DoxyCodeLine{3289       assert(f-\/>alloc.alloc\_buffer\_length\_in\_bytes == f-\/>temp\_offset);}
\DoxyCodeLine{3290 }
\DoxyCodeLine{3291    \textcolor{comment}{// re-\/enable coupled channels if necessary}}
\DoxyCodeLine{3292    memcpy(really\_zero\_channel, zero\_channel, \textcolor{keyword}{sizeof}(really\_zero\_channel[0]) * f-\/>channels);}
\DoxyCodeLine{3293    \textcolor{keywordflow}{for} (i=0; i < map-\/>coupling\_steps; ++i)}
\DoxyCodeLine{3294       \textcolor{keywordflow}{if} (!zero\_channel[map-\/>chan[i].magnitude] || !zero\_channel[map-\/>chan[i].angle]) \{}
\DoxyCodeLine{3295          zero\_channel[map-\/>chan[i].magnitude] = zero\_channel[map-\/>chan[i].angle] = FALSE;}
\DoxyCodeLine{3296       \}}
\DoxyCodeLine{3297 }
\DoxyCodeLine{3298    STBV\_CHECK(f);}
\DoxyCodeLine{3299 \textcolor{comment}{// RESIDUE STBV\_DECODE}}
\DoxyCodeLine{3300    \textcolor{keywordflow}{for} (i=0; i < map-\/>submaps; ++i) \{}
\DoxyCodeLine{3301       \textcolor{keywordtype}{float} *residue\_buffers[STB\_VORBIS\_MAX\_CHANNELS];}
\DoxyCodeLine{3302       \textcolor{keywordtype}{int} r;}
\DoxyCodeLine{3303       stbv\_uint8 do\_not\_decode[256];}
\DoxyCodeLine{3304       \textcolor{keywordtype}{int} ch = 0;}
\DoxyCodeLine{3305       \textcolor{keywordflow}{for} (j=0; j < f-\/>channels; ++j) \{}
\DoxyCodeLine{3306          \textcolor{keywordflow}{if} (map-\/>chan[j].mux == i) \{}
\DoxyCodeLine{3307             \textcolor{keywordflow}{if} (zero\_channel[j]) \{}
\DoxyCodeLine{3308                do\_not\_decode[ch] = TRUE;}
\DoxyCodeLine{3309                residue\_buffers[ch] = NULL;}
\DoxyCodeLine{3310             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3311                do\_not\_decode[ch] = FALSE;}
\DoxyCodeLine{3312                residue\_buffers[ch] = f-\/>channel\_buffers[j];}
\DoxyCodeLine{3313             \}}
\DoxyCodeLine{3314             ++ch;}
\DoxyCodeLine{3315          \}}
\DoxyCodeLine{3316       \}}
\DoxyCodeLine{3317       r = map-\/>submap\_residue[i];}
\DoxyCodeLine{3318       stbv\_decode\_residue(f, residue\_buffers, ch, n2, r, do\_not\_decode);}
\DoxyCodeLine{3319    \}}
\DoxyCodeLine{3320 }
\DoxyCodeLine{3321    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer)}
\DoxyCodeLine{3322       assert(f-\/>alloc.alloc\_buffer\_length\_in\_bytes == f-\/>temp\_offset);}
\DoxyCodeLine{3323    STBV\_CHECK(f);}
\DoxyCodeLine{3324 }
\DoxyCodeLine{3325 \textcolor{comment}{// INVERSE COUPLING}}
\DoxyCodeLine{3326    \textcolor{keywordflow}{for} (i = map-\/>coupling\_steps-\/1; i >= 0; -\/-\/i) \{}
\DoxyCodeLine{3327       \textcolor{keywordtype}{int} n2 = n >> 1;}
\DoxyCodeLine{3328       \textcolor{keywordtype}{float} *m = f-\/>channel\_buffers[map-\/>chan[i].magnitude];}
\DoxyCodeLine{3329       \textcolor{keywordtype}{float} *a = f-\/>channel\_buffers[map-\/>chan[i].angle    ];}
\DoxyCodeLine{3330       \textcolor{keywordflow}{for} (j=0; j < n2; ++j) \{}
\DoxyCodeLine{3331          \textcolor{keywordtype}{float} a2,m2;}
\DoxyCodeLine{3332          \textcolor{keywordflow}{if} (m[j] > 0)}
\DoxyCodeLine{3333             \textcolor{keywordflow}{if} (a[j] > 0)}
\DoxyCodeLine{3334                m2 = m[j], a2 = m[j] -\/ a[j];}
\DoxyCodeLine{3335             \textcolor{keywordflow}{else}}
\DoxyCodeLine{3336                a2 = m[j], m2 = m[j] + a[j];}
\DoxyCodeLine{3337          \textcolor{keywordflow}{else}}
\DoxyCodeLine{3338             \textcolor{keywordflow}{if} (a[j] > 0)}
\DoxyCodeLine{3339                m2 = m[j], a2 = m[j] + a[j];}
\DoxyCodeLine{3340             \textcolor{keywordflow}{else}}
\DoxyCodeLine{3341                a2 = m[j], m2 = m[j] -\/ a[j];}
\DoxyCodeLine{3342          m[j] = m2;}
\DoxyCodeLine{3343          a[j] = a2;}
\DoxyCodeLine{3344       \}}
\DoxyCodeLine{3345    \}}
\DoxyCodeLine{3346    STBV\_CHECK(f);}
\DoxyCodeLine{3347 }
\DoxyCodeLine{3348    \textcolor{comment}{// finish decoding the floors}}
\DoxyCodeLine{3349 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{3350    \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i) \{}
\DoxyCodeLine{3351       \textcolor{keywordflow}{if} (really\_zero\_channel[i]) \{}
\DoxyCodeLine{3352          memset(f-\/>channel\_buffers[i], 0, \textcolor{keyword}{sizeof}(*f-\/>channel\_buffers[i]) * n2);}
\DoxyCodeLine{3353       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3354          stbv\_do\_floor(f, map, i, n, f-\/>channel\_buffers[i], f-\/>finalY[i], NULL);}
\DoxyCodeLine{3355       \}}
\DoxyCodeLine{3356    \}}
\DoxyCodeLine{3357 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3358    \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i) \{}
\DoxyCodeLine{3359       \textcolor{keywordflow}{if} (really\_zero\_channel[i]) \{}
\DoxyCodeLine{3360          memset(f-\/>channel\_buffers[i], 0, \textcolor{keyword}{sizeof}(*f-\/>channel\_buffers[i]) * n2);}
\DoxyCodeLine{3361       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3362          \textcolor{keywordflow}{for} (j=0; j < n2; ++j)}
\DoxyCodeLine{3363             f-\/>channel\_buffers[i][j] *= f-\/>floor\_buffers[i][j];}
\DoxyCodeLine{3364       \}}
\DoxyCodeLine{3365    \}}
\DoxyCodeLine{3366 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3367 }
\DoxyCodeLine{3368 \textcolor{comment}{// INVERSE MDCT}}
\DoxyCodeLine{3369    STBV\_CHECK(f);}
\DoxyCodeLine{3370    \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i)}
\DoxyCodeLine{3371       stbv\_inverse\_mdct(f-\/>channel\_buffers[i], n, f, m-\/>blockflag);}
\DoxyCodeLine{3372    STBV\_CHECK(f);}
\DoxyCodeLine{3373 }
\DoxyCodeLine{3374    \textcolor{comment}{// this shouldn't be necessary, unless we exited on an error}}
\DoxyCodeLine{3375    \textcolor{comment}{// and want to flush to get to the next packet}}
\DoxyCodeLine{3376    stbv\_flush\_packet(f);}
\DoxyCodeLine{3377 }
\DoxyCodeLine{3378    \textcolor{keywordflow}{if} (f-\/>first\_decode) \{}
\DoxyCodeLine{3379       \textcolor{comment}{// assume we start so first non-\/discarded sample is sample 0}}
\DoxyCodeLine{3380       \textcolor{comment}{// this isn't to spec, but spec would require us to read ahead}}
\DoxyCodeLine{3381       \textcolor{comment}{// and decode the size of all current frames-\/-\/could be done,}}
\DoxyCodeLine{3382       \textcolor{comment}{// but presumably it's not a commonly used feature}}
\DoxyCodeLine{3383       f-\/>current\_loc = -\/n2; \textcolor{comment}{// start of first frame is positioned for discard}}
\DoxyCodeLine{3384       \textcolor{comment}{// we might have to discard samples "{}from"{} the next frame too,}}
\DoxyCodeLine{3385       \textcolor{comment}{// if we're lapping a large block then a small at the start?}}
\DoxyCodeLine{3386       f-\/>discard\_samples\_deferred = n -\/ right\_end;}
\DoxyCodeLine{3387       f-\/>current\_loc\_valid = TRUE;}
\DoxyCodeLine{3388       f-\/>first\_decode = FALSE;}
\DoxyCodeLine{3389    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (f-\/>discard\_samples\_deferred) \{}
\DoxyCodeLine{3390       \textcolor{keywordflow}{if} (f-\/>discard\_samples\_deferred >= right\_start -\/ left\_start) \{}
\DoxyCodeLine{3391          f-\/>discard\_samples\_deferred -\/= (right\_start -\/ left\_start);}
\DoxyCodeLine{3392          left\_start = right\_start;}
\DoxyCodeLine{3393          *p\_left = left\_start;}
\DoxyCodeLine{3394       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3395          left\_start += f-\/>discard\_samples\_deferred;}
\DoxyCodeLine{3396          *p\_left = left\_start;}
\DoxyCodeLine{3397          f-\/>discard\_samples\_deferred = 0;}
\DoxyCodeLine{3398       \}}
\DoxyCodeLine{3399    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (f-\/>previous\_length == 0 \&\& f-\/>current\_loc\_valid) \{}
\DoxyCodeLine{3400       \textcolor{comment}{// we're recovering from a seek... that means we're going to discard}}
\DoxyCodeLine{3401       \textcolor{comment}{// the samples from this packet even though we know our position from}}
\DoxyCodeLine{3402       \textcolor{comment}{// the last page header, so we need to update the position based on}}
\DoxyCodeLine{3403       \textcolor{comment}{// the discarded samples here}}
\DoxyCodeLine{3404       \textcolor{comment}{// but wait, the code below is going to add this in itself even}}
\DoxyCodeLine{3405       \textcolor{comment}{// on a discard, so we don't need to do it here...}}
\DoxyCodeLine{3406    \}}
\DoxyCodeLine{3407 }
\DoxyCodeLine{3408    \textcolor{comment}{// check if we have ogg information about the sample \# for this packet}}
\DoxyCodeLine{3409    \textcolor{keywordflow}{if} (f-\/>last\_seg\_which == f-\/>end\_seg\_with\_known\_loc) \{}
\DoxyCodeLine{3410       \textcolor{comment}{// if we have a valid current loc, and this is final:}}
\DoxyCodeLine{3411       \textcolor{keywordflow}{if} (f-\/>current\_loc\_valid \&\& (f-\/>page\_flag \& STBV\_PAGEFLAG\_last\_page)) \{}
\DoxyCodeLine{3412          stbv\_uint32 current\_end = f-\/>known\_loc\_for\_packet;}
\DoxyCodeLine{3413          \textcolor{comment}{// then let's infer the size of the (probably) short final frame}}
\DoxyCodeLine{3414          \textcolor{keywordflow}{if} (current\_end < f-\/>current\_loc + (right\_end-\/left\_start)) \{}
\DoxyCodeLine{3415             \textcolor{keywordflow}{if} (current\_end < f-\/>current\_loc) \{}
\DoxyCodeLine{3416                \textcolor{comment}{// negative truncation, that's impossible!}}
\DoxyCodeLine{3417                *len = 0;}
\DoxyCodeLine{3418             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3419                *len = current\_end -\/ f-\/>current\_loc;}
\DoxyCodeLine{3420             \}}
\DoxyCodeLine{3421             *len += left\_start; \textcolor{comment}{// this doesn't seem right, but has no ill effect on my test files}}
\DoxyCodeLine{3422             \textcolor{keywordflow}{if} (*len > right\_end) *len = right\_end; \textcolor{comment}{// this should never happen}}
\DoxyCodeLine{3423             f-\/>current\_loc += *len;}
\DoxyCodeLine{3424             \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{3425          \}}
\DoxyCodeLine{3426       \}}
\DoxyCodeLine{3427       \textcolor{comment}{// otherwise, just set our sample loc}}
\DoxyCodeLine{3428       \textcolor{comment}{// guess that the ogg granule pos refers to the \_middle\_ of the}}
\DoxyCodeLine{3429       \textcolor{comment}{// last frame?}}
\DoxyCodeLine{3430       \textcolor{comment}{// set f-\/>current\_loc to the position of left\_start}}
\DoxyCodeLine{3431       f-\/>current\_loc = f-\/>known\_loc\_for\_packet -\/ (n2-\/left\_start);}
\DoxyCodeLine{3432       f-\/>current\_loc\_valid = TRUE;}
\DoxyCodeLine{3433    \}}
\DoxyCodeLine{3434    \textcolor{keywordflow}{if} (f-\/>current\_loc\_valid)}
\DoxyCodeLine{3435       f-\/>current\_loc += (right\_start -\/ left\_start);}
\DoxyCodeLine{3436 }
\DoxyCodeLine{3437    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer)}
\DoxyCodeLine{3438       assert(f-\/>alloc.alloc\_buffer\_length\_in\_bytes == f-\/>temp\_offset);}
\DoxyCodeLine{3439    *len = right\_end;  \textcolor{comment}{// ignore samples after the window goes to 0}}
\DoxyCodeLine{3440    STBV\_CHECK(f);}
\DoxyCodeLine{3441 }
\DoxyCodeLine{3442    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{3443 \}}
\DoxyCodeLine{3444 }
\DoxyCodeLine{3445 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_vorbis\_decode\_packet(stbv\_vorb *f, \textcolor{keywordtype}{int} *len, \textcolor{keywordtype}{int} *p\_left, \textcolor{keywordtype}{int} *p\_right)}
\DoxyCodeLine{3446 \{}
\DoxyCodeLine{3447    \textcolor{keywordtype}{int} mode, left\_end, right\_end;}
\DoxyCodeLine{3448    \textcolor{keywordflow}{if} (!stbv\_vorbis\_decode\_initial(f, p\_left, \&left\_end, p\_right, \&right\_end, \&mode)) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3449    \textcolor{keywordflow}{return} stbv\_vorbis\_decode\_packet\_rest(f, len, f-\/>mode\_config + mode, *p\_left, left\_end, *p\_right, right\_end, p\_left);}
\DoxyCodeLine{3450 \}}
\DoxyCodeLine{3451 }
\DoxyCodeLine{3452 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_vorbis\_finish\_frame(stb\_vorbis *f, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} left, \textcolor{keywordtype}{int} right)}
\DoxyCodeLine{3453 \{}
\DoxyCodeLine{3454    \textcolor{keywordtype}{int} prev,i,j;}
\DoxyCodeLine{3455    \textcolor{comment}{// we use right\&left (the start of the right-\/ and left-\/window sin()-\/regions)}}
\DoxyCodeLine{3456    \textcolor{comment}{// to determine how much to return, rather than inferring from the rules}}
\DoxyCodeLine{3457    \textcolor{comment}{// (same result, clearer code); 'left' indicates where our sin() window}}
\DoxyCodeLine{3458    \textcolor{comment}{// starts, therefore where the previous window's right edge starts, and}}
\DoxyCodeLine{3459    \textcolor{comment}{// therefore where to start mixing from the previous buffer. 'right'}}
\DoxyCodeLine{3460    \textcolor{comment}{// indicates where our sin() ending-\/window starts, therefore that's where}}
\DoxyCodeLine{3461    \textcolor{comment}{// we start saving, and where our returned-\/data ends.}}
\DoxyCodeLine{3462 }
\DoxyCodeLine{3463    \textcolor{comment}{// mixin from previous window}}
\DoxyCodeLine{3464    \textcolor{keywordflow}{if} (f-\/>previous\_length) \{}
\DoxyCodeLine{3465       \textcolor{keywordtype}{int} i,j, n = f-\/>previous\_length;}
\DoxyCodeLine{3466       \textcolor{keywordtype}{float} *w = stbv\_get\_window(f, n);}
\DoxyCodeLine{3467       \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i) \{}
\DoxyCodeLine{3468          \textcolor{keywordflow}{for} (j=0; j < n; ++j)}
\DoxyCodeLine{3469             f-\/>channel\_buffers[i][left+j] =}
\DoxyCodeLine{3470                f-\/>channel\_buffers[i][left+j]*w[    j] +}
\DoxyCodeLine{3471                f-\/>previous\_window[i][     j]*w[n-\/1-\/j];}
\DoxyCodeLine{3472       \}}
\DoxyCodeLine{3473    \}}
\DoxyCodeLine{3474 }
\DoxyCodeLine{3475    prev = f-\/>previous\_length;}
\DoxyCodeLine{3476 }
\DoxyCodeLine{3477    \textcolor{comment}{// last half of this data becomes previous window}}
\DoxyCodeLine{3478    f-\/>previous\_length = len -\/ right;}
\DoxyCodeLine{3479 }
\DoxyCodeLine{3480    \textcolor{comment}{// @OPTIMIZE: could avoid this copy by double-\/buffering the}}
\DoxyCodeLine{3481    \textcolor{comment}{// output (flipping previous\_window with channel\_buffers), but}}
\DoxyCodeLine{3482    \textcolor{comment}{// then previous\_window would have to be 2x as large, and}}
\DoxyCodeLine{3483    \textcolor{comment}{// channel\_buffers couldn't be temp mem (although they're NOT}}
\DoxyCodeLine{3484    \textcolor{comment}{// currently temp mem, they could be (unless we want to level}}
\DoxyCodeLine{3485    \textcolor{comment}{// performance by spreading out the computation))}}
\DoxyCodeLine{3486    \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i)}
\DoxyCodeLine{3487       \textcolor{keywordflow}{for} (j=0; right+j < len; ++j)}
\DoxyCodeLine{3488          f-\/>previous\_window[i][j] = f-\/>channel\_buffers[i][right+j];}
\DoxyCodeLine{3489 }
\DoxyCodeLine{3490    if (!prev)}
\DoxyCodeLine{3491       \textcolor{comment}{// there was no previous packet, so this data isn't valid...}}
\DoxyCodeLine{3492       \textcolor{comment}{// this isn't entirely true, only the would-\/have-\/overlapped data}}
\DoxyCodeLine{3493       \textcolor{comment}{// isn't valid, but this seems to be what the spec requires}}
\DoxyCodeLine{3494       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3495 }
\DoxyCodeLine{3496    \textcolor{comment}{// truncate a short frame}}
\DoxyCodeLine{3497    \textcolor{keywordflow}{if} (len < right) right = len;}
\DoxyCodeLine{3498 }
\DoxyCodeLine{3499    f-\/>samples\_output += right-\/left;}
\DoxyCodeLine{3500 }
\DoxyCodeLine{3501    \textcolor{keywordflow}{return} right -\/ left;}
\DoxyCodeLine{3502 \}}
\DoxyCodeLine{3503 }
\DoxyCodeLine{3504 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_vorbis\_pump\_first\_frame(stb\_vorbis *f)}
\DoxyCodeLine{3505 \{}
\DoxyCodeLine{3506    \textcolor{keywordtype}{int} len, right, left, res;}
\DoxyCodeLine{3507    res = stbv\_vorbis\_decode\_packet(f, \&len, \&left, \&right);}
\DoxyCodeLine{3508    \textcolor{keywordflow}{if} (res)}
\DoxyCodeLine{3509       stbv\_vorbis\_finish\_frame(f, len, left, right);}
\DoxyCodeLine{3510    \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{3511 \}}
\DoxyCodeLine{3512 }
\DoxyCodeLine{3513 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{3514 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_is\_whole\_packet\_present(stb\_vorbis *f, \textcolor{keywordtype}{int} end\_page)}
\DoxyCodeLine{3515 \{}
\DoxyCodeLine{3516    \textcolor{comment}{// make sure that we have the packet available before continuing...}}
\DoxyCodeLine{3517    \textcolor{comment}{// this requires a full ogg parse, but we know we can fetch from f-\/>stream}}
\DoxyCodeLine{3518 }
\DoxyCodeLine{3519    \textcolor{comment}{// instead of coding this out explicitly, we could save the current read state,}}
\DoxyCodeLine{3520    \textcolor{comment}{// read the next packet with stbv\_get8() until end-\/of-\/packet, check f-\/>eof, then}}
\DoxyCodeLine{3521    \textcolor{comment}{// reset the state? but that would be slower, esp. since we'd have over 256 bytes}}
\DoxyCodeLine{3522    \textcolor{comment}{// of state to restore (primarily the page segment table)}}
\DoxyCodeLine{3523 }
\DoxyCodeLine{3524    \textcolor{keywordtype}{int} s = f-\/>next\_seg, first = TRUE;}
\DoxyCodeLine{3525    stbv\_uint8 *p = f-\/>stream;}
\DoxyCodeLine{3526 }
\DoxyCodeLine{3527    \textcolor{keywordflow}{if} (s != -\/1) \{ \textcolor{comment}{// if we're not starting the packet with a 'continue on next page' flag}}
\DoxyCodeLine{3528       \textcolor{keywordflow}{for} (; s < f-\/>segment\_count; ++s) \{}
\DoxyCodeLine{3529          p += f-\/>segments[s];}
\DoxyCodeLine{3530          \textcolor{keywordflow}{if} (f-\/>segments[s] < 255)               \textcolor{comment}{// stop at first short segment}}
\DoxyCodeLine{3531             \textcolor{keywordflow}{break};}
\DoxyCodeLine{3532       \}}
\DoxyCodeLine{3533       \textcolor{comment}{// either this continues, or it ends it...}}
\DoxyCodeLine{3534       \textcolor{keywordflow}{if} (end\_page)}
\DoxyCodeLine{3535          \textcolor{keywordflow}{if} (s < f-\/>segment\_count-\/1)             \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{3536       \textcolor{keywordflow}{if} (s == f-\/>segment\_count)}
\DoxyCodeLine{3537          s = -\/1; \textcolor{comment}{// set 'crosses page' flag}}
\DoxyCodeLine{3538       \textcolor{keywordflow}{if} (p > f-\/>stream\_end)                     \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_need\_more\_data);}
\DoxyCodeLine{3539       first = FALSE;}
\DoxyCodeLine{3540    \}}
\DoxyCodeLine{3541    \textcolor{keywordflow}{for} (; s == -\/1;) \{}
\DoxyCodeLine{3542       stbv\_uint8 *q; }
\DoxyCodeLine{3543       \textcolor{keywordtype}{int} n;}
\DoxyCodeLine{3544 }
\DoxyCodeLine{3545       \textcolor{comment}{// check that we have the page header ready}}
\DoxyCodeLine{3546       \textcolor{keywordflow}{if} (p + 26 >= f-\/>stream\_end)               \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_need\_more\_data);}
\DoxyCodeLine{3547       \textcolor{comment}{// validate the page}}
\DoxyCodeLine{3548       \textcolor{keywordflow}{if} (memcmp(p, stbv\_ogg\_page\_header, 4))         \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{3549       \textcolor{keywordflow}{if} (p[4] != 0)                             \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{3550       \textcolor{keywordflow}{if} (first) \{ \textcolor{comment}{// the first segment must NOT have 'continued\_packet', later ones MUST}}
\DoxyCodeLine{3551          \textcolor{keywordflow}{if} (f-\/>previous\_length)}
\DoxyCodeLine{3552             \textcolor{keywordflow}{if} ((p[5] \& STBV\_PAGEFLAG\_continued\_packet))  \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{3553          \textcolor{comment}{// if no previous length, we're resynching, so we can come in on a continued-\/packet,}}
\DoxyCodeLine{3554          \textcolor{comment}{// which we'll just drop}}
\DoxyCodeLine{3555       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3556          \textcolor{keywordflow}{if} (!(p[5] \& STBV\_PAGEFLAG\_continued\_packet)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{3557       \}}
\DoxyCodeLine{3558       n = p[26]; \textcolor{comment}{// segment counts}}
\DoxyCodeLine{3559       q = p+27;  \textcolor{comment}{// q points to segment table}}
\DoxyCodeLine{3560       p = q + n; \textcolor{comment}{// advance past header}}
\DoxyCodeLine{3561       \textcolor{comment}{// make sure we've read the segment table}}
\DoxyCodeLine{3562       \textcolor{keywordflow}{if} (p > f-\/>stream\_end)                     \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_need\_more\_data);}
\DoxyCodeLine{3563       \textcolor{keywordflow}{for} (s=0; s < n; ++s) \{}
\DoxyCodeLine{3564          p += q[s];}
\DoxyCodeLine{3565          \textcolor{keywordflow}{if} (q[s] < 255)}
\DoxyCodeLine{3566             \textcolor{keywordflow}{break};}
\DoxyCodeLine{3567       \}}
\DoxyCodeLine{3568       \textcolor{keywordflow}{if} (end\_page)}
\DoxyCodeLine{3569          \textcolor{keywordflow}{if} (s < n-\/1)                            \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_stream);}
\DoxyCodeLine{3570       \textcolor{keywordflow}{if} (s == n)}
\DoxyCodeLine{3571          s = -\/1; \textcolor{comment}{// set 'crosses page' flag}}
\DoxyCodeLine{3572       \textcolor{keywordflow}{if} (p > f-\/>stream\_end)                     \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_need\_more\_data);}
\DoxyCodeLine{3573       first = FALSE;}
\DoxyCodeLine{3574    \}}
\DoxyCodeLine{3575    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{3576 \}}
\DoxyCodeLine{3577 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{3578 }
\DoxyCodeLine{3579 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_start\_decoder(stbv\_vorb *f)}
\DoxyCodeLine{3580 \{}
\DoxyCodeLine{3581    stbv\_uint8 header[6], x,y;}
\DoxyCodeLine{3582    \textcolor{keywordtype}{int} len,i,j,k, max\_submaps = 0;}
\DoxyCodeLine{3583    \textcolor{keywordtype}{int} longest\_floorlist=0;}
\DoxyCodeLine{3584 }
\DoxyCodeLine{3585    \textcolor{comment}{// first page, first packet}}
\DoxyCodeLine{3586 }
\DoxyCodeLine{3587    \textcolor{keywordflow}{if} (!stbv\_start\_page(f))                              \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3588    \textcolor{comment}{// validate page flag}}
\DoxyCodeLine{3589    \textcolor{keywordflow}{if} (!(f-\/>page\_flag \& STBV\_PAGEFLAG\_first\_page))       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3590    \textcolor{keywordflow}{if} (f-\/>page\_flag \& STBV\_PAGEFLAG\_last\_page)           \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3591    \textcolor{keywordflow}{if} (f-\/>page\_flag \& STBV\_PAGEFLAG\_continued\_packet)    \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3592    \textcolor{comment}{// check for expected packet length}}
\DoxyCodeLine{3593    \textcolor{keywordflow}{if} (f-\/>segment\_count != 1)                       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3594    \textcolor{keywordflow}{if} (f-\/>segments[0] != 30)                        \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3595    \textcolor{comment}{// read packet}}
\DoxyCodeLine{3596    \textcolor{comment}{// check packet header}}
\DoxyCodeLine{3597    \textcolor{keywordflow}{if} (stbv\_get8(f) != STBV\_VORBIS\_packet\_id)                 \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3598    \textcolor{keywordflow}{if} (!stbv\_getn(f, header, 6))                         \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_unexpected\_eof);}
\DoxyCodeLine{3599    \textcolor{keywordflow}{if} (!stbv\_vorbis\_validate(header))                    \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3600    \textcolor{comment}{// vorbis\_version}}
\DoxyCodeLine{3601    \textcolor{keywordflow}{if} (stbv\_get32(f) != 0)                               \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3602    f-\/>channels = stbv\_get8(f); \textcolor{keywordflow}{if} (!f-\/>channels)         \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3603    \textcolor{keywordflow}{if} (f-\/>channels > STB\_VORBIS\_MAX\_CHANNELS)       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_too\_many\_channels);}
\DoxyCodeLine{3604    f-\/>sample\_rate = stbv\_get32(f); \textcolor{keywordflow}{if} (!f-\/>sample\_rate)  \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3605    stbv\_get32(f); \textcolor{comment}{// bitrate\_maximum}}
\DoxyCodeLine{3606    stbv\_get32(f); \textcolor{comment}{// bitrate\_nominal}}
\DoxyCodeLine{3607    stbv\_get32(f); \textcolor{comment}{// bitrate\_minimum}}
\DoxyCodeLine{3608    x = stbv\_get8(f);}
\DoxyCodeLine{3609    \{}
\DoxyCodeLine{3610       \textcolor{keywordtype}{int} log0,log1;}
\DoxyCodeLine{3611       log0 = x \& 15;}
\DoxyCodeLine{3612       log1 = x >> 4;}
\DoxyCodeLine{3613       f-\/>blocksize\_0 = 1 << log0;}
\DoxyCodeLine{3614       f-\/>blocksize\_1 = 1 << log1;}
\DoxyCodeLine{3615       \textcolor{keywordflow}{if} (log0 < 6 || log0 > 13)                       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3616       \textcolor{keywordflow}{if} (log1 < 6 || log1 > 13)                       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3617       \textcolor{keywordflow}{if} (log0 > log1)                                 \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3618    \}}
\DoxyCodeLine{3619 }
\DoxyCodeLine{3620    \textcolor{comment}{// framing\_flag}}
\DoxyCodeLine{3621    x = stbv\_get8(f);}
\DoxyCodeLine{3622    \textcolor{keywordflow}{if} (!(x \& 1))                                    \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_first\_page);}
\DoxyCodeLine{3623 }
\DoxyCodeLine{3624    \textcolor{comment}{// second packet!}}
\DoxyCodeLine{3625    \textcolor{keywordflow}{if} (!stbv\_start\_page(f))                              \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3626 }
\DoxyCodeLine{3627    \textcolor{keywordflow}{if} (!stbv\_start\_packet(f))                            \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3628    \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{3629       len = stbv\_next\_segment(f);}
\DoxyCodeLine{3630       stbv\_skip(f, len);}
\DoxyCodeLine{3631       f-\/>bytes\_in\_seg = 0;}
\DoxyCodeLine{3632    \} \textcolor{keywordflow}{while} (len);}
\DoxyCodeLine{3633 }
\DoxyCodeLine{3634    \textcolor{comment}{// third packet!}}
\DoxyCodeLine{3635    \textcolor{keywordflow}{if} (!stbv\_start\_packet(f))                            \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3636 }
\DoxyCodeLine{3637 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{3638    \textcolor{keywordflow}{if} (STBV\_IS\_PUSH\_MODE(f)) \{}
\DoxyCodeLine{3639       \textcolor{keywordflow}{if} (!stbv\_is\_whole\_packet\_present(f, TRUE)) \{}
\DoxyCodeLine{3640          \textcolor{comment}{// convert error in ogg header to write type}}
\DoxyCodeLine{3641          \textcolor{keywordflow}{if} (f-\/>error == VORBIS\_invalid\_stream)}
\DoxyCodeLine{3642             f-\/>error = VORBIS\_invalid\_setup;}
\DoxyCodeLine{3643          \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{3644       \}}
\DoxyCodeLine{3645    \}}
\DoxyCodeLine{3646 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{3647 }
\DoxyCodeLine{3648    stbv\_crc32\_init(); \textcolor{comment}{// always init it, to avoid multithread race conditions}}
\DoxyCodeLine{3649 }
\DoxyCodeLine{3650    \textcolor{keywordflow}{if} (stbv\_get8\_packet(f) != STBV\_VORBIS\_packet\_setup)       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3651    \textcolor{keywordflow}{for} (i=0; i < 6; ++i) header[i] = stbv\_get8\_packet(f);}
\DoxyCodeLine{3652    \textcolor{keywordflow}{if} (!stbv\_vorbis\_validate(header))                    \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3653 }
\DoxyCodeLine{3654    \textcolor{comment}{// codebooks}}
\DoxyCodeLine{3655 }
\DoxyCodeLine{3656    f-\/>codebook\_count = stbv\_get\_bits(f,8) + 1;}
\DoxyCodeLine{3657    f-\/>codebooks = (StbvCodebook *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(*f-\/>codebooks) * f-\/>codebook\_count);}
\DoxyCodeLine{3658    \textcolor{keywordflow}{if} (f-\/>codebooks == NULL)                        \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3659    memset(f-\/>codebooks, 0, \textcolor{keyword}{sizeof}(*f-\/>codebooks) * f-\/>codebook\_count);}
\DoxyCodeLine{3660    \textcolor{keywordflow}{for} (i=0; i < f-\/>codebook\_count; ++i) \{}
\DoxyCodeLine{3661       stbv\_uint32 *values;}
\DoxyCodeLine{3662       \textcolor{keywordtype}{int} ordered, sorted\_count;}
\DoxyCodeLine{3663       \textcolor{keywordtype}{int} total=0;}
\DoxyCodeLine{3664       stbv\_uint8 *lengths;}
\DoxyCodeLine{3665       StbvCodebook *c = f-\/>codebooks+i;}
\DoxyCodeLine{3666       STBV\_CHECK(f);}
\DoxyCodeLine{3667       x = stbv\_get\_bits(f, 8); \textcolor{keywordflow}{if} (x != 0x42)            \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3668       x = stbv\_get\_bits(f, 8); \textcolor{keywordflow}{if} (x != 0x43)            \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3669       x = stbv\_get\_bits(f, 8); \textcolor{keywordflow}{if} (x != 0x56)            \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3670       x = stbv\_get\_bits(f, 8);}
\DoxyCodeLine{3671       c-\/>dimensions = (stbv\_get\_bits(f, 8)<<8) + x;}
\DoxyCodeLine{3672       x = stbv\_get\_bits(f, 8);}
\DoxyCodeLine{3673       y = stbv\_get\_bits(f, 8);}
\DoxyCodeLine{3674       c-\/>entries = (stbv\_get\_bits(f, 8)<<16) + (y<<8) + x;}
\DoxyCodeLine{3675       ordered = stbv\_get\_bits(f,1);}
\DoxyCodeLine{3676       c-\/>sparse = ordered ? 0 : stbv\_get\_bits(f,1);}
\DoxyCodeLine{3677 }
\DoxyCodeLine{3678       \textcolor{keywordflow}{if} (c-\/>dimensions == 0 \&\& c-\/>entries != 0)    \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3679 }
\DoxyCodeLine{3680       \textcolor{keywordflow}{if} (c-\/>sparse)}
\DoxyCodeLine{3681          lengths = (stbv\_uint8 *) stbv\_setup\_temp\_malloc(f, c-\/>entries);}
\DoxyCodeLine{3682       \textcolor{keywordflow}{else}}
\DoxyCodeLine{3683          lengths = c-\/>codeword\_lengths = (stbv\_uint8 *) stbv\_setup\_malloc(f, c-\/>entries);}
\DoxyCodeLine{3684 }
\DoxyCodeLine{3685       \textcolor{keywordflow}{if} (!lengths) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3686 }
\DoxyCodeLine{3687       \textcolor{keywordflow}{if} (ordered) \{}
\DoxyCodeLine{3688          \textcolor{keywordtype}{int} current\_entry = 0;}
\DoxyCodeLine{3689          \textcolor{keywordtype}{int} current\_length = stbv\_get\_bits(f,5) + 1;}
\DoxyCodeLine{3690          \textcolor{keywordflow}{while} (current\_entry < c-\/>entries) \{}
\DoxyCodeLine{3691             \textcolor{keywordtype}{int} limit = c-\/>entries -\/ current\_entry;}
\DoxyCodeLine{3692             \textcolor{keywordtype}{int} n = stbv\_get\_bits(f, stbv\_ilog(limit));}
\DoxyCodeLine{3693             \textcolor{keywordflow}{if} (current\_entry + n > (\textcolor{keywordtype}{int}) c-\/>entries) \{ \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup); \}}
\DoxyCodeLine{3694             memset(lengths + current\_entry, current\_length, n);}
\DoxyCodeLine{3695             current\_entry += n;}
\DoxyCodeLine{3696             ++current\_length;}
\DoxyCodeLine{3697          \}}
\DoxyCodeLine{3698       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3699          \textcolor{keywordflow}{for} (j=0; j < c-\/>entries; ++j) \{}
\DoxyCodeLine{3700             \textcolor{keywordtype}{int} present = c-\/>sparse ? stbv\_get\_bits(f,1) : 1;}
\DoxyCodeLine{3701             \textcolor{keywordflow}{if} (present) \{}
\DoxyCodeLine{3702                lengths[j] = stbv\_get\_bits(f, 5) + 1;}
\DoxyCodeLine{3703                ++total;}
\DoxyCodeLine{3704                \textcolor{keywordflow}{if} (lengths[j] == 32)}
\DoxyCodeLine{3705                   \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3706             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3707                lengths[j] = NO\_CODE;}
\DoxyCodeLine{3708             \}}
\DoxyCodeLine{3709          \}}
\DoxyCodeLine{3710       \}}
\DoxyCodeLine{3711 }
\DoxyCodeLine{3712       \textcolor{keywordflow}{if} (c-\/>sparse \&\& total >= c-\/>entries >> 2) \{}
\DoxyCodeLine{3713          \textcolor{comment}{// convert sparse items to non-\/sparse!}}
\DoxyCodeLine{3714          \textcolor{keywordflow}{if} (c-\/>entries > (\textcolor{keywordtype}{int}) f-\/>setup\_temp\_memory\_required)}
\DoxyCodeLine{3715             f-\/>setup\_temp\_memory\_required = c-\/>entries;}
\DoxyCodeLine{3716 }
\DoxyCodeLine{3717          c-\/>codeword\_lengths = (stbv\_uint8 *) stbv\_setup\_malloc(f, c-\/>entries);}
\DoxyCodeLine{3718          \textcolor{keywordflow}{if} (c-\/>codeword\_lengths == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3719          memcpy(c-\/>codeword\_lengths, lengths, c-\/>entries);}
\DoxyCodeLine{3720          stbv\_setup\_temp\_free(f, lengths, c-\/>entries); \textcolor{comment}{// note this is only safe if there have been no intervening temp mallocs!}}
\DoxyCodeLine{3721          lengths = c-\/>codeword\_lengths;}
\DoxyCodeLine{3722          c-\/>sparse = 0;}
\DoxyCodeLine{3723       \}}
\DoxyCodeLine{3724 }
\DoxyCodeLine{3725       \textcolor{comment}{// compute the size of the sorted tables}}
\DoxyCodeLine{3726       \textcolor{keywordflow}{if} (c-\/>sparse) \{}
\DoxyCodeLine{3727          sorted\_count = total;}
\DoxyCodeLine{3728       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3729          sorted\_count = 0;}
\DoxyCodeLine{3730 \textcolor{preprocessor}{         \#ifndef STB\_VORBIS\_NO\_HUFFMAN\_BINARY\_SEARCH}}
\DoxyCodeLine{3731          \textcolor{keywordflow}{for} (j=0; j < c-\/>entries; ++j)}
\DoxyCodeLine{3732             \textcolor{keywordflow}{if} (lengths[j] > STB\_VORBIS\_FAST\_HUFFMAN\_LENGTH \&\& lengths[j] != NO\_CODE)}
\DoxyCodeLine{3733                ++sorted\_count;}
\DoxyCodeLine{3734 \textcolor{preprocessor}{         \#endif}}
\DoxyCodeLine{3735       \}}
\DoxyCodeLine{3736 }
\DoxyCodeLine{3737       c-\/>sorted\_entries = sorted\_count;}
\DoxyCodeLine{3738       values = NULL;}
\DoxyCodeLine{3739 }
\DoxyCodeLine{3740       STBV\_CHECK(f);}
\DoxyCodeLine{3741       \textcolor{keywordflow}{if} (!c-\/>sparse) \{}
\DoxyCodeLine{3742          c-\/>codewords = (stbv\_uint32 *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(c-\/>codewords[0]) * c-\/>entries);}
\DoxyCodeLine{3743          \textcolor{keywordflow}{if} (!c-\/>codewords)                  \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3744       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3745          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} size;}
\DoxyCodeLine{3746          \textcolor{keywordflow}{if} (c-\/>sorted\_entries) \{}
\DoxyCodeLine{3747             c-\/>codeword\_lengths = (stbv\_uint8 *) stbv\_setup\_malloc(f, c-\/>sorted\_entries);}
\DoxyCodeLine{3748             \textcolor{keywordflow}{if} (!c-\/>codeword\_lengths)           \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3749             c-\/>codewords = (stbv\_uint32 *) stbv\_setup\_temp\_malloc(f, \textcolor{keyword}{sizeof}(*c-\/>codewords) * c-\/>sorted\_entries);}
\DoxyCodeLine{3750             \textcolor{keywordflow}{if} (!c-\/>codewords)                  \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3751             values = (stbv\_uint32 *) stbv\_setup\_temp\_malloc(f, \textcolor{keyword}{sizeof}(*values) * c-\/>sorted\_entries);}
\DoxyCodeLine{3752             \textcolor{keywordflow}{if} (!values)                        \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3753          \}}
\DoxyCodeLine{3754          size = c-\/>entries + (\textcolor{keyword}{sizeof}(*c-\/>codewords) + \textcolor{keyword}{sizeof}(*values)) * c-\/>sorted\_entries;}
\DoxyCodeLine{3755          if (size > f-\/>setup\_temp\_memory\_required)}
\DoxyCodeLine{3756             f-\/>setup\_temp\_memory\_required = size;}
\DoxyCodeLine{3757       \}}
\DoxyCodeLine{3758 }
\DoxyCodeLine{3759       \textcolor{keywordflow}{if} (!stbv\_compute\_codewords(c, lengths, c-\/>entries, values)) \{}
\DoxyCodeLine{3760          \textcolor{keywordflow}{if} (c-\/>sparse) stbv\_setup\_temp\_free(f, values, 0);}
\DoxyCodeLine{3761          \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3762       \}}
\DoxyCodeLine{3763 }
\DoxyCodeLine{3764       \textcolor{keywordflow}{if} (c-\/>sorted\_entries) \{}
\DoxyCodeLine{3765          \textcolor{comment}{// allocate an extra slot for sentinels}}
\DoxyCodeLine{3766          c-\/>sorted\_codewords = (stbv\_uint32 *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(*c-\/>sorted\_codewords) * (c-\/>sorted\_entries+1));}
\DoxyCodeLine{3767          \textcolor{keywordflow}{if} (c-\/>sorted\_codewords == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3768          \textcolor{comment}{// allocate an extra slot at the front so that c-\/>sorted\_values[-\/1] is defined}}
\DoxyCodeLine{3769          \textcolor{comment}{// so that we can catch that case without an extra if}}
\DoxyCodeLine{3770          c-\/>sorted\_values    = ( \textcolor{keywordtype}{int}   *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(*c-\/>sorted\_values   ) * (c-\/>sorted\_entries+1));}
\DoxyCodeLine{3771          \textcolor{keywordflow}{if} (c-\/>sorted\_values == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3772          ++c-\/>sorted\_values;}
\DoxyCodeLine{3773          c-\/>sorted\_values[-\/1] = -\/1;}
\DoxyCodeLine{3774          stbv\_compute\_sorted\_huffman(c, lengths, values);}
\DoxyCodeLine{3775       \}}
\DoxyCodeLine{3776 }
\DoxyCodeLine{3777       \textcolor{keywordflow}{if} (c-\/>sparse) \{}
\DoxyCodeLine{3778          stbv\_setup\_temp\_free(f, values, \textcolor{keyword}{sizeof}(*values)*c-\/>sorted\_entries);}
\DoxyCodeLine{3779          stbv\_setup\_temp\_free(f, c-\/>codewords, \textcolor{keyword}{sizeof}(*c-\/>codewords)*c-\/>sorted\_entries);}
\DoxyCodeLine{3780          stbv\_setup\_temp\_free(f, lengths, c-\/>entries);}
\DoxyCodeLine{3781          c-\/>codewords = NULL;}
\DoxyCodeLine{3782       \}}
\DoxyCodeLine{3783 }
\DoxyCodeLine{3784       stbv\_compute\_accelerated\_huffman(c);}
\DoxyCodeLine{3785 }
\DoxyCodeLine{3786       STBV\_CHECK(f);}
\DoxyCodeLine{3787       c-\/>lookup\_type = stbv\_get\_bits(f, 4);}
\DoxyCodeLine{3788       \textcolor{keywordflow}{if} (c-\/>lookup\_type > 2) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3789       \textcolor{keywordflow}{if} (c-\/>lookup\_type > 0) \{}
\DoxyCodeLine{3790          stbv\_uint16 *mults;}
\DoxyCodeLine{3791          c-\/>minimum\_value = stbv\_float32\_unpack(stbv\_get\_bits(f, 32));}
\DoxyCodeLine{3792          c-\/>delta\_value = stbv\_float32\_unpack(stbv\_get\_bits(f, 32));}
\DoxyCodeLine{3793          c-\/>value\_bits = stbv\_get\_bits(f, 4)+1;}
\DoxyCodeLine{3794          c-\/>sequence\_p = stbv\_get\_bits(f,1);}
\DoxyCodeLine{3795          \textcolor{keywordflow}{if} (c-\/>lookup\_type == 1) \{}
\DoxyCodeLine{3796             c-\/>lookup\_values = stbv\_lookup1\_values(c-\/>entries, c-\/>dimensions);}
\DoxyCodeLine{3797          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3798             c-\/>lookup\_values = c-\/>entries * c-\/>dimensions;}
\DoxyCodeLine{3799          \}}
\DoxyCodeLine{3800          \textcolor{keywordflow}{if} (c-\/>lookup\_values == 0) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3801          mults = (stbv\_uint16 *) stbv\_setup\_temp\_malloc(f, \textcolor{keyword}{sizeof}(mults[0]) * c-\/>lookup\_values);}
\DoxyCodeLine{3802          \textcolor{keywordflow}{if} (mults == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3803          \textcolor{keywordflow}{for} (j=0; j < (int) c-\/>lookup\_values; ++j) \{}
\DoxyCodeLine{3804             \textcolor{keywordtype}{int} q = stbv\_get\_bits(f, c-\/>value\_bits);}
\DoxyCodeLine{3805             \textcolor{keywordflow}{if} (q == STBV\_EOP) \{ stbv\_setup\_temp\_free(f,mults,\textcolor{keyword}{sizeof}(mults[0])*c-\/>lookup\_values); \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup); \}}
\DoxyCodeLine{3806             mults[j] = q;}
\DoxyCodeLine{3807          \}}
\DoxyCodeLine{3808 }
\DoxyCodeLine{3809 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{3810          \textcolor{keywordflow}{if} (c-\/>lookup\_type == 1) \{}
\DoxyCodeLine{3811             \textcolor{keywordtype}{int} len, sparse = c-\/>sparse;}
\DoxyCodeLine{3812             \textcolor{keywordtype}{float} last=0;}
\DoxyCodeLine{3813             \textcolor{comment}{// pre-\/expand the lookup1-\/style multiplicands, to avoid a divide in the inner loop}}
\DoxyCodeLine{3814             \textcolor{keywordflow}{if} (sparse) \{}
\DoxyCodeLine{3815                \textcolor{keywordflow}{if} (c-\/>sorted\_entries == 0) \textcolor{keywordflow}{goto} stbv\_skip;}
\DoxyCodeLine{3816                c-\/>multiplicands = (stbv\_codetype *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(c-\/>multiplicands[0]) * c-\/>sorted\_entries * c-\/>dimensions);}
\DoxyCodeLine{3817             \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{3818                c-\/>multiplicands = (stbv\_codetype *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(c-\/>multiplicands[0]) * c-\/>entries        * c-\/>dimensions);}
\DoxyCodeLine{3819             \textcolor{keywordflow}{if} (c-\/>multiplicands == NULL) \{ stbv\_setup\_temp\_free(f,mults,\textcolor{keyword}{sizeof}(mults[0])*c-\/>lookup\_values); \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem); \}}
\DoxyCodeLine{3820             len = sparse ? c-\/>sorted\_entries : c-\/>entries;}
\DoxyCodeLine{3821             \textcolor{keywordflow}{for} (j=0; j < len; ++j) \{}
\DoxyCodeLine{3822                \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} z = sparse ? c-\/>sorted\_values[j] : j;}
\DoxyCodeLine{3823                \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} div=1;}
\DoxyCodeLine{3824                \textcolor{keywordflow}{for} (k=0; k < c-\/>dimensions; ++k) \{}
\DoxyCodeLine{3825                   \textcolor{keywordtype}{int} off = (z / div) \% c-\/>lookup\_values;}
\DoxyCodeLine{3826                   \textcolor{keywordtype}{float} val = mults[off];}
\DoxyCodeLine{3827                   val = mults[off]*c-\/>delta\_value + c-\/>minimum\_value + last;}
\DoxyCodeLine{3828                   c-\/>multiplicands[j*c-\/>dimensions + k] = val;}
\DoxyCodeLine{3829                   if (c-\/>sequence\_p)}
\DoxyCodeLine{3830                      last = val;}
\DoxyCodeLine{3831                   \textcolor{keywordflow}{if} (k+1 < c-\/>dimensions) \{}
\DoxyCodeLine{3832                      \textcolor{keywordflow}{if} (div > UINT\_MAX / (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) c-\/>lookup\_values) \{}
\DoxyCodeLine{3833                         stbv\_setup\_temp\_free(f, mults,\textcolor{keyword}{sizeof}(mults[0])*c-\/>lookup\_values);}
\DoxyCodeLine{3834                         \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3835                      \}}
\DoxyCodeLine{3836                      div *= c-\/>lookup\_values;}
\DoxyCodeLine{3837                   \}}
\DoxyCodeLine{3838                \}}
\DoxyCodeLine{3839             \}}
\DoxyCodeLine{3840             c-\/>lookup\_type = 2;}
\DoxyCodeLine{3841          \}}
\DoxyCodeLine{3842          \textcolor{keywordflow}{else}}
\DoxyCodeLine{3843 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3844          \{}
\DoxyCodeLine{3845             \textcolor{keywordtype}{float} last=0;}
\DoxyCodeLine{3846             STBV\_CHECK(f);}
\DoxyCodeLine{3847             c-\/>multiplicands = (stbv\_codetype *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(c-\/>multiplicands[0]) * c-\/>lookup\_values);}
\DoxyCodeLine{3848             \textcolor{keywordflow}{if} (c-\/>multiplicands == NULL) \{ stbv\_setup\_temp\_free(f, mults,\textcolor{keyword}{sizeof}(mults[0])*c-\/>lookup\_values); \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem); \}}
\DoxyCodeLine{3849             \textcolor{keywordflow}{for} (j=0; j < (int) c-\/>lookup\_values; ++j) \{}
\DoxyCodeLine{3850                \textcolor{keywordtype}{float} val = mults[j] * c-\/>delta\_value + c-\/>minimum\_value + last;}
\DoxyCodeLine{3851                c-\/>multiplicands[j] = val;}
\DoxyCodeLine{3852                \textcolor{keywordflow}{if} (c-\/>sequence\_p)}
\DoxyCodeLine{3853                   last = val;}
\DoxyCodeLine{3854             \}}
\DoxyCodeLine{3855          \}}
\DoxyCodeLine{3856 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_DIVIDES\_IN\_CODEBOOK}}
\DoxyCodeLine{3857         stbv\_skip:;}
\DoxyCodeLine{3858 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3859          stbv\_setup\_temp\_free(f, mults, \textcolor{keyword}{sizeof}(mults[0])*c-\/>lookup\_values);}
\DoxyCodeLine{3860 }
\DoxyCodeLine{3861          STBV\_CHECK(f);}
\DoxyCodeLine{3862       \}}
\DoxyCodeLine{3863       STBV\_CHECK(f);}
\DoxyCodeLine{3864    \}}
\DoxyCodeLine{3865 }
\DoxyCodeLine{3866    \textcolor{comment}{// time domain transfers (notused)}}
\DoxyCodeLine{3867 }
\DoxyCodeLine{3868    x = stbv\_get\_bits(f, 6) + 1;}
\DoxyCodeLine{3869    \textcolor{keywordflow}{for} (i=0; i < x; ++i) \{}
\DoxyCodeLine{3870       stbv\_uint32 z = stbv\_get\_bits(f, 16);}
\DoxyCodeLine{3871       \textcolor{keywordflow}{if} (z != 0) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3872    \}}
\DoxyCodeLine{3873 }
\DoxyCodeLine{3874    \textcolor{comment}{// Floors}}
\DoxyCodeLine{3875    f-\/>floor\_count = stbv\_get\_bits(f, 6)+1;}
\DoxyCodeLine{3876    f-\/>floor\_config = (StbvFloor *)  stbv\_setup\_malloc(f, f-\/>floor\_count * \textcolor{keyword}{sizeof}(*f-\/>floor\_config));}
\DoxyCodeLine{3877    \textcolor{keywordflow}{if} (f-\/>floor\_config == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3878    \textcolor{keywordflow}{for} (i=0; i < f-\/>floor\_count; ++i) \{}
\DoxyCodeLine{3879       f-\/>floor\_types[i] = stbv\_get\_bits(f, 16);}
\DoxyCodeLine{3880       \textcolor{keywordflow}{if} (f-\/>floor\_types[i] > 1) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3881       \textcolor{keywordflow}{if} (f-\/>floor\_types[i] == 0) \{}
\DoxyCodeLine{3882          StbvFloor0 *g = \&f-\/>floor\_config[i].floor0;}
\DoxyCodeLine{3883          g-\/>order = stbv\_get\_bits(f,8);}
\DoxyCodeLine{3884          g-\/>rate = stbv\_get\_bits(f,16);}
\DoxyCodeLine{3885          g-\/>bark\_map\_size = stbv\_get\_bits(f,16);}
\DoxyCodeLine{3886          g-\/>amplitude\_bits = stbv\_get\_bits(f,6);}
\DoxyCodeLine{3887          g-\/>amplitude\_offset = stbv\_get\_bits(f,8);}
\DoxyCodeLine{3888          g-\/>number\_of\_books = stbv\_get\_bits(f,4) + 1;}
\DoxyCodeLine{3889          \textcolor{keywordflow}{for} (j=0; j < g-\/>number\_of\_books; ++j)}
\DoxyCodeLine{3890             g-\/>book\_list[j] = stbv\_get\_bits(f,8);}
\DoxyCodeLine{3891          \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_feature\_not\_supported);}
\DoxyCodeLine{3892       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3893          stbv\_floor\_ordering p[31*8+2];}
\DoxyCodeLine{3894          StbvFloor1 *g = \&f-\/>floor\_config[i].floor1;}
\DoxyCodeLine{3895          \textcolor{keywordtype}{int} max\_class = -\/1; }
\DoxyCodeLine{3896          g-\/>partitions = stbv\_get\_bits(f, 5);}
\DoxyCodeLine{3897          \textcolor{keywordflow}{for} (j=0; j < g-\/>partitions; ++j) \{}
\DoxyCodeLine{3898             g-\/>partition\_class\_list[j] = stbv\_get\_bits(f, 4);}
\DoxyCodeLine{3899             \textcolor{keywordflow}{if} (g-\/>partition\_class\_list[j] > max\_class)}
\DoxyCodeLine{3900                max\_class = g-\/>partition\_class\_list[j];}
\DoxyCodeLine{3901          \}}
\DoxyCodeLine{3902          \textcolor{keywordflow}{for} (j=0; j <= max\_class; ++j) \{}
\DoxyCodeLine{3903             g-\/>class\_dimensions[j] = stbv\_get\_bits(f, 3)+1;}
\DoxyCodeLine{3904             g-\/>class\_subclasses[j] = stbv\_get\_bits(f, 2);}
\DoxyCodeLine{3905             \textcolor{keywordflow}{if} (g-\/>class\_subclasses[j]) \{}
\DoxyCodeLine{3906                g-\/>class\_masterbooks[j] = stbv\_get\_bits(f, 8);}
\DoxyCodeLine{3907                \textcolor{keywordflow}{if} (g-\/>class\_masterbooks[j] >= f-\/>codebook\_count) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3908             \}}
\DoxyCodeLine{3909             \textcolor{keywordflow}{for} (k=0; k < 1 << g-\/>class\_subclasses[j]; ++k) \{}
\DoxyCodeLine{3910                g-\/>subclass\_books[j][k] = stbv\_get\_bits(f,8)-\/1;}
\DoxyCodeLine{3911                \textcolor{keywordflow}{if} (g-\/>subclass\_books[j][k] >= f-\/>codebook\_count) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3912             \}}
\DoxyCodeLine{3913          \}}
\DoxyCodeLine{3914          g-\/>floor1\_multiplier = stbv\_get\_bits(f,2)+1;}
\DoxyCodeLine{3915          g-\/>rangebits = stbv\_get\_bits(f,4);}
\DoxyCodeLine{3916          g-\/>Xlist[0] = 0;}
\DoxyCodeLine{3917          g-\/>Xlist[1] = 1 << g-\/>rangebits;}
\DoxyCodeLine{3918          g-\/>values = 2;}
\DoxyCodeLine{3919          \textcolor{keywordflow}{for} (j=0; j < g-\/>partitions; ++j) \{}
\DoxyCodeLine{3920             \textcolor{keywordtype}{int} c = g-\/>partition\_class\_list[j];}
\DoxyCodeLine{3921             \textcolor{keywordflow}{for} (k=0; k < g-\/>class\_dimensions[c]; ++k) \{}
\DoxyCodeLine{3922                g-\/>Xlist[g-\/>values] = stbv\_get\_bits(f, g-\/>rangebits);}
\DoxyCodeLine{3923                ++g-\/>values;}
\DoxyCodeLine{3924             \}}
\DoxyCodeLine{3925          \}}
\DoxyCodeLine{3926          \textcolor{comment}{// precompute the sorting}}
\DoxyCodeLine{3927          \textcolor{keywordflow}{for} (j=0; j < g-\/>values; ++j) \{}
\DoxyCodeLine{3928             p[j].x = g-\/>Xlist[j];}
\DoxyCodeLine{3929             p[j].id = j;}
\DoxyCodeLine{3930          \}}
\DoxyCodeLine{3931          qsort(p, g-\/>values, \textcolor{keyword}{sizeof}(p[0]), stbv\_point\_compare);}
\DoxyCodeLine{3932          \textcolor{keywordflow}{for} (j=0; j < g-\/>values; ++j)}
\DoxyCodeLine{3933             g-\/>sorted\_order[j] = (stbv\_uint8) p[j].id;}
\DoxyCodeLine{3934          \textcolor{comment}{// precompute the stbv\_neighbors}}
\DoxyCodeLine{3935          \textcolor{keywordflow}{for} (j=2; j < g-\/>values; ++j) \{}
\DoxyCodeLine{3936             \textcolor{keywordtype}{int} low,hi;}
\DoxyCodeLine{3937             stbv\_neighbors(g-\/>Xlist, j, \&low,\&hi);}
\DoxyCodeLine{3938             g-\/>stbv\_neighbors[j][0] = low;}
\DoxyCodeLine{3939             g-\/>stbv\_neighbors[j][1] = hi;}
\DoxyCodeLine{3940          \}}
\DoxyCodeLine{3941 }
\DoxyCodeLine{3942          \textcolor{keywordflow}{if} (g-\/>values > longest\_floorlist)}
\DoxyCodeLine{3943             longest\_floorlist = g-\/>values;}
\DoxyCodeLine{3944       \}}
\DoxyCodeLine{3945    \}}
\DoxyCodeLine{3946 }
\DoxyCodeLine{3947    \textcolor{comment}{// StbvResidue}}
\DoxyCodeLine{3948    f-\/>residue\_count = stbv\_get\_bits(f, 6)+1;}
\DoxyCodeLine{3949    f-\/>residue\_config = (StbvResidue *) stbv\_setup\_malloc(f, f-\/>residue\_count * \textcolor{keyword}{sizeof}(f-\/>residue\_config[0]));}
\DoxyCodeLine{3950    \textcolor{keywordflow}{if} (f-\/>residue\_config == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3951    memset(f-\/>residue\_config, 0, f-\/>residue\_count * \textcolor{keyword}{sizeof}(f-\/>residue\_config[0]));}
\DoxyCodeLine{3952    \textcolor{keywordflow}{for} (i=0; i < f-\/>residue\_count; ++i) \{}
\DoxyCodeLine{3953       stbv\_uint8 residue\_cascade[64];}
\DoxyCodeLine{3954       StbvResidue *r = f-\/>residue\_config+i;}
\DoxyCodeLine{3955       f-\/>residue\_types[i] = stbv\_get\_bits(f, 16);}
\DoxyCodeLine{3956       \textcolor{keywordflow}{if} (f-\/>residue\_types[i] > 2) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3957       r-\/>begin = stbv\_get\_bits(f, 24);}
\DoxyCodeLine{3958       r-\/>end = stbv\_get\_bits(f, 24);}
\DoxyCodeLine{3959       \textcolor{keywordflow}{if} (r-\/>end < r-\/>begin) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3960       r-\/>part\_size = stbv\_get\_bits(f,24)+1;}
\DoxyCodeLine{3961       r-\/>classifications = stbv\_get\_bits(f,6)+1;}
\DoxyCodeLine{3962       r-\/>classbook = stbv\_get\_bits(f,8);}
\DoxyCodeLine{3963       \textcolor{keywordflow}{if} (r-\/>classbook >= f-\/>codebook\_count) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3964       \textcolor{keywordflow}{for} (j=0; j < r-\/>classifications; ++j) \{}
\DoxyCodeLine{3965          stbv\_uint8 high\_bits=0;}
\DoxyCodeLine{3966          stbv\_uint8 low\_bits=stbv\_get\_bits(f,3);}
\DoxyCodeLine{3967          \textcolor{keywordflow}{if} (stbv\_get\_bits(f,1))}
\DoxyCodeLine{3968             high\_bits = stbv\_get\_bits(f,5);}
\DoxyCodeLine{3969          residue\_cascade[j] = high\_bits*8 + low\_bits;}
\DoxyCodeLine{3970       \}}
\DoxyCodeLine{3971       r-\/>residue\_books = (short (*)[8]) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(r-\/>residue\_books[0]) * r-\/>classifications);}
\DoxyCodeLine{3972       \textcolor{keywordflow}{if} (r-\/>residue\_books == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3973       \textcolor{keywordflow}{for} (j=0; j < r-\/>classifications; ++j) \{}
\DoxyCodeLine{3974          \textcolor{keywordflow}{for} (k=0; k < 8; ++k) \{}
\DoxyCodeLine{3975             \textcolor{keywordflow}{if} (residue\_cascade[j] \& (1 << k)) \{}
\DoxyCodeLine{3976                r-\/>residue\_books[j][k] = stbv\_get\_bits(f, 8);}
\DoxyCodeLine{3977                \textcolor{keywordflow}{if} (r-\/>residue\_books[j][k] >= f-\/>codebook\_count) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{3978             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3979                r-\/>residue\_books[j][k] = -\/1;}
\DoxyCodeLine{3980             \}}
\DoxyCodeLine{3981          \}}
\DoxyCodeLine{3982       \}}
\DoxyCodeLine{3983       \textcolor{comment}{// precompute the classifications[] array to avoid inner-\/loop mod/divide}}
\DoxyCodeLine{3984       \textcolor{comment}{// call it 'classdata' since we already have r-\/>classifications}}
\DoxyCodeLine{3985       r-\/>classdata = (stbv\_uint8 **) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(*r-\/>classdata) * f-\/>codebooks[r-\/>classbook].entries);}
\DoxyCodeLine{3986       \textcolor{keywordflow}{if} (!r-\/>classdata) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3987       memset(r-\/>classdata, 0, \textcolor{keyword}{sizeof}(*r-\/>classdata) * f-\/>codebooks[r-\/>classbook].entries);}
\DoxyCodeLine{3988       \textcolor{keywordflow}{for} (j=0; j < f-\/>codebooks[r-\/>classbook].entries; ++j) \{}
\DoxyCodeLine{3989          \textcolor{keywordtype}{int} classwords = f-\/>codebooks[r-\/>classbook].dimensions;}
\DoxyCodeLine{3990          \textcolor{keywordtype}{int} temp = j;}
\DoxyCodeLine{3991          r-\/>classdata[j] = (stbv\_uint8 *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(r-\/>classdata[j][0]) * classwords);}
\DoxyCodeLine{3992          \textcolor{keywordflow}{if} (r-\/>classdata[j] == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{3993          \textcolor{keywordflow}{for} (k=classwords-\/1; k >= 0; -\/-\/k) \{}
\DoxyCodeLine{3994             r-\/>classdata[j][k] = temp \% r-\/>classifications;}
\DoxyCodeLine{3995             temp /= r-\/>classifications;}
\DoxyCodeLine{3996          \}}
\DoxyCodeLine{3997       \}}
\DoxyCodeLine{3998    \}}
\DoxyCodeLine{3999 }
\DoxyCodeLine{4000    f-\/>mapping\_count = stbv\_get\_bits(f,6)+1;}
\DoxyCodeLine{4001    f-\/>mapping = (StbvMapping *) stbv\_setup\_malloc(f, f-\/>mapping\_count * \textcolor{keyword}{sizeof}(*f-\/>mapping));}
\DoxyCodeLine{4002    \textcolor{keywordflow}{if} (f-\/>mapping == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{4003    memset(f-\/>mapping, 0, f-\/>mapping\_count * \textcolor{keyword}{sizeof}(*f-\/>mapping));}
\DoxyCodeLine{4004    \textcolor{keywordflow}{for} (i=0; i < f-\/>mapping\_count; ++i) \{}
\DoxyCodeLine{4005       StbvMapping *m = f-\/>mapping + i;      }
\DoxyCodeLine{4006       \textcolor{keywordtype}{int} mapping\_type = stbv\_get\_bits(f,16);}
\DoxyCodeLine{4007       \textcolor{keywordflow}{if} (mapping\_type != 0) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4008       m-\/>chan = (StbvMappingChannel *) stbv\_setup\_malloc(f, f-\/>channels * \textcolor{keyword}{sizeof}(*m-\/>chan));}
\DoxyCodeLine{4009       \textcolor{keywordflow}{if} (m-\/>chan == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{4010       \textcolor{keywordflow}{if} (stbv\_get\_bits(f,1))}
\DoxyCodeLine{4011          m-\/>submaps = stbv\_get\_bits(f,4)+1;}
\DoxyCodeLine{4012       \textcolor{keywordflow}{else}}
\DoxyCodeLine{4013          m-\/>submaps = 1;}
\DoxyCodeLine{4014       \textcolor{keywordflow}{if} (m-\/>submaps > max\_submaps)}
\DoxyCodeLine{4015          max\_submaps = m-\/>submaps;}
\DoxyCodeLine{4016       \textcolor{keywordflow}{if} (stbv\_get\_bits(f,1)) \{}
\DoxyCodeLine{4017          m-\/>coupling\_steps = stbv\_get\_bits(f,8)+1;}
\DoxyCodeLine{4018          \textcolor{keywordflow}{for} (k=0; k < m-\/>coupling\_steps; ++k) \{}
\DoxyCodeLine{4019             m-\/>chan[k].magnitude = stbv\_get\_bits(f, stbv\_ilog(f-\/>channels-\/1));}
\DoxyCodeLine{4020             m-\/>chan[k].angle = stbv\_get\_bits(f, stbv\_ilog(f-\/>channels-\/1));}
\DoxyCodeLine{4021             \textcolor{keywordflow}{if} (m-\/>chan[k].magnitude >= f-\/>channels)        \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4022             \textcolor{keywordflow}{if} (m-\/>chan[k].angle     >= f-\/>channels)        \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4023             \textcolor{keywordflow}{if} (m-\/>chan[k].magnitude == m-\/>chan[k].angle)   \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4024          \}}
\DoxyCodeLine{4025       \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{4026          m-\/>coupling\_steps = 0;}
\DoxyCodeLine{4027 }
\DoxyCodeLine{4028       \textcolor{comment}{// reserved field}}
\DoxyCodeLine{4029       \textcolor{keywordflow}{if} (stbv\_get\_bits(f,2)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4030       \textcolor{keywordflow}{if} (m-\/>submaps > 1) \{}
\DoxyCodeLine{4031          \textcolor{keywordflow}{for} (j=0; j < f-\/>channels; ++j) \{}
\DoxyCodeLine{4032             m-\/>chan[j].mux = stbv\_get\_bits(f, 4);}
\DoxyCodeLine{4033             \textcolor{keywordflow}{if} (m-\/>chan[j].mux >= m-\/>submaps)                \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4034          \}}
\DoxyCodeLine{4035       \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{4036          \textcolor{comment}{// @SPECIFICATION: this case is missing from the spec}}
\DoxyCodeLine{4037          \textcolor{keywordflow}{for} (j=0; j < f-\/>channels; ++j)}
\DoxyCodeLine{4038             m-\/>chan[j].mux = 0;}
\DoxyCodeLine{4039 }
\DoxyCodeLine{4040       for (j=0; j < m-\/>submaps; ++j) \{}
\DoxyCodeLine{4041          stbv\_get\_bits(f,8); \textcolor{comment}{// discard}}
\DoxyCodeLine{4042          m-\/>submap\_floor[j] = stbv\_get\_bits(f,8);}
\DoxyCodeLine{4043          m-\/>submap\_residue[j] = stbv\_get\_bits(f,8);}
\DoxyCodeLine{4044          \textcolor{keywordflow}{if} (m-\/>submap\_floor[j] >= f-\/>floor\_count)      \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4045          \textcolor{keywordflow}{if} (m-\/>submap\_residue[j] >= f-\/>residue\_count)  \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4046       \}}
\DoxyCodeLine{4047    \}}
\DoxyCodeLine{4048 }
\DoxyCodeLine{4049    \textcolor{comment}{// Modes}}
\DoxyCodeLine{4050    f-\/>mode\_count = stbv\_get\_bits(f, 6)+1;}
\DoxyCodeLine{4051    \textcolor{keywordflow}{for} (i=0; i < f-\/>mode\_count; ++i) \{}
\DoxyCodeLine{4052       StbvMode *m = f-\/>mode\_config+i;}
\DoxyCodeLine{4053       m-\/>blockflag = stbv\_get\_bits(f,1);}
\DoxyCodeLine{4054       m-\/>windowtype = stbv\_get\_bits(f,16);}
\DoxyCodeLine{4055       m-\/>transformtype = stbv\_get\_bits(f,16);}
\DoxyCodeLine{4056       m-\/>mapping = stbv\_get\_bits(f,8);}
\DoxyCodeLine{4057       \textcolor{keywordflow}{if} (m-\/>windowtype != 0)                 \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4058       \textcolor{keywordflow}{if} (m-\/>transformtype != 0)              \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4059       \textcolor{keywordflow}{if} (m-\/>mapping >= f-\/>mapping\_count)     \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_setup);}
\DoxyCodeLine{4060    \}}
\DoxyCodeLine{4061 }
\DoxyCodeLine{4062    stbv\_flush\_packet(f);}
\DoxyCodeLine{4063 }
\DoxyCodeLine{4064    f-\/>previous\_length = 0;}
\DoxyCodeLine{4065 }
\DoxyCodeLine{4066    \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i) \{}
\DoxyCodeLine{4067       f-\/>channel\_buffers[i] = (\textcolor{keywordtype}{float} *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * f-\/>blocksize\_1);}
\DoxyCodeLine{4068       f-\/>previous\_window[i] = (\textcolor{keywordtype}{float} *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * f-\/>blocksize\_1/2);}
\DoxyCodeLine{4069       f-\/>finalY[i]          = (stbv\_int16 *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(stbv\_int16) * longest\_floorlist);}
\DoxyCodeLine{4070       \textcolor{keywordflow}{if} (f-\/>channel\_buffers[i] == NULL || f-\/>previous\_window[i] == NULL || f-\/>finalY[i] == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{4071       memset(f-\/>channel\_buffers[i], 0, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * f-\/>blocksize\_1);}
\DoxyCodeLine{4072 \textcolor{preprocessor}{      \#ifdef STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{4073       f-\/>floor\_buffers[i]   = (\textcolor{keywordtype}{float} *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * f-\/>blocksize\_1/2);}
\DoxyCodeLine{4074       \textcolor{keywordflow}{if} (f-\/>floor\_buffers[i] == NULL) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{4075 \textcolor{preprocessor}{      \#endif}}
\DoxyCodeLine{4076    \}}
\DoxyCodeLine{4077 }
\DoxyCodeLine{4078    \textcolor{keywordflow}{if} (!stbv\_init\_blocksize(f, 0, f-\/>blocksize\_0)) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{4079    \textcolor{keywordflow}{if} (!stbv\_init\_blocksize(f, 1, f-\/>blocksize\_1)) \textcolor{keywordflow}{return} FALSE;}
\DoxyCodeLine{4080    f-\/>blocksize[0] = f-\/>blocksize\_0;}
\DoxyCodeLine{4081    f-\/>blocksize[1] = f-\/>blocksize\_1;}
\DoxyCodeLine{4082 }
\DoxyCodeLine{4083 \textcolor{preprocessor}{\#ifdef STB\_VORBIS\_DIVIDE\_TABLE}}
\DoxyCodeLine{4084    \textcolor{keywordflow}{if} (stbv\_integer\_divide\_table[1][1]==0)}
\DoxyCodeLine{4085       \textcolor{keywordflow}{for} (i=0; i < STBV\_DIVTAB\_NUMER; ++i)}
\DoxyCodeLine{4086          \textcolor{keywordflow}{for} (j=1; j < STBV\_DIVTAB\_DENOM; ++j)}
\DoxyCodeLine{4087             stbv\_integer\_divide\_table[i][j] = i / j;}
\DoxyCodeLine{4088 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4089 }
\DoxyCodeLine{4090    \textcolor{comment}{// compute how much temporary memory is needed}}
\DoxyCodeLine{4091 }
\DoxyCodeLine{4092    \textcolor{comment}{// 1.}}
\DoxyCodeLine{4093    \{}
\DoxyCodeLine{4094       stbv\_uint32 imdct\_mem = (f-\/>blocksize\_1 * \textcolor{keyword}{sizeof}(float) >> 1);}
\DoxyCodeLine{4095       stbv\_uint32 classify\_mem;}
\DoxyCodeLine{4096       \textcolor{keywordtype}{int} i,max\_part\_read=0;}
\DoxyCodeLine{4097       \textcolor{keywordflow}{for} (i=0; i < f-\/>residue\_count; ++i) \{}
\DoxyCodeLine{4098          StbvResidue *r = f-\/>residue\_config + i;}
\DoxyCodeLine{4099          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} actual\_size = f-\/>blocksize\_1 / 2;}
\DoxyCodeLine{4100          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit\_r\_begin = r-\/>begin < actual\_size ? r-\/>begin : actual\_size;}
\DoxyCodeLine{4101          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit\_r\_end   = r-\/>end   < actual\_size ? r-\/>end   : actual\_size;}
\DoxyCodeLine{4102          \textcolor{keywordtype}{int} n\_read = limit\_r\_end -\/ limit\_r\_begin;}
\DoxyCodeLine{4103          \textcolor{keywordtype}{int} part\_read = n\_read / r-\/>part\_size;}
\DoxyCodeLine{4104          \textcolor{keywordflow}{if} (part\_read > max\_part\_read)}
\DoxyCodeLine{4105             max\_part\_read = part\_read;}
\DoxyCodeLine{4106       \}}
\DoxyCodeLine{4107 \textcolor{preprocessor}{      \#ifndef STB\_VORBIS\_DIVIDES\_IN\_RESIDUE}}
\DoxyCodeLine{4108       classify\_mem = f-\/>channels * (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*) + max\_part\_read * \textcolor{keyword}{sizeof}(stbv\_uint8 *));}
\DoxyCodeLine{4109 \textcolor{preprocessor}{      \#else}}
\DoxyCodeLine{4110       classify\_mem = f-\/>channels * (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*) + max\_part\_read * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int} *));}
\DoxyCodeLine{4111 \textcolor{preprocessor}{      \#endif}}
\DoxyCodeLine{4112 }
\DoxyCodeLine{4113       \textcolor{comment}{// maximum reasonable partition size is f-\/>blocksize\_1}}
\DoxyCodeLine{4114 }
\DoxyCodeLine{4115       f-\/>temp\_memory\_required = classify\_mem;}
\DoxyCodeLine{4116       \textcolor{keywordflow}{if} (imdct\_mem > f-\/>temp\_memory\_required)}
\DoxyCodeLine{4117          f-\/>temp\_memory\_required = imdct\_mem;}
\DoxyCodeLine{4118    \}}
\DoxyCodeLine{4119 }
\DoxyCodeLine{4120    f-\/>first\_decode = TRUE;}
\DoxyCodeLine{4121 }
\DoxyCodeLine{4122    \textcolor{keywordflow}{if} (f-\/>alloc.alloc\_buffer) \{}
\DoxyCodeLine{4123       assert(f-\/>temp\_offset == f-\/>alloc.alloc\_buffer\_length\_in\_bytes);}
\DoxyCodeLine{4124       \textcolor{comment}{// check if there's enough temp memory so we don't error later}}
\DoxyCodeLine{4125       \textcolor{keywordflow}{if} (f-\/>setup\_offset + \textcolor{keyword}{sizeof}(*f) + f-\/>temp\_memory\_required > (\textcolor{keywordtype}{unsigned}) f-\/>temp\_offset)}
\DoxyCodeLine{4126          \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_outofmem);}
\DoxyCodeLine{4127    \}}
\DoxyCodeLine{4128 }
\DoxyCodeLine{4129    f-\/>first\_audio\_page\_offset = stb\_vorbis\_get\_file\_offset(f);}
\DoxyCodeLine{4130 }
\DoxyCodeLine{4131    \textcolor{keywordflow}{return} TRUE;}
\DoxyCodeLine{4132 \}}
\DoxyCodeLine{4133 }
\DoxyCodeLine{4134 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_vorbis\_deinit(stb\_vorbis *p)}
\DoxyCodeLine{4135 \{}
\DoxyCodeLine{4136    \textcolor{keywordtype}{int} i,j;}
\DoxyCodeLine{4137    \textcolor{keywordflow}{if} (p-\/>residue\_config) \{}
\DoxyCodeLine{4138       \textcolor{keywordflow}{for} (i=0; i < p-\/>residue\_count; ++i) \{}
\DoxyCodeLine{4139          StbvResidue *r = p-\/>residue\_config+i;}
\DoxyCodeLine{4140          \textcolor{keywordflow}{if} (r-\/>classdata) \{}
\DoxyCodeLine{4141             \textcolor{keywordflow}{for} (j=0; j < p-\/>codebooks[r-\/>classbook].entries; ++j)}
\DoxyCodeLine{4142                stbv\_setup\_free(p, r-\/>classdata[j]);}
\DoxyCodeLine{4143             stbv\_setup\_free(p, r-\/>classdata);}
\DoxyCodeLine{4144          \}}
\DoxyCodeLine{4145          stbv\_setup\_free(p, r-\/>residue\_books);}
\DoxyCodeLine{4146       \}}
\DoxyCodeLine{4147    \}}
\DoxyCodeLine{4148 }
\DoxyCodeLine{4149    \textcolor{keywordflow}{if} (p-\/>codebooks) \{}
\DoxyCodeLine{4150       STBV\_CHECK(p);}
\DoxyCodeLine{4151       \textcolor{keywordflow}{for} (i=0; i < p-\/>codebook\_count; ++i) \{}
\DoxyCodeLine{4152          StbvCodebook *c = p-\/>codebooks + i;}
\DoxyCodeLine{4153          stbv\_setup\_free(p, c-\/>codeword\_lengths);}
\DoxyCodeLine{4154          stbv\_setup\_free(p, c-\/>multiplicands);}
\DoxyCodeLine{4155          stbv\_setup\_free(p, c-\/>codewords);}
\DoxyCodeLine{4156          stbv\_setup\_free(p, c-\/>sorted\_codewords);}
\DoxyCodeLine{4157          \textcolor{comment}{// c-\/>sorted\_values[-\/1] is the first entry in the array}}
\DoxyCodeLine{4158          stbv\_setup\_free(p, c-\/>sorted\_values ? c-\/>sorted\_values-\/1 : NULL);}
\DoxyCodeLine{4159       \}}
\DoxyCodeLine{4160       stbv\_setup\_free(p, p-\/>codebooks);}
\DoxyCodeLine{4161    \}}
\DoxyCodeLine{4162    stbv\_setup\_free(p, p-\/>floor\_config);}
\DoxyCodeLine{4163    stbv\_setup\_free(p, p-\/>residue\_config);}
\DoxyCodeLine{4164    \textcolor{keywordflow}{if} (p-\/>mapping) \{}
\DoxyCodeLine{4165       \textcolor{keywordflow}{for} (i=0; i < p-\/>mapping\_count; ++i)}
\DoxyCodeLine{4166          stbv\_setup\_free(p, p-\/>mapping[i].chan);}
\DoxyCodeLine{4167       stbv\_setup\_free(p, p-\/>mapping);}
\DoxyCodeLine{4168    \}}
\DoxyCodeLine{4169    STBV\_CHECK(p);}
\DoxyCodeLine{4170    \textcolor{keywordflow}{for} (i=0; i < p-\/>channels \&\& i < STB\_VORBIS\_MAX\_CHANNELS; ++i) \{}
\DoxyCodeLine{4171       stbv\_setup\_free(p, p-\/>channel\_buffers[i]);}
\DoxyCodeLine{4172       stbv\_setup\_free(p, p-\/>previous\_window[i]);}
\DoxyCodeLine{4173 \textcolor{preprocessor}{      \#ifdef STB\_VORBIS\_NO\_DEFER\_FLOOR}}
\DoxyCodeLine{4174       stbv\_setup\_free(p, p-\/>floor\_buffers[i]);}
\DoxyCodeLine{4175 \textcolor{preprocessor}{      \#endif}}
\DoxyCodeLine{4176       stbv\_setup\_free(p, p-\/>finalY[i]);}
\DoxyCodeLine{4177    \}}
\DoxyCodeLine{4178    \textcolor{keywordflow}{for} (i=0; i < 2; ++i) \{}
\DoxyCodeLine{4179       stbv\_setup\_free(p, p-\/>A[i]);}
\DoxyCodeLine{4180       stbv\_setup\_free(p, p-\/>B[i]);}
\DoxyCodeLine{4181       stbv\_setup\_free(p, p-\/>C[i]);}
\DoxyCodeLine{4182       stbv\_setup\_free(p, p-\/>window[i]);}
\DoxyCodeLine{4183       stbv\_setup\_free(p, p-\/>stbv\_bit\_reverse[i]);}
\DoxyCodeLine{4184    \}}
\DoxyCodeLine{4185 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{4186    \textcolor{keywordflow}{if} (p-\/>close\_on\_free) fclose(p-\/>f);}
\DoxyCodeLine{4187 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{4188 \}}
\DoxyCodeLine{4189 }
\DoxyCodeLine{4190 STBVDEF \textcolor{keywordtype}{void} stb\_vorbis\_close(stb\_vorbis *p)}
\DoxyCodeLine{4191 \{}
\DoxyCodeLine{4192    \textcolor{keywordflow}{if} (p == NULL) \textcolor{keywordflow}{return};}
\DoxyCodeLine{4193    stbv\_vorbis\_deinit(p);}
\DoxyCodeLine{4194    stbv\_setup\_free(p,p);}
\DoxyCodeLine{4195 \}}
\DoxyCodeLine{4196 }
\DoxyCodeLine{4197 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_vorbis\_init(stb\_vorbis *p, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *z)}
\DoxyCodeLine{4198 \{}
\DoxyCodeLine{4199    memset(p, 0, \textcolor{keyword}{sizeof}(*p)); \textcolor{comment}{// NULL out all malloc'd pointers to start}}
\DoxyCodeLine{4200    \textcolor{keywordflow}{if} (z) \{}
\DoxyCodeLine{4201       p-\/>alloc = *z;}
\DoxyCodeLine{4202       p-\/>alloc.alloc\_buffer\_length\_in\_bytes = (p-\/>alloc.alloc\_buffer\_length\_in\_bytes+3) \& \string~3;}
\DoxyCodeLine{4203       p-\/>temp\_offset = p-\/>alloc.alloc\_buffer\_length\_in\_bytes;}
\DoxyCodeLine{4204    \}}
\DoxyCodeLine{4205    p-\/>eof = 0;}
\DoxyCodeLine{4206    p-\/>error = VORBIS\_\_no\_error;}
\DoxyCodeLine{4207    p-\/>stream = NULL;}
\DoxyCodeLine{4208    p-\/>codebooks = NULL;}
\DoxyCodeLine{4209    p-\/>page\_crc\_tests = -\/1;}
\DoxyCodeLine{4210 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{4211    p-\/>close\_on\_free = FALSE;}
\DoxyCodeLine{4212    p-\/>f = NULL;}
\DoxyCodeLine{4213 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{4214 \}}
\DoxyCodeLine{4215 }
\DoxyCodeLine{4216 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_sample\_offset(stb\_vorbis *f)}
\DoxyCodeLine{4217 \{}
\DoxyCodeLine{4218    \textcolor{keywordflow}{if} (f-\/>current\_loc\_valid)}
\DoxyCodeLine{4219       \textcolor{keywordflow}{return} f-\/>current\_loc;}
\DoxyCodeLine{4220    \textcolor{keywordflow}{else}}
\DoxyCodeLine{4221       \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4222 \}}
\DoxyCodeLine{4223 }
\DoxyCodeLine{4224 STBVDEF \mbox{\hyperlink{structstb__vorbis__info}{stb\_vorbis\_info}} stb\_vorbis\_get\_info(stb\_vorbis *f)}
\DoxyCodeLine{4225 \{}
\DoxyCodeLine{4226    \mbox{\hyperlink{structstb__vorbis__info}{stb\_vorbis\_info}} d;}
\DoxyCodeLine{4227    d.channels = f-\/>channels;}
\DoxyCodeLine{4228    d.sample\_rate = f-\/>sample\_rate;}
\DoxyCodeLine{4229    d.setup\_memory\_required = f-\/>setup\_memory\_required;}
\DoxyCodeLine{4230    d.setup\_temp\_memory\_required = f-\/>setup\_temp\_memory\_required;}
\DoxyCodeLine{4231    d.temp\_memory\_required = f-\/>temp\_memory\_required;}
\DoxyCodeLine{4232    d.max\_frame\_size = f-\/>blocksize\_1 >> 1;}
\DoxyCodeLine{4233    \textcolor{keywordflow}{return} d;}
\DoxyCodeLine{4234 \}}
\DoxyCodeLine{4235 }
\DoxyCodeLine{4236 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_error(stb\_vorbis *f)}
\DoxyCodeLine{4237 \{}
\DoxyCodeLine{4238    \textcolor{keywordtype}{int} e = f-\/>error;}
\DoxyCodeLine{4239    f-\/>error = VORBIS\_\_no\_error;}
\DoxyCodeLine{4240    \textcolor{keywordflow}{return} e;}
\DoxyCodeLine{4241 \}}
\DoxyCodeLine{4242 }
\DoxyCodeLine{4243 \textcolor{keyword}{static} stb\_vorbis * stbv\_vorbis\_alloc(stb\_vorbis *f)}
\DoxyCodeLine{4244 \{}
\DoxyCodeLine{4245    stb\_vorbis *p = (stb\_vorbis *) stbv\_setup\_malloc(f, \textcolor{keyword}{sizeof}(*p));}
\DoxyCodeLine{4246    \textcolor{keywordflow}{return} p;}
\DoxyCodeLine{4247 \}}
\DoxyCodeLine{4248 }
\DoxyCodeLine{4249 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{4250 }
\DoxyCodeLine{4251 STBVDEF \textcolor{keywordtype}{void} stb\_vorbis\_flush\_pushdata(stb\_vorbis *f)}
\DoxyCodeLine{4252 \{}
\DoxyCodeLine{4253    f-\/>previous\_length = 0;}
\DoxyCodeLine{4254    f-\/>page\_crc\_tests  = 0;}
\DoxyCodeLine{4255    f-\/>discard\_samples\_deferred = 0;}
\DoxyCodeLine{4256    f-\/>current\_loc\_valid = FALSE;}
\DoxyCodeLine{4257    f-\/>first\_decode = FALSE;}
\DoxyCodeLine{4258    f-\/>samples\_output = 0;}
\DoxyCodeLine{4259    f-\/>channel\_buffer\_start = 0;}
\DoxyCodeLine{4260    f-\/>channel\_buffer\_end = 0;}
\DoxyCodeLine{4261 \}}
\DoxyCodeLine{4262 }
\DoxyCodeLine{4263 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_vorbis\_search\_for\_page\_pushdata(stbv\_vorb *f, stbv\_uint8 *data, \textcolor{keywordtype}{int} data\_len)}
\DoxyCodeLine{4264 \{}
\DoxyCodeLine{4265    \textcolor{keywordtype}{int} i,n;}
\DoxyCodeLine{4266    \textcolor{keywordflow}{for} (i=0; i < f-\/>page\_crc\_tests; ++i)}
\DoxyCodeLine{4267       f-\/>scan[i].bytes\_done = 0;}
\DoxyCodeLine{4268 }
\DoxyCodeLine{4269    \textcolor{comment}{// if we have room for more scans, search for them first, because}}
\DoxyCodeLine{4270    \textcolor{comment}{// they may cause us to stop early if their header is incomplete}}
\DoxyCodeLine{4271    if (f-\/>page\_crc\_tests < STB\_VORBIS\_PUSHDATA\_CRC\_COUNT) \{}
\DoxyCodeLine{4272       \textcolor{keywordflow}{if} (data\_len < 4) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4273       data\_len -\/= 3; \textcolor{comment}{// need to look for 4-\/byte sequence, so don't miss}}
\DoxyCodeLine{4274                      \textcolor{comment}{// one that straddles a boundary}}
\DoxyCodeLine{4275       \textcolor{keywordflow}{for} (i=0; i < data\_len; ++i) \{}
\DoxyCodeLine{4276          \textcolor{keywordflow}{if} (data[i] == 0x4f) \{}
\DoxyCodeLine{4277             \textcolor{keywordflow}{if} (0==memcmp(data+i, stbv\_ogg\_page\_header, 4)) \{}
\DoxyCodeLine{4278                \textcolor{keywordtype}{int} j,len;}
\DoxyCodeLine{4279                stbv\_uint32 crc;}
\DoxyCodeLine{4280                \textcolor{comment}{// make sure we have the whole page header}}
\DoxyCodeLine{4281                \textcolor{keywordflow}{if} (i+26 >= data\_len || i+27+data[i+26] >= data\_len) \{}
\DoxyCodeLine{4282                   \textcolor{comment}{// only read up to this page start, so hopefully we'll}}
\DoxyCodeLine{4283                   \textcolor{comment}{// have the whole page header start next time}}
\DoxyCodeLine{4284                   data\_len = i;}
\DoxyCodeLine{4285                   \textcolor{keywordflow}{break};}
\DoxyCodeLine{4286                \}}
\DoxyCodeLine{4287                \textcolor{comment}{// ok, we have it all; compute the length of the page}}
\DoxyCodeLine{4288                len = 27 + data[i+26];}
\DoxyCodeLine{4289                \textcolor{keywordflow}{for} (j=0; j < data[i+26]; ++j)}
\DoxyCodeLine{4290                   len += data[i+27+j];}
\DoxyCodeLine{4291                \textcolor{comment}{// scan everything up to the embedded crc (which we must 0)}}
\DoxyCodeLine{4292                crc = 0;}
\DoxyCodeLine{4293                \textcolor{keywordflow}{for} (j=0; j < 22; ++j)}
\DoxyCodeLine{4294                   crc = stbv\_crc32\_update(crc, data[i+j]);}
\DoxyCodeLine{4295                \textcolor{comment}{// now process 4 0-\/bytes}}
\DoxyCodeLine{4296                \textcolor{keywordflow}{for} (   ; j < 26; ++j)}
\DoxyCodeLine{4297                   crc = stbv\_crc32\_update(crc, 0);}
\DoxyCodeLine{4298                \textcolor{comment}{// len is the total number of bytes we need to scan}}
\DoxyCodeLine{4299                n = f-\/>page\_crc\_tests++;}
\DoxyCodeLine{4300                f-\/>scan[n].bytes\_left = len-\/j;}
\DoxyCodeLine{4301                f-\/>scan[n].crc\_so\_far = crc;}
\DoxyCodeLine{4302                f-\/>scan[n].goal\_crc = data[i+22] + (data[i+23] << 8) + (data[i+24]<<16) + (data[i+25]<<24);}
\DoxyCodeLine{4303                \textcolor{comment}{// if the last frame on a page is continued to the next, then}}
\DoxyCodeLine{4304                \textcolor{comment}{// we can't recover the sample\_loc immediately}}
\DoxyCodeLine{4305                \textcolor{keywordflow}{if} (data[i+27+data[i+26]-\/1] == 255)}
\DoxyCodeLine{4306                   f-\/>scan[n].sample\_loc = \string~0;}
\DoxyCodeLine{4307                \textcolor{keywordflow}{else}}
\DoxyCodeLine{4308                   f-\/>scan[n].sample\_loc = data[i+6] + (data[i+7] << 8) + (data[i+ 8]<<16) + (data[i+ 9]<<24);}
\DoxyCodeLine{4309                f-\/>scan[n].bytes\_done = i+j;}
\DoxyCodeLine{4310                \textcolor{keywordflow}{if} (f-\/>page\_crc\_tests == STB\_VORBIS\_PUSHDATA\_CRC\_COUNT)}
\DoxyCodeLine{4311                   \textcolor{keywordflow}{break};}
\DoxyCodeLine{4312                \textcolor{comment}{// keep going if we still have room for more}}
\DoxyCodeLine{4313             \}}
\DoxyCodeLine{4314          \}}
\DoxyCodeLine{4315       \}}
\DoxyCodeLine{4316    \}}
\DoxyCodeLine{4317 }
\DoxyCodeLine{4318    \textcolor{keywordflow}{for} (i=0; i < f-\/>page\_crc\_tests;) \{}
\DoxyCodeLine{4319       stbv\_uint32 crc;}
\DoxyCodeLine{4320       \textcolor{keywordtype}{int} j;}
\DoxyCodeLine{4321       \textcolor{keywordtype}{int} n = f-\/>scan[i].bytes\_done;}
\DoxyCodeLine{4322       \textcolor{keywordtype}{int} m = f-\/>scan[i].bytes\_left;}
\DoxyCodeLine{4323       \textcolor{keywordflow}{if} (m > data\_len -\/ n) m = data\_len -\/ n;}
\DoxyCodeLine{4324       \textcolor{comment}{// m is the bytes to scan in the current chunk}}
\DoxyCodeLine{4325       crc = f-\/>scan[i].crc\_so\_far;}
\DoxyCodeLine{4326       \textcolor{keywordflow}{for} (j=0; j < m; ++j)}
\DoxyCodeLine{4327          crc = stbv\_crc32\_update(crc, data[n+j]);}
\DoxyCodeLine{4328       f-\/>scan[i].bytes\_left -\/= m;}
\DoxyCodeLine{4329       f-\/>scan[i].crc\_so\_far = crc;}
\DoxyCodeLine{4330       \textcolor{keywordflow}{if} (f-\/>scan[i].bytes\_left == 0) \{}
\DoxyCodeLine{4331          \textcolor{comment}{// does it match?}}
\DoxyCodeLine{4332          \textcolor{keywordflow}{if} (f-\/>scan[i].crc\_so\_far == f-\/>scan[i].goal\_crc) \{}
\DoxyCodeLine{4333             \textcolor{comment}{// Houston, we have page}}
\DoxyCodeLine{4334             data\_len = n+m; \textcolor{comment}{// consumption amount is wherever that scan ended}}
\DoxyCodeLine{4335             f-\/>page\_crc\_tests = -\/1; \textcolor{comment}{// drop out of page scan mode}}
\DoxyCodeLine{4336             f-\/>previous\_length = 0; \textcolor{comment}{// decode-\/but-\/don't-\/output one frame}}
\DoxyCodeLine{4337             f-\/>next\_seg = -\/1;       \textcolor{comment}{// start a new page}}
\DoxyCodeLine{4338             f-\/>current\_loc = f-\/>scan[i].sample\_loc; \textcolor{comment}{// set the current sample location}}
\DoxyCodeLine{4339                                     \textcolor{comment}{// to the amount we'd have decoded had we decoded this page}}
\DoxyCodeLine{4340             f-\/>current\_loc\_valid = f-\/>current\_loc != \string~0U;}
\DoxyCodeLine{4341             \textcolor{keywordflow}{return} data\_len;}
\DoxyCodeLine{4342          \}}
\DoxyCodeLine{4343          \textcolor{comment}{// delete entry}}
\DoxyCodeLine{4344          f-\/>scan[i] = f-\/>scan[-\/-\/f-\/>page\_crc\_tests];}
\DoxyCodeLine{4345       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4346          ++i;}
\DoxyCodeLine{4347       \}}
\DoxyCodeLine{4348    \}}
\DoxyCodeLine{4349 }
\DoxyCodeLine{4350    \textcolor{keywordflow}{return} data\_len;}
\DoxyCodeLine{4351 \}}
\DoxyCodeLine{4352 }
\DoxyCodeLine{4353 \textcolor{comment}{// return value: number of bytes we used}}
\DoxyCodeLine{4354 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_decode\_frame\_pushdata(}
\DoxyCodeLine{4355          stb\_vorbis *f,                   \textcolor{comment}{// the file we're decoding}}
\DoxyCodeLine{4356          \textcolor{keyword}{const} stbv\_uint8 *data, \textcolor{keywordtype}{int} data\_len, \textcolor{comment}{// the memory available for decoding}}
\DoxyCodeLine{4357          \textcolor{keywordtype}{int} *channels,                   \textcolor{comment}{// place to write number of float * buffers}}
\DoxyCodeLine{4358          \textcolor{keywordtype}{float} ***output,                 \textcolor{comment}{// place to write float ** array of float * buffers}}
\DoxyCodeLine{4359          \textcolor{keywordtype}{int} *samples                     \textcolor{comment}{// place to write number of output samples}}
\DoxyCodeLine{4360      )}
\DoxyCodeLine{4361 \{}
\DoxyCodeLine{4362    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{4363    \textcolor{keywordtype}{int} len,right,left;}
\DoxyCodeLine{4364 }
\DoxyCodeLine{4365    \textcolor{keywordflow}{if} (!STBV\_IS\_PUSH\_MODE(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_api\_mixing);}
\DoxyCodeLine{4366 }
\DoxyCodeLine{4367    \textcolor{keywordflow}{if} (f-\/>page\_crc\_tests >= 0) \{}
\DoxyCodeLine{4368       *samples = 0;}
\DoxyCodeLine{4369       \textcolor{keywordflow}{return} stbv\_vorbis\_search\_for\_page\_pushdata(f, (stbv\_uint8 *) data, data\_len);}
\DoxyCodeLine{4370    \}}
\DoxyCodeLine{4371 }
\DoxyCodeLine{4372    f-\/>stream     = (stbv\_uint8 *) data;}
\DoxyCodeLine{4373    f-\/>stream\_end = (stbv\_uint8 *) data + data\_len;}
\DoxyCodeLine{4374    f-\/>error      = VORBIS\_\_no\_error;}
\DoxyCodeLine{4375 }
\DoxyCodeLine{4376    \textcolor{comment}{// check that we have the entire packet in memory}}
\DoxyCodeLine{4377    \textcolor{keywordflow}{if} (!stbv\_is\_whole\_packet\_present(f, FALSE)) \{}
\DoxyCodeLine{4378       *samples = 0;}
\DoxyCodeLine{4379       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4380    \}}
\DoxyCodeLine{4381 }
\DoxyCodeLine{4382    \textcolor{keywordflow}{if} (!stbv\_vorbis\_decode\_packet(f, \&len, \&left, \&right)) \{}
\DoxyCodeLine{4383       \textcolor{comment}{// save the actual error we encountered}}
\DoxyCodeLine{4384       \textcolor{keyword}{enum} STBVorbisError \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = f-\/>error;}
\DoxyCodeLine{4385       \textcolor{keywordflow}{if} (error == VORBIS\_bad\_packet\_type) \{}
\DoxyCodeLine{4386          \textcolor{comment}{// flush and resynch}}
\DoxyCodeLine{4387          f-\/>error = VORBIS\_\_no\_error;}
\DoxyCodeLine{4388          \textcolor{keywordflow}{while} (stbv\_get8\_packet(f) != STBV\_EOP)}
\DoxyCodeLine{4389             \textcolor{keywordflow}{if} (f-\/>eof) \textcolor{keywordflow}{break};}
\DoxyCodeLine{4390          *samples = 0;}
\DoxyCodeLine{4391          \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int}) (f-\/>stream -\/ data);}
\DoxyCodeLine{4392       \}}
\DoxyCodeLine{4393       \textcolor{keywordflow}{if} (error == VORBIS\_continued\_packet\_flag\_invalid) \{}
\DoxyCodeLine{4394          \textcolor{keywordflow}{if} (f-\/>previous\_length == 0) \{}
\DoxyCodeLine{4395             \textcolor{comment}{// we may be resynching, in which case it's ok to hit one}}
\DoxyCodeLine{4396             \textcolor{comment}{// of these; just discard the packet}}
\DoxyCodeLine{4397             f-\/>error = VORBIS\_\_no\_error;}
\DoxyCodeLine{4398             \textcolor{keywordflow}{while} (stbv\_get8\_packet(f) != STBV\_EOP)}
\DoxyCodeLine{4399                \textcolor{keywordflow}{if} (f-\/>eof) \textcolor{keywordflow}{break};}
\DoxyCodeLine{4400             *samples = 0;}
\DoxyCodeLine{4401             \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int}) (f-\/>stream -\/ data);}
\DoxyCodeLine{4402          \}}
\DoxyCodeLine{4403       \}}
\DoxyCodeLine{4404       \textcolor{comment}{// if we get an error while parsing, what to do?}}
\DoxyCodeLine{4405       \textcolor{comment}{// well, it DEFINITELY won't work to continue from where we are!}}
\DoxyCodeLine{4406       stb\_vorbis\_flush\_pushdata(f);}
\DoxyCodeLine{4407       \textcolor{comment}{// restore the error that actually made us bail}}
\DoxyCodeLine{4408       f-\/>error = \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{4409       *samples = 0;}
\DoxyCodeLine{4410       \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4411    \}}
\DoxyCodeLine{4412 }
\DoxyCodeLine{4413    \textcolor{comment}{// success!}}
\DoxyCodeLine{4414    len = stbv\_vorbis\_finish\_frame(f, len, left, right);}
\DoxyCodeLine{4415    \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i)}
\DoxyCodeLine{4416       f-\/>outputs[i] = f-\/>channel\_buffers[i] + left;}
\DoxyCodeLine{4417 }
\DoxyCodeLine{4418    if (channels) *channels = f-\/>channels;}
\DoxyCodeLine{4419    *samples = len;}
\DoxyCodeLine{4420    *output = f-\/>outputs;}
\DoxyCodeLine{4421    \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int}) (f-\/>stream -\/ data);}
\DoxyCodeLine{4422 \}}
\DoxyCodeLine{4423 }
\DoxyCodeLine{4424 STBVDEF stb\_vorbis *stb\_vorbis\_open\_pushdata(}
\DoxyCodeLine{4425          \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} data\_len, \textcolor{comment}{// the memory available for decoding}}
\DoxyCodeLine{4426          \textcolor{keywordtype}{int} *data\_used,              \textcolor{comment}{// only defined if result is not NULL}}
\DoxyCodeLine{4427          \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc)}
\DoxyCodeLine{4428 \{}
\DoxyCodeLine{4429    stb\_vorbis *f, p;}
\DoxyCodeLine{4430    stbv\_vorbis\_init(\&p, alloc);}
\DoxyCodeLine{4431    p.stream     = (stbv\_uint8 *) data;}
\DoxyCodeLine{4432    p.stream\_end = (stbv\_uint8 *) data + data\_len;}
\DoxyCodeLine{4433    p.push\_mode  = TRUE;}
\DoxyCodeLine{4434    \textcolor{keywordflow}{if} (!stbv\_start\_decoder(\&p)) \{}
\DoxyCodeLine{4435       \textcolor{keywordflow}{if} (p.eof)}
\DoxyCodeLine{4436          *\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = VORBIS\_need\_more\_data;}
\DoxyCodeLine{4437       \textcolor{keywordflow}{else}}
\DoxyCodeLine{4438          *\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = p.error;}
\DoxyCodeLine{4439       \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{4440    \}}
\DoxyCodeLine{4441    f = stbv\_vorbis\_alloc(\&p);}
\DoxyCodeLine{4442    \textcolor{keywordflow}{if} (f) \{}
\DoxyCodeLine{4443       *f = p;}
\DoxyCodeLine{4444       *data\_used = (int) (f-\/>stream -\/ data);}
\DoxyCodeLine{4445       *\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = 0;}
\DoxyCodeLine{4446       \textcolor{keywordflow}{return} f;}
\DoxyCodeLine{4447    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4448       stbv\_vorbis\_deinit(\&p);}
\DoxyCodeLine{4449       \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{4450    \}}
\DoxyCodeLine{4451 \}}
\DoxyCodeLine{4452 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{4453 }
\DoxyCodeLine{4454 STBVDEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} stb\_vorbis\_get\_file\_offset(stb\_vorbis *f)}
\DoxyCodeLine{4455 \{}
\DoxyCodeLine{4456 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_PUSHDATA\_API}}
\DoxyCodeLine{4457    \textcolor{keywordflow}{if} (f-\/>push\_mode) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4458 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{4459    \textcolor{keywordflow}{if} (STBV\_USE\_MEMORY(f)) \textcolor{keywordflow}{return} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) (f-\/>stream -\/ f-\/>stream\_start);}
\DoxyCodeLine{4460 \textcolor{preprocessor}{   \#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{4461    \textcolor{keywordflow}{return} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) (ftell(f-\/>f) -\/ f-\/>f\_start);}
\DoxyCodeLine{4462 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{4463 \}}
\DoxyCodeLine{4464 }
\DoxyCodeLine{4465 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_PULLDATA\_API}}
\DoxyCodeLine{4466 \textcolor{comment}{//}}
\DoxyCodeLine{4467 \textcolor{comment}{// DATA-\/PULLING API}}
\DoxyCodeLine{4468 \textcolor{comment}{//}}
\DoxyCodeLine{4469 }
\DoxyCodeLine{4470 \textcolor{keyword}{static} stbv\_uint32 stbv\_vorbis\_find\_page(stb\_vorbis *f, stbv\_uint32 *end, stbv\_uint32 *last)}
\DoxyCodeLine{4471 \{}
\DoxyCodeLine{4472    \textcolor{keywordflow}{for}(;;) \{}
\DoxyCodeLine{4473       \textcolor{keywordtype}{int} n;}
\DoxyCodeLine{4474       \textcolor{keywordflow}{if} (f-\/>eof) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4475       n = stbv\_get8(f);}
\DoxyCodeLine{4476       \textcolor{keywordflow}{if} (n == 0x4f) \{ \textcolor{comment}{// page header candidate}}
\DoxyCodeLine{4477          \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} retry\_loc = stb\_vorbis\_get\_file\_offset(f);}
\DoxyCodeLine{4478          \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{4479          \textcolor{comment}{// check if we're off the end of a file\_section stream}}
\DoxyCodeLine{4480          \textcolor{keywordflow}{if} (retry\_loc -\/ 25 > f-\/>stream\_len)}
\DoxyCodeLine{4481             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4482          \textcolor{comment}{// check the rest of the header}}
\DoxyCodeLine{4483          \textcolor{keywordflow}{for} (i=1; i < 4; ++i)}
\DoxyCodeLine{4484             \textcolor{keywordflow}{if} (stbv\_get8(f) != stbv\_ogg\_page\_header[i])}
\DoxyCodeLine{4485                \textcolor{keywordflow}{break};}
\DoxyCodeLine{4486          \textcolor{keywordflow}{if} (f-\/>eof) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4487          \textcolor{keywordflow}{if} (i == 4) \{}
\DoxyCodeLine{4488             stbv\_uint8 header[27];}
\DoxyCodeLine{4489             stbv\_uint32 i, crc, goal, len;}
\DoxyCodeLine{4490             \textcolor{keywordflow}{for} (i=0; i < 4; ++i)}
\DoxyCodeLine{4491                header[i] = stbv\_ogg\_page\_header[i];}
\DoxyCodeLine{4492             \textcolor{keywordflow}{for} (; i < 27; ++i)}
\DoxyCodeLine{4493                header[i] = stbv\_get8(f);}
\DoxyCodeLine{4494             \textcolor{keywordflow}{if} (f-\/>eof) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4495             \textcolor{keywordflow}{if} (header[4] != 0) \textcolor{keywordflow}{goto} invalid;}
\DoxyCodeLine{4496             goal = header[22] + (header[23] << 8) + (header[24]<<16) + (header[25]<<24);}
\DoxyCodeLine{4497             \textcolor{keywordflow}{for} (i=22; i < 26; ++i)}
\DoxyCodeLine{4498                header[i] = 0;}
\DoxyCodeLine{4499             crc = 0;}
\DoxyCodeLine{4500             \textcolor{keywordflow}{for} (i=0; i < 27; ++i)}
\DoxyCodeLine{4501                crc = stbv\_crc32\_update(crc, header[i]);}
\DoxyCodeLine{4502             len = 0;}
\DoxyCodeLine{4503             \textcolor{keywordflow}{for} (i=0; i < header[26]; ++i) \{}
\DoxyCodeLine{4504                \textcolor{keywordtype}{int} s = stbv\_get8(f);}
\DoxyCodeLine{4505                crc = stbv\_crc32\_update(crc, s);}
\DoxyCodeLine{4506                len += s;}
\DoxyCodeLine{4507             \}}
\DoxyCodeLine{4508             \textcolor{keywordflow}{if} (len \&\& f-\/>eof) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4509             \textcolor{keywordflow}{for} (i=0; i < len; ++i)}
\DoxyCodeLine{4510                crc = stbv\_crc32\_update(crc, stbv\_get8(f));}
\DoxyCodeLine{4511             \textcolor{comment}{// finished parsing probable page}}
\DoxyCodeLine{4512             \textcolor{keywordflow}{if} (crc == goal) \{}
\DoxyCodeLine{4513                \textcolor{comment}{// we could now check that it's either got the last}}
\DoxyCodeLine{4514                \textcolor{comment}{// page flag set, OR it's followed by the capture}}
\DoxyCodeLine{4515                \textcolor{comment}{// pattern, but I guess TECHNICALLY you could have}}
\DoxyCodeLine{4516                \textcolor{comment}{// a file with garbage between each ogg page and recover}}
\DoxyCodeLine{4517                \textcolor{comment}{// from it automatically? So even though that paranoia}}
\DoxyCodeLine{4518                \textcolor{comment}{// might decrease the chance of an invalid decode by}}
\DoxyCodeLine{4519                \textcolor{comment}{// another 2\string^32, not worth it since it would hose those}}
\DoxyCodeLine{4520                \textcolor{comment}{// invalid-\/but-\/useful files?}}
\DoxyCodeLine{4521                \textcolor{keywordflow}{if} (end)}
\DoxyCodeLine{4522                   *end = stb\_vorbis\_get\_file\_offset(f);}
\DoxyCodeLine{4523                \textcolor{keywordflow}{if} (last) \{}
\DoxyCodeLine{4524                   \textcolor{keywordflow}{if} (header[5] \& 0x04)}
\DoxyCodeLine{4525                      *last = 1;}
\DoxyCodeLine{4526                   \textcolor{keywordflow}{else}}
\DoxyCodeLine{4527                      *last = 0;}
\DoxyCodeLine{4528                \}}
\DoxyCodeLine{4529                stbv\_set\_file\_offset(f, retry\_loc-\/1);}
\DoxyCodeLine{4530                \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4531             \}}
\DoxyCodeLine{4532          \}}
\DoxyCodeLine{4533         invalid:}
\DoxyCodeLine{4534          \textcolor{comment}{// not a valid page, so rewind and look for next one}}
\DoxyCodeLine{4535          stbv\_set\_file\_offset(f, retry\_loc);}
\DoxyCodeLine{4536       \}}
\DoxyCodeLine{4537    \}}
\DoxyCodeLine{4538 \}}
\DoxyCodeLine{4539 }
\DoxyCodeLine{4540 }
\DoxyCodeLine{4541 \textcolor{preprocessor}{\#define STBV\_SAMPLE\_unknown  0xffffffff}}
\DoxyCodeLine{4542 }
\DoxyCodeLine{4543 \textcolor{comment}{// seeking is implemented with a binary search, which narrows down the range to}}
\DoxyCodeLine{4544 \textcolor{comment}{// 64K, before using a linear search (because finding the synchronization}}
\DoxyCodeLine{4545 \textcolor{comment}{// pattern can be expensive, and the chance we'd find the end page again is}}
\DoxyCodeLine{4546 \textcolor{comment}{// relatively high for small ranges)}}
\DoxyCodeLine{4547 \textcolor{comment}{//}}
\DoxyCodeLine{4548 \textcolor{comment}{// two initial interpolation-\/style probes are used at the start of the search}}
\DoxyCodeLine{4549 \textcolor{comment}{// to try to bound either side of the binary search sensibly, while still}}
\DoxyCodeLine{4550 \textcolor{comment}{// working in O(log n) time if they fail.}}
\DoxyCodeLine{4551 }
\DoxyCodeLine{4552 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_get\_seek\_page\_info(stb\_vorbis *f, StbvProbedPage *z)}
\DoxyCodeLine{4553 \{}
\DoxyCodeLine{4554    stbv\_uint8 header[27], lacing[255];}
\DoxyCodeLine{4555    \textcolor{keywordtype}{int} i,len;}
\DoxyCodeLine{4556 }
\DoxyCodeLine{4557    \textcolor{comment}{// record where the page starts}}
\DoxyCodeLine{4558    z-\/>page\_start = stb\_vorbis\_get\_file\_offset(f);}
\DoxyCodeLine{4559 }
\DoxyCodeLine{4560    \textcolor{comment}{// parse the header}}
\DoxyCodeLine{4561    stbv\_getn(f, header, 27);}
\DoxyCodeLine{4562    \textcolor{keywordflow}{if} (header[0] != \textcolor{charliteral}{'O'} || header[1] != \textcolor{charliteral}{'g'} || header[2] != \textcolor{charliteral}{'g'} || header[3] != \textcolor{charliteral}{'S'})}
\DoxyCodeLine{4563       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4564    stbv\_getn(f, lacing, header[26]);}
\DoxyCodeLine{4565 }
\DoxyCodeLine{4566    \textcolor{comment}{// determine the length of the payload}}
\DoxyCodeLine{4567    len = 0;}
\DoxyCodeLine{4568    \textcolor{keywordflow}{for} (i=0; i < header[26]; ++i)}
\DoxyCodeLine{4569       len += lacing[i];}
\DoxyCodeLine{4570 }
\DoxyCodeLine{4571    \textcolor{comment}{// this implies where the page ends}}
\DoxyCodeLine{4572    z-\/>page\_end = z-\/>page\_start + 27 + header[26] + len;}
\DoxyCodeLine{4573 }
\DoxyCodeLine{4574    \textcolor{comment}{// read the last-\/decoded sample out of the data}}
\DoxyCodeLine{4575    z-\/>last\_decoded\_sample = header[6] + (header[7] << 8) + (header[8] << 16) + (header[9] << 24);}
\DoxyCodeLine{4576 }
\DoxyCodeLine{4577    \textcolor{comment}{// restore file state to where we were}}
\DoxyCodeLine{4578    stbv\_set\_file\_offset(f, z-\/>page\_start);}
\DoxyCodeLine{4579    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4580 \}}
\DoxyCodeLine{4581 }
\DoxyCodeLine{4582 \textcolor{comment}{// rarely used function to seek back to the preceeding page while finding the}}
\DoxyCodeLine{4583 \textcolor{comment}{// start of a packet}}
\DoxyCodeLine{4584 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_go\_to\_page\_before(stb\_vorbis *f, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} limit\_offset)}
\DoxyCodeLine{4585 \{}
\DoxyCodeLine{4586    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} previous\_safe, end;}
\DoxyCodeLine{4587 }
\DoxyCodeLine{4588    \textcolor{comment}{// now we want to seek back 64K from the limit}}
\DoxyCodeLine{4589    \textcolor{keywordflow}{if} (limit\_offset >= 65536 \&\& limit\_offset-\/65536 >= f-\/>first\_audio\_page\_offset)}
\DoxyCodeLine{4590       previous\_safe = limit\_offset -\/ 65536;}
\DoxyCodeLine{4591    \textcolor{keywordflow}{else}}
\DoxyCodeLine{4592       previous\_safe = f-\/>first\_audio\_page\_offset;}
\DoxyCodeLine{4593 }
\DoxyCodeLine{4594    stbv\_set\_file\_offset(f, previous\_safe);}
\DoxyCodeLine{4595 }
\DoxyCodeLine{4596    \textcolor{keywordflow}{while} (stbv\_vorbis\_find\_page(f, \&end, NULL)) \{}
\DoxyCodeLine{4597       \textcolor{keywordflow}{if} (end >= limit\_offset \&\& stb\_vorbis\_get\_file\_offset(f) < limit\_offset)}
\DoxyCodeLine{4598          \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4599       stbv\_set\_file\_offset(f, end);}
\DoxyCodeLine{4600    \}}
\DoxyCodeLine{4601 }
\DoxyCodeLine{4602    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4603 \}}
\DoxyCodeLine{4604 }
\DoxyCodeLine{4605 \textcolor{comment}{// implements the search logic for finding a page and starting decoding. if}}
\DoxyCodeLine{4606 \textcolor{comment}{// the function succeeds, current\_loc\_valid will be true and current\_loc will}}
\DoxyCodeLine{4607 \textcolor{comment}{// be less than or equal to the provided sample number (the closer the}}
\DoxyCodeLine{4608 \textcolor{comment}{// better).}}
\DoxyCodeLine{4609 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_seek\_to\_sample\_coarse(stb\_vorbis *f, stbv\_uint32 sample\_number)}
\DoxyCodeLine{4610 \{}
\DoxyCodeLine{4611    StbvProbedPage left, right, mid;}
\DoxyCodeLine{4612    \textcolor{keywordtype}{int} i, start\_seg\_with\_known\_loc, end\_pos, page\_start;}
\DoxyCodeLine{4613    stbv\_uint32 delta, stream\_length, padding;}
\DoxyCodeLine{4614    \textcolor{keywordtype}{double} offset, bytes\_per\_sample;}
\DoxyCodeLine{4615    \textcolor{keywordtype}{int} probe = 0;}
\DoxyCodeLine{4616 }
\DoxyCodeLine{4617    \textcolor{comment}{// find the last page and validate the target sample}}
\DoxyCodeLine{4618    stream\_length = stb\_vorbis\_stream\_length\_in\_samples(f);}
\DoxyCodeLine{4619    \textcolor{keywordflow}{if} (stream\_length == 0)            \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_seek\_without\_length);}
\DoxyCodeLine{4620    \textcolor{keywordflow}{if} (sample\_number > stream\_length) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_seek\_invalid);}
\DoxyCodeLine{4621 }
\DoxyCodeLine{4622    \textcolor{comment}{// this is the maximum difference between the window-\/center (which is the}}
\DoxyCodeLine{4623    \textcolor{comment}{// actual granule position value), and the right-\/start (which the spec}}
\DoxyCodeLine{4624    \textcolor{comment}{// indicates should be the granule position (give or take one)).}}
\DoxyCodeLine{4625    padding = ((f-\/>blocksize\_1 -\/ f-\/>blocksize\_0) >> 2);}
\DoxyCodeLine{4626    \textcolor{keywordflow}{if} (sample\_number < padding)}
\DoxyCodeLine{4627       sample\_number = 0;}
\DoxyCodeLine{4628    \textcolor{keywordflow}{else}}
\DoxyCodeLine{4629       sample\_number -\/= padding;}
\DoxyCodeLine{4630 }
\DoxyCodeLine{4631    left = f-\/>p\_first;}
\DoxyCodeLine{4632    \textcolor{keywordflow}{while} (left.last\_decoded\_sample == \string~0U) \{}
\DoxyCodeLine{4633       \textcolor{comment}{// (untested) the first page does not have a 'last\_decoded\_sample'}}
\DoxyCodeLine{4634       stbv\_set\_file\_offset(f, left.page\_end);}
\DoxyCodeLine{4635       \textcolor{keywordflow}{if} (!stbv\_get\_seek\_page\_info(f, \&left)) \textcolor{keywordflow}{goto} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{4636    \}}
\DoxyCodeLine{4637 }
\DoxyCodeLine{4638    right = f-\/>p\_last;}
\DoxyCodeLine{4639    assert(right.last\_decoded\_sample != \string~0U);}
\DoxyCodeLine{4640 }
\DoxyCodeLine{4641    \textcolor{comment}{// starting from the start is handled differently}}
\DoxyCodeLine{4642    \textcolor{keywordflow}{if} (sample\_number <= left.last\_decoded\_sample) \{}
\DoxyCodeLine{4643       \textcolor{keywordflow}{if} (stb\_vorbis\_seek\_start(f))}
\DoxyCodeLine{4644          \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4645       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4646    \}}
\DoxyCodeLine{4647 }
\DoxyCodeLine{4648    \textcolor{keywordflow}{while} (left.page\_end != right.page\_start) \{}
\DoxyCodeLine{4649       assert(left.page\_end < right.page\_start);}
\DoxyCodeLine{4650       \textcolor{comment}{// search range in bytes}}
\DoxyCodeLine{4651       delta = right.page\_start -\/ left.page\_end;}
\DoxyCodeLine{4652       \textcolor{keywordflow}{if} (delta <= 65536) \{}
\DoxyCodeLine{4653          \textcolor{comment}{// there's only 64K left to search -\/ handle it linearly}}
\DoxyCodeLine{4654          stbv\_set\_file\_offset(f, left.page\_end);}
\DoxyCodeLine{4655       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4656          \textcolor{keywordflow}{if} (probe < 2) \{}
\DoxyCodeLine{4657             \textcolor{keywordflow}{if} (probe == 0) \{}
\DoxyCodeLine{4658                \textcolor{comment}{// first probe (interpolate)}}
\DoxyCodeLine{4659                \textcolor{keywordtype}{double} data\_bytes = right.page\_end -\/ left.page\_start;}
\DoxyCodeLine{4660                bytes\_per\_sample = data\_bytes / right.last\_decoded\_sample;}
\DoxyCodeLine{4661                offset = left.page\_start + bytes\_per\_sample * (sample\_number -\/ left.last\_decoded\_sample);}
\DoxyCodeLine{4662             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4663                \textcolor{comment}{// second probe (try to bound the other side)}}
\DoxyCodeLine{4664                \textcolor{keywordtype}{double} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = ((double) sample\_number -\/ mid.last\_decoded\_sample) * bytes\_per\_sample;}
\DoxyCodeLine{4665                \textcolor{keywordflow}{if} (error >= 0 \&\& error <  8000) \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} =  8000;}
\DoxyCodeLine{4666                \textcolor{keywordflow}{if} (error <  0 \&\& error > -\/8000) \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = -\/8000;}
\DoxyCodeLine{4667                offset += \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} * 2;}
\DoxyCodeLine{4668             \}}
\DoxyCodeLine{4669 }
\DoxyCodeLine{4670             \textcolor{comment}{// ensure the offset is valid}}
\DoxyCodeLine{4671             \textcolor{keywordflow}{if} (offset < left.page\_end)}
\DoxyCodeLine{4672                offset = left.page\_end;}
\DoxyCodeLine{4673             \textcolor{keywordflow}{if} (offset > right.page\_start -\/ 65536)}
\DoxyCodeLine{4674                offset = right.page\_start -\/ 65536;}
\DoxyCodeLine{4675 }
\DoxyCodeLine{4676             stbv\_set\_file\_offset(f, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) offset);}
\DoxyCodeLine{4677          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4678             \textcolor{comment}{// binary search for large ranges (offset by 32K to ensure}}
\DoxyCodeLine{4679             \textcolor{comment}{// we don't hit the right page)}}
\DoxyCodeLine{4680             stbv\_set\_file\_offset(f, left.page\_end + (delta / 2) -\/ 32768);}
\DoxyCodeLine{4681          \}}
\DoxyCodeLine{4682 }
\DoxyCodeLine{4683          \textcolor{keywordflow}{if} (!stbv\_vorbis\_find\_page(f, NULL, NULL)) \textcolor{keywordflow}{goto} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{4684       \}}
\DoxyCodeLine{4685 }
\DoxyCodeLine{4686       \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{4687          \textcolor{keywordflow}{if} (!stbv\_get\_seek\_page\_info(f, \&mid)) \textcolor{keywordflow}{goto} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{4688          \textcolor{keywordflow}{if} (mid.last\_decoded\_sample != \string~0U) \textcolor{keywordflow}{break};}
\DoxyCodeLine{4689          \textcolor{comment}{// (untested) no frames end on this page}}
\DoxyCodeLine{4690          stbv\_set\_file\_offset(f, mid.page\_end);}
\DoxyCodeLine{4691          assert(mid.page\_start < right.page\_start);}
\DoxyCodeLine{4692       \}}
\DoxyCodeLine{4693 }
\DoxyCodeLine{4694       \textcolor{comment}{// if we've just found the last page again then we're in a tricky file,}}
\DoxyCodeLine{4695       \textcolor{comment}{// and we're close enough.}}
\DoxyCodeLine{4696       \textcolor{keywordflow}{if} (mid.page\_start == right.page\_start)}
\DoxyCodeLine{4697          \textcolor{keywordflow}{break};}
\DoxyCodeLine{4698 }
\DoxyCodeLine{4699       \textcolor{keywordflow}{if} (sample\_number < mid.last\_decoded\_sample)}
\DoxyCodeLine{4700          right = mid;}
\DoxyCodeLine{4701       \textcolor{keywordflow}{else}}
\DoxyCodeLine{4702          left = mid;}
\DoxyCodeLine{4703 }
\DoxyCodeLine{4704       ++probe;}
\DoxyCodeLine{4705    \}}
\DoxyCodeLine{4706 }
\DoxyCodeLine{4707    \textcolor{comment}{// seek back to start of the last packet}}
\DoxyCodeLine{4708    page\_start = left.page\_start;}
\DoxyCodeLine{4709    stbv\_set\_file\_offset(f, page\_start);}
\DoxyCodeLine{4710    \textcolor{keywordflow}{if} (!stbv\_start\_page(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_seek\_failed);}
\DoxyCodeLine{4711    end\_pos = f-\/>end\_seg\_with\_known\_loc;}
\DoxyCodeLine{4712    assert(end\_pos >= 0);}
\DoxyCodeLine{4713 }
\DoxyCodeLine{4714    \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{4715       \textcolor{keywordflow}{for} (i = end\_pos; i > 0; -\/-\/i)}
\DoxyCodeLine{4716          \textcolor{keywordflow}{if} (f-\/>segments[i-\/1] != 255)}
\DoxyCodeLine{4717             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4718 }
\DoxyCodeLine{4719       start\_seg\_with\_known\_loc = i;}
\DoxyCodeLine{4720 }
\DoxyCodeLine{4721       \textcolor{keywordflow}{if} (start\_seg\_with\_known\_loc > 0 || !(f-\/>page\_flag \& STBV\_PAGEFLAG\_continued\_packet))}
\DoxyCodeLine{4722          \textcolor{keywordflow}{break};}
\DoxyCodeLine{4723 }
\DoxyCodeLine{4724       \textcolor{comment}{// (untested) the final packet begins on an earlier page}}
\DoxyCodeLine{4725       \textcolor{keywordflow}{if} (!stbv\_go\_to\_page\_before(f, page\_start))}
\DoxyCodeLine{4726          \textcolor{keywordflow}{goto} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{4727 }
\DoxyCodeLine{4728       page\_start = stb\_vorbis\_get\_file\_offset(f);}
\DoxyCodeLine{4729       \textcolor{keywordflow}{if} (!stbv\_start\_page(f)) \textcolor{keywordflow}{goto} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{4730       end\_pos = f-\/>segment\_count -\/ 1;}
\DoxyCodeLine{4731    \}}
\DoxyCodeLine{4732 }
\DoxyCodeLine{4733    \textcolor{comment}{// prepare to start decoding}}
\DoxyCodeLine{4734    f-\/>current\_loc\_valid = FALSE;}
\DoxyCodeLine{4735    f-\/>last\_seg = FALSE;}
\DoxyCodeLine{4736    f-\/>valid\_bits = 0;}
\DoxyCodeLine{4737    f-\/>packet\_bytes = 0;}
\DoxyCodeLine{4738    f-\/>bytes\_in\_seg = 0;}
\DoxyCodeLine{4739    f-\/>previous\_length = 0;}
\DoxyCodeLine{4740    f-\/>next\_seg = start\_seg\_with\_known\_loc;}
\DoxyCodeLine{4741 }
\DoxyCodeLine{4742    \textcolor{keywordflow}{for} (i = 0; i < start\_seg\_with\_known\_loc; i++)}
\DoxyCodeLine{4743       stbv\_skip(f, f-\/>segments[i]);}
\DoxyCodeLine{4744 }
\DoxyCodeLine{4745    \textcolor{comment}{// start decoding (optimizable -\/ this frame is generally discarded)}}
\DoxyCodeLine{4746    \textcolor{keywordflow}{if} (!stbv\_vorbis\_pump\_first\_frame(f))}
\DoxyCodeLine{4747       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4748    \textcolor{keywordflow}{if} (f-\/>current\_loc > sample\_number)}
\DoxyCodeLine{4749       \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_seek\_failed);}
\DoxyCodeLine{4750    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4751 }
\DoxyCodeLine{4752 \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}}:}
\DoxyCodeLine{4753    \textcolor{comment}{// try to restore the file to a valid state}}
\DoxyCodeLine{4754    stb\_vorbis\_seek\_start(f);}
\DoxyCodeLine{4755    \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_seek\_failed);}
\DoxyCodeLine{4756 \}}
\DoxyCodeLine{4757 }
\DoxyCodeLine{4758 \textcolor{comment}{// the same as stbv\_vorbis\_decode\_initial, but without advancing}}
\DoxyCodeLine{4759 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbv\_peek\_decode\_initial(stbv\_vorb *f, \textcolor{keywordtype}{int} *p\_left\_start, \textcolor{keywordtype}{int} *p\_left\_end, \textcolor{keywordtype}{int} *p\_right\_start, \textcolor{keywordtype}{int} *p\_right\_end, \textcolor{keywordtype}{int} *mode)}
\DoxyCodeLine{4760 \{}
\DoxyCodeLine{4761    \textcolor{keywordtype}{int} bits\_read, bytes\_read;}
\DoxyCodeLine{4762 }
\DoxyCodeLine{4763    \textcolor{keywordflow}{if} (!stbv\_vorbis\_decode\_initial(f, p\_left\_start, p\_left\_end, p\_right\_start, p\_right\_end, mode))}
\DoxyCodeLine{4764       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4765 }
\DoxyCodeLine{4766    \textcolor{comment}{// either 1 or 2 bytes were read, figure out which so we can rewind}}
\DoxyCodeLine{4767    bits\_read = 1 + stbv\_ilog(f-\/>mode\_count-\/1);}
\DoxyCodeLine{4768    \textcolor{keywordflow}{if} (f-\/>mode\_config[*mode].blockflag)}
\DoxyCodeLine{4769       bits\_read += 2;}
\DoxyCodeLine{4770    bytes\_read = (bits\_read + 7) / 8;}
\DoxyCodeLine{4771 }
\DoxyCodeLine{4772    f-\/>bytes\_in\_seg += bytes\_read;}
\DoxyCodeLine{4773    f-\/>packet\_bytes -\/= bytes\_read;}
\DoxyCodeLine{4774    stbv\_skip(f, -\/bytes\_read);}
\DoxyCodeLine{4775    \textcolor{keywordflow}{if} (f-\/>next\_seg == -\/1)}
\DoxyCodeLine{4776       f-\/>next\_seg = f-\/>segment\_count -\/ 1;}
\DoxyCodeLine{4777    \textcolor{keywordflow}{else}}
\DoxyCodeLine{4778       f-\/>next\_seg-\/-\/;}
\DoxyCodeLine{4779    f-\/>valid\_bits = 0;}
\DoxyCodeLine{4780 }
\DoxyCodeLine{4781    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4782 \}}
\DoxyCodeLine{4783 }
\DoxyCodeLine{4784 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_seek\_frame(stb\_vorbis *f, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sample\_number)}
\DoxyCodeLine{4785 \{}
\DoxyCodeLine{4786    stbv\_uint32 max\_frame\_samples;}
\DoxyCodeLine{4787 }
\DoxyCodeLine{4788    \textcolor{keywordflow}{if} (STBV\_IS\_PUSH\_MODE(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_api\_mixing);}
\DoxyCodeLine{4789 }
\DoxyCodeLine{4790    \textcolor{comment}{// fast page-\/level search}}
\DoxyCodeLine{4791    \textcolor{keywordflow}{if} (!stbv\_seek\_to\_sample\_coarse(f, sample\_number))}
\DoxyCodeLine{4792       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4793 }
\DoxyCodeLine{4794    assert(f-\/>current\_loc\_valid);}
\DoxyCodeLine{4795    assert(f-\/>current\_loc <= sample\_number);}
\DoxyCodeLine{4796 }
\DoxyCodeLine{4797    \textcolor{comment}{// linear search for the relevant packet}}
\DoxyCodeLine{4798    max\_frame\_samples = (f-\/>blocksize\_1*3 -\/ f-\/>blocksize\_0) >> 2;}
\DoxyCodeLine{4799    \textcolor{keywordflow}{while} (f-\/>current\_loc < sample\_number) \{}
\DoxyCodeLine{4800       \textcolor{keywordtype}{int} left\_start, left\_end, right\_start, right\_end, mode, frame\_samples;}
\DoxyCodeLine{4801       \textcolor{keywordflow}{if} (!stbv\_peek\_decode\_initial(f, \&left\_start, \&left\_end, \&right\_start, \&right\_end, \&mode))}
\DoxyCodeLine{4802          \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_seek\_failed);}
\DoxyCodeLine{4803       \textcolor{comment}{// calculate the number of samples returned by the next frame}}
\DoxyCodeLine{4804       frame\_samples = right\_start -\/ left\_start;}
\DoxyCodeLine{4805       \textcolor{keywordflow}{if} (f-\/>current\_loc + frame\_samples > sample\_number) \{}
\DoxyCodeLine{4806          \textcolor{keywordflow}{return} 1; \textcolor{comment}{// the next frame will contain the sample}}
\DoxyCodeLine{4807       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (f-\/>current\_loc + frame\_samples + max\_frame\_samples > sample\_number) \{}
\DoxyCodeLine{4808          \textcolor{comment}{// there's a chance the frame after this could contain the sample}}
\DoxyCodeLine{4809          stbv\_vorbis\_pump\_first\_frame(f);}
\DoxyCodeLine{4810       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4811          \textcolor{comment}{// this frame is too early to be relevant}}
\DoxyCodeLine{4812          f-\/>current\_loc += frame\_samples;}
\DoxyCodeLine{4813          f-\/>previous\_length = 0;}
\DoxyCodeLine{4814          stbv\_maybe\_start\_packet(f);}
\DoxyCodeLine{4815          stbv\_flush\_packet(f);}
\DoxyCodeLine{4816       \}}
\DoxyCodeLine{4817    \}}
\DoxyCodeLine{4818    \textcolor{comment}{// the next frame will start with the sample}}
\DoxyCodeLine{4819    assert(f-\/>current\_loc == sample\_number);}
\DoxyCodeLine{4820    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4821 \}}
\DoxyCodeLine{4822 }
\DoxyCodeLine{4823 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_seek(stb\_vorbis *f, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sample\_number)}
\DoxyCodeLine{4824 \{}
\DoxyCodeLine{4825    \textcolor{keywordflow}{if} (!stb\_vorbis\_seek\_frame(f, sample\_number))}
\DoxyCodeLine{4826       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4827 }
\DoxyCodeLine{4828    \textcolor{keywordflow}{if} (sample\_number != f-\/>current\_loc) \{}
\DoxyCodeLine{4829       \textcolor{keywordtype}{int} n;}
\DoxyCodeLine{4830       stbv\_uint32 frame\_start = f-\/>current\_loc;}
\DoxyCodeLine{4831       stb\_vorbis\_get\_frame\_float(f, \&n, NULL);}
\DoxyCodeLine{4832       assert(sample\_number > frame\_start);}
\DoxyCodeLine{4833       assert(f-\/>channel\_buffer\_start + (\textcolor{keywordtype}{int}) (sample\_number-\/frame\_start) <= f-\/>channel\_buffer\_end);}
\DoxyCodeLine{4834       f-\/>channel\_buffer\_start += (sample\_number -\/ frame\_start);}
\DoxyCodeLine{4835    \}}
\DoxyCodeLine{4836 }
\DoxyCodeLine{4837    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4838 \}}
\DoxyCodeLine{4839 }
\DoxyCodeLine{4840 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_seek\_start(stb\_vorbis *f)}
\DoxyCodeLine{4841 \{}
\DoxyCodeLine{4842    \textcolor{keywordflow}{if} (STBV\_IS\_PUSH\_MODE(f)) \{ \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_api\_mixing); \}}
\DoxyCodeLine{4843    stbv\_set\_file\_offset(f, f-\/>first\_audio\_page\_offset);}
\DoxyCodeLine{4844    f-\/>previous\_length = 0;}
\DoxyCodeLine{4845    f-\/>first\_decode = TRUE;}
\DoxyCodeLine{4846    f-\/>next\_seg = -\/1;}
\DoxyCodeLine{4847    \textcolor{keywordflow}{return} stbv\_vorbis\_pump\_first\_frame(f);}
\DoxyCodeLine{4848 \}}
\DoxyCodeLine{4849 }
\DoxyCodeLine{4850 STBVDEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} stb\_vorbis\_stream\_length\_in\_samples(stb\_vorbis *f)}
\DoxyCodeLine{4851 \{}
\DoxyCodeLine{4852    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} restore\_offset, previous\_safe;}
\DoxyCodeLine{4853    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} end, last\_page\_loc;}
\DoxyCodeLine{4854 }
\DoxyCodeLine{4855    \textcolor{keywordflow}{if} (STBV\_IS\_PUSH\_MODE(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_api\_mixing);}
\DoxyCodeLine{4856    \textcolor{keywordflow}{if} (!f-\/>total\_samples) \{}
\DoxyCodeLine{4857       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} last;}
\DoxyCodeLine{4858       stbv\_uint32 lo,hi;}
\DoxyCodeLine{4859       \textcolor{keywordtype}{char} header[6];}
\DoxyCodeLine{4860 }
\DoxyCodeLine{4861       \textcolor{comment}{// first, store the current decode position so we can restore it}}
\DoxyCodeLine{4862       restore\_offset = stb\_vorbis\_get\_file\_offset(f);}
\DoxyCodeLine{4863 }
\DoxyCodeLine{4864       \textcolor{comment}{// now we want to seek back 64K from the end (the last page must}}
\DoxyCodeLine{4865       \textcolor{comment}{// be at most a little less than 64K, but let's allow a little slop)}}
\DoxyCodeLine{4866       \textcolor{keywordflow}{if} (f-\/>stream\_len >= 65536 \&\& f-\/>stream\_len-\/65536 >= f-\/>first\_audio\_page\_offset)}
\DoxyCodeLine{4867          previous\_safe = f-\/>stream\_len -\/ 65536;}
\DoxyCodeLine{4868       \textcolor{keywordflow}{else}}
\DoxyCodeLine{4869          previous\_safe = f-\/>first\_audio\_page\_offset;}
\DoxyCodeLine{4870 }
\DoxyCodeLine{4871       stbv\_set\_file\_offset(f, previous\_safe);}
\DoxyCodeLine{4872       \textcolor{comment}{// previous\_safe is now our candidate 'earliest known place that seeking}}
\DoxyCodeLine{4873       \textcolor{comment}{// to will lead to the final page'}}
\DoxyCodeLine{4874 }
\DoxyCodeLine{4875       \textcolor{keywordflow}{if} (!stbv\_vorbis\_find\_page(f, \&end, \&last)) \{}
\DoxyCodeLine{4876          \textcolor{comment}{// if we can't find a page, we're hosed!}}
\DoxyCodeLine{4877          f-\/>error = VORBIS\_cant\_find\_last\_page;}
\DoxyCodeLine{4878          f-\/>total\_samples = 0xffffffff;}
\DoxyCodeLine{4879          \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{4880       \}}
\DoxyCodeLine{4881 }
\DoxyCodeLine{4882       \textcolor{comment}{// check if there are more pages}}
\DoxyCodeLine{4883       last\_page\_loc = stb\_vorbis\_get\_file\_offset(f);}
\DoxyCodeLine{4884 }
\DoxyCodeLine{4885       \textcolor{comment}{// stop when the last\_page flag is set, not when we reach eof;}}
\DoxyCodeLine{4886       \textcolor{comment}{// this allows us to stop short of a 'file\_section' end without}}
\DoxyCodeLine{4887       \textcolor{comment}{// explicitly checking the length of the section}}
\DoxyCodeLine{4888       \textcolor{keywordflow}{while} (!last) \{}
\DoxyCodeLine{4889          stbv\_set\_file\_offset(f, end);}
\DoxyCodeLine{4890          \textcolor{keywordflow}{if} (!stbv\_vorbis\_find\_page(f, \&end, \&last)) \{}
\DoxyCodeLine{4891             \textcolor{comment}{// the last page we found didn't have the 'last page' flag}}
\DoxyCodeLine{4892             \textcolor{comment}{// set. whoops!}}
\DoxyCodeLine{4893             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4894          \}}
\DoxyCodeLine{4895          previous\_safe = last\_page\_loc+1;}
\DoxyCodeLine{4896          last\_page\_loc = stb\_vorbis\_get\_file\_offset(f);}
\DoxyCodeLine{4897       \}}
\DoxyCodeLine{4898 }
\DoxyCodeLine{4899       stbv\_set\_file\_offset(f, last\_page\_loc);}
\DoxyCodeLine{4900 }
\DoxyCodeLine{4901       \textcolor{comment}{// parse the header}}
\DoxyCodeLine{4902       stbv\_getn(f, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)header, 6);}
\DoxyCodeLine{4903       \textcolor{comment}{// extract the absolute granule position}}
\DoxyCodeLine{4904       lo = stbv\_get32(f);}
\DoxyCodeLine{4905       hi = stbv\_get32(f);}
\DoxyCodeLine{4906       \textcolor{keywordflow}{if} (lo == 0xffffffff \&\& hi == 0xffffffff) \{}
\DoxyCodeLine{4907          f-\/>error = VORBIS\_cant\_find\_last\_page;}
\DoxyCodeLine{4908          f-\/>total\_samples = STBV\_SAMPLE\_unknown;}
\DoxyCodeLine{4909          \textcolor{keywordflow}{goto} done;}
\DoxyCodeLine{4910       \}}
\DoxyCodeLine{4911       \textcolor{keywordflow}{if} (hi)}
\DoxyCodeLine{4912          lo = 0xfffffffe; \textcolor{comment}{// saturate}}
\DoxyCodeLine{4913       f-\/>total\_samples = lo;}
\DoxyCodeLine{4914 }
\DoxyCodeLine{4915       f-\/>p\_last.page\_start = last\_page\_loc;}
\DoxyCodeLine{4916       f-\/>p\_last.page\_end   = end;}
\DoxyCodeLine{4917       f-\/>p\_last.last\_decoded\_sample = lo;}
\DoxyCodeLine{4918 }
\DoxyCodeLine{4919      done:}
\DoxyCodeLine{4920       stbv\_set\_file\_offset(f, restore\_offset);}
\DoxyCodeLine{4921    \}}
\DoxyCodeLine{4922    \textcolor{keywordflow}{return} f-\/>total\_samples == STBV\_SAMPLE\_unknown ? 0 : f-\/>total\_samples;}
\DoxyCodeLine{4923 \}}
\DoxyCodeLine{4924 }
\DoxyCodeLine{4925 STBVDEF \textcolor{keywordtype}{float} stb\_vorbis\_stream\_length\_in\_seconds(stb\_vorbis *f)}
\DoxyCodeLine{4926 \{}
\DoxyCodeLine{4927    \textcolor{keywordflow}{return} stb\_vorbis\_stream\_length\_in\_samples(f) / (float) f-\/>sample\_rate;}
\DoxyCodeLine{4928 \}}
\DoxyCodeLine{4929 }
\DoxyCodeLine{4930 }
\DoxyCodeLine{4931 }
\DoxyCodeLine{4932 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_frame\_float(stb\_vorbis *f, \textcolor{keywordtype}{int} *channels, \textcolor{keywordtype}{float} ***output)}
\DoxyCodeLine{4933 \{}
\DoxyCodeLine{4934    \textcolor{keywordtype}{int} len, right,left,i;}
\DoxyCodeLine{4935    \textcolor{keywordflow}{if} (STBV\_IS\_PUSH\_MODE(f)) \textcolor{keywordflow}{return} stbv\_error(f, VORBIS\_invalid\_api\_mixing);}
\DoxyCodeLine{4936 }
\DoxyCodeLine{4937    \textcolor{keywordflow}{if} (!stbv\_vorbis\_decode\_packet(f, \&len, \&left, \&right)) \{}
\DoxyCodeLine{4938       f-\/>channel\_buffer\_start = f-\/>channel\_buffer\_end = 0;}
\DoxyCodeLine{4939       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4940    \}}
\DoxyCodeLine{4941 }
\DoxyCodeLine{4942    len = stbv\_vorbis\_finish\_frame(f, len, left, right);}
\DoxyCodeLine{4943    \textcolor{keywordflow}{for} (i=0; i < f-\/>channels; ++i)}
\DoxyCodeLine{4944       f-\/>outputs[i] = f-\/>channel\_buffers[i] + left;}
\DoxyCodeLine{4945 }
\DoxyCodeLine{4946    f-\/>channel\_buffer\_start = left;}
\DoxyCodeLine{4947    f-\/>channel\_buffer\_end   = left+len;}
\DoxyCodeLine{4948 }
\DoxyCodeLine{4949    if (channels) *channels = f-\/>channels;}
\DoxyCodeLine{4950    \textcolor{keywordflow}{if} (output)   *output = f-\/>outputs;}
\DoxyCodeLine{4951    \textcolor{keywordflow}{return} len;}
\DoxyCodeLine{4952 \}}
\DoxyCodeLine{4953 }
\DoxyCodeLine{4954 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{4955 }
\DoxyCodeLine{4956 STBVDEF stb\_vorbis * stb\_vorbis\_open\_file\_section(FILE *file, \textcolor{keywordtype}{int} close\_on\_free, \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} length)}
\DoxyCodeLine{4957 \{}
\DoxyCodeLine{4958    stb\_vorbis *f, p;}
\DoxyCodeLine{4959    stbv\_vorbis\_init(\&p, alloc);}
\DoxyCodeLine{4960    p.f = file;}
\DoxyCodeLine{4961    p.f\_start = (stbv\_uint32) ftell(file);}
\DoxyCodeLine{4962    p.stream\_len   = length;}
\DoxyCodeLine{4963    p.close\_on\_free = close\_on\_free;}
\DoxyCodeLine{4964    \textcolor{keywordflow}{if} (stbv\_start\_decoder(\&p)) \{}
\DoxyCodeLine{4965       f = stbv\_vorbis\_alloc(\&p);}
\DoxyCodeLine{4966       \textcolor{keywordflow}{if} (f) \{}
\DoxyCodeLine{4967          *f = p;}
\DoxyCodeLine{4968          stbv\_vorbis\_pump\_first\_frame(f);}
\DoxyCodeLine{4969          \textcolor{keywordflow}{return} f;}
\DoxyCodeLine{4970       \}}
\DoxyCodeLine{4971    \}}
\DoxyCodeLine{4972    \textcolor{keywordflow}{if} (error) *\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = p.error;}
\DoxyCodeLine{4973    stbv\_vorbis\_deinit(\&p);}
\DoxyCodeLine{4974    \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{4975 \}}
\DoxyCodeLine{4976 }
\DoxyCodeLine{4977 STBVDEF stb\_vorbis * stb\_vorbis\_open\_file(FILE *file, \textcolor{keywordtype}{int} close\_on\_free, \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc)}
\DoxyCodeLine{4978 \{}
\DoxyCodeLine{4979    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len, start;}
\DoxyCodeLine{4980    start = (\textcolor{keywordtype}{unsigned} int) ftell(file);}
\DoxyCodeLine{4981    fseek(file, 0, SEEK\_END);}
\DoxyCodeLine{4982    len = (\textcolor{keywordtype}{unsigned} int) (ftell(file) -\/ start);}
\DoxyCodeLine{4983    fseek(file, start, SEEK\_SET);}
\DoxyCodeLine{4984    \textcolor{keywordflow}{return} stb\_vorbis\_open\_file\_section(file, close\_on\_free, error, alloc, len);}
\DoxyCodeLine{4985 \}}
\DoxyCodeLine{4986 }
\DoxyCodeLine{4987 STBVDEF stb\_vorbis * stb\_vorbis\_open\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename, \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc)}
\DoxyCodeLine{4988 \{}
\DoxyCodeLine{4989    FILE *f = fopen(filename, \textcolor{stringliteral}{"{}rb"{}});}
\DoxyCodeLine{4990    \textcolor{keywordflow}{if} (f) }
\DoxyCodeLine{4991       \textcolor{keywordflow}{return} stb\_vorbis\_open\_file(f, TRUE, error, alloc);}
\DoxyCodeLine{4992    \textcolor{keywordflow}{if} (error) *\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = VORBIS\_file\_open\_failure;}
\DoxyCodeLine{4993    \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{4994 \}}
\DoxyCodeLine{4995 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{4996 }
\DoxyCodeLine{4997 STBVDEF stb\_vorbis * stb\_vorbis\_open\_memory(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} *error, \textcolor{keyword}{const} \mbox{\hyperlink{structstb__vorbis__alloc}{stb\_vorbis\_alloc}} *alloc)}
\DoxyCodeLine{4998 \{}
\DoxyCodeLine{4999    stb\_vorbis *f, p;}
\DoxyCodeLine{5000    \textcolor{keywordflow}{if} (data == NULL) \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{5001    stbv\_vorbis\_init(\&p, alloc);}
\DoxyCodeLine{5002    p.stream = (stbv\_uint8 *) data;}
\DoxyCodeLine{5003    p.stream\_end = (stbv\_uint8 *) data + len;}
\DoxyCodeLine{5004    p.stream\_start = (stbv\_uint8 *) p.stream;}
\DoxyCodeLine{5005    p.stream\_len = len;}
\DoxyCodeLine{5006    p.push\_mode = FALSE;}
\DoxyCodeLine{5007    if (stbv\_start\_decoder(\&p)) \{}
\DoxyCodeLine{5008       f = stbv\_vorbis\_alloc(\&p);}
\DoxyCodeLine{5009       \textcolor{keywordflow}{if} (f) \{}
\DoxyCodeLine{5010          *f = p;}
\DoxyCodeLine{5011          stbv\_vorbis\_pump\_first\_frame(f);}
\DoxyCodeLine{5012          \textcolor{keywordflow}{if} (error) *\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = VORBIS\_\_no\_error;}
\DoxyCodeLine{5013          \textcolor{keywordflow}{return} f;}
\DoxyCodeLine{5014       \}}
\DoxyCodeLine{5015    \}}
\DoxyCodeLine{5016    \textcolor{keywordflow}{if} (error) *\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}} = p.error;}
\DoxyCodeLine{5017    stbv\_vorbis\_deinit(\&p);}
\DoxyCodeLine{5018    \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{5019 \}}
\DoxyCodeLine{5020 }
\DoxyCodeLine{5021 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{5022 \textcolor{preprocessor}{\#define STBV\_PLAYBACK\_MONO 1}}
\DoxyCodeLine{5023 \textcolor{preprocessor}{\#define STBV\_PLAYBACK\_LEFT 2}}
\DoxyCodeLine{5024 \textcolor{preprocessor}{\#define STBV\_PLAYBACK\_RIGHT 4}}
\DoxyCodeLine{5025 }
\DoxyCodeLine{5026 \textcolor{preprocessor}{\#define STBV\_L  (STBV\_PLAYBACK\_LEFT  | STBV\_PLAYBACK\_MONO)}}
\DoxyCodeLine{5027 \textcolor{preprocessor}{\#define STBV\_C  (STBV\_PLAYBACK\_LEFT  | STBV\_PLAYBACK\_RIGHT | STBV\_PLAYBACK\_MONO)}}
\DoxyCodeLine{5028 \textcolor{preprocessor}{\#define STBV\_R  (STBV\_PLAYBACK\_RIGHT | STBV\_PLAYBACK\_MONO)}}
\DoxyCodeLine{5029 }
\DoxyCodeLine{5030 \textcolor{keyword}{static} stbv\_int8 stbv\_channel\_position[7][6] =}
\DoxyCodeLine{5031 \{}
\DoxyCodeLine{5032    \{ 0 \},}
\DoxyCodeLine{5033    \{ STBV\_C \},}
\DoxyCodeLine{5034    \{ STBV\_L, STBV\_R \},}
\DoxyCodeLine{5035    \{ STBV\_L, STBV\_C, STBV\_R \},}
\DoxyCodeLine{5036    \{ STBV\_L, STBV\_R, STBV\_L, STBV\_R \},}
\DoxyCodeLine{5037    \{ STBV\_L, STBV\_C, STBV\_R, STBV\_L, STBV\_R \},}
\DoxyCodeLine{5038    \{ STBV\_L, STBV\_C, STBV\_R, STBV\_L, STBV\_R, STBV\_C \},}
\DoxyCodeLine{5039 \};}
\DoxyCodeLine{5040 }
\DoxyCodeLine{5041 }
\DoxyCodeLine{5042 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_FAST\_SCALED\_FLOAT}}
\DoxyCodeLine{5043    \textcolor{keyword}{typedef} \textcolor{keyword}{union }\{}
\DoxyCodeLine{5044       \textcolor{keywordtype}{float} f;}
\DoxyCodeLine{5045       \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{5046    \} stbv\_float\_conv;}
\DoxyCodeLine{5047    \textcolor{keyword}{typedef} \textcolor{keywordtype}{char} stb\_vorbis\_float\_size\_test[\textcolor{keyword}{sizeof}(float)==4 \&\& \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) == 4];}
\DoxyCodeLine{5048 \textcolor{preprocessor}{   \#define STBV\_FASTDEF(x) stbv\_float\_conv x}}
\DoxyCodeLine{5049    \textcolor{comment}{// add (1<<23) to convert to int, then divide by 2\string^SHIFT, then add 0.5/2\string^SHIFT to round}}
\DoxyCodeLine{5050 \textcolor{preprocessor}{   \#define STBV\_MAGIC(SHIFT) (1.5f * (1 << (23-\/SHIFT)) + 0.5f/(1 << SHIFT))}}
\DoxyCodeLine{5051 \textcolor{preprocessor}{   \#define STBV\_ADDEND(SHIFT) (((150-\/SHIFT) << 23) + (1 << 22))}}
\DoxyCodeLine{5052 \textcolor{preprocessor}{   \#define STBV\_FAST\_SCALED\_FLOAT\_TO\_INT(temp,x,s) (temp.f = (x) + STBV\_MAGIC(s), temp.i -\/ STBV\_ADDEND(s))}}
\DoxyCodeLine{5053 \textcolor{preprocessor}{   \#define stbv\_check\_endianness()  }}
\DoxyCodeLine{5054 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{5055 \textcolor{preprocessor}{   \#define STBV\_FAST\_SCALED\_FLOAT\_TO\_INT(temp,x,s) ((int) ((x) * (1 << (s))))}}
\DoxyCodeLine{5056 \textcolor{preprocessor}{   \#define stbv\_check\_endianness()}}
\DoxyCodeLine{5057 \textcolor{preprocessor}{   \#define STBV\_FASTDEF(x)}}
\DoxyCodeLine{5058 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5059 }
\DoxyCodeLine{5060 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_copy\_samples(\textcolor{keywordtype}{short} *dest, \textcolor{keywordtype}{float} *src, \textcolor{keywordtype}{int} len)}
\DoxyCodeLine{5061 \{}
\DoxyCodeLine{5062    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{5063    stbv\_check\_endianness();}
\DoxyCodeLine{5064    \textcolor{keywordflow}{for} (i=0; i < len; ++i) \{}
\DoxyCodeLine{5065       STBV\_FASTDEF(temp);}
\DoxyCodeLine{5066       \textcolor{keywordtype}{int} v = STBV\_FAST\_SCALED\_FLOAT\_TO\_INT(temp, src[i],15);}
\DoxyCodeLine{5067       \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) (v + 32768) > 65535)}
\DoxyCodeLine{5068          v = v < 0 ? -\/32768 : 32767;}
\DoxyCodeLine{5069       dest[i] = v;}
\DoxyCodeLine{5070    \}}
\DoxyCodeLine{5071 \}}
\DoxyCodeLine{5072 }
\DoxyCodeLine{5073 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_compute\_samples(\textcolor{keywordtype}{int} mask, \textcolor{keywordtype}{short} *output, \textcolor{keywordtype}{int} num\_c, \textcolor{keywordtype}{float} **data, \textcolor{keywordtype}{int} d\_offset, \textcolor{keywordtype}{int} len)}
\DoxyCodeLine{5074 \{}
\DoxyCodeLine{5075 \textcolor{preprocessor}{   \#define BUFFER\_SIZE  32}}
\DoxyCodeLine{5076    \textcolor{keywordtype}{float} buffer[BUFFER\_SIZE];}
\DoxyCodeLine{5077    \textcolor{keywordtype}{int} i,j,o,n = BUFFER\_SIZE;}
\DoxyCodeLine{5078    stbv\_check\_endianness();}
\DoxyCodeLine{5079    \textcolor{keywordflow}{for} (o = 0; o < len; o += BUFFER\_SIZE) \{}
\DoxyCodeLine{5080       memset(buffer, 0, \textcolor{keyword}{sizeof}(buffer));}
\DoxyCodeLine{5081       \textcolor{keywordflow}{if} (o + n > len) n = len -\/ o;}
\DoxyCodeLine{5082       \textcolor{keywordflow}{for} (j=0; j < num\_c; ++j) \{}
\DoxyCodeLine{5083          \textcolor{keywordflow}{if} (stbv\_channel\_position[num\_c][j] \& mask) \{}
\DoxyCodeLine{5084             \textcolor{keywordflow}{for} (i=0; i < n; ++i)}
\DoxyCodeLine{5085                buffer[i] += data[j][d\_offset+o+i];}
\DoxyCodeLine{5086          \}}
\DoxyCodeLine{5087       \}}
\DoxyCodeLine{5088       \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{5089          STBV\_FASTDEF(temp);}
\DoxyCodeLine{5090          \textcolor{keywordtype}{int} v = STBV\_FAST\_SCALED\_FLOAT\_TO\_INT(temp,buffer[i],15);}
\DoxyCodeLine{5091          \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) (v + 32768) > 65535)}
\DoxyCodeLine{5092             v = v < 0 ? -\/32768 : 32767;}
\DoxyCodeLine{5093          output[o+i] = v;}
\DoxyCodeLine{5094       \}}
\DoxyCodeLine{5095    \}}
\DoxyCodeLine{5096 \}}
\DoxyCodeLine{5097 }
\DoxyCodeLine{5098 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_compute\_stereo\_samples(\textcolor{keywordtype}{short} *output, \textcolor{keywordtype}{int} num\_c, \textcolor{keywordtype}{float} **data, \textcolor{keywordtype}{int} d\_offset, \textcolor{keywordtype}{int} len)}
\DoxyCodeLine{5099 \{}
\DoxyCodeLine{5100 \textcolor{preprocessor}{   \#define BUFFER\_SIZE  32}}
\DoxyCodeLine{5101    \textcolor{keywordtype}{float} buffer[BUFFER\_SIZE];}
\DoxyCodeLine{5102    \textcolor{keywordtype}{int} i,j,o,n = BUFFER\_SIZE >> 1;}
\DoxyCodeLine{5103    \textcolor{comment}{// o is the offset in the source data}}
\DoxyCodeLine{5104    stbv\_check\_endianness();}
\DoxyCodeLine{5105    \textcolor{keywordflow}{for} (o = 0; o < len; o += BUFFER\_SIZE >> 1) \{}
\DoxyCodeLine{5106       \textcolor{comment}{// o2 is the offset in the output data}}
\DoxyCodeLine{5107       \textcolor{keywordtype}{int} o2 = o << 1;}
\DoxyCodeLine{5108       memset(buffer, 0, \textcolor{keyword}{sizeof}(buffer));}
\DoxyCodeLine{5109       \textcolor{keywordflow}{if} (o + n > len) n = len -\/ o;}
\DoxyCodeLine{5110       \textcolor{keywordflow}{for} (j=0; j < num\_c; ++j) \{}
\DoxyCodeLine{5111          \textcolor{keywordtype}{int} m = stbv\_channel\_position[num\_c][j] \& (STBV\_PLAYBACK\_LEFT | STBV\_PLAYBACK\_RIGHT);}
\DoxyCodeLine{5112          \textcolor{keywordflow}{if} (m == (STBV\_PLAYBACK\_LEFT | STBV\_PLAYBACK\_RIGHT)) \{}
\DoxyCodeLine{5113             \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{5114                buffer[i*2+0] += data[j][d\_offset+o+i];}
\DoxyCodeLine{5115                buffer[i*2+1] += data[j][d\_offset+o+i];}
\DoxyCodeLine{5116             \}}
\DoxyCodeLine{5117          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m == STBV\_PLAYBACK\_LEFT) \{}
\DoxyCodeLine{5118             \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{5119                buffer[i*2+0] += data[j][d\_offset+o+i];}
\DoxyCodeLine{5120             \}}
\DoxyCodeLine{5121          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m == STBV\_PLAYBACK\_RIGHT) \{}
\DoxyCodeLine{5122             \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{5123                buffer[i*2+1] += data[j][d\_offset+o+i];}
\DoxyCodeLine{5124             \}}
\DoxyCodeLine{5125          \}}
\DoxyCodeLine{5126       \}}
\DoxyCodeLine{5127       \textcolor{keywordflow}{for} (i=0; i < (n<<1); ++i) \{}
\DoxyCodeLine{5128          STBV\_FASTDEF(temp);}
\DoxyCodeLine{5129          \textcolor{keywordtype}{int} v = STBV\_FAST\_SCALED\_FLOAT\_TO\_INT(temp,buffer[i],15);}
\DoxyCodeLine{5130          \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) (v + 32768) > 65535)}
\DoxyCodeLine{5131             v = v < 0 ? -\/32768 : 32767;}
\DoxyCodeLine{5132          output[o2+i] = v;}
\DoxyCodeLine{5133       \}}
\DoxyCodeLine{5134    \}}
\DoxyCodeLine{5135 \}}
\DoxyCodeLine{5136 }
\DoxyCodeLine{5137 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_convert\_samples\_short(\textcolor{keywordtype}{int} buf\_c, \textcolor{keywordtype}{short} **buffer, \textcolor{keywordtype}{int} b\_offset, \textcolor{keywordtype}{int} data\_c, \textcolor{keywordtype}{float} **data, \textcolor{keywordtype}{int} d\_offset, \textcolor{keywordtype}{int} samples)}
\DoxyCodeLine{5138 \{}
\DoxyCodeLine{5139    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{5140    \textcolor{keywordflow}{if} (buf\_c != data\_c \&\& buf\_c <= 2 \&\& data\_c <= 6) \{}
\DoxyCodeLine{5141       \textcolor{keyword}{static} \textcolor{keywordtype}{int} channel\_selector[3][2] = \{ \{0\}, \{STBV\_PLAYBACK\_MONO\}, \{STBV\_PLAYBACK\_LEFT, STBV\_PLAYBACK\_RIGHT\} \};}
\DoxyCodeLine{5142       \textcolor{keywordflow}{for} (i=0; i < buf\_c; ++i)}
\DoxyCodeLine{5143          stbv\_compute\_samples(channel\_selector[buf\_c][i], buffer[i]+b\_offset, data\_c, data, d\_offset, samples);}
\DoxyCodeLine{5144    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5145       \textcolor{keywordtype}{int} limit = buf\_c < data\_c ? buf\_c : data\_c;}
\DoxyCodeLine{5146       \textcolor{keywordflow}{for} (i=0; i < limit; ++i)}
\DoxyCodeLine{5147          stbv\_copy\_samples(buffer[i]+b\_offset, data[i]+d\_offset, samples);}
\DoxyCodeLine{5148       \textcolor{keywordflow}{for} (   ; i < buf\_c; ++i)}
\DoxyCodeLine{5149          memset(buffer[i]+b\_offset, 0, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{short}) * samples);}
\DoxyCodeLine{5150    \}}
\DoxyCodeLine{5151 \}}
\DoxyCodeLine{5152 }
\DoxyCodeLine{5153 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_frame\_short(stb\_vorbis *f, \textcolor{keywordtype}{int} num\_c, \textcolor{keywordtype}{short} **buffer, \textcolor{keywordtype}{int} num\_samples)}
\DoxyCodeLine{5154 \{}
\DoxyCodeLine{5155    \textcolor{keywordtype}{float} **output;}
\DoxyCodeLine{5156    \textcolor{keywordtype}{int} len = stb\_vorbis\_get\_frame\_float(f, NULL, \&output);}
\DoxyCodeLine{5157    \textcolor{keywordflow}{if} (len > num\_samples) len = num\_samples;}
\DoxyCodeLine{5158    \textcolor{keywordflow}{if} (len)}
\DoxyCodeLine{5159       stbv\_convert\_samples\_short(num\_c, buffer, 0, f-\/>channels, output, 0, len);}
\DoxyCodeLine{5160    \textcolor{keywordflow}{return} len;}
\DoxyCodeLine{5161 \}}
\DoxyCodeLine{5162 }
\DoxyCodeLine{5163 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbv\_convert\_channels\_short\_interleaved(\textcolor{keywordtype}{int} buf\_c, \textcolor{keywordtype}{short} *buffer, \textcolor{keywordtype}{int} data\_c, \textcolor{keywordtype}{float} **data, \textcolor{keywordtype}{int} d\_offset, \textcolor{keywordtype}{int} len)}
\DoxyCodeLine{5164 \{}
\DoxyCodeLine{5165    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{5166    stbv\_check\_endianness();}
\DoxyCodeLine{5167    \textcolor{keywordflow}{if} (buf\_c != data\_c \&\& buf\_c <= 2 \&\& data\_c <= 6) \{}
\DoxyCodeLine{5168       assert(buf\_c == 2);}
\DoxyCodeLine{5169       \textcolor{keywordflow}{for} (i=0; i < buf\_c; ++i)}
\DoxyCodeLine{5170          stbv\_compute\_stereo\_samples(buffer, data\_c, data, d\_offset, len);}
\DoxyCodeLine{5171    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5172       \textcolor{keywordtype}{int} limit = buf\_c < data\_c ? buf\_c : data\_c;}
\DoxyCodeLine{5173       \textcolor{keywordtype}{int} j;}
\DoxyCodeLine{5174       \textcolor{keywordflow}{for} (j=0; j < len; ++j) \{}
\DoxyCodeLine{5175          \textcolor{keywordflow}{for} (i=0; i < limit; ++i) \{}
\DoxyCodeLine{5176             STBV\_FASTDEF(temp);}
\DoxyCodeLine{5177             \textcolor{keywordtype}{float} f = data[i][d\_offset+j];}
\DoxyCodeLine{5178             \textcolor{keywordtype}{int} v = STBV\_FAST\_SCALED\_FLOAT\_TO\_INT(temp, f,15);\textcolor{comment}{//data[i][d\_offset+j],15);}}
\DoxyCodeLine{5179             \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) (v + 32768) > 65535)}
\DoxyCodeLine{5180                v = v < 0 ? -\/32768 : 32767;}
\DoxyCodeLine{5181             *buffer++ = v;}
\DoxyCodeLine{5182          \}}
\DoxyCodeLine{5183          \textcolor{keywordflow}{for} (   ; i < buf\_c; ++i)}
\DoxyCodeLine{5184             *buffer++ = 0;}
\DoxyCodeLine{5185       \}}
\DoxyCodeLine{5186    \}}
\DoxyCodeLine{5187 \}}
\DoxyCodeLine{5188 }
\DoxyCodeLine{5189 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_frame\_short\_interleaved(stb\_vorbis *f, \textcolor{keywordtype}{int} num\_c, \textcolor{keywordtype}{short} *buffer, \textcolor{keywordtype}{int} num\_shorts)}
\DoxyCodeLine{5190 \{}
\DoxyCodeLine{5191    \textcolor{keywordtype}{float} **output;}
\DoxyCodeLine{5192    \textcolor{keywordtype}{int} len;}
\DoxyCodeLine{5193    \textcolor{keywordflow}{if} (num\_c == 1) \textcolor{keywordflow}{return} stb\_vorbis\_get\_frame\_short(f,num\_c,\&buffer, num\_shorts);}
\DoxyCodeLine{5194    len = stb\_vorbis\_get\_frame\_float(f, NULL, \&output);}
\DoxyCodeLine{5195    \textcolor{keywordflow}{if} (len) \{}
\DoxyCodeLine{5196       \textcolor{keywordflow}{if} (len*num\_c > num\_shorts) len = num\_shorts / num\_c;}
\DoxyCodeLine{5197       stbv\_convert\_channels\_short\_interleaved(num\_c, buffer, f-\/>channels, output, 0, len);}
\DoxyCodeLine{5198    \}}
\DoxyCodeLine{5199    \textcolor{keywordflow}{return} len;}
\DoxyCodeLine{5200 \}}
\DoxyCodeLine{5201 }
\DoxyCodeLine{5202 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_samples\_short\_interleaved(stb\_vorbis *f, \textcolor{keywordtype}{int} channels, \textcolor{keywordtype}{short} *buffer, \textcolor{keywordtype}{int} num\_shorts)}
\DoxyCodeLine{5203 \{}
\DoxyCodeLine{5204    \textcolor{keywordtype}{float} **outputs;}
\DoxyCodeLine{5205    \textcolor{keywordtype}{int} len = num\_shorts / channels;}
\DoxyCodeLine{5206    \textcolor{keywordtype}{int} n=0;}
\DoxyCodeLine{5207    \textcolor{keywordtype}{int} z = f-\/>channels;}
\DoxyCodeLine{5208    \textcolor{keywordflow}{if} (z > channels) z = channels;}
\DoxyCodeLine{5209    \textcolor{keywordflow}{while} (n < len) \{}
\DoxyCodeLine{5210       \textcolor{keywordtype}{int} k = f-\/>channel\_buffer\_end -\/ f-\/>channel\_buffer\_start;}
\DoxyCodeLine{5211       \textcolor{keywordflow}{if} (n+k >= len) k = len -\/ n;}
\DoxyCodeLine{5212       \textcolor{keywordflow}{if} (k)}
\DoxyCodeLine{5213          stbv\_convert\_channels\_short\_interleaved(channels, buffer, f-\/>channels, f-\/>channel\_buffers, f-\/>channel\_buffer\_start, k);}
\DoxyCodeLine{5214       buffer += k*channels;}
\DoxyCodeLine{5215       n += k;}
\DoxyCodeLine{5216       f-\/>channel\_buffer\_start += k;}
\DoxyCodeLine{5217       \textcolor{keywordflow}{if} (n == len) \textcolor{keywordflow}{break};}
\DoxyCodeLine{5218       \textcolor{keywordflow}{if} (!stb\_vorbis\_get\_frame\_float(f, NULL, \&outputs)) \textcolor{keywordflow}{break};}
\DoxyCodeLine{5219    \}}
\DoxyCodeLine{5220    \textcolor{keywordflow}{return} n;}
\DoxyCodeLine{5221 \}}
\DoxyCodeLine{5222 }
\DoxyCodeLine{5223 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_samples\_short(stb\_vorbis *f, \textcolor{keywordtype}{int} channels, \textcolor{keywordtype}{short} **buffer, \textcolor{keywordtype}{int} len)}
\DoxyCodeLine{5224 \{}
\DoxyCodeLine{5225    \textcolor{keywordtype}{float} **outputs;}
\DoxyCodeLine{5226    \textcolor{keywordtype}{int} n=0;}
\DoxyCodeLine{5227    \textcolor{keywordtype}{int} z = f-\/>channels;}
\DoxyCodeLine{5228    \textcolor{keywordflow}{if} (z > channels) z = channels;}
\DoxyCodeLine{5229    \textcolor{keywordflow}{while} (n < len) \{}
\DoxyCodeLine{5230       \textcolor{keywordtype}{int} k = f-\/>channel\_buffer\_end -\/ f-\/>channel\_buffer\_start;}
\DoxyCodeLine{5231       \textcolor{keywordflow}{if} (n+k >= len) k = len -\/ n;}
\DoxyCodeLine{5232       \textcolor{keywordflow}{if} (k)}
\DoxyCodeLine{5233          stbv\_convert\_samples\_short(channels, buffer, n, f-\/>channels, f-\/>channel\_buffers, f-\/>channel\_buffer\_start, k);}
\DoxyCodeLine{5234       n += k;}
\DoxyCodeLine{5235       f-\/>channel\_buffer\_start += k;}
\DoxyCodeLine{5236       \textcolor{keywordflow}{if} (n == len) \textcolor{keywordflow}{break};}
\DoxyCodeLine{5237       \textcolor{keywordflow}{if} (!stb\_vorbis\_get\_frame\_float(f, NULL, \&outputs)) \textcolor{keywordflow}{break};}
\DoxyCodeLine{5238    \}}
\DoxyCodeLine{5239    \textcolor{keywordflow}{return} n;}
\DoxyCodeLine{5240 \}}
\DoxyCodeLine{5241 }
\DoxyCodeLine{5242 \textcolor{preprocessor}{\#ifndef STB\_VORBIS\_NO\_STDIO}}
\DoxyCodeLine{5243 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_decode\_filename(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename, \textcolor{keywordtype}{int} *channels, \textcolor{keywordtype}{int} *sample\_rate, \textcolor{keywordtype}{short} **output)}
\DoxyCodeLine{5244 \{}
\DoxyCodeLine{5245    \textcolor{keywordtype}{int} data\_len, offset, total, limit, \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{5246    \textcolor{keywordtype}{short} *data;}
\DoxyCodeLine{5247    stb\_vorbis *v = stb\_vorbis\_open\_filename(filename, \&error, NULL);}
\DoxyCodeLine{5248    \textcolor{keywordflow}{if} (v == NULL) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{5249    limit = v-\/>channels * 4096;}
\DoxyCodeLine{5250    *channels = v-\/>channels;}
\DoxyCodeLine{5251    \textcolor{keywordflow}{if} (sample\_rate)}
\DoxyCodeLine{5252       *sample\_rate = v-\/>sample\_rate;}
\DoxyCodeLine{5253    offset = data\_len = 0;}
\DoxyCodeLine{5254    total = limit;}
\DoxyCodeLine{5255    data = (\textcolor{keywordtype}{short} *) malloc(total * \textcolor{keyword}{sizeof}(*data));}
\DoxyCodeLine{5256    \textcolor{keywordflow}{if} (data == NULL) \{}
\DoxyCodeLine{5257       stb\_vorbis\_close(v);}
\DoxyCodeLine{5258       \textcolor{keywordflow}{return} -\/2;}
\DoxyCodeLine{5259    \}}
\DoxyCodeLine{5260    \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{5261       \textcolor{keywordtype}{int} n = stb\_vorbis\_get\_frame\_short\_interleaved(v, v-\/>channels, data+offset, total-\/offset);}
\DoxyCodeLine{5262       \textcolor{keywordflow}{if} (n == 0) \textcolor{keywordflow}{break};}
\DoxyCodeLine{5263       data\_len += n;}
\DoxyCodeLine{5264       offset += n * v-\/>channels;}
\DoxyCodeLine{5265       \textcolor{keywordflow}{if} (offset + limit > total) \{}
\DoxyCodeLine{5266          \textcolor{keywordtype}{short} *data2;}
\DoxyCodeLine{5267          total *= 2;}
\DoxyCodeLine{5268          data2 = (\textcolor{keywordtype}{short} *) realloc(data, total * \textcolor{keyword}{sizeof}(*data));}
\DoxyCodeLine{5269          \textcolor{keywordflow}{if} (data2 == NULL) \{}
\DoxyCodeLine{5270             free(data);}
\DoxyCodeLine{5271             stb\_vorbis\_close(v);}
\DoxyCodeLine{5272             \textcolor{keywordflow}{return} -\/2;}
\DoxyCodeLine{5273          \}}
\DoxyCodeLine{5274          data = data2;}
\DoxyCodeLine{5275       \}}
\DoxyCodeLine{5276    \}}
\DoxyCodeLine{5277    *output = data;}
\DoxyCodeLine{5278    stb\_vorbis\_close(v);}
\DoxyCodeLine{5279    \textcolor{keywordflow}{return} data\_len;}
\DoxyCodeLine{5280 \}}
\DoxyCodeLine{5281 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// NO\_STDIO}}
\DoxyCodeLine{5282 }
\DoxyCodeLine{5283 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_decode\_memory(\textcolor{keyword}{const} stbv\_uint8 *mem, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} *channels, \textcolor{keywordtype}{int} *sample\_rate, \textcolor{keywordtype}{short} **output)}
\DoxyCodeLine{5284 \{}
\DoxyCodeLine{5285    \textcolor{keywordtype}{int} data\_len, offset, total, limit, \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{5286    \textcolor{keywordtype}{short} *data;}
\DoxyCodeLine{5287    stb\_vorbis *v = stb\_vorbis\_open\_memory(mem, len, \&error, NULL);}
\DoxyCodeLine{5288    \textcolor{keywordflow}{if} (v == NULL) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{5289    limit = v-\/>channels * 4096;}
\DoxyCodeLine{5290    *channels = v-\/>channels;}
\DoxyCodeLine{5291    \textcolor{keywordflow}{if} (sample\_rate)}
\DoxyCodeLine{5292       *sample\_rate = v-\/>sample\_rate;}
\DoxyCodeLine{5293    offset = data\_len = 0;}
\DoxyCodeLine{5294    total = limit;}
\DoxyCodeLine{5295    data = (\textcolor{keywordtype}{short} *) malloc(total * \textcolor{keyword}{sizeof}(*data));}
\DoxyCodeLine{5296    \textcolor{keywordflow}{if} (data == NULL) \{}
\DoxyCodeLine{5297       stb\_vorbis\_close(v);}
\DoxyCodeLine{5298       \textcolor{keywordflow}{return} -\/2;}
\DoxyCodeLine{5299    \}}
\DoxyCodeLine{5300    \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{5301       \textcolor{keywordtype}{int} n = stb\_vorbis\_get\_frame\_short\_interleaved(v, v-\/>channels, data+offset, total-\/offset);}
\DoxyCodeLine{5302       \textcolor{keywordflow}{if} (n == 0) \textcolor{keywordflow}{break};}
\DoxyCodeLine{5303       data\_len += n;}
\DoxyCodeLine{5304       offset += n * v-\/>channels;}
\DoxyCodeLine{5305       \textcolor{keywordflow}{if} (offset + limit > total) \{}
\DoxyCodeLine{5306          \textcolor{keywordtype}{short} *data2;}
\DoxyCodeLine{5307          total *= 2;}
\DoxyCodeLine{5308          data2 = (\textcolor{keywordtype}{short} *) realloc(data, total * \textcolor{keyword}{sizeof}(*data));}
\DoxyCodeLine{5309          \textcolor{keywordflow}{if} (data2 == NULL) \{}
\DoxyCodeLine{5310             free(data);}
\DoxyCodeLine{5311             stb\_vorbis\_close(v);}
\DoxyCodeLine{5312             \textcolor{keywordflow}{return} -\/2;}
\DoxyCodeLine{5313          \}}
\DoxyCodeLine{5314          data = data2;}
\DoxyCodeLine{5315       \}}
\DoxyCodeLine{5316    \}}
\DoxyCodeLine{5317    *output = data;}
\DoxyCodeLine{5318    stb\_vorbis\_close(v);}
\DoxyCodeLine{5319    \textcolor{keywordflow}{return} data\_len;}
\DoxyCodeLine{5320 \}}
\DoxyCodeLine{5321 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{5322 }
\DoxyCodeLine{5323 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_samples\_float\_interleaved(stb\_vorbis *f, \textcolor{keywordtype}{int} channels, \textcolor{keywordtype}{float} *buffer, \textcolor{keywordtype}{int} num\_floats)}
\DoxyCodeLine{5324 \{}
\DoxyCodeLine{5325    \textcolor{keywordtype}{float} **outputs;}
\DoxyCodeLine{5326    \textcolor{keywordtype}{int} len = num\_floats / channels;}
\DoxyCodeLine{5327    \textcolor{keywordtype}{int} n=0;}
\DoxyCodeLine{5328    \textcolor{keywordtype}{int} z = f-\/>channels;}
\DoxyCodeLine{5329    \textcolor{keywordflow}{if} (z > channels) z = channels;}
\DoxyCodeLine{5330    \textcolor{keywordflow}{while} (n < len) \{}
\DoxyCodeLine{5331       \textcolor{keywordtype}{int} i,j;}
\DoxyCodeLine{5332       \textcolor{keywordtype}{int} k = f-\/>channel\_buffer\_end -\/ f-\/>channel\_buffer\_start;}
\DoxyCodeLine{5333       \textcolor{keywordflow}{if} (n+k >= len) k = len -\/ n;}
\DoxyCodeLine{5334       \textcolor{keywordflow}{for} (j=0; j < k; ++j) \{}
\DoxyCodeLine{5335          \textcolor{keywordflow}{for} (i=0; i < z; ++i)}
\DoxyCodeLine{5336             *buffer++ = f-\/>channel\_buffers[i][f-\/>channel\_buffer\_start+j];}
\DoxyCodeLine{5337          for (   ; i < channels; ++i)}
\DoxyCodeLine{5338             *buffer++ = 0;}
\DoxyCodeLine{5339       \}}
\DoxyCodeLine{5340       n += k;}
\DoxyCodeLine{5341       f-\/>channel\_buffer\_start += k;}
\DoxyCodeLine{5342       \textcolor{keywordflow}{if} (n == len)}
\DoxyCodeLine{5343          \textcolor{keywordflow}{break};}
\DoxyCodeLine{5344       \textcolor{keywordflow}{if} (!stb\_vorbis\_get\_frame\_float(f, NULL, \&outputs))}
\DoxyCodeLine{5345          \textcolor{keywordflow}{break};}
\DoxyCodeLine{5346    \}}
\DoxyCodeLine{5347    \textcolor{keywordflow}{return} n;}
\DoxyCodeLine{5348 \}}
\DoxyCodeLine{5349 }
\DoxyCodeLine{5350 STBVDEF \textcolor{keywordtype}{int} stb\_vorbis\_get\_samples\_float(stb\_vorbis *f, \textcolor{keywordtype}{int} channels, \textcolor{keywordtype}{float} **buffer, \textcolor{keywordtype}{int} num\_samples)}
\DoxyCodeLine{5351 \{}
\DoxyCodeLine{5352    \textcolor{keywordtype}{float} **outputs;}
\DoxyCodeLine{5353    \textcolor{keywordtype}{int} n=0;}
\DoxyCodeLine{5354    \textcolor{keywordtype}{int} z = f-\/>channels;}
\DoxyCodeLine{5355    \textcolor{keywordflow}{if} (z > channels) z = channels;}
\DoxyCodeLine{5356    \textcolor{keywordflow}{while} (n < num\_samples) \{}
\DoxyCodeLine{5357       \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{5358       \textcolor{keywordtype}{int} k = f-\/>channel\_buffer\_end -\/ f-\/>channel\_buffer\_start;}
\DoxyCodeLine{5359       \textcolor{keywordflow}{if} (n+k >= num\_samples) k = num\_samples -\/ n;}
\DoxyCodeLine{5360       \textcolor{keywordflow}{if} (k) \{}
\DoxyCodeLine{5361          \textcolor{keywordflow}{for} (i=0; i < z; ++i)}
\DoxyCodeLine{5362             memcpy(buffer[i]+n, f-\/>channel\_buffers[i]+f-\/>channel\_buffer\_start, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})*k);}
\DoxyCodeLine{5363          \textcolor{keywordflow}{for} (   ; i < channels; ++i)}
\DoxyCodeLine{5364             memset(buffer[i]+n, 0, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) * k);}
\DoxyCodeLine{5365       \}}
\DoxyCodeLine{5366       n += k;}
\DoxyCodeLine{5367       f-\/>channel\_buffer\_start += k;}
\DoxyCodeLine{5368       \textcolor{keywordflow}{if} (n == num\_samples)}
\DoxyCodeLine{5369          \textcolor{keywordflow}{break};}
\DoxyCodeLine{5370       \textcolor{keywordflow}{if} (!stb\_vorbis\_get\_frame\_float(f, NULL, \&outputs))}
\DoxyCodeLine{5371          \textcolor{keywordflow}{break};}
\DoxyCodeLine{5372    \}}
\DoxyCodeLine{5373    \textcolor{keywordflow}{return} n;}
\DoxyCodeLine{5374 \}}
\DoxyCodeLine{5375 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// STB\_VORBIS\_NO\_PULLDATA\_API}}
\DoxyCodeLine{5376 }
\DoxyCodeLine{5377 \textcolor{comment}{/* Version history}}
\DoxyCodeLine{5378 \textcolor{comment}{    1.12    -\/ 2017-\/11-\/21 -\/ limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files}}
\DoxyCodeLine{5379 \textcolor{comment}{    1.11    -\/ 2017-\/07-\/23 -\/ fix MinGW compilation }}
\DoxyCodeLine{5380 \textcolor{comment}{    1.10    -\/ 2017-\/03-\/03 -\/ more robust seeking; fix negative stbv\_ilog(); clear error in open\_memory}}
\DoxyCodeLine{5381 \textcolor{comment}{    1.09    -\/ 2016-\/04-\/04 -\/ back out 'avoid discarding last frame' fix from previous version}}
\DoxyCodeLine{5382 \textcolor{comment}{    1.08    -\/ 2016-\/04-\/02 -\/ fixed multiple warnings; fix setup memory leaks;}}
\DoxyCodeLine{5383 \textcolor{comment}{                           avoid discarding last frame of audio data}}
\DoxyCodeLine{5384 \textcolor{comment}{    1.07    -\/ 2015-\/01-\/16 -\/ fixed some warnings, fix mingw, const-\/correct API}}
\DoxyCodeLine{5385 \textcolor{comment}{                           some more crash fixes when out of memory or with corrupt files }}
\DoxyCodeLine{5386 \textcolor{comment}{    1.06    -\/ 2015-\/08-\/31 -\/ full, correct support for seeking API (Dougall Johnson)}}
\DoxyCodeLine{5387 \textcolor{comment}{                           some crash fixes when out of memory or with corrupt files}}
\DoxyCodeLine{5388 \textcolor{comment}{    1.05    -\/ 2015-\/04-\/19 -\/ don't define \_\_forceinline if it's redundant}}
\DoxyCodeLine{5389 \textcolor{comment}{    1.04    -\/ 2014-\/08-\/27 -\/ fix missing const-\/correct case in API}}
\DoxyCodeLine{5390 \textcolor{comment}{    1.03    -\/ 2014-\/08-\/07 -\/ Warning fixes}}
\DoxyCodeLine{5391 \textcolor{comment}{    1.02    -\/ 2014-\/07-\/09 -\/ Declare qsort compare function \_cdecl on windows}}
\DoxyCodeLine{5392 \textcolor{comment}{    1.01    -\/ 2014-\/06-\/18 -\/ fix stb\_vorbis\_get\_samples\_float}}
\DoxyCodeLine{5393 \textcolor{comment}{    1.0     -\/ 2014-\/05-\/26 -\/ fix memory leaks; fix warnings; fix bugs in multichannel}}
\DoxyCodeLine{5394 \textcolor{comment}{                           (API change) report sample rate for decode-\/full-\/file funcs}}
\DoxyCodeLine{5395 \textcolor{comment}{    0.99996 -\/ bracket \#include <malloc.h> for macintosh compilation by Laurent Gomila}}
\DoxyCodeLine{5396 \textcolor{comment}{    0.99995 -\/ use union instead of pointer-\/cast for fast-\/float-\/to-\/int to avoid alias-\/optimization problem}}
\DoxyCodeLine{5397 \textcolor{comment}{    0.99994 -\/ change fast-\/float-\/to-\/int to work in single-\/precision FPU mode, remove endian-\/dependence}}
\DoxyCodeLine{5398 \textcolor{comment}{    0.99993 -\/ remove assert that fired on legal files with empty tables}}
\DoxyCodeLine{5399 \textcolor{comment}{    0.99992 -\/ rewind-\/to-\/start}}
\DoxyCodeLine{5400 \textcolor{comment}{    0.99991 -\/ bugfix to stb\_vorbis\_get\_samples\_short by Bernhard Wodo}}
\DoxyCodeLine{5401 \textcolor{comment}{    0.9999 -\/ (should have been 0.99990) fix no-\/CRT support, compiling as C++}}
\DoxyCodeLine{5402 \textcolor{comment}{    0.9998 -\/ add a full-\/decode function with a memory source}}
\DoxyCodeLine{5403 \textcolor{comment}{    0.9997 -\/ fix a bug in the read-\/from-\/FILE case in 0.9996 addition}}
\DoxyCodeLine{5404 \textcolor{comment}{    0.9996 -\/ query length of vorbis stream in samples/seconds}}
\DoxyCodeLine{5405 \textcolor{comment}{    0.9995 -\/ bugfix to another optimization that only happened in certain files}}
\DoxyCodeLine{5406 \textcolor{comment}{    0.9994 -\/ bugfix to one of the optimizations that caused significant (but inaudible?) errors}}
\DoxyCodeLine{5407 \textcolor{comment}{    0.9993 -\/ performance improvements; runs in 99\% to 104\% of time of reference implementation}}
\DoxyCodeLine{5408 \textcolor{comment}{    0.9992 -\/ performance improvement of IMDCT; now performs close to reference implementation}}
\DoxyCodeLine{5409 \textcolor{comment}{    0.9991 -\/ performance improvement of IMDCT}}
\DoxyCodeLine{5410 \textcolor{comment}{    0.999 -\/ (should have been 0.9990) performance improvement of IMDCT}}
\DoxyCodeLine{5411 \textcolor{comment}{    0.998 -\/ no-\/CRT support from Casey Muratori}}
\DoxyCodeLine{5412 \textcolor{comment}{    0.997 -\/ bugfixes for bugs found by Terje Mathisen}}
\DoxyCodeLine{5413 \textcolor{comment}{    0.996 -\/ bugfix: fast-\/huffman decode initialized incorrectly for sparse codebooks; fixing gives 10\% speedup -\/ found by Terje Mathisen}}
\DoxyCodeLine{5414 \textcolor{comment}{    0.995 -\/ bugfix: fix to 'effective' overrun detection -\/ found by Terje Mathisen}}
\DoxyCodeLine{5415 \textcolor{comment}{    0.994 -\/ bugfix: garbage decode on final VQ symbol of a non-\/multiple -\/ found by Terje Mathisen}}
\DoxyCodeLine{5416 \textcolor{comment}{    0.993 -\/ bugfix: pushdata API required 1 extra byte for empty page (failed to consume final page if empty) -\/ found by Terje Mathisen}}
\DoxyCodeLine{5417 \textcolor{comment}{    0.992 -\/ fixes for MinGW warning}}
\DoxyCodeLine{5418 \textcolor{comment}{    0.991 -\/ turn fast-\/float-\/conversion on by default}}
\DoxyCodeLine{5419 \textcolor{comment}{    0.990 -\/ fix push-\/mode seek recovery if you seek into the headers}}
\DoxyCodeLine{5420 \textcolor{comment}{    0.98b -\/ fix to bad release of 0.98}}
\DoxyCodeLine{5421 \textcolor{comment}{    0.98 -\/ fix push-\/mode seek recovery; robustify float-\/to-\/int and support non-\/fast mode}}
\DoxyCodeLine{5422 \textcolor{comment}{    0.97 -\/ builds under c++ (typecasting, don't use 'class' keyword)}}
\DoxyCodeLine{5423 \textcolor{comment}{    0.96 -\/ somehow MY 0.95 was right, but the web one was wrong, so here's my 0.95 rereleased as 0.96, fixes a typo in the clamping code}}
\DoxyCodeLine{5424 \textcolor{comment}{    0.95 -\/ clamping code for 16-\/bit functions}}
\DoxyCodeLine{5425 \textcolor{comment}{    0.94 -\/ not publically released}}
\DoxyCodeLine{5426 \textcolor{comment}{    0.93 -\/ fixed all-\/zero-\/floor case (was decoding garbage)}}
\DoxyCodeLine{5427 \textcolor{comment}{    0.92 -\/ fixed a memory leak}}
\DoxyCodeLine{5428 \textcolor{comment}{    0.91 -\/ conditional compiles to omit parts of the API and the infrastructure to support them: STB\_VORBIS\_NO\_PULLDATA\_API, STB\_VORBIS\_NO\_PUSHDATA\_API, STB\_VORBIS\_NO\_STDIO, STB\_VORBIS\_NO\_INTEGER\_CONVERSION}}
\DoxyCodeLine{5429 \textcolor{comment}{    0.90 -\/ first public release}}
\DoxyCodeLine{5430 \textcolor{comment}{*/}}
\DoxyCodeLine{5431 }
\DoxyCodeLine{5432 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// STB\_VORBIS\_IMPLEMENTATION}}
\DoxyCodeLine{5433 }
\DoxyCodeLine{5434 }
\DoxyCodeLine{5435 \textcolor{comment}{/*}}
\DoxyCodeLine{5436 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5437 \textcolor{comment}{This software is available under 2 licenses -\/-\/ choose whichever you prefer.}}
\DoxyCodeLine{5438 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5439 \textcolor{comment}{ALTERNATIVE A -\/ MIT License}}
\DoxyCodeLine{5440 \textcolor{comment}{Copyright (c) 2017 Sean Barrett}}
\DoxyCodeLine{5441 \textcolor{comment}{Permission is hereby granted, free of charge, to any person obtaining a copy of }}
\DoxyCodeLine{5442 \textcolor{comment}{this software and associated documentation files (the "{}Software"{}), to deal in }}
\DoxyCodeLine{5443 \textcolor{comment}{the Software without restriction, including without limitation the rights to }}
\DoxyCodeLine{5444 \textcolor{comment}{use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies }}
\DoxyCodeLine{5445 \textcolor{comment}{of the Software, and to permit persons to whom the Software is furnished to do }}
\DoxyCodeLine{5446 \textcolor{comment}{so, subject to the following conditions:}}
\DoxyCodeLine{5447 \textcolor{comment}{The above copyright notice and this permission notice shall be included in all }}
\DoxyCodeLine{5448 \textcolor{comment}{copies or substantial portions of the Software.}}
\DoxyCodeLine{5449 \textcolor{comment}{THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR }}
\DoxyCodeLine{5450 \textcolor{comment}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, }}
\DoxyCodeLine{5451 \textcolor{comment}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE }}
\DoxyCodeLine{5452 \textcolor{comment}{AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER }}
\DoxyCodeLine{5453 \textcolor{comment}{LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, }}
\DoxyCodeLine{5454 \textcolor{comment}{OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE }}
\DoxyCodeLine{5455 \textcolor{comment}{SOFTWARE.}}
\DoxyCodeLine{5456 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5457 \textcolor{comment}{ALTERNATIVE B -\/ Public Domain (www.unlicense.org)}}
\DoxyCodeLine{5458 \textcolor{comment}{This is free and unencumbered software released into the public domain.}}
\DoxyCodeLine{5459 \textcolor{comment}{Anyone is free to copy, modify, publish, use, compile, sell, or distribute this }}
\DoxyCodeLine{5460 \textcolor{comment}{software, either in source code form or as a compiled binary, for any purpose, }}
\DoxyCodeLine{5461 \textcolor{comment}{commercial or non-\/commercial, and by any means.}}
\DoxyCodeLine{5462 \textcolor{comment}{In jurisdictions that recognize copyright laws, the author or authors of this }}
\DoxyCodeLine{5463 \textcolor{comment}{software dedicate any and all copyright interest in the software to the public }}
\DoxyCodeLine{5464 \textcolor{comment}{domain. We make this dedication for the benefit of the public at large and to }}
\DoxyCodeLine{5465 \textcolor{comment}{the detriment of our heirs and successors. We intend this dedication to be an }}
\DoxyCodeLine{5466 \textcolor{comment}{overt act of relinquishment in perpetuity of all present and future rights to }}
\DoxyCodeLine{5467 \textcolor{comment}{this software under copyright law.}}
\DoxyCodeLine{5468 \textcolor{comment}{THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR }}
\DoxyCodeLine{5469 \textcolor{comment}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, }}
\DoxyCodeLine{5470 \textcolor{comment}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE }}
\DoxyCodeLine{5471 \textcolor{comment}{AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN }}
\DoxyCodeLine{5472 \textcolor{comment}{ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION }}
\DoxyCodeLine{5473 \textcolor{comment}{WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{5474 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5475 \textcolor{comment}{*/}}

\end{DoxyCode}
