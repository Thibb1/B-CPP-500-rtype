\hypertarget{raylib-src_2src_2raymath_8h_source}{}\doxysection{raymath.\+h}
\label{raylib-src_2src_2raymath_8h_source}\index{build/\_deps/raylib-\/src/src/raymath.h@{build/\_deps/raylib-\/src/src/raymath.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/**********************************************************************************************}}
\DoxyCodeLine{2 \textcolor{comment}{*}}
\DoxyCodeLine{3 \textcolor{comment}{*   raymath v1.5 -\/ Math functions to work with Vector2, Vector3, Matrix and Quaternions}}
\DoxyCodeLine{4 \textcolor{comment}{*}}
\DoxyCodeLine{5 \textcolor{comment}{*   CONFIGURATION:}}
\DoxyCodeLine{6 \textcolor{comment}{*}}
\DoxyCodeLine{7 \textcolor{comment}{*   \#define RAYMATH\_IMPLEMENTATION}}
\DoxyCodeLine{8 \textcolor{comment}{*       Generates the implementation of the library into the included file.}}
\DoxyCodeLine{9 \textcolor{comment}{*       If not defined, the library is in header only mode and can be included in other headers}}
\DoxyCodeLine{10 \textcolor{comment}{*       or source files without problems. But only ONE file should hold the implementation.}}
\DoxyCodeLine{11 \textcolor{comment}{*}}
\DoxyCodeLine{12 \textcolor{comment}{*   \#define RAYMATH\_STATIC\_INLINE}}
\DoxyCodeLine{13 \textcolor{comment}{*       Define static inline functions code, so \#include header suffices for use.}}
\DoxyCodeLine{14 \textcolor{comment}{*       This may use up lots of memory.}}
\DoxyCodeLine{15 \textcolor{comment}{*}}
\DoxyCodeLine{16 \textcolor{comment}{*   CONVENTIONS:}}
\DoxyCodeLine{17 \textcolor{comment}{*}}
\DoxyCodeLine{18 \textcolor{comment}{*     -\/ Functions are always self-\/contained, no function use another raymath function inside,}}
\DoxyCodeLine{19 \textcolor{comment}{*       required code is directly re-\/implemented inside}}
\DoxyCodeLine{20 \textcolor{comment}{*     -\/ Functions input parameters are always received by value (2 unavoidable exceptions)}}
\DoxyCodeLine{21 \textcolor{comment}{*     -\/ Functions use always a "{}result"{} variable for return}}
\DoxyCodeLine{22 \textcolor{comment}{*     -\/ Functions are always defined inline}}
\DoxyCodeLine{23 \textcolor{comment}{*     -\/ Angles are always in radians (DEG2RAD/RAD2DEG macros provided for convenience)}}
\DoxyCodeLine{24 \textcolor{comment}{*}}
\DoxyCodeLine{25 \textcolor{comment}{*}}
\DoxyCodeLine{26 \textcolor{comment}{*   LICENSE: zlib/libpng}}
\DoxyCodeLine{27 \textcolor{comment}{*}}
\DoxyCodeLine{28 \textcolor{comment}{*   Copyright (c) 2015-\/2022 Ramon Santamaria (@raysan5)}}
\DoxyCodeLine{29 \textcolor{comment}{*}}
\DoxyCodeLine{30 \textcolor{comment}{*   This software is provided "{}as-\/is"{}, without any express or implied warranty. In no event}}
\DoxyCodeLine{31 \textcolor{comment}{*   will the authors be held liable for any damages arising from the use of this software.}}
\DoxyCodeLine{32 \textcolor{comment}{*}}
\DoxyCodeLine{33 \textcolor{comment}{*   Permission is granted to anyone to use this software for any purpose, including commercial}}
\DoxyCodeLine{34 \textcolor{comment}{*   applications, and to alter it and redistribute it freely, subject to the following restrictions:}}
\DoxyCodeLine{35 \textcolor{comment}{*}}
\DoxyCodeLine{36 \textcolor{comment}{*     1. The origin of this software must not be misrepresented; you must not claim that you}}
\DoxyCodeLine{37 \textcolor{comment}{*     wrote the original software. If you use this software in a product, an acknowledgment}}
\DoxyCodeLine{38 \textcolor{comment}{*     in the product documentation would be appreciated but is not required.}}
\DoxyCodeLine{39 \textcolor{comment}{*}}
\DoxyCodeLine{40 \textcolor{comment}{*     2. Altered source versions must be plainly marked as such, and must not be misrepresented}}
\DoxyCodeLine{41 \textcolor{comment}{*     as being the original software.}}
\DoxyCodeLine{42 \textcolor{comment}{*}}
\DoxyCodeLine{43 \textcolor{comment}{*     3. This notice may not be removed or altered from any source distribution.}}
\DoxyCodeLine{44 \textcolor{comment}{*}}
\DoxyCodeLine{45 \textcolor{comment}{**********************************************************************************************/}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{preprocessor}{\#ifndef RAYMATH\_H}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#define RAYMATH\_H}}
\DoxyCodeLine{49 }
\DoxyCodeLine{50 \textcolor{preprocessor}{\#if defined(RAYMATH\_IMPLEMENTATION) \&\& defined(RAYMATH\_STATIC\_INLINE)}}
\DoxyCodeLine{51 \textcolor{preprocessor}{    \#error "{}Specifying both RAYMATH\_IMPLEMENTATION and RAYMATH\_STATIC\_INLINE is contradictory"{}}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{comment}{// Function specifiers definition}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#if defined(RAYMATH\_IMPLEMENTATION)}}
\DoxyCodeLine{56 \textcolor{preprocessor}{    \#if defined(\_WIN32) \&\& defined(BUILD\_LIBTYPE\_SHARED)}}
\DoxyCodeLine{57 \textcolor{preprocessor}{        \#define RMAPI \_\_declspec(dllexport) extern inline }\textcolor{comment}{// We are building raylib as a Win32 shared library (.dll).}}
\DoxyCodeLine{58 \textcolor{preprocessor}{    \#elif defined(\_WIN32) \&\& defined(USE\_LIBTYPE\_SHARED)}}
\DoxyCodeLine{59 \textcolor{preprocessor}{        \#define RMAPI \_\_declspec(dllimport)         }\textcolor{comment}{// We are using raylib as a Win32 shared library (.dll)}}
\DoxyCodeLine{60 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{61 \textcolor{preprocessor}{        \#define RMAPI extern inline }\textcolor{comment}{// Provide external definition}}
\DoxyCodeLine{62 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#elif defined(RAYMATH\_STATIC\_INLINE)}}
\DoxyCodeLine{64 \textcolor{preprocessor}{    \#define RMAPI static inline }\textcolor{comment}{// Functions may be inlined, no external out-\/of-\/line definition}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{66 \textcolor{preprocessor}{    \#if defined(\_\_TINYC\_\_)}}
\DoxyCodeLine{67 \textcolor{preprocessor}{        \#define RMAPI static inline }\textcolor{comment}{// plain inline not supported by tinycc (See issue \#435)}}
\DoxyCodeLine{68 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{69 \textcolor{preprocessor}{        \#define RMAPI inline        }\textcolor{comment}{// Functions may be inlined or external definition used}}
\DoxyCodeLine{70 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{74 \textcolor{comment}{// Defines and Macros}}
\DoxyCodeLine{75 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#ifndef PI}}
\DoxyCodeLine{77 \textcolor{preprocessor}{    \#define PI 3.14159265358979323846f}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 \textcolor{preprocessor}{\#ifndef EPSILON}}
\DoxyCodeLine{81 \textcolor{preprocessor}{    \#define EPSILON 0.000001f}}
\DoxyCodeLine{82 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{preprocessor}{\#ifndef DEG2RAD}}
\DoxyCodeLine{85 \textcolor{preprocessor}{    \#define DEG2RAD (PI/180.0f)}}
\DoxyCodeLine{86 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{preprocessor}{\#ifndef RAD2DEG}}
\DoxyCodeLine{89 \textcolor{preprocessor}{    \#define RAD2DEG (180.0f/PI)}}
\DoxyCodeLine{90 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92 \textcolor{comment}{// Get float vector for Matrix}}
\DoxyCodeLine{93 \textcolor{preprocessor}{\#ifndef MatrixToFloat}}
\DoxyCodeLine{94 \textcolor{preprocessor}{    \#define MatrixToFloat(mat) (MatrixToFloatV(mat).v)}}
\DoxyCodeLine{95 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{96 }
\DoxyCodeLine{97 \textcolor{comment}{// Get float vector for Vector3}}
\DoxyCodeLine{98 \textcolor{preprocessor}{\#ifndef Vector3ToFloat}}
\DoxyCodeLine{99 \textcolor{preprocessor}{    \#define Vector3ToFloat(vec) (Vector3ToFloatV(vec).v)}}
\DoxyCodeLine{100 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{103 \textcolor{comment}{// Types and Structures Definition}}
\DoxyCodeLine{104 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{105 \textcolor{preprocessor}{\#if !defined(RL\_VECTOR2\_TYPE)}}
\DoxyCodeLine{106 \textcolor{comment}{// Vector2 type}}
\DoxyCodeLine{107 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structVector2}{Vector2}} \{}
\DoxyCodeLine{108     \textcolor{keywordtype}{float} x;}
\DoxyCodeLine{109     \textcolor{keywordtype}{float} y;}
\DoxyCodeLine{110 \} \mbox{\hyperlink{structVector2}{Vector2}};}
\DoxyCodeLine{111 \textcolor{preprocessor}{\#define RL\_VECTOR2\_TYPE}}
\DoxyCodeLine{112 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 \textcolor{preprocessor}{\#if !defined(RL\_VECTOR3\_TYPE)}}
\DoxyCodeLine{115 \textcolor{comment}{// Vector3 type}}
\DoxyCodeLine{116 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structVector3}{Vector3}} \{}
\DoxyCodeLine{117     \textcolor{keywordtype}{float} x;}
\DoxyCodeLine{118     \textcolor{keywordtype}{float} y;}
\DoxyCodeLine{119     \textcolor{keywordtype}{float} z;}
\DoxyCodeLine{120 \} \mbox{\hyperlink{structVector3}{Vector3}};}
\DoxyCodeLine{121 \textcolor{preprocessor}{\#define RL\_VECTOR3\_TYPE}}
\DoxyCodeLine{122 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{123 }
\DoxyCodeLine{124 \textcolor{preprocessor}{\#if !defined(RL\_VECTOR4\_TYPE)}}
\DoxyCodeLine{125 \textcolor{comment}{// Vector4 type}}
\DoxyCodeLine{126 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structVector4}{Vector4}} \{}
\DoxyCodeLine{127     \textcolor{keywordtype}{float} x;}
\DoxyCodeLine{128     \textcolor{keywordtype}{float} y;}
\DoxyCodeLine{129     \textcolor{keywordtype}{float} z;}
\DoxyCodeLine{130     \textcolor{keywordtype}{float} w;}
\DoxyCodeLine{131 \} \mbox{\hyperlink{structVector4}{Vector4}};}
\DoxyCodeLine{132 \textcolor{preprocessor}{\#define RL\_VECTOR4\_TYPE}}
\DoxyCodeLine{133 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135 \textcolor{preprocessor}{\#if !defined(RL\_QUATERNION\_TYPE)}}
\DoxyCodeLine{136 \textcolor{comment}{// Quaternion type}}
\DoxyCodeLine{137 \textcolor{keyword}{typedef} \mbox{\hyperlink{structVector4}{Vector4}} \mbox{\hyperlink{structVector4}{Quaternion}};}
\DoxyCodeLine{138 \textcolor{preprocessor}{\#define RL\_QUATERNION\_TYPE}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{140 }
\DoxyCodeLine{141 \textcolor{preprocessor}{\#if !defined(RL\_MATRIX\_TYPE)}}
\DoxyCodeLine{142 \textcolor{comment}{// Matrix type (OpenGL style 4x4 -\/ right handed, column major)}}
\DoxyCodeLine{143 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structMatrix}{Matrix}} \{}
\DoxyCodeLine{144     \textcolor{keywordtype}{float} m0, m4, m8, m12;      \textcolor{comment}{// Matrix first row (4 components)}}
\DoxyCodeLine{145     \textcolor{keywordtype}{float} m1, m5, m9, m13;      \textcolor{comment}{// Matrix second row (4 components)}}
\DoxyCodeLine{146     \textcolor{keywordtype}{float} m2, m6, m10, m14;     \textcolor{comment}{// Matrix third row (4 components)}}
\DoxyCodeLine{147     \textcolor{keywordtype}{float} m3, m7, m11, m15;     \textcolor{comment}{// Matrix fourth row (4 components)}}
\DoxyCodeLine{148 \} \mbox{\hyperlink{structMatrix}{Matrix}};}
\DoxyCodeLine{149 \textcolor{preprocessor}{\#define RL\_MATRIX\_TYPE}}
\DoxyCodeLine{150 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{151 }
\DoxyCodeLine{152 \textcolor{comment}{// NOTE: Helper types to be used instead of array return types for *ToFloat functions}}
\DoxyCodeLine{153 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structfloat3}{float3}} \{}
\DoxyCodeLine{154     \textcolor{keywordtype}{float} v[3];}
\DoxyCodeLine{155 \} \mbox{\hyperlink{structfloat3}{float3}};}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structfloat16}{float16}} \{}
\DoxyCodeLine{158     \textcolor{keywordtype}{float} v[16];}
\DoxyCodeLine{159 \} \mbox{\hyperlink{structfloat16}{float16}};}
\DoxyCodeLine{160 }
\DoxyCodeLine{161 \textcolor{preprocessor}{\#include <math.h>}       \textcolor{comment}{// Required for: sinf(), cosf(), tan(), atan2f(), sqrtf(), floor(), fminf(), fmaxf(), fabs()}}
\DoxyCodeLine{162 }
\DoxyCodeLine{163 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{164 \textcolor{comment}{// Module Functions Definition -\/ Utils math}}
\DoxyCodeLine{165 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \textcolor{comment}{// Clamp float value}}
\DoxyCodeLine{168 RMAPI \textcolor{keywordtype}{float} Clamp(\textcolor{keywordtype}{float} value, \textcolor{keywordtype}{float} min, \textcolor{keywordtype}{float} max)}
\DoxyCodeLine{169 \{}
\DoxyCodeLine{170     \textcolor{keywordtype}{float} result = (value < min)? min : value;}
\DoxyCodeLine{171 }
\DoxyCodeLine{172     \textcolor{keywordflow}{if} (result > max) result = max;}
\DoxyCodeLine{173 }
\DoxyCodeLine{174     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{175 \}}
\DoxyCodeLine{176 }
\DoxyCodeLine{177 \textcolor{comment}{// Calculate linear interpolation between two floats}}
\DoxyCodeLine{178 RMAPI \textcolor{keywordtype}{float} Lerp(\textcolor{keywordtype}{float} start, \textcolor{keywordtype}{float} end, \textcolor{keywordtype}{float} amount)}
\DoxyCodeLine{179 \{}
\DoxyCodeLine{180     \textcolor{keywordtype}{float} result = start + amount*(end -\/ start);}
\DoxyCodeLine{181 }
\DoxyCodeLine{182     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{183 \}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 \textcolor{comment}{// Normalize input value within input range}}
\DoxyCodeLine{186 RMAPI \textcolor{keywordtype}{float} Normalize(\textcolor{keywordtype}{float} value, \textcolor{keywordtype}{float} start, \textcolor{keywordtype}{float} end)}
\DoxyCodeLine{187 \{}
\DoxyCodeLine{188     \textcolor{keywordtype}{float} result = (value -\/ start)/(end -\/ start);}
\DoxyCodeLine{189 }
\DoxyCodeLine{190     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{191 \}}
\DoxyCodeLine{192 }
\DoxyCodeLine{193 \textcolor{comment}{// Remap input value within input range to output range}}
\DoxyCodeLine{194 RMAPI \textcolor{keywordtype}{float} Remap(\textcolor{keywordtype}{float} value, \textcolor{keywordtype}{float} inputStart, \textcolor{keywordtype}{float} inputEnd, \textcolor{keywordtype}{float} outputStart, \textcolor{keywordtype}{float} outputEnd)}
\DoxyCodeLine{195 \{}
\DoxyCodeLine{196     \textcolor{keywordtype}{float} result = (value -\/ inputStart)/(inputEnd -\/ inputStart)*(outputEnd -\/ outputStart) + outputStart;}
\DoxyCodeLine{197 }
\DoxyCodeLine{198     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{199 \}}
\DoxyCodeLine{200 }
\DoxyCodeLine{201 \textcolor{comment}{// Wrap input value from min to max}}
\DoxyCodeLine{202 RMAPI \textcolor{keywordtype}{float} Wrap(\textcolor{keywordtype}{float} value, \textcolor{keywordtype}{float} min, \textcolor{keywordtype}{float} max)}
\DoxyCodeLine{203 \{}
\DoxyCodeLine{204     \textcolor{keywordtype}{float} result = value -\/ (max -\/ min)*floorf((value -\/ min)/(max -\/ min));}
\DoxyCodeLine{205 }
\DoxyCodeLine{206     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{207 \}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{comment}{// Check whether two given floats are almost equal}}
\DoxyCodeLine{210 RMAPI \textcolor{keywordtype}{int} FloatEquals(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y)}
\DoxyCodeLine{211 \{}
\DoxyCodeLine{212     \textcolor{keywordtype}{int} result = (fabsf(x -\/ y)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(x), fabsf(y))));}
\DoxyCodeLine{213 }
\DoxyCodeLine{214     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{215 \}}
\DoxyCodeLine{216 }
\DoxyCodeLine{217 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{218 \textcolor{comment}{// Module Functions Definition -\/ Vector2 math}}
\DoxyCodeLine{219 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{220 }
\DoxyCodeLine{221 \textcolor{comment}{// Vector with components value 0.0f}}
\DoxyCodeLine{222 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Zero(\textcolor{keywordtype}{void})}
\DoxyCodeLine{223 \{}
\DoxyCodeLine{224     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 0.0f, 0.0f \};}
\DoxyCodeLine{225 }
\DoxyCodeLine{226     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{227 \}}
\DoxyCodeLine{228 }
\DoxyCodeLine{229 \textcolor{comment}{// Vector with components value 1.0f}}
\DoxyCodeLine{230 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2One(\textcolor{keywordtype}{void})}
\DoxyCodeLine{231 \{}
\DoxyCodeLine{232     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 1.0f, 1.0f \};}
\DoxyCodeLine{233 }
\DoxyCodeLine{234     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{235 \}}
\DoxyCodeLine{236 }
\DoxyCodeLine{237 \textcolor{comment}{// Add two vectors (v1 + v2)}}
\DoxyCodeLine{238 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Add(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2)}
\DoxyCodeLine{239 \{}
\DoxyCodeLine{240     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ v1.x + v2.x, v1.y + v2.y \};}
\DoxyCodeLine{241 }
\DoxyCodeLine{242     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{243 \}}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 \textcolor{comment}{// Add vector and float value}}
\DoxyCodeLine{246 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2AddValue(\mbox{\hyperlink{structVector2}{Vector2}} v, \textcolor{keywordtype}{float} add)}
\DoxyCodeLine{247 \{}
\DoxyCodeLine{248     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ v.x + add, v.y + add \};}
\DoxyCodeLine{249 }
\DoxyCodeLine{250     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{251 \}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253 \textcolor{comment}{// Subtract two vectors (v1 -\/ v2)}}
\DoxyCodeLine{254 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Subtract(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2)}
\DoxyCodeLine{255 \{}
\DoxyCodeLine{256     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ v1.x -\/ v2.x, v1.y -\/ v2.y \};}
\DoxyCodeLine{257 }
\DoxyCodeLine{258     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{259 \}}
\DoxyCodeLine{260 }
\DoxyCodeLine{261 \textcolor{comment}{// Subtract vector by float value}}
\DoxyCodeLine{262 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2SubtractValue(\mbox{\hyperlink{structVector2}{Vector2}} v, \textcolor{keywordtype}{float} sub)}
\DoxyCodeLine{263 \{}
\DoxyCodeLine{264     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ v.x -\/ sub, v.y -\/ sub \};}
\DoxyCodeLine{265 }
\DoxyCodeLine{266     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{267 \}}
\DoxyCodeLine{268 }
\DoxyCodeLine{269 \textcolor{comment}{// Calculate vector length}}
\DoxyCodeLine{270 RMAPI \textcolor{keywordtype}{float} Vector2Length(\mbox{\hyperlink{structVector2}{Vector2}} v)}
\DoxyCodeLine{271 \{}
\DoxyCodeLine{272     \textcolor{keywordtype}{float} result = sqrtf((v.x*v.x) + (v.y*v.y));}
\DoxyCodeLine{273 }
\DoxyCodeLine{274     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{275 \}}
\DoxyCodeLine{276 }
\DoxyCodeLine{277 \textcolor{comment}{// Calculate vector square length}}
\DoxyCodeLine{278 RMAPI \textcolor{keywordtype}{float} Vector2LengthSqr(\mbox{\hyperlink{structVector2}{Vector2}} v)}
\DoxyCodeLine{279 \{}
\DoxyCodeLine{280     \textcolor{keywordtype}{float} result = (v.x*v.x) + (v.y*v.y);}
\DoxyCodeLine{281 }
\DoxyCodeLine{282     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{283 \}}
\DoxyCodeLine{284 }
\DoxyCodeLine{285 \textcolor{comment}{// Calculate two vectors dot product}}
\DoxyCodeLine{286 RMAPI \textcolor{keywordtype}{float} Vector2DotProduct(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2)}
\DoxyCodeLine{287 \{}
\DoxyCodeLine{288     \textcolor{keywordtype}{float} result = (v1.x*v2.x + v1.y*v2.y);}
\DoxyCodeLine{289 }
\DoxyCodeLine{290     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{291 \}}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{comment}{// Calculate distance between two vectors}}
\DoxyCodeLine{294 RMAPI \textcolor{keywordtype}{float} Vector2Distance(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2)}
\DoxyCodeLine{295 \{}
\DoxyCodeLine{296     \textcolor{keywordtype}{float} result = sqrtf((v1.x -\/ v2.x)*(v1.x -\/ v2.x) + (v1.y -\/ v2.y)*(v1.y -\/ v2.y));}
\DoxyCodeLine{297 }
\DoxyCodeLine{298     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{299 \}}
\DoxyCodeLine{300 }
\DoxyCodeLine{301 \textcolor{comment}{// Calculate square distance between two vectors}}
\DoxyCodeLine{302 RMAPI \textcolor{keywordtype}{float} Vector2DistanceSqr(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2)}
\DoxyCodeLine{303 \{}
\DoxyCodeLine{304     \textcolor{keywordtype}{float} result = ((v1.x -\/ v2.x)*(v1.x -\/ v2.x) + (v1.y -\/ v2.y)*(v1.y -\/ v2.y));}
\DoxyCodeLine{305 }
\DoxyCodeLine{306     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{307 \}}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{comment}{// Calculate angle from two vectors}}
\DoxyCodeLine{310 RMAPI \textcolor{keywordtype}{float} Vector2Angle(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2)}
\DoxyCodeLine{311 \{}
\DoxyCodeLine{312     \textcolor{keywordtype}{float} result = atan2f(v2.y, v2.x) -\/ atan2f(v1.y, v1.x);}
\DoxyCodeLine{313 }
\DoxyCodeLine{314     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{315 \}}
\DoxyCodeLine{316 }
\DoxyCodeLine{317 \textcolor{comment}{// Scale vector (multiply by value)}}
\DoxyCodeLine{318 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Scale(\mbox{\hyperlink{structVector2}{Vector2}} v, \textcolor{keywordtype}{float} scale)}
\DoxyCodeLine{319 \{}
\DoxyCodeLine{320     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ v.x*scale, v.y*scale \};}
\DoxyCodeLine{321 }
\DoxyCodeLine{322     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{323 \}}
\DoxyCodeLine{324 }
\DoxyCodeLine{325 \textcolor{comment}{// Multiply vector by vector}}
\DoxyCodeLine{326 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Multiply(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2)}
\DoxyCodeLine{327 \{}
\DoxyCodeLine{328     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ v1.x*v2.x, v1.y*v2.y \};}
\DoxyCodeLine{329 }
\DoxyCodeLine{330     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{331 \}}
\DoxyCodeLine{332 }
\DoxyCodeLine{333 \textcolor{comment}{// Negate vector}}
\DoxyCodeLine{334 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Negate(\mbox{\hyperlink{structVector2}{Vector2}} v)}
\DoxyCodeLine{335 \{}
\DoxyCodeLine{336     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ -\/v.x, -\/v.y \};}
\DoxyCodeLine{337 }
\DoxyCodeLine{338     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{339 \}}
\DoxyCodeLine{340 }
\DoxyCodeLine{341 \textcolor{comment}{// Divide vector by vector}}
\DoxyCodeLine{342 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Divide(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2)}
\DoxyCodeLine{343 \{}
\DoxyCodeLine{344     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ v1.x/v2.x, v1.y/v2.y \};}
\DoxyCodeLine{345 }
\DoxyCodeLine{346     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{347 \}}
\DoxyCodeLine{348 }
\DoxyCodeLine{349 \textcolor{comment}{// Normalize provided vector}}
\DoxyCodeLine{350 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Normalize(\mbox{\hyperlink{structVector2}{Vector2}} v)}
\DoxyCodeLine{351 \{}
\DoxyCodeLine{352     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 0 \};}
\DoxyCodeLine{353     \textcolor{keywordtype}{float} length = sqrtf((v.x*v.x) + (v.y*v.y));}
\DoxyCodeLine{354 }
\DoxyCodeLine{355     \textcolor{keywordflow}{if} (length > 0)}
\DoxyCodeLine{356     \{}
\DoxyCodeLine{357         \textcolor{keywordtype}{float} ilength = 1.0f/length;}
\DoxyCodeLine{358         result.x = v.x*ilength;}
\DoxyCodeLine{359         result.y = v.y*ilength;}
\DoxyCodeLine{360     \}}
\DoxyCodeLine{361 }
\DoxyCodeLine{362     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{363 \}}
\DoxyCodeLine{364 }
\DoxyCodeLine{365 \textcolor{comment}{// Transforms a Vector2 by a given Matrix}}
\DoxyCodeLine{366 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Transform(\mbox{\hyperlink{structVector2}{Vector2}} v, \mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{367 \{}
\DoxyCodeLine{368     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 0 \};}
\DoxyCodeLine{369 }
\DoxyCodeLine{370     \textcolor{keywordtype}{float} x = v.x;}
\DoxyCodeLine{371     \textcolor{keywordtype}{float} y = v.y;}
\DoxyCodeLine{372     \textcolor{keywordtype}{float} z = 0;}
\DoxyCodeLine{373 }
\DoxyCodeLine{374     result.x = mat.m0*x + mat.m4*y + mat.m8*z + mat.m12;}
\DoxyCodeLine{375     result.y = mat.m1*x + mat.m5*y + mat.m9*z + mat.m13;}
\DoxyCodeLine{376 }
\DoxyCodeLine{377     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{378 \}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 \textcolor{comment}{// Calculate linear interpolation between two vectors}}
\DoxyCodeLine{381 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Lerp(\mbox{\hyperlink{structVector2}{Vector2}} v1, \mbox{\hyperlink{structVector2}{Vector2}} v2, \textcolor{keywordtype}{float} amount)}
\DoxyCodeLine{382 \{}
\DoxyCodeLine{383     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 0 \};}
\DoxyCodeLine{384 }
\DoxyCodeLine{385     result.x = v1.x + amount*(v2.x -\/ v1.x);}
\DoxyCodeLine{386     result.y = v1.y + amount*(v2.y -\/ v1.y);}
\DoxyCodeLine{387 }
\DoxyCodeLine{388     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{389 \}}
\DoxyCodeLine{390 }
\DoxyCodeLine{391 \textcolor{comment}{// Calculate reflected vector to normal}}
\DoxyCodeLine{392 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Reflect(\mbox{\hyperlink{structVector2}{Vector2}} v, \mbox{\hyperlink{structVector2}{Vector2}} normal)}
\DoxyCodeLine{393 \{}
\DoxyCodeLine{394     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 0 \};}
\DoxyCodeLine{395 }
\DoxyCodeLine{396     \textcolor{keywordtype}{float} dotProduct = (v.x*normal.x + v.y*normal.y); \textcolor{comment}{// Dot product}}
\DoxyCodeLine{397 }
\DoxyCodeLine{398     result.x = v.x -\/ (2.0f*normal.x)*dotProduct;}
\DoxyCodeLine{399     result.y = v.y -\/ (2.0f*normal.y)*dotProduct;}
\DoxyCodeLine{400 }
\DoxyCodeLine{401     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{402 \}}
\DoxyCodeLine{403 }
\DoxyCodeLine{404 \textcolor{comment}{// Rotate vector by angle}}
\DoxyCodeLine{405 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Rotate(\mbox{\hyperlink{structVector2}{Vector2}} v, \textcolor{keywordtype}{float} angle)}
\DoxyCodeLine{406 \{}
\DoxyCodeLine{407     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 0 \};}
\DoxyCodeLine{408 }
\DoxyCodeLine{409     \textcolor{keywordtype}{float} cosres = cosf(angle);}
\DoxyCodeLine{410     \textcolor{keywordtype}{float} sinres = sinf(angle);}
\DoxyCodeLine{411 }
\DoxyCodeLine{412     result.x = v.x*cosres -\/ v.y*sinres;}
\DoxyCodeLine{413     result.y = v.x*sinres + v.y*cosres;}
\DoxyCodeLine{414 }
\DoxyCodeLine{415     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{416 \}}
\DoxyCodeLine{417 }
\DoxyCodeLine{418 \textcolor{comment}{// Move Vector towards target}}
\DoxyCodeLine{419 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2MoveTowards(\mbox{\hyperlink{structVector2}{Vector2}} v, \mbox{\hyperlink{structVector2}{Vector2}} target, \textcolor{keywordtype}{float} maxDistance)}
\DoxyCodeLine{420 \{}
\DoxyCodeLine{421     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 0 \};}
\DoxyCodeLine{422 }
\DoxyCodeLine{423     \textcolor{keywordtype}{float} dx = target.x -\/ v.x;}
\DoxyCodeLine{424     \textcolor{keywordtype}{float} dy = target.y -\/ v.y;}
\DoxyCodeLine{425     \textcolor{keywordtype}{float} value = (dx*dx) + (dy*dy);}
\DoxyCodeLine{426 }
\DoxyCodeLine{427     \textcolor{keywordflow}{if} ((value == 0) || ((maxDistance >= 0) \&\& (value <= maxDistance*maxDistance))) \textcolor{keywordflow}{return} target;}
\DoxyCodeLine{428 }
\DoxyCodeLine{429     \textcolor{keywordtype}{float} dist = sqrtf(value);}
\DoxyCodeLine{430 }
\DoxyCodeLine{431     result.x = v.x + dx/dist*maxDistance;}
\DoxyCodeLine{432     result.y = v.y + dy/dist*maxDistance;}
\DoxyCodeLine{433 }
\DoxyCodeLine{434     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{435 \}}
\DoxyCodeLine{436 }
\DoxyCodeLine{437 \textcolor{comment}{// Invert the given vector}}
\DoxyCodeLine{438 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Invert(\mbox{\hyperlink{structVector2}{Vector2}} v)}
\DoxyCodeLine{439 \{}
\DoxyCodeLine{440     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 1.0f/v.x, 1.0f/v.y \};}
\DoxyCodeLine{441 }
\DoxyCodeLine{442     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{443 \}}
\DoxyCodeLine{444 }
\DoxyCodeLine{445 \textcolor{comment}{// Clamp the components of the vector between}}
\DoxyCodeLine{446 \textcolor{comment}{// min and max values specified by the given vectors}}
\DoxyCodeLine{447 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2Clamp(\mbox{\hyperlink{structVector2}{Vector2}} v, \mbox{\hyperlink{structVector2}{Vector2}} min, \mbox{\hyperlink{structVector2}{Vector2}} max)}
\DoxyCodeLine{448 \{}
\DoxyCodeLine{449     \mbox{\hyperlink{structVector2}{Vector2}} result = \{ 0 \};}
\DoxyCodeLine{450 }
\DoxyCodeLine{451     result.x = fminf(max.x, fmaxf(min.x, v.x));}
\DoxyCodeLine{452     result.y = fminf(max.y, fmaxf(min.y, v.y));}
\DoxyCodeLine{453 }
\DoxyCodeLine{454     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{455 \}}
\DoxyCodeLine{456 }
\DoxyCodeLine{457 \textcolor{comment}{// Clamp the magnitude of the vector between two min and max values}}
\DoxyCodeLine{458 RMAPI \mbox{\hyperlink{structVector2}{Vector2}} Vector2ClampValue(\mbox{\hyperlink{structVector2}{Vector2}} v, \textcolor{keywordtype}{float} min, \textcolor{keywordtype}{float} max)}
\DoxyCodeLine{459 \{}
\DoxyCodeLine{460     \mbox{\hyperlink{structVector2}{Vector2}} result = v;}
\DoxyCodeLine{461 }
\DoxyCodeLine{462     \textcolor{keywordtype}{float} length = (v.x*v.x) + (v.y*v.y);}
\DoxyCodeLine{463     \textcolor{keywordflow}{if} (length > 0.0f)}
\DoxyCodeLine{464     \{}
\DoxyCodeLine{465         length = sqrtf(length);}
\DoxyCodeLine{466 }
\DoxyCodeLine{467         \textcolor{keywordflow}{if} (length < min)}
\DoxyCodeLine{468         \{}
\DoxyCodeLine{469             \textcolor{keywordtype}{float} scale = min/length;}
\DoxyCodeLine{470             result.x = v.x*scale;}
\DoxyCodeLine{471             result.y = v.y*scale;}
\DoxyCodeLine{472         \}}
\DoxyCodeLine{473         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (length > max)}
\DoxyCodeLine{474         \{}
\DoxyCodeLine{475             \textcolor{keywordtype}{float} scale = max/length;}
\DoxyCodeLine{476             result.x = v.x*scale;}
\DoxyCodeLine{477             result.y = v.y*scale;}
\DoxyCodeLine{478         \}}
\DoxyCodeLine{479     \}}
\DoxyCodeLine{480 }
\DoxyCodeLine{481     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{482 \}}
\DoxyCodeLine{483 }
\DoxyCodeLine{484 \textcolor{comment}{// Check whether two given vectors are almost equal}}
\DoxyCodeLine{485 RMAPI \textcolor{keywordtype}{int} Vector2Equals(\mbox{\hyperlink{structVector2}{Vector2}} p, \mbox{\hyperlink{structVector2}{Vector2}} q)}
\DoxyCodeLine{486 \{}
\DoxyCodeLine{487     \textcolor{keywordtype}{int} result = ((fabsf(p.x -\/ q.x)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.x), fabsf(q.x))))) \&\&}
\DoxyCodeLine{488                   ((fabsf(p.y -\/ q.y)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.y), fabsf(q.y)))));}
\DoxyCodeLine{489 }
\DoxyCodeLine{490     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{491 \}}
\DoxyCodeLine{492 }
\DoxyCodeLine{493 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{494 \textcolor{comment}{// Module Functions Definition -\/ Vector3 math}}
\DoxyCodeLine{495 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{496 }
\DoxyCodeLine{497 \textcolor{comment}{// Vector with components value 0.0f}}
\DoxyCodeLine{498 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Zero(\textcolor{keywordtype}{void})}
\DoxyCodeLine{499 \{}
\DoxyCodeLine{500     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{501 }
\DoxyCodeLine{502     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{503 \}}
\DoxyCodeLine{504 }
\DoxyCodeLine{505 \textcolor{comment}{// Vector with components value 1.0f}}
\DoxyCodeLine{506 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3One(\textcolor{keywordtype}{void})}
\DoxyCodeLine{507 \{}
\DoxyCodeLine{508     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 1.0f, 1.0f, 1.0f \};}
\DoxyCodeLine{509 }
\DoxyCodeLine{510     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{511 \}}
\DoxyCodeLine{512 }
\DoxyCodeLine{513 \textcolor{comment}{// Add two vectors}}
\DoxyCodeLine{514 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Add(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{515 \{}
\DoxyCodeLine{516     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ v1.x + v2.x, v1.y + v2.y, v1.z + v2.z \};}
\DoxyCodeLine{517 }
\DoxyCodeLine{518     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{519 \}}
\DoxyCodeLine{520 }
\DoxyCodeLine{521 \textcolor{comment}{// Add vector and float value}}
\DoxyCodeLine{522 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3AddValue(\mbox{\hyperlink{structVector3}{Vector3}} v, \textcolor{keywordtype}{float} add)}
\DoxyCodeLine{523 \{}
\DoxyCodeLine{524     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ v.x + add, v.y + add, v.z + add \};}
\DoxyCodeLine{525 }
\DoxyCodeLine{526     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{527 \}}
\DoxyCodeLine{528 }
\DoxyCodeLine{529 \textcolor{comment}{// Subtract two vectors}}
\DoxyCodeLine{530 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Subtract(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{531 \{}
\DoxyCodeLine{532     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ v1.x -\/ v2.x, v1.y -\/ v2.y, v1.z -\/ v2.z \};}
\DoxyCodeLine{533 }
\DoxyCodeLine{534     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{535 \}}
\DoxyCodeLine{536 }
\DoxyCodeLine{537 \textcolor{comment}{// Subtract vector by float value}}
\DoxyCodeLine{538 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3SubtractValue(\mbox{\hyperlink{structVector3}{Vector3}} v, \textcolor{keywordtype}{float} sub)}
\DoxyCodeLine{539 \{}
\DoxyCodeLine{540     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ v.x -\/ sub, v.y -\/ sub, v.z -\/ sub \};}
\DoxyCodeLine{541 }
\DoxyCodeLine{542     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{543 \}}
\DoxyCodeLine{544 }
\DoxyCodeLine{545 \textcolor{comment}{// Multiply vector by scalar}}
\DoxyCodeLine{546 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Scale(\mbox{\hyperlink{structVector3}{Vector3}} v, \textcolor{keywordtype}{float} scalar)}
\DoxyCodeLine{547 \{}
\DoxyCodeLine{548     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ v.x*scalar, v.y*scalar, v.z*scalar \};}
\DoxyCodeLine{549 }
\DoxyCodeLine{550     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{551 \}}
\DoxyCodeLine{552 }
\DoxyCodeLine{553 \textcolor{comment}{// Multiply vector by vector}}
\DoxyCodeLine{554 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Multiply(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{555 \{}
\DoxyCodeLine{556     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ v1.x*v2.x, v1.y*v2.y, v1.z*v2.z \};}
\DoxyCodeLine{557 }
\DoxyCodeLine{558     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{559 \}}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \textcolor{comment}{// Calculate two vectors cross product}}
\DoxyCodeLine{562 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3CrossProduct(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{563 \{}
\DoxyCodeLine{564     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ v1.y*v2.z -\/ v1.z*v2.y, v1.z*v2.x -\/ v1.x*v2.z, v1.x*v2.y -\/ v1.y*v2.x \};}
\DoxyCodeLine{565 }
\DoxyCodeLine{566     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{567 \}}
\DoxyCodeLine{568 }
\DoxyCodeLine{569 \textcolor{comment}{// Calculate one vector perpendicular vector}}
\DoxyCodeLine{570 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Perpendicular(\mbox{\hyperlink{structVector3}{Vector3}} v)}
\DoxyCodeLine{571 \{}
\DoxyCodeLine{572     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{573 }
\DoxyCodeLine{574     \textcolor{keywordtype}{float} min = (float) fabs(v.x);}
\DoxyCodeLine{575     \mbox{\hyperlink{structVector3}{Vector3}} cardinalAxis = \{1.0f, 0.0f, 0.0f\};}
\DoxyCodeLine{576 }
\DoxyCodeLine{577     \textcolor{keywordflow}{if} (fabsf(v.y) < min)}
\DoxyCodeLine{578     \{}
\DoxyCodeLine{579         min = (float) fabs(v.y);}
\DoxyCodeLine{580         \mbox{\hyperlink{structVector3}{Vector3}} tmp = \{0.0f, 1.0f, 0.0f\};}
\DoxyCodeLine{581         cardinalAxis = tmp;}
\DoxyCodeLine{582     \}}
\DoxyCodeLine{583 }
\DoxyCodeLine{584     \textcolor{keywordflow}{if} (fabsf(v.z) < min)}
\DoxyCodeLine{585     \{}
\DoxyCodeLine{586         \mbox{\hyperlink{structVector3}{Vector3}} tmp = \{0.0f, 0.0f, 1.0f\};}
\DoxyCodeLine{587         cardinalAxis = tmp;}
\DoxyCodeLine{588     \}}
\DoxyCodeLine{589 }
\DoxyCodeLine{590     \textcolor{comment}{// Cross product between vectors}}
\DoxyCodeLine{591     result.x = v.y*cardinalAxis.z -\/ v.z*cardinalAxis.y;}
\DoxyCodeLine{592     result.y = v.z*cardinalAxis.x -\/ v.x*cardinalAxis.z;}
\DoxyCodeLine{593     result.z = v.x*cardinalAxis.y -\/ v.y*cardinalAxis.x;}
\DoxyCodeLine{594 }
\DoxyCodeLine{595     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{596 \}}
\DoxyCodeLine{597 }
\DoxyCodeLine{598 \textcolor{comment}{// Calculate vector length}}
\DoxyCodeLine{599 RMAPI \textcolor{keywordtype}{float} Vector3Length(\textcolor{keyword}{const} \mbox{\hyperlink{structVector3}{Vector3}} v)}
\DoxyCodeLine{600 \{}
\DoxyCodeLine{601     \textcolor{keywordtype}{float} result = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);}
\DoxyCodeLine{602 }
\DoxyCodeLine{603     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{604 \}}
\DoxyCodeLine{605 }
\DoxyCodeLine{606 \textcolor{comment}{// Calculate vector square length}}
\DoxyCodeLine{607 RMAPI \textcolor{keywordtype}{float} Vector3LengthSqr(\textcolor{keyword}{const} \mbox{\hyperlink{structVector3}{Vector3}} v)}
\DoxyCodeLine{608 \{}
\DoxyCodeLine{609     \textcolor{keywordtype}{float} result = v.x*v.x + v.y*v.y + v.z*v.z;}
\DoxyCodeLine{610 }
\DoxyCodeLine{611     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{612 \}}
\DoxyCodeLine{613 }
\DoxyCodeLine{614 \textcolor{comment}{// Calculate two vectors dot product}}
\DoxyCodeLine{615 RMAPI \textcolor{keywordtype}{float} Vector3DotProduct(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{616 \{}
\DoxyCodeLine{617     \textcolor{keywordtype}{float} result = (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z);}
\DoxyCodeLine{618 }
\DoxyCodeLine{619     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{620 \}}
\DoxyCodeLine{621 }
\DoxyCodeLine{622 \textcolor{comment}{// Calculate distance between two vectors}}
\DoxyCodeLine{623 RMAPI \textcolor{keywordtype}{float} Vector3Distance(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{624 \{}
\DoxyCodeLine{625     \textcolor{keywordtype}{float} result = 0.0f;}
\DoxyCodeLine{626 }
\DoxyCodeLine{627     \textcolor{keywordtype}{float} dx = v2.x -\/ v1.x;}
\DoxyCodeLine{628     \textcolor{keywordtype}{float} dy = v2.y -\/ v1.y;}
\DoxyCodeLine{629     \textcolor{keywordtype}{float} dz = v2.z -\/ v1.z;}
\DoxyCodeLine{630     result = sqrtf(dx*dx + dy*dy + dz*dz);}
\DoxyCodeLine{631 }
\DoxyCodeLine{632     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{633 \}}
\DoxyCodeLine{634 }
\DoxyCodeLine{635 \textcolor{comment}{// Calculate square distance between two vectors}}
\DoxyCodeLine{636 RMAPI \textcolor{keywordtype}{float} Vector3DistanceSqr(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{637 \{}
\DoxyCodeLine{638     \textcolor{keywordtype}{float} result = 0.0f;}
\DoxyCodeLine{639 }
\DoxyCodeLine{640     \textcolor{keywordtype}{float} dx = v2.x -\/ v1.x;}
\DoxyCodeLine{641     \textcolor{keywordtype}{float} dy = v2.y -\/ v1.y;}
\DoxyCodeLine{642     \textcolor{keywordtype}{float} dz = v2.z -\/ v1.z;}
\DoxyCodeLine{643     result = dx*dx + dy*dy + dz*dz;}
\DoxyCodeLine{644 }
\DoxyCodeLine{645     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{646 \}}
\DoxyCodeLine{647 }
\DoxyCodeLine{648 \textcolor{comment}{// Calculate angle between two vectors}}
\DoxyCodeLine{649 RMAPI \textcolor{keywordtype}{float} Vector3Angle(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{650 \{}
\DoxyCodeLine{651     \textcolor{keywordtype}{float} result = 0.0f;}
\DoxyCodeLine{652 }
\DoxyCodeLine{653     \mbox{\hyperlink{structVector3}{Vector3}} cross = \{ v1.y*v2.z -\/ v1.z*v2.y, v1.z*v2.x -\/ v1.x*v2.z, v1.x*v2.y -\/ v1.y*v2.x \};}
\DoxyCodeLine{654     \textcolor{keywordtype}{float} len = sqrtf(cross.x*cross.x + cross.y*cross.y + cross.z*cross.z);}
\DoxyCodeLine{655     \textcolor{keywordtype}{float} dot = (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z);}
\DoxyCodeLine{656     result = atan2f(len, dot);}
\DoxyCodeLine{657 }
\DoxyCodeLine{658     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{659 \}}
\DoxyCodeLine{660 }
\DoxyCodeLine{661 \textcolor{comment}{// Negate provided vector (invert direction)}}
\DoxyCodeLine{662 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Negate(\mbox{\hyperlink{structVector3}{Vector3}} v)}
\DoxyCodeLine{663 \{}
\DoxyCodeLine{664     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ -\/v.x, -\/v.y, -\/v.z \};}
\DoxyCodeLine{665 }
\DoxyCodeLine{666     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{667 \}}
\DoxyCodeLine{668 }
\DoxyCodeLine{669 \textcolor{comment}{// Divide vector by vector}}
\DoxyCodeLine{670 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Divide(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{671 \{}
\DoxyCodeLine{672     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ v1.x/v2.x, v1.y/v2.y, v1.z/v2.z \};}
\DoxyCodeLine{673 }
\DoxyCodeLine{674     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{675 \}}
\DoxyCodeLine{676 }
\DoxyCodeLine{677 \textcolor{comment}{// Normalize provided vector}}
\DoxyCodeLine{678 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Normalize(\mbox{\hyperlink{structVector3}{Vector3}} v)}
\DoxyCodeLine{679 \{}
\DoxyCodeLine{680     \mbox{\hyperlink{structVector3}{Vector3}} result = v;}
\DoxyCodeLine{681 }
\DoxyCodeLine{682     \textcolor{keywordtype}{float} length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);}
\DoxyCodeLine{683     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{684     \textcolor{keywordtype}{float} ilength = 1.0f/length;}
\DoxyCodeLine{685 }
\DoxyCodeLine{686     result.x *= ilength;}
\DoxyCodeLine{687     result.y *= ilength;}
\DoxyCodeLine{688     result.z *= ilength;}
\DoxyCodeLine{689 }
\DoxyCodeLine{690     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{691 \}}
\DoxyCodeLine{692 }
\DoxyCodeLine{693 \textcolor{comment}{// Orthonormalize provided vectors}}
\DoxyCodeLine{694 \textcolor{comment}{// Makes vectors normalized and orthogonal to each other}}
\DoxyCodeLine{695 \textcolor{comment}{// Gram-\/Schmidt function implementation}}
\DoxyCodeLine{696 RMAPI \textcolor{keywordtype}{void} Vector3OrthoNormalize(\mbox{\hyperlink{structVector3}{Vector3}} *v1, \mbox{\hyperlink{structVector3}{Vector3}} *v2)}
\DoxyCodeLine{697 \{}
\DoxyCodeLine{698     \textcolor{keywordtype}{float} length = 0.0f;}
\DoxyCodeLine{699     \textcolor{keywordtype}{float} ilength = 0.0f;}
\DoxyCodeLine{700 }
\DoxyCodeLine{701     \textcolor{comment}{// Vector3Normalize(*v1);}}
\DoxyCodeLine{702     \mbox{\hyperlink{structVector3}{Vector3}} v = *v1;}
\DoxyCodeLine{703     length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);}
\DoxyCodeLine{704     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{705     ilength = 1.0f/length;}
\DoxyCodeLine{706     v1-\/>x *= ilength;}
\DoxyCodeLine{707     v1-\/>y *= ilength;}
\DoxyCodeLine{708     v1-\/>z *= ilength;}
\DoxyCodeLine{709 }
\DoxyCodeLine{710     \textcolor{comment}{// Vector3CrossProduct(*v1, *v2)}}
\DoxyCodeLine{711     \mbox{\hyperlink{structVector3}{Vector3}} vn1 = \{ v1-\/>y*v2-\/>z -\/ v1-\/>z*v2-\/>y, v1-\/>z*v2-\/>x -\/ v1-\/>x*v2-\/>z, v1-\/>x*v2-\/>y -\/ v1-\/>y*v2-\/>x \};}
\DoxyCodeLine{712 }
\DoxyCodeLine{713     \textcolor{comment}{// Vector3Normalize(vn1);}}
\DoxyCodeLine{714     v = vn1;}
\DoxyCodeLine{715     length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);}
\DoxyCodeLine{716     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{717     ilength = 1.0f/length;}
\DoxyCodeLine{718     vn1.x *= ilength;}
\DoxyCodeLine{719     vn1.y *= ilength;}
\DoxyCodeLine{720     vn1.z *= ilength;}
\DoxyCodeLine{721 }
\DoxyCodeLine{722     \textcolor{comment}{// Vector3CrossProduct(vn1, *v1)}}
\DoxyCodeLine{723     \mbox{\hyperlink{structVector3}{Vector3}} vn2 = \{ vn1.y*v1-\/>z -\/ vn1.z*v1-\/>y, vn1.z*v1-\/>x -\/ vn1.x*v1-\/>z, vn1.x*v1-\/>y -\/ vn1.y*v1-\/>x \};}
\DoxyCodeLine{724 }
\DoxyCodeLine{725     *v2 = vn2;}
\DoxyCodeLine{726 \}}
\DoxyCodeLine{727 }
\DoxyCodeLine{728 \textcolor{comment}{// Transforms a Vector3 by a given Matrix}}
\DoxyCodeLine{729 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Transform(\mbox{\hyperlink{structVector3}{Vector3}} v, \mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{730 \{}
\DoxyCodeLine{731     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{732 }
\DoxyCodeLine{733     \textcolor{keywordtype}{float} x = v.x;}
\DoxyCodeLine{734     \textcolor{keywordtype}{float} y = v.y;}
\DoxyCodeLine{735     \textcolor{keywordtype}{float} z = v.z;}
\DoxyCodeLine{736 }
\DoxyCodeLine{737     result.x = mat.m0*x + mat.m4*y + mat.m8*z + mat.m12;}
\DoxyCodeLine{738     result.y = mat.m1*x + mat.m5*y + mat.m9*z + mat.m13;}
\DoxyCodeLine{739     result.z = mat.m2*x + mat.m6*y + mat.m10*z + mat.m14;}
\DoxyCodeLine{740 }
\DoxyCodeLine{741     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{742 \}}
\DoxyCodeLine{743 }
\DoxyCodeLine{744 \textcolor{comment}{// Transform a vector by quaternion rotation}}
\DoxyCodeLine{745 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3RotateByQuaternion(\mbox{\hyperlink{structVector3}{Vector3}} v, \mbox{\hyperlink{structVector4}{Quaternion}} q)}
\DoxyCodeLine{746 \{}
\DoxyCodeLine{747     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{748 }
\DoxyCodeLine{749     result.x = v.x*(q.x*q.x + q.w*q.w -\/ q.y*q.y -\/ q.z*q.z) + v.y*(2*q.x*q.y -\/ 2*q.w*q.z) + v.z*(2*q.x*q.z + 2*q.w*q.y);}
\DoxyCodeLine{750     result.y = v.x*(2*q.w*q.z + 2*q.x*q.y) + v.y*(q.w*q.w -\/ q.x*q.x + q.y*q.y -\/ q.z*q.z) + v.z*(-\/2*q.w*q.x + 2*q.y*q.z);}
\DoxyCodeLine{751     result.z = v.x*(-\/2*q.w*q.y + 2*q.x*q.z) + v.y*(2*q.w*q.x + 2*q.y*q.z)+ v.z*(q.w*q.w -\/ q.x*q.x -\/ q.y*q.y + q.z*q.z);}
\DoxyCodeLine{752 }
\DoxyCodeLine{753     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{754 \}}
\DoxyCodeLine{755 }
\DoxyCodeLine{756 \textcolor{comment}{// Rotates a vector around an axis}}
\DoxyCodeLine{757 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3RotateByAxisAngle(\mbox{\hyperlink{structVector3}{Vector3}} v, \mbox{\hyperlink{structVector3}{Vector3}} axis, \textcolor{keywordtype}{float} angle)}
\DoxyCodeLine{758 \{}
\DoxyCodeLine{759     \textcolor{comment}{// Using Euler-\/Rodrigues Formula}}
\DoxyCodeLine{760     \textcolor{comment}{// Ref.: https://en.wikipedia.org/w/index.php?title=Euler\%E2\%80\%93Rodrigues\_formula}}
\DoxyCodeLine{761 }
\DoxyCodeLine{762     \mbox{\hyperlink{structVector3}{Vector3}} result = v;}
\DoxyCodeLine{763 }
\DoxyCodeLine{764     \textcolor{comment}{// Vector3Normalize(axis);}}
\DoxyCodeLine{765     \textcolor{keywordtype}{float} length = sqrtf(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z);}
\DoxyCodeLine{766     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{767     \textcolor{keywordtype}{float} ilength = 1.0f / length;}
\DoxyCodeLine{768     axis.x *= ilength;}
\DoxyCodeLine{769     axis.y *= ilength;}
\DoxyCodeLine{770     axis.z *= ilength;}
\DoxyCodeLine{771 }
\DoxyCodeLine{772     angle /= 2.0f;}
\DoxyCodeLine{773     \textcolor{keywordtype}{float} a = sinf(angle);}
\DoxyCodeLine{774     \textcolor{keywordtype}{float} b = axis.x * a;}
\DoxyCodeLine{775     \textcolor{keywordtype}{float} c = axis.y * a;}
\DoxyCodeLine{776     \textcolor{keywordtype}{float} d = axis.z * a;}
\DoxyCodeLine{777     a = cosf(angle);}
\DoxyCodeLine{778     \mbox{\hyperlink{structVector3}{Vector3}} w = \{ b, c, d \};}
\DoxyCodeLine{779 }
\DoxyCodeLine{780     \textcolor{comment}{// Vector3CrossProduct(w, v)}}
\DoxyCodeLine{781     \mbox{\hyperlink{structVector3}{Vector3}} wv = \{ w.y * v.z -\/ w.z * v.y, w.z * v.x -\/ w.x * v.z, w.x * v.y -\/ w.y * v.x \};}
\DoxyCodeLine{782 }
\DoxyCodeLine{783     \textcolor{comment}{// Vector3CrossProduct(w, wv)}}
\DoxyCodeLine{784     \mbox{\hyperlink{structVector3}{Vector3}} wwv = \{ w.y * wv.z -\/ w.z * wv.y, w.z * wv.x -\/ w.x * wv.z, w.x * wv.y -\/ w.y * wv.x \};}
\DoxyCodeLine{785 }
\DoxyCodeLine{786     \textcolor{comment}{// Vector3Scale(wv, 2 * a)}}
\DoxyCodeLine{787     a *= 2;}
\DoxyCodeLine{788     wv.x *= a;}
\DoxyCodeLine{789     wv.y *= a;}
\DoxyCodeLine{790     wv.z *= a;}
\DoxyCodeLine{791 }
\DoxyCodeLine{792     \textcolor{comment}{// Vector3Scale(wwv, 2)}}
\DoxyCodeLine{793     wwv.x *= 2;}
\DoxyCodeLine{794     wwv.y *= 2;}
\DoxyCodeLine{795     wwv.z *= 2;}
\DoxyCodeLine{796 }
\DoxyCodeLine{797     result.x += wv.x;}
\DoxyCodeLine{798     result.y += wv.y;}
\DoxyCodeLine{799     result.z += wv.z;}
\DoxyCodeLine{800 }
\DoxyCodeLine{801     result.x += wwv.x;}
\DoxyCodeLine{802     result.y += wwv.y;}
\DoxyCodeLine{803     result.z += wwv.z;}
\DoxyCodeLine{804 }
\DoxyCodeLine{805     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{806 \}}
\DoxyCodeLine{807 }
\DoxyCodeLine{808 \textcolor{comment}{// Calculate linear interpolation between two vectors}}
\DoxyCodeLine{809 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Lerp(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2, \textcolor{keywordtype}{float} amount)}
\DoxyCodeLine{810 \{}
\DoxyCodeLine{811     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{812 }
\DoxyCodeLine{813     result.x = v1.x + amount*(v2.x -\/ v1.x);}
\DoxyCodeLine{814     result.y = v1.y + amount*(v2.y -\/ v1.y);}
\DoxyCodeLine{815     result.z = v1.z + amount*(v2.z -\/ v1.z);}
\DoxyCodeLine{816 }
\DoxyCodeLine{817     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{818 \}}
\DoxyCodeLine{819 }
\DoxyCodeLine{820 \textcolor{comment}{// Calculate reflected vector to normal}}
\DoxyCodeLine{821 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Reflect(\mbox{\hyperlink{structVector3}{Vector3}} v, \mbox{\hyperlink{structVector3}{Vector3}} normal)}
\DoxyCodeLine{822 \{}
\DoxyCodeLine{823     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{824 }
\DoxyCodeLine{825     \textcolor{comment}{// I is the original vector}}
\DoxyCodeLine{826     \textcolor{comment}{// N is the normal of the incident plane}}
\DoxyCodeLine{827     \textcolor{comment}{// R = I -\/ (2*N*(DotProduct[I, N]))}}
\DoxyCodeLine{828 }
\DoxyCodeLine{829     \textcolor{keywordtype}{float} dotProduct = (v.x*normal.x + v.y*normal.y + v.z*normal.z);}
\DoxyCodeLine{830 }
\DoxyCodeLine{831     result.x = v.x -\/ (2.0f*normal.x)*dotProduct;}
\DoxyCodeLine{832     result.y = v.y -\/ (2.0f*normal.y)*dotProduct;}
\DoxyCodeLine{833     result.z = v.z -\/ (2.0f*normal.z)*dotProduct;}
\DoxyCodeLine{834 }
\DoxyCodeLine{835     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{836 \}}
\DoxyCodeLine{837 }
\DoxyCodeLine{838 \textcolor{comment}{// Get min value for each pair of components}}
\DoxyCodeLine{839 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Min(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{840 \{}
\DoxyCodeLine{841     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{842 }
\DoxyCodeLine{843     result.x = fminf(v1.x, v2.x);}
\DoxyCodeLine{844     result.y = fminf(v1.y, v2.y);}
\DoxyCodeLine{845     result.z = fminf(v1.z, v2.z);}
\DoxyCodeLine{846 }
\DoxyCodeLine{847     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{848 \}}
\DoxyCodeLine{849 }
\DoxyCodeLine{850 \textcolor{comment}{// Get max value for each pair of components}}
\DoxyCodeLine{851 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Max(\mbox{\hyperlink{structVector3}{Vector3}} v1, \mbox{\hyperlink{structVector3}{Vector3}} v2)}
\DoxyCodeLine{852 \{}
\DoxyCodeLine{853     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{854 }
\DoxyCodeLine{855     result.x = fmaxf(v1.x, v2.x);}
\DoxyCodeLine{856     result.y = fmaxf(v1.y, v2.y);}
\DoxyCodeLine{857     result.z = fmaxf(v1.z, v2.z);}
\DoxyCodeLine{858 }
\DoxyCodeLine{859     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{860 \}}
\DoxyCodeLine{861 }
\DoxyCodeLine{862 \textcolor{comment}{// Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)}}
\DoxyCodeLine{863 \textcolor{comment}{// NOTE: Assumes P is on the plane of the triangle}}
\DoxyCodeLine{864 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Barycenter(\mbox{\hyperlink{structVector3}{Vector3}} p, \mbox{\hyperlink{structVector3}{Vector3}} a, \mbox{\hyperlink{structVector3}{Vector3}} b, \mbox{\hyperlink{structVector3}{Vector3}} c)}
\DoxyCodeLine{865 \{}
\DoxyCodeLine{866     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{867 }
\DoxyCodeLine{868     \mbox{\hyperlink{structVector3}{Vector3}} v0 = \{ b.x -\/ a.x, b.y -\/ a.y, b.z -\/ a.z \};   \textcolor{comment}{// Vector3Subtract(b, a)}}
\DoxyCodeLine{869     \mbox{\hyperlink{structVector3}{Vector3}} v1 = \{ c.x -\/ a.x, c.y -\/ a.y, c.z -\/ a.z \};   \textcolor{comment}{// Vector3Subtract(c, a)}}
\DoxyCodeLine{870     \mbox{\hyperlink{structVector3}{Vector3}} v2 = \{ p.x -\/ a.x, p.y -\/ a.y, p.z -\/ a.z \};   \textcolor{comment}{// Vector3Subtract(p, a)}}
\DoxyCodeLine{871     \textcolor{keywordtype}{float} d00 = (v0.x*v0.x + v0.y*v0.y + v0.z*v0.z);    \textcolor{comment}{// Vector3DotProduct(v0, v0)}}
\DoxyCodeLine{872     \textcolor{keywordtype}{float} d01 = (v0.x*v1.x + v0.y*v1.y + v0.z*v1.z);    \textcolor{comment}{// Vector3DotProduct(v0, v1)}}
\DoxyCodeLine{873     \textcolor{keywordtype}{float} d11 = (v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);    \textcolor{comment}{// Vector3DotProduct(v1, v1)}}
\DoxyCodeLine{874     \textcolor{keywordtype}{float} d20 = (v2.x*v0.x + v2.y*v0.y + v2.z*v0.z);    \textcolor{comment}{// Vector3DotProduct(v2, v0)}}
\DoxyCodeLine{875     \textcolor{keywordtype}{float} d21 = (v2.x*v1.x + v2.y*v1.y + v2.z*v1.z);    \textcolor{comment}{// Vector3DotProduct(v2, v1)}}
\DoxyCodeLine{876 }
\DoxyCodeLine{877     \textcolor{keywordtype}{float} denom = d00*d11 -\/ d01*d01;}
\DoxyCodeLine{878 }
\DoxyCodeLine{879     result.y = (d11*d20 -\/ d01*d21)/denom;}
\DoxyCodeLine{880     result.z = (d00*d21 -\/ d01*d20)/denom;}
\DoxyCodeLine{881     result.x = 1.0f -\/ (result.z + result.y);}
\DoxyCodeLine{882 }
\DoxyCodeLine{883     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{884 \}}
\DoxyCodeLine{885 }
\DoxyCodeLine{886 \textcolor{comment}{// Projects a Vector3 from screen space into object space}}
\DoxyCodeLine{887 \textcolor{comment}{// NOTE: We are avoiding calling other raymath functions despite available}}
\DoxyCodeLine{888 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Unproject(\mbox{\hyperlink{structVector3}{Vector3}} source, \mbox{\hyperlink{structMatrix}{Matrix}} projection, \mbox{\hyperlink{structMatrix}{Matrix}} view)}
\DoxyCodeLine{889 \{}
\DoxyCodeLine{890     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{891 }
\DoxyCodeLine{892     \textcolor{comment}{// Calculate unproject matrix (multiply view patrix by projection matrix) and invert it}}
\DoxyCodeLine{893     \mbox{\hyperlink{structMatrix}{Matrix}} matViewProj = \{      \textcolor{comment}{// MatrixMultiply(view, projection);}}
\DoxyCodeLine{894         view.m0*projection.m0 + view.m1*projection.m4 + view.m2*projection.m8 + view.m3*projection.m12,}
\DoxyCodeLine{895         view.m0*projection.m1 + view.m1*projection.m5 + view.m2*projection.m9 + view.m3*projection.m13,}
\DoxyCodeLine{896         view.m0*projection.m2 + view.m1*projection.m6 + view.m2*projection.m10 + view.m3*projection.m14,}
\DoxyCodeLine{897         view.m0*projection.m3 + view.m1*projection.m7 + view.m2*projection.m11 + view.m3*projection.m15,}
\DoxyCodeLine{898         view.m4*projection.m0 + view.m5*projection.m4 + view.m6*projection.m8 + view.m7*projection.m12,}
\DoxyCodeLine{899         view.m4*projection.m1 + view.m5*projection.m5 + view.m6*projection.m9 + view.m7*projection.m13,}
\DoxyCodeLine{900         view.m4*projection.m2 + view.m5*projection.m6 + view.m6*projection.m10 + view.m7*projection.m14,}
\DoxyCodeLine{901         view.m4*projection.m3 + view.m5*projection.m7 + view.m6*projection.m11 + view.m7*projection.m15,}
\DoxyCodeLine{902         view.m8*projection.m0 + view.m9*projection.m4 + view.m10*projection.m8 + view.m11*projection.m12,}
\DoxyCodeLine{903         view.m8*projection.m1 + view.m9*projection.m5 + view.m10*projection.m9 + view.m11*projection.m13,}
\DoxyCodeLine{904         view.m8*projection.m2 + view.m9*projection.m6 + view.m10*projection.m10 + view.m11*projection.m14,}
\DoxyCodeLine{905         view.m8*projection.m3 + view.m9*projection.m7 + view.m10*projection.m11 + view.m11*projection.m15,}
\DoxyCodeLine{906         view.m12*projection.m0 + view.m13*projection.m4 + view.m14*projection.m8 + view.m15*projection.m12,}
\DoxyCodeLine{907         view.m12*projection.m1 + view.m13*projection.m5 + view.m14*projection.m9 + view.m15*projection.m13,}
\DoxyCodeLine{908         view.m12*projection.m2 + view.m13*projection.m6 + view.m14*projection.m10 + view.m15*projection.m14,}
\DoxyCodeLine{909         view.m12*projection.m3 + view.m13*projection.m7 + view.m14*projection.m11 + view.m15*projection.m15 \};}
\DoxyCodeLine{910 }
\DoxyCodeLine{911     \textcolor{comment}{// Calculate inverted matrix -\/> MatrixInvert(matViewProj);}}
\DoxyCodeLine{912     \textcolor{comment}{// Cache the matrix values (speed optimization)}}
\DoxyCodeLine{913     \textcolor{keywordtype}{float} a00 = matViewProj.m0, a01 = matViewProj.m1, a02 = matViewProj.m2, a03 = matViewProj.m3;}
\DoxyCodeLine{914     \textcolor{keywordtype}{float} a10 = matViewProj.m4, a11 = matViewProj.m5, a12 = matViewProj.m6, a13 = matViewProj.m7;}
\DoxyCodeLine{915     \textcolor{keywordtype}{float} a20 = matViewProj.m8, a21 = matViewProj.m9, a22 = matViewProj.m10, a23 = matViewProj.m11;}
\DoxyCodeLine{916     \textcolor{keywordtype}{float} a30 = matViewProj.m12, a31 = matViewProj.m13, a32 = matViewProj.m14, a33 = matViewProj.m15;}
\DoxyCodeLine{917 }
\DoxyCodeLine{918     \textcolor{keywordtype}{float} b00 = a00*a11 -\/ a01*a10;}
\DoxyCodeLine{919     \textcolor{keywordtype}{float} b01 = a00*a12 -\/ a02*a10;}
\DoxyCodeLine{920     \textcolor{keywordtype}{float} b02 = a00*a13 -\/ a03*a10;}
\DoxyCodeLine{921     \textcolor{keywordtype}{float} b03 = a01*a12 -\/ a02*a11;}
\DoxyCodeLine{922     \textcolor{keywordtype}{float} b04 = a01*a13 -\/ a03*a11;}
\DoxyCodeLine{923     \textcolor{keywordtype}{float} b05 = a02*a13 -\/ a03*a12;}
\DoxyCodeLine{924     \textcolor{keywordtype}{float} b06 = a20*a31 -\/ a21*a30;}
\DoxyCodeLine{925     \textcolor{keywordtype}{float} b07 = a20*a32 -\/ a22*a30;}
\DoxyCodeLine{926     \textcolor{keywordtype}{float} b08 = a20*a33 -\/ a23*a30;}
\DoxyCodeLine{927     \textcolor{keywordtype}{float} b09 = a21*a32 -\/ a22*a31;}
\DoxyCodeLine{928     \textcolor{keywordtype}{float} b10 = a21*a33 -\/ a23*a31;}
\DoxyCodeLine{929     \textcolor{keywordtype}{float} b11 = a22*a33 -\/ a23*a32;}
\DoxyCodeLine{930 }
\DoxyCodeLine{931     \textcolor{comment}{// Calculate the invert determinant (inlined to avoid double-\/caching)}}
\DoxyCodeLine{932     \textcolor{keywordtype}{float} invDet = 1.0f/(b00*b11 -\/ b01*b10 + b02*b09 + b03*b08 -\/ b04*b07 + b05*b06);}
\DoxyCodeLine{933 }
\DoxyCodeLine{934     \mbox{\hyperlink{structMatrix}{Matrix}} matViewProjInv = \{}
\DoxyCodeLine{935         (a11*b11 -\/ a12*b10 + a13*b09)*invDet,}
\DoxyCodeLine{936         (-\/a01*b11 + a02*b10 -\/ a03*b09)*invDet,}
\DoxyCodeLine{937         (a31*b05 -\/ a32*b04 + a33*b03)*invDet,}
\DoxyCodeLine{938         (-\/a21*b05 + a22*b04 -\/ a23*b03)*invDet,}
\DoxyCodeLine{939         (-\/a10*b11 + a12*b08 -\/ a13*b07)*invDet,}
\DoxyCodeLine{940         (a00*b11 -\/ a02*b08 + a03*b07)*invDet,}
\DoxyCodeLine{941         (-\/a30*b05 + a32*b02 -\/ a33*b01)*invDet,}
\DoxyCodeLine{942         (a20*b05 -\/ a22*b02 + a23*b01)*invDet,}
\DoxyCodeLine{943         (a10*b10 -\/ a11*b08 + a13*b06)*invDet,}
\DoxyCodeLine{944         (-\/a00*b10 + a01*b08 -\/ a03*b06)*invDet,}
\DoxyCodeLine{945         (a30*b04 -\/ a31*b02 + a33*b00)*invDet,}
\DoxyCodeLine{946         (-\/a20*b04 + a21*b02 -\/ a23*b00)*invDet,}
\DoxyCodeLine{947         (-\/a10*b09 + a11*b07 -\/ a12*b06)*invDet,}
\DoxyCodeLine{948         (a00*b09 -\/ a01*b07 + a02*b06)*invDet,}
\DoxyCodeLine{949         (-\/a30*b03 + a31*b01 -\/ a32*b00)*invDet,}
\DoxyCodeLine{950         (a20*b03 -\/ a21*b01 + a22*b00)*invDet \};}
\DoxyCodeLine{951 }
\DoxyCodeLine{952     \textcolor{comment}{// Create quaternion from source point}}
\DoxyCodeLine{953     \mbox{\hyperlink{structVector4}{Quaternion}} quat = \{ source.x, source.y, source.z, 1.0f \};}
\DoxyCodeLine{954 }
\DoxyCodeLine{955     \textcolor{comment}{// Multiply quat point by unproject matrix}}
\DoxyCodeLine{956     \mbox{\hyperlink{structVector4}{Quaternion}} qtransformed = \{     \textcolor{comment}{// QuaternionTransform(quat, matViewProjInv)}}
\DoxyCodeLine{957         matViewProjInv.m0*quat.x + matViewProjInv.m4*quat.y + matViewProjInv.m8*quat.z + matViewProjInv.m12*quat.w,}
\DoxyCodeLine{958         matViewProjInv.m1*quat.x + matViewProjInv.m5*quat.y + matViewProjInv.m9*quat.z + matViewProjInv.m13*quat.w,}
\DoxyCodeLine{959         matViewProjInv.m2*quat.x + matViewProjInv.m6*quat.y + matViewProjInv.m10*quat.z + matViewProjInv.m14*quat.w,}
\DoxyCodeLine{960         matViewProjInv.m3*quat.x + matViewProjInv.m7*quat.y + matViewProjInv.m11*quat.z + matViewProjInv.m15*quat.w \};}
\DoxyCodeLine{961 }
\DoxyCodeLine{962     \textcolor{comment}{// Normalized world points in vectors}}
\DoxyCodeLine{963     result.x = qtransformed.x/qtransformed.w;}
\DoxyCodeLine{964     result.y = qtransformed.y/qtransformed.w;}
\DoxyCodeLine{965     result.z = qtransformed.z/qtransformed.w;}
\DoxyCodeLine{966 }
\DoxyCodeLine{967     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{968 \}}
\DoxyCodeLine{969 }
\DoxyCodeLine{970 \textcolor{comment}{// Get Vector3 as float array}}
\DoxyCodeLine{971 RMAPI \mbox{\hyperlink{structfloat3}{float3}} Vector3ToFloatV(\mbox{\hyperlink{structVector3}{Vector3}} v)}
\DoxyCodeLine{972 \{}
\DoxyCodeLine{973     \mbox{\hyperlink{structfloat3}{float3}} buffer = \{ 0 \};}
\DoxyCodeLine{974 }
\DoxyCodeLine{975     buffer.v[0] = v.x;}
\DoxyCodeLine{976     buffer.v[1] = v.y;}
\DoxyCodeLine{977     buffer.v[2] = v.z;}
\DoxyCodeLine{978 }
\DoxyCodeLine{979     \textcolor{keywordflow}{return} buffer;}
\DoxyCodeLine{980 \}}
\DoxyCodeLine{981 }
\DoxyCodeLine{982 \textcolor{comment}{// Invert the given vector}}
\DoxyCodeLine{983 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Invert(\mbox{\hyperlink{structVector3}{Vector3}} v)}
\DoxyCodeLine{984 \{}
\DoxyCodeLine{985     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 1.0f/v.x, 1.0f/v.y, 1.0f/v.z \};}
\DoxyCodeLine{986 }
\DoxyCodeLine{987     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{988 \}}
\DoxyCodeLine{989 }
\DoxyCodeLine{990 \textcolor{comment}{// Clamp the components of the vector between}}
\DoxyCodeLine{991 \textcolor{comment}{// min and max values specified by the given vectors}}
\DoxyCodeLine{992 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Clamp(\mbox{\hyperlink{structVector3}{Vector3}} v, \mbox{\hyperlink{structVector3}{Vector3}} min, \mbox{\hyperlink{structVector3}{Vector3}} max)}
\DoxyCodeLine{993 \{}
\DoxyCodeLine{994     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{995 }
\DoxyCodeLine{996     result.x = fminf(max.x, fmaxf(min.x, v.x));}
\DoxyCodeLine{997     result.y = fminf(max.y, fmaxf(min.y, v.y));}
\DoxyCodeLine{998     result.z = fminf(max.z, fmaxf(min.z, v.z));}
\DoxyCodeLine{999 }
\DoxyCodeLine{1000     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1001 \}}
\DoxyCodeLine{1002 }
\DoxyCodeLine{1003 \textcolor{comment}{// Clamp the magnitude of the vector between two values}}
\DoxyCodeLine{1004 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3ClampValue(\mbox{\hyperlink{structVector3}{Vector3}} v, \textcolor{keywordtype}{float} min, \textcolor{keywordtype}{float} max)}
\DoxyCodeLine{1005 \{}
\DoxyCodeLine{1006     \mbox{\hyperlink{structVector3}{Vector3}} result = v;}
\DoxyCodeLine{1007 }
\DoxyCodeLine{1008     \textcolor{keywordtype}{float} length = (v.x*v.x) + (v.y*v.y) + (v.z*v.z);}
\DoxyCodeLine{1009     \textcolor{keywordflow}{if} (length > 0.0f)}
\DoxyCodeLine{1010     \{}
\DoxyCodeLine{1011         length = sqrtf(length);}
\DoxyCodeLine{1012 }
\DoxyCodeLine{1013         \textcolor{keywordflow}{if} (length < min)}
\DoxyCodeLine{1014         \{}
\DoxyCodeLine{1015             \textcolor{keywordtype}{float} scale = min/length;}
\DoxyCodeLine{1016             result.x = v.x*scale;}
\DoxyCodeLine{1017             result.y = v.y*scale;}
\DoxyCodeLine{1018             result.z = v.z*scale;}
\DoxyCodeLine{1019         \}}
\DoxyCodeLine{1020         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (length > max)}
\DoxyCodeLine{1021         \{}
\DoxyCodeLine{1022             \textcolor{keywordtype}{float} scale = max/length;}
\DoxyCodeLine{1023             result.x = v.x*scale;}
\DoxyCodeLine{1024             result.y = v.y*scale;}
\DoxyCodeLine{1025             result.z = v.z*scale;}
\DoxyCodeLine{1026         \}}
\DoxyCodeLine{1027     \}}
\DoxyCodeLine{1028 }
\DoxyCodeLine{1029     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1030 \}}
\DoxyCodeLine{1031 }
\DoxyCodeLine{1032 \textcolor{comment}{// Check whether two given vectors are almost equal}}
\DoxyCodeLine{1033 RMAPI \textcolor{keywordtype}{int} Vector3Equals(\mbox{\hyperlink{structVector3}{Vector3}} p, \mbox{\hyperlink{structVector3}{Vector3}} q)}
\DoxyCodeLine{1034 \{}
\DoxyCodeLine{1035     \textcolor{keywordtype}{int} result = ((fabsf(p.x -\/ q.x)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.x), fabsf(q.x))))) \&\&}
\DoxyCodeLine{1036                   ((fabsf(p.y -\/ q.y)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.y), fabsf(q.y))))) \&\&}
\DoxyCodeLine{1037                   ((fabsf(p.z -\/ q.z)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.z), fabsf(q.z)))));}
\DoxyCodeLine{1038 }
\DoxyCodeLine{1039     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1040 \}}
\DoxyCodeLine{1041 }
\DoxyCodeLine{1042 \textcolor{comment}{// Compute the direction of a refracted ray where v specifies the}}
\DoxyCodeLine{1043 \textcolor{comment}{// normalized direction of the incoming ray, n specifies the}}
\DoxyCodeLine{1044 \textcolor{comment}{// normalized normal vector of the interface of two optical media,}}
\DoxyCodeLine{1045 \textcolor{comment}{// and r specifies the ratio of the refractive index of the medium}}
\DoxyCodeLine{1046 \textcolor{comment}{// from where the ray comes to the refractive index of the medium}}
\DoxyCodeLine{1047 \textcolor{comment}{// on the other side of the surface}}
\DoxyCodeLine{1048 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} Vector3Refract(\mbox{\hyperlink{structVector3}{Vector3}} v, \mbox{\hyperlink{structVector3}{Vector3}} n, \textcolor{keywordtype}{float} r)}
\DoxyCodeLine{1049 \{}
\DoxyCodeLine{1050     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{1051 }
\DoxyCodeLine{1052     \textcolor{keywordtype}{float} dot = v.x*n.x + v.y*n.y + v.z*n.z;}
\DoxyCodeLine{1053     \textcolor{keywordtype}{float} d = 1.0f -\/ r*r*(1.0f -\/ dot*dot);}
\DoxyCodeLine{1054 }
\DoxyCodeLine{1055     \textcolor{keywordflow}{if} (d >= 0.0f)}
\DoxyCodeLine{1056     \{}
\DoxyCodeLine{1057         d = sqrtf(d);}
\DoxyCodeLine{1058         v.x = r*v.x -\/ (r*dot + d)*n.x;}
\DoxyCodeLine{1059         v.y = r*v.y -\/ (r*dot + d)*n.y;}
\DoxyCodeLine{1060         v.z = r*v.z -\/ (r*dot + d)*n.z;}
\DoxyCodeLine{1061 }
\DoxyCodeLine{1062         result = v;}
\DoxyCodeLine{1063     \}}
\DoxyCodeLine{1064 }
\DoxyCodeLine{1065     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1066 \}}
\DoxyCodeLine{1067 }
\DoxyCodeLine{1068 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1069 \textcolor{comment}{// Module Functions Definition -\/ Matrix math}}
\DoxyCodeLine{1070 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1071 }
\DoxyCodeLine{1072 \textcolor{comment}{// Compute matrix determinant}}
\DoxyCodeLine{1073 RMAPI \textcolor{keywordtype}{float} MatrixDeterminant(\mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{1074 \{}
\DoxyCodeLine{1075     \textcolor{keywordtype}{float} result = 0.0f;}
\DoxyCodeLine{1076 }
\DoxyCodeLine{1077     \textcolor{comment}{// Cache the matrix values (speed optimization)}}
\DoxyCodeLine{1078     \textcolor{keywordtype}{float} a00 = mat.m0, a01 = mat.m1, a02 = mat.m2, a03 = mat.m3;}
\DoxyCodeLine{1079     \textcolor{keywordtype}{float} a10 = mat.m4, a11 = mat.m5, a12 = mat.m6, a13 = mat.m7;}
\DoxyCodeLine{1080     \textcolor{keywordtype}{float} a20 = mat.m8, a21 = mat.m9, a22 = mat.m10, a23 = mat.m11;}
\DoxyCodeLine{1081     \textcolor{keywordtype}{float} a30 = mat.m12, a31 = mat.m13, a32 = mat.m14, a33 = mat.m15;}
\DoxyCodeLine{1082 }
\DoxyCodeLine{1083     result = a30*a21*a12*a03 -\/ a20*a31*a12*a03 -\/ a30*a11*a22*a03 + a10*a31*a22*a03 +}
\DoxyCodeLine{1084              a20*a11*a32*a03 -\/ a10*a21*a32*a03 -\/ a30*a21*a02*a13 + a20*a31*a02*a13 +}
\DoxyCodeLine{1085              a30*a01*a22*a13 -\/ a00*a31*a22*a13 -\/ a20*a01*a32*a13 + a00*a21*a32*a13 +}
\DoxyCodeLine{1086              a30*a11*a02*a23 -\/ a10*a31*a02*a23 -\/ a30*a01*a12*a23 + a00*a31*a12*a23 +}
\DoxyCodeLine{1087              a10*a01*a32*a23 -\/ a00*a11*a32*a23 -\/ a20*a11*a02*a33 + a10*a21*a02*a33 +}
\DoxyCodeLine{1088              a20*a01*a12*a33 -\/ a00*a21*a12*a33 -\/ a10*a01*a22*a33 + a00*a11*a22*a33;}
\DoxyCodeLine{1089 }
\DoxyCodeLine{1090     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1091 \}}
\DoxyCodeLine{1092 }
\DoxyCodeLine{1093 \textcolor{comment}{// Get the trace of the matrix (sum of the values along the diagonal)}}
\DoxyCodeLine{1094 RMAPI \textcolor{keywordtype}{float} MatrixTrace(\mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{1095 \{}
\DoxyCodeLine{1096     \textcolor{keywordtype}{float} result = (mat.m0 + mat.m5 + mat.m10 + mat.m15);}
\DoxyCodeLine{1097 }
\DoxyCodeLine{1098     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1099 \}}
\DoxyCodeLine{1100 }
\DoxyCodeLine{1101 \textcolor{comment}{// Transposes provided matrix}}
\DoxyCodeLine{1102 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixTranspose(\mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{1103 \{}
\DoxyCodeLine{1104     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1105 }
\DoxyCodeLine{1106     result.m0 = mat.m0;}
\DoxyCodeLine{1107     result.m1 = mat.m4;}
\DoxyCodeLine{1108     result.m2 = mat.m8;}
\DoxyCodeLine{1109     result.m3 = mat.m12;}
\DoxyCodeLine{1110     result.m4 = mat.m1;}
\DoxyCodeLine{1111     result.m5 = mat.m5;}
\DoxyCodeLine{1112     result.m6 = mat.m9;}
\DoxyCodeLine{1113     result.m7 = mat.m13;}
\DoxyCodeLine{1114     result.m8 = mat.m2;}
\DoxyCodeLine{1115     result.m9 = mat.m6;}
\DoxyCodeLine{1116     result.m10 = mat.m10;}
\DoxyCodeLine{1117     result.m11 = mat.m14;}
\DoxyCodeLine{1118     result.m12 = mat.m3;}
\DoxyCodeLine{1119     result.m13 = mat.m7;}
\DoxyCodeLine{1120     result.m14 = mat.m11;}
\DoxyCodeLine{1121     result.m15 = mat.m15;}
\DoxyCodeLine{1122 }
\DoxyCodeLine{1123     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1124 \}}
\DoxyCodeLine{1125 }
\DoxyCodeLine{1126 \textcolor{comment}{// Invert provided matrix}}
\DoxyCodeLine{1127 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixInvert(\mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{1128 \{}
\DoxyCodeLine{1129     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1130 }
\DoxyCodeLine{1131     \textcolor{comment}{// Cache the matrix values (speed optimization)}}
\DoxyCodeLine{1132     \textcolor{keywordtype}{float} a00 = mat.m0, a01 = mat.m1, a02 = mat.m2, a03 = mat.m3;}
\DoxyCodeLine{1133     \textcolor{keywordtype}{float} a10 = mat.m4, a11 = mat.m5, a12 = mat.m6, a13 = mat.m7;}
\DoxyCodeLine{1134     \textcolor{keywordtype}{float} a20 = mat.m8, a21 = mat.m9, a22 = mat.m10, a23 = mat.m11;}
\DoxyCodeLine{1135     \textcolor{keywordtype}{float} a30 = mat.m12, a31 = mat.m13, a32 = mat.m14, a33 = mat.m15;}
\DoxyCodeLine{1136 }
\DoxyCodeLine{1137     \textcolor{keywordtype}{float} b00 = a00*a11 -\/ a01*a10;}
\DoxyCodeLine{1138     \textcolor{keywordtype}{float} b01 = a00*a12 -\/ a02*a10;}
\DoxyCodeLine{1139     \textcolor{keywordtype}{float} b02 = a00*a13 -\/ a03*a10;}
\DoxyCodeLine{1140     \textcolor{keywordtype}{float} b03 = a01*a12 -\/ a02*a11;}
\DoxyCodeLine{1141     \textcolor{keywordtype}{float} b04 = a01*a13 -\/ a03*a11;}
\DoxyCodeLine{1142     \textcolor{keywordtype}{float} b05 = a02*a13 -\/ a03*a12;}
\DoxyCodeLine{1143     \textcolor{keywordtype}{float} b06 = a20*a31 -\/ a21*a30;}
\DoxyCodeLine{1144     \textcolor{keywordtype}{float} b07 = a20*a32 -\/ a22*a30;}
\DoxyCodeLine{1145     \textcolor{keywordtype}{float} b08 = a20*a33 -\/ a23*a30;}
\DoxyCodeLine{1146     \textcolor{keywordtype}{float} b09 = a21*a32 -\/ a22*a31;}
\DoxyCodeLine{1147     \textcolor{keywordtype}{float} b10 = a21*a33 -\/ a23*a31;}
\DoxyCodeLine{1148     \textcolor{keywordtype}{float} b11 = a22*a33 -\/ a23*a32;}
\DoxyCodeLine{1149 }
\DoxyCodeLine{1150     \textcolor{comment}{// Calculate the invert determinant (inlined to avoid double-\/caching)}}
\DoxyCodeLine{1151     \textcolor{keywordtype}{float} invDet = 1.0f/(b00*b11 -\/ b01*b10 + b02*b09 + b03*b08 -\/ b04*b07 + b05*b06);}
\DoxyCodeLine{1152 }
\DoxyCodeLine{1153     result.m0 = (a11*b11 -\/ a12*b10 + a13*b09)*invDet;}
\DoxyCodeLine{1154     result.m1 = (-\/a01*b11 + a02*b10 -\/ a03*b09)*invDet;}
\DoxyCodeLine{1155     result.m2 = (a31*b05 -\/ a32*b04 + a33*b03)*invDet;}
\DoxyCodeLine{1156     result.m3 = (-\/a21*b05 + a22*b04 -\/ a23*b03)*invDet;}
\DoxyCodeLine{1157     result.m4 = (-\/a10*b11 + a12*b08 -\/ a13*b07)*invDet;}
\DoxyCodeLine{1158     result.m5 = (a00*b11 -\/ a02*b08 + a03*b07)*invDet;}
\DoxyCodeLine{1159     result.m6 = (-\/a30*b05 + a32*b02 -\/ a33*b01)*invDet;}
\DoxyCodeLine{1160     result.m7 = (a20*b05 -\/ a22*b02 + a23*b01)*invDet;}
\DoxyCodeLine{1161     result.m8 = (a10*b10 -\/ a11*b08 + a13*b06)*invDet;}
\DoxyCodeLine{1162     result.m9 = (-\/a00*b10 + a01*b08 -\/ a03*b06)*invDet;}
\DoxyCodeLine{1163     result.m10 = (a30*b04 -\/ a31*b02 + a33*b00)*invDet;}
\DoxyCodeLine{1164     result.m11 = (-\/a20*b04 + a21*b02 -\/ a23*b00)*invDet;}
\DoxyCodeLine{1165     result.m12 = (-\/a10*b09 + a11*b07 -\/ a12*b06)*invDet;}
\DoxyCodeLine{1166     result.m13 = (a00*b09 -\/ a01*b07 + a02*b06)*invDet;}
\DoxyCodeLine{1167     result.m14 = (-\/a30*b03 + a31*b01 -\/ a32*b00)*invDet;}
\DoxyCodeLine{1168     result.m15 = (a20*b03 -\/ a21*b01 + a22*b00)*invDet;}
\DoxyCodeLine{1169 }
\DoxyCodeLine{1170     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1171 \}}
\DoxyCodeLine{1172 }
\DoxyCodeLine{1173 \textcolor{comment}{// Get identity matrix}}
\DoxyCodeLine{1174 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixIdentity(\textcolor{keywordtype}{void})}
\DoxyCodeLine{1175 \{}
\DoxyCodeLine{1176     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 1.0f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1177                       0.0f, 1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1178                       0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{1179                       0.0f, 0.0f, 0.0f, 1.0f \};}
\DoxyCodeLine{1180 }
\DoxyCodeLine{1181     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1182 \}}
\DoxyCodeLine{1183 }
\DoxyCodeLine{1184 \textcolor{comment}{// Add two matrices}}
\DoxyCodeLine{1185 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixAdd(\mbox{\hyperlink{structMatrix}{Matrix}} left, \mbox{\hyperlink{structMatrix}{Matrix}} right)}
\DoxyCodeLine{1186 \{}
\DoxyCodeLine{1187     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1188 }
\DoxyCodeLine{1189     result.m0 = left.m0 + right.m0;}
\DoxyCodeLine{1190     result.m1 = left.m1 + right.m1;}
\DoxyCodeLine{1191     result.m2 = left.m2 + right.m2;}
\DoxyCodeLine{1192     result.m3 = left.m3 + right.m3;}
\DoxyCodeLine{1193     result.m4 = left.m4 + right.m4;}
\DoxyCodeLine{1194     result.m5 = left.m5 + right.m5;}
\DoxyCodeLine{1195     result.m6 = left.m6 + right.m6;}
\DoxyCodeLine{1196     result.m7 = left.m7 + right.m7;}
\DoxyCodeLine{1197     result.m8 = left.m8 + right.m8;}
\DoxyCodeLine{1198     result.m9 = left.m9 + right.m9;}
\DoxyCodeLine{1199     result.m10 = left.m10 + right.m10;}
\DoxyCodeLine{1200     result.m11 = left.m11 + right.m11;}
\DoxyCodeLine{1201     result.m12 = left.m12 + right.m12;}
\DoxyCodeLine{1202     result.m13 = left.m13 + right.m13;}
\DoxyCodeLine{1203     result.m14 = left.m14 + right.m14;}
\DoxyCodeLine{1204     result.m15 = left.m15 + right.m15;}
\DoxyCodeLine{1205 }
\DoxyCodeLine{1206     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1207 \}}
\DoxyCodeLine{1208 }
\DoxyCodeLine{1209 \textcolor{comment}{// Subtract two matrices (left -\/ right)}}
\DoxyCodeLine{1210 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixSubtract(\mbox{\hyperlink{structMatrix}{Matrix}} left, \mbox{\hyperlink{structMatrix}{Matrix}} right)}
\DoxyCodeLine{1211 \{}
\DoxyCodeLine{1212     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1213 }
\DoxyCodeLine{1214     result.m0 = left.m0 -\/ right.m0;}
\DoxyCodeLine{1215     result.m1 = left.m1 -\/ right.m1;}
\DoxyCodeLine{1216     result.m2 = left.m2 -\/ right.m2;}
\DoxyCodeLine{1217     result.m3 = left.m3 -\/ right.m3;}
\DoxyCodeLine{1218     result.m4 = left.m4 -\/ right.m4;}
\DoxyCodeLine{1219     result.m5 = left.m5 -\/ right.m5;}
\DoxyCodeLine{1220     result.m6 = left.m6 -\/ right.m6;}
\DoxyCodeLine{1221     result.m7 = left.m7 -\/ right.m7;}
\DoxyCodeLine{1222     result.m8 = left.m8 -\/ right.m8;}
\DoxyCodeLine{1223     result.m9 = left.m9 -\/ right.m9;}
\DoxyCodeLine{1224     result.m10 = left.m10 -\/ right.m10;}
\DoxyCodeLine{1225     result.m11 = left.m11 -\/ right.m11;}
\DoxyCodeLine{1226     result.m12 = left.m12 -\/ right.m12;}
\DoxyCodeLine{1227     result.m13 = left.m13 -\/ right.m13;}
\DoxyCodeLine{1228     result.m14 = left.m14 -\/ right.m14;}
\DoxyCodeLine{1229     result.m15 = left.m15 -\/ right.m15;}
\DoxyCodeLine{1230 }
\DoxyCodeLine{1231     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1232 \}}
\DoxyCodeLine{1233 }
\DoxyCodeLine{1234 \textcolor{comment}{// Get two matrix multiplication}}
\DoxyCodeLine{1235 \textcolor{comment}{// NOTE: When multiplying matrices... the order matters!}}
\DoxyCodeLine{1236 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixMultiply(\mbox{\hyperlink{structMatrix}{Matrix}} left, \mbox{\hyperlink{structMatrix}{Matrix}} right)}
\DoxyCodeLine{1237 \{}
\DoxyCodeLine{1238     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1239 }
\DoxyCodeLine{1240     result.m0 = left.m0*right.m0 + left.m1*right.m4 + left.m2*right.m8 + left.m3*right.m12;}
\DoxyCodeLine{1241     result.m1 = left.m0*right.m1 + left.m1*right.m5 + left.m2*right.m9 + left.m3*right.m13;}
\DoxyCodeLine{1242     result.m2 = left.m0*right.m2 + left.m1*right.m6 + left.m2*right.m10 + left.m3*right.m14;}
\DoxyCodeLine{1243     result.m3 = left.m0*right.m3 + left.m1*right.m7 + left.m2*right.m11 + left.m3*right.m15;}
\DoxyCodeLine{1244     result.m4 = left.m4*right.m0 + left.m5*right.m4 + left.m6*right.m8 + left.m7*right.m12;}
\DoxyCodeLine{1245     result.m5 = left.m4*right.m1 + left.m5*right.m5 + left.m6*right.m9 + left.m7*right.m13;}
\DoxyCodeLine{1246     result.m6 = left.m4*right.m2 + left.m5*right.m6 + left.m6*right.m10 + left.m7*right.m14;}
\DoxyCodeLine{1247     result.m7 = left.m4*right.m3 + left.m5*right.m7 + left.m6*right.m11 + left.m7*right.m15;}
\DoxyCodeLine{1248     result.m8 = left.m8*right.m0 + left.m9*right.m4 + left.m10*right.m8 + left.m11*right.m12;}
\DoxyCodeLine{1249     result.m9 = left.m8*right.m1 + left.m9*right.m5 + left.m10*right.m9 + left.m11*right.m13;}
\DoxyCodeLine{1250     result.m10 = left.m8*right.m2 + left.m9*right.m6 + left.m10*right.m10 + left.m11*right.m14;}
\DoxyCodeLine{1251     result.m11 = left.m8*right.m3 + left.m9*right.m7 + left.m10*right.m11 + left.m11*right.m15;}
\DoxyCodeLine{1252     result.m12 = left.m12*right.m0 + left.m13*right.m4 + left.m14*right.m8 + left.m15*right.m12;}
\DoxyCodeLine{1253     result.m13 = left.m12*right.m1 + left.m13*right.m5 + left.m14*right.m9 + left.m15*right.m13;}
\DoxyCodeLine{1254     result.m14 = left.m12*right.m2 + left.m13*right.m6 + left.m14*right.m10 + left.m15*right.m14;}
\DoxyCodeLine{1255     result.m15 = left.m12*right.m3 + left.m13*right.m7 + left.m14*right.m11 + left.m15*right.m15;}
\DoxyCodeLine{1256 }
\DoxyCodeLine{1257     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1258 \}}
\DoxyCodeLine{1259 }
\DoxyCodeLine{1260 \textcolor{comment}{// Get translation matrix}}
\DoxyCodeLine{1261 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixTranslate(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z)}
\DoxyCodeLine{1262 \{}
\DoxyCodeLine{1263     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 1.0f, 0.0f, 0.0f, x,}
\DoxyCodeLine{1264                       0.0f, 1.0f, 0.0f, y,}
\DoxyCodeLine{1265                       0.0f, 0.0f, 1.0f, z,}
\DoxyCodeLine{1266                       0.0f, 0.0f, 0.0f, 1.0f \};}
\DoxyCodeLine{1267 }
\DoxyCodeLine{1268     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1269 \}}
\DoxyCodeLine{1270 }
\DoxyCodeLine{1271 \textcolor{comment}{// Create rotation matrix from axis and angle}}
\DoxyCodeLine{1272 \textcolor{comment}{// NOTE: Angle should be provided in radians}}
\DoxyCodeLine{1273 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixRotate(\mbox{\hyperlink{structVector3}{Vector3}} axis, \textcolor{keywordtype}{float} angle)}
\DoxyCodeLine{1274 \{}
\DoxyCodeLine{1275     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1276 }
\DoxyCodeLine{1277     \textcolor{keywordtype}{float} x = axis.x, y = axis.y, z = axis.z;}
\DoxyCodeLine{1278 }
\DoxyCodeLine{1279     \textcolor{keywordtype}{float} lengthSquared = x*x + y*y + z*z;}
\DoxyCodeLine{1280 }
\DoxyCodeLine{1281     \textcolor{keywordflow}{if} ((lengthSquared != 1.0f) \&\& (lengthSquared != 0.0f))}
\DoxyCodeLine{1282     \{}
\DoxyCodeLine{1283         \textcolor{keywordtype}{float} ilength = 1.0f/sqrtf(lengthSquared);}
\DoxyCodeLine{1284         x *= ilength;}
\DoxyCodeLine{1285         y *= ilength;}
\DoxyCodeLine{1286         z *= ilength;}
\DoxyCodeLine{1287     \}}
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289     \textcolor{keywordtype}{float} sinres = sinf(angle);}
\DoxyCodeLine{1290     \textcolor{keywordtype}{float} cosres = cosf(angle);}
\DoxyCodeLine{1291     \textcolor{keywordtype}{float} t = 1.0f -\/ cosres;}
\DoxyCodeLine{1292 }
\DoxyCodeLine{1293     result.m0 = x*x*t + cosres;}
\DoxyCodeLine{1294     result.m1 = y*x*t + z*sinres;}
\DoxyCodeLine{1295     result.m2 = z*x*t -\/ y*sinres;}
\DoxyCodeLine{1296     result.m3 = 0.0f;}
\DoxyCodeLine{1297 }
\DoxyCodeLine{1298     result.m4 = x*y*t -\/ z*sinres;}
\DoxyCodeLine{1299     result.m5 = y*y*t + cosres;}
\DoxyCodeLine{1300     result.m6 = z*y*t + x*sinres;}
\DoxyCodeLine{1301     result.m7 = 0.0f;}
\DoxyCodeLine{1302 }
\DoxyCodeLine{1303     result.m8 = x*z*t + y*sinres;}
\DoxyCodeLine{1304     result.m9 = y*z*t -\/ x*sinres;}
\DoxyCodeLine{1305     result.m10 = z*z*t + cosres;}
\DoxyCodeLine{1306     result.m11 = 0.0f;}
\DoxyCodeLine{1307 }
\DoxyCodeLine{1308     result.m12 = 0.0f;}
\DoxyCodeLine{1309     result.m13 = 0.0f;}
\DoxyCodeLine{1310     result.m14 = 0.0f;}
\DoxyCodeLine{1311     result.m15 = 1.0f;}
\DoxyCodeLine{1312 }
\DoxyCodeLine{1313     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1314 \}}
\DoxyCodeLine{1315 }
\DoxyCodeLine{1316 \textcolor{comment}{// Get x-\/rotation matrix}}
\DoxyCodeLine{1317 \textcolor{comment}{// NOTE: Angle must be provided in radians}}
\DoxyCodeLine{1318 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixRotateX(\textcolor{keywordtype}{float} angle)}
\DoxyCodeLine{1319 \{}
\DoxyCodeLine{1320     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 1.0f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1321                       0.0f, 1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1322                       0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{1323                       0.0f, 0.0f, 0.0f, 1.0f \}; \textcolor{comment}{// MatrixIdentity()}}
\DoxyCodeLine{1324 }
\DoxyCodeLine{1325     \textcolor{keywordtype}{float} cosres = cosf(angle);}
\DoxyCodeLine{1326     \textcolor{keywordtype}{float} sinres = sinf(angle);}
\DoxyCodeLine{1327 }
\DoxyCodeLine{1328     result.m5 = cosres;}
\DoxyCodeLine{1329     result.m6 = sinres;}
\DoxyCodeLine{1330     result.m9 = -\/sinres;}
\DoxyCodeLine{1331     result.m10 = cosres;}
\DoxyCodeLine{1332 }
\DoxyCodeLine{1333     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1334 \}}
\DoxyCodeLine{1335 }
\DoxyCodeLine{1336 \textcolor{comment}{// Get y-\/rotation matrix}}
\DoxyCodeLine{1337 \textcolor{comment}{// NOTE: Angle must be provided in radians}}
\DoxyCodeLine{1338 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixRotateY(\textcolor{keywordtype}{float} angle)}
\DoxyCodeLine{1339 \{}
\DoxyCodeLine{1340     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 1.0f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1341                       0.0f, 1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1342                       0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{1343                       0.0f, 0.0f, 0.0f, 1.0f \}; \textcolor{comment}{// MatrixIdentity()}}
\DoxyCodeLine{1344 }
\DoxyCodeLine{1345     \textcolor{keywordtype}{float} cosres = cosf(angle);}
\DoxyCodeLine{1346     \textcolor{keywordtype}{float} sinres = sinf(angle);}
\DoxyCodeLine{1347 }
\DoxyCodeLine{1348     result.m0 = cosres;}
\DoxyCodeLine{1349     result.m2 = -\/sinres;}
\DoxyCodeLine{1350     result.m8 = sinres;}
\DoxyCodeLine{1351     result.m10 = cosres;}
\DoxyCodeLine{1352 }
\DoxyCodeLine{1353     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1354 \}}
\DoxyCodeLine{1355 }
\DoxyCodeLine{1356 \textcolor{comment}{// Get z-\/rotation matrix}}
\DoxyCodeLine{1357 \textcolor{comment}{// NOTE: Angle must be provided in radians}}
\DoxyCodeLine{1358 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixRotateZ(\textcolor{keywordtype}{float} angle)}
\DoxyCodeLine{1359 \{}
\DoxyCodeLine{1360     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 1.0f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1361                       0.0f, 1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1362                       0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{1363                       0.0f, 0.0f, 0.0f, 1.0f \}; \textcolor{comment}{// MatrixIdentity()}}
\DoxyCodeLine{1364 }
\DoxyCodeLine{1365     \textcolor{keywordtype}{float} cosres = cosf(angle);}
\DoxyCodeLine{1366     \textcolor{keywordtype}{float} sinres = sinf(angle);}
\DoxyCodeLine{1367 }
\DoxyCodeLine{1368     result.m0 = cosres;}
\DoxyCodeLine{1369     result.m1 = sinres;}
\DoxyCodeLine{1370     result.m4 = -\/sinres;}
\DoxyCodeLine{1371     result.m5 = cosres;}
\DoxyCodeLine{1372 }
\DoxyCodeLine{1373     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1374 \}}
\DoxyCodeLine{1375 }
\DoxyCodeLine{1376 }
\DoxyCodeLine{1377 \textcolor{comment}{// Get xyz-\/rotation matrix}}
\DoxyCodeLine{1378 \textcolor{comment}{// NOTE: Angle must be provided in radians}}
\DoxyCodeLine{1379 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixRotateXYZ(\mbox{\hyperlink{structVector3}{Vector3}} angle)}
\DoxyCodeLine{1380 \{}
\DoxyCodeLine{1381     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 1.0f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1382                       0.0f, 1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1383                       0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{1384                       0.0f, 0.0f, 0.0f, 1.0f \}; \textcolor{comment}{// MatrixIdentity()}}
\DoxyCodeLine{1385 }
\DoxyCodeLine{1386     \textcolor{keywordtype}{float} cosz = cosf(-\/angle.z);}
\DoxyCodeLine{1387     \textcolor{keywordtype}{float} sinz = sinf(-\/angle.z);}
\DoxyCodeLine{1388     \textcolor{keywordtype}{float} cosy = cosf(-\/angle.y);}
\DoxyCodeLine{1389     \textcolor{keywordtype}{float} siny = sinf(-\/angle.y);}
\DoxyCodeLine{1390     \textcolor{keywordtype}{float} cosx = cosf(-\/angle.x);}
\DoxyCodeLine{1391     \textcolor{keywordtype}{float} sinx = sinf(-\/angle.x);}
\DoxyCodeLine{1392 }
\DoxyCodeLine{1393     result.m0 = cosz*cosy;}
\DoxyCodeLine{1394     result.m1 = (cosz*siny*sinx) -\/ (sinz*cosx);}
\DoxyCodeLine{1395     result.m2 = (cosz*siny*cosx) + (sinz*sinx);}
\DoxyCodeLine{1396 }
\DoxyCodeLine{1397     result.m4 = sinz*cosy;}
\DoxyCodeLine{1398     result.m5 = (sinz*siny*sinx) + (cosz*cosx);}
\DoxyCodeLine{1399     result.m6 = (sinz*siny*cosx) -\/ (cosz*sinx);}
\DoxyCodeLine{1400 }
\DoxyCodeLine{1401     result.m8 = -\/siny;}
\DoxyCodeLine{1402     result.m9 = cosy*sinx;}
\DoxyCodeLine{1403     result.m10= cosy*cosx;}
\DoxyCodeLine{1404 }
\DoxyCodeLine{1405     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1406 \}}
\DoxyCodeLine{1407 }
\DoxyCodeLine{1408 \textcolor{comment}{// Get zyx-\/rotation matrix}}
\DoxyCodeLine{1409 \textcolor{comment}{// NOTE: Angle must be provided in radians}}
\DoxyCodeLine{1410 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixRotateZYX(\mbox{\hyperlink{structVector3}{Vector3}} angle)}
\DoxyCodeLine{1411 \{}
\DoxyCodeLine{1412     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1413 }
\DoxyCodeLine{1414     \textcolor{keywordtype}{float} cz = cosf(angle.z);}
\DoxyCodeLine{1415     \textcolor{keywordtype}{float} sz = sinf(angle.z);}
\DoxyCodeLine{1416     \textcolor{keywordtype}{float} cy = cosf(angle.y);}
\DoxyCodeLine{1417     \textcolor{keywordtype}{float} sy = sinf(angle.y);}
\DoxyCodeLine{1418     \textcolor{keywordtype}{float} cx = cosf(angle.x);}
\DoxyCodeLine{1419     \textcolor{keywordtype}{float} sx = sinf(angle.x);}
\DoxyCodeLine{1420 }
\DoxyCodeLine{1421     result.m0 = cz*cy;}
\DoxyCodeLine{1422     result.m4 = cz*sy*sx -\/ cx*sz;}
\DoxyCodeLine{1423     result.m8 = sz*sx + cz*cx*sy;}
\DoxyCodeLine{1424     result.m12 = 0;}
\DoxyCodeLine{1425 }
\DoxyCodeLine{1426     result.m1 = cy*sz;}
\DoxyCodeLine{1427     result.m5 = cz*cx + sz*sy*sx;}
\DoxyCodeLine{1428     result.m9 = cx*sz*sy -\/ cz*sx;}
\DoxyCodeLine{1429     result.m13 = 0;}
\DoxyCodeLine{1430 }
\DoxyCodeLine{1431     result.m2 = -\/sy;}
\DoxyCodeLine{1432     result.m6 = cy*sx;}
\DoxyCodeLine{1433     result.m10 = cy*cx;}
\DoxyCodeLine{1434     result.m14 = 0;}
\DoxyCodeLine{1435 }
\DoxyCodeLine{1436     result.m3 = 0;}
\DoxyCodeLine{1437     result.m7 = 0;}
\DoxyCodeLine{1438     result.m11 = 0;}
\DoxyCodeLine{1439     result.m15 = 1;}
\DoxyCodeLine{1440 }
\DoxyCodeLine{1441     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1442 \}}
\DoxyCodeLine{1443 }
\DoxyCodeLine{1444 \textcolor{comment}{// Get scaling matrix}}
\DoxyCodeLine{1445 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixScale(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z)}
\DoxyCodeLine{1446 \{}
\DoxyCodeLine{1447     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ x, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1448                       0.0f, y, 0.0f, 0.0f,}
\DoxyCodeLine{1449                       0.0f, 0.0f, z, 0.0f,}
\DoxyCodeLine{1450                       0.0f, 0.0f, 0.0f, 1.0f \};}
\DoxyCodeLine{1451 }
\DoxyCodeLine{1452     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1453 \}}
\DoxyCodeLine{1454 }
\DoxyCodeLine{1455 \textcolor{comment}{// Get perspective projection matrix}}
\DoxyCodeLine{1456 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixFrustum(\textcolor{keywordtype}{double} left, \textcolor{keywordtype}{double} right, \textcolor{keywordtype}{double} bottom, \textcolor{keywordtype}{double} top, \textcolor{keywordtype}{double} near, \textcolor{keywordtype}{double} far)}
\DoxyCodeLine{1457 \{}
\DoxyCodeLine{1458     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1459 }
\DoxyCodeLine{1460     \textcolor{keywordtype}{float} rl = (float)(right -\/ left);}
\DoxyCodeLine{1461     \textcolor{keywordtype}{float} tb = (float)(top -\/ bottom);}
\DoxyCodeLine{1462     \textcolor{keywordtype}{float} fn = (float)(far -\/ near);}
\DoxyCodeLine{1463 }
\DoxyCodeLine{1464     result.m0 = ((float)near*2.0f)/rl;}
\DoxyCodeLine{1465     result.m1 = 0.0f;}
\DoxyCodeLine{1466     result.m2 = 0.0f;}
\DoxyCodeLine{1467     result.m3 = 0.0f;}
\DoxyCodeLine{1468 }
\DoxyCodeLine{1469     result.m4 = 0.0f;}
\DoxyCodeLine{1470     result.m5 = ((float)near*2.0f)/tb;}
\DoxyCodeLine{1471     result.m6 = 0.0f;}
\DoxyCodeLine{1472     result.m7 = 0.0f;}
\DoxyCodeLine{1473 }
\DoxyCodeLine{1474     result.m8 = ((float)right + (\textcolor{keywordtype}{float})left)/rl;}
\DoxyCodeLine{1475     result.m9 = ((float)top + (\textcolor{keywordtype}{float})bottom)/tb;}
\DoxyCodeLine{1476     result.m10 = -\/((float)far + (\textcolor{keywordtype}{float})near)/fn;}
\DoxyCodeLine{1477     result.m11 = -\/1.0f;}
\DoxyCodeLine{1478 }
\DoxyCodeLine{1479     result.m12 = 0.0f;}
\DoxyCodeLine{1480     result.m13 = 0.0f;}
\DoxyCodeLine{1481     result.m14 = -\/((float)far*(\textcolor{keywordtype}{float})near*2.0f)/fn;}
\DoxyCodeLine{1482     result.m15 = 0.0f;}
\DoxyCodeLine{1483 }
\DoxyCodeLine{1484     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1485 \}}
\DoxyCodeLine{1486 }
\DoxyCodeLine{1487 \textcolor{comment}{// Get perspective projection matrix}}
\DoxyCodeLine{1488 \textcolor{comment}{// NOTE: Fovy angle must be provided in radians}}
\DoxyCodeLine{1489 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixPerspective(\textcolor{keywordtype}{double} fovy, \textcolor{keywordtype}{double} aspect, \textcolor{keywordtype}{double} near, \textcolor{keywordtype}{double} far)}
\DoxyCodeLine{1490 \{}
\DoxyCodeLine{1491     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1492 }
\DoxyCodeLine{1493     \textcolor{keywordtype}{double} top = near*tan(fovy*0.5);}
\DoxyCodeLine{1494     \textcolor{keywordtype}{double} bottom = -\/top;}
\DoxyCodeLine{1495     \textcolor{keywordtype}{double} right = top*aspect;}
\DoxyCodeLine{1496     \textcolor{keywordtype}{double} left = -\/right;}
\DoxyCodeLine{1497 }
\DoxyCodeLine{1498     \textcolor{comment}{// MatrixFrustum(-\/right, right, -\/top, top, near, far);}}
\DoxyCodeLine{1499     \textcolor{keywordtype}{float} rl = (float)(right -\/ left);}
\DoxyCodeLine{1500     \textcolor{keywordtype}{float} tb = (float)(top -\/ bottom);}
\DoxyCodeLine{1501     \textcolor{keywordtype}{float} fn = (float)(far -\/ near);}
\DoxyCodeLine{1502 }
\DoxyCodeLine{1503     result.m0 = ((float)near*2.0f)/rl;}
\DoxyCodeLine{1504     result.m5 = ((float)near*2.0f)/tb;}
\DoxyCodeLine{1505     result.m8 = ((float)right + (\textcolor{keywordtype}{float})left)/rl;}
\DoxyCodeLine{1506     result.m9 = ((float)top + (\textcolor{keywordtype}{float})bottom)/tb;}
\DoxyCodeLine{1507     result.m10 = -\/((float)far + (\textcolor{keywordtype}{float})near)/fn;}
\DoxyCodeLine{1508     result.m11 = -\/1.0f;}
\DoxyCodeLine{1509     result.m14 = -\/((float)far*(\textcolor{keywordtype}{float})near*2.0f)/fn;}
\DoxyCodeLine{1510 }
\DoxyCodeLine{1511     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1512 \}}
\DoxyCodeLine{1513 }
\DoxyCodeLine{1514 \textcolor{comment}{// Get orthographic projection matrix}}
\DoxyCodeLine{1515 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixOrtho(\textcolor{keywordtype}{double} left, \textcolor{keywordtype}{double} right, \textcolor{keywordtype}{double} bottom, \textcolor{keywordtype}{double} top, \textcolor{keywordtype}{double} near, \textcolor{keywordtype}{double} far)}
\DoxyCodeLine{1516 \{}
\DoxyCodeLine{1517     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1518 }
\DoxyCodeLine{1519     \textcolor{keywordtype}{float} rl = (float)(right -\/ left);}
\DoxyCodeLine{1520     \textcolor{keywordtype}{float} tb = (float)(top -\/ bottom);}
\DoxyCodeLine{1521     \textcolor{keywordtype}{float} fn = (float)(far -\/ near);}
\DoxyCodeLine{1522 }
\DoxyCodeLine{1523     result.m0 = 2.0f/rl;}
\DoxyCodeLine{1524     result.m1 = 0.0f;}
\DoxyCodeLine{1525     result.m2 = 0.0f;}
\DoxyCodeLine{1526     result.m3 = 0.0f;}
\DoxyCodeLine{1527     result.m4 = 0.0f;}
\DoxyCodeLine{1528     result.m5 = 2.0f/tb;}
\DoxyCodeLine{1529     result.m6 = 0.0f;}
\DoxyCodeLine{1530     result.m7 = 0.0f;}
\DoxyCodeLine{1531     result.m8 = 0.0f;}
\DoxyCodeLine{1532     result.m9 = 0.0f;}
\DoxyCodeLine{1533     result.m10 = -\/2.0f/fn;}
\DoxyCodeLine{1534     result.m11 = 0.0f;}
\DoxyCodeLine{1535     result.m12 = -\/((float)left + (\textcolor{keywordtype}{float})right)/rl;}
\DoxyCodeLine{1536     result.m13 = -\/((float)top + (\textcolor{keywordtype}{float})bottom)/tb;}
\DoxyCodeLine{1537     result.m14 = -\/((float)far + (\textcolor{keywordtype}{float})near)/fn;}
\DoxyCodeLine{1538     result.m15 = 1.0f;}
\DoxyCodeLine{1539 }
\DoxyCodeLine{1540     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1541 \}}
\DoxyCodeLine{1542 }
\DoxyCodeLine{1543 \textcolor{comment}{// Get camera look-\/at matrix (view matrix)}}
\DoxyCodeLine{1544 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} MatrixLookAt(\mbox{\hyperlink{structVector3}{Vector3}} eye, \mbox{\hyperlink{structVector3}{Vector3}} target, \mbox{\hyperlink{structVector3}{Vector3}} up)}
\DoxyCodeLine{1545 \{}
\DoxyCodeLine{1546     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 0 \};}
\DoxyCodeLine{1547 }
\DoxyCodeLine{1548     \textcolor{keywordtype}{float} length = 0.0f;}
\DoxyCodeLine{1549     \textcolor{keywordtype}{float} ilength = 0.0f;}
\DoxyCodeLine{1550 }
\DoxyCodeLine{1551     \textcolor{comment}{// Vector3Subtract(eye, target)}}
\DoxyCodeLine{1552     \mbox{\hyperlink{structVector3}{Vector3}} vz = \{ eye.x -\/ target.x, eye.y -\/ target.y, eye.z -\/ target.z \};}
\DoxyCodeLine{1553 }
\DoxyCodeLine{1554     \textcolor{comment}{// Vector3Normalize(vz)}}
\DoxyCodeLine{1555     \mbox{\hyperlink{structVector3}{Vector3}} v = vz;}
\DoxyCodeLine{1556     length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);}
\DoxyCodeLine{1557     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{1558     ilength = 1.0f/length;}
\DoxyCodeLine{1559     vz.x *= ilength;}
\DoxyCodeLine{1560     vz.y *= ilength;}
\DoxyCodeLine{1561     vz.z *= ilength;}
\DoxyCodeLine{1562 }
\DoxyCodeLine{1563     \textcolor{comment}{// Vector3CrossProduct(up, vz)}}
\DoxyCodeLine{1564     \mbox{\hyperlink{structVector3}{Vector3}} vx = \{ up.y*vz.z -\/ up.z*vz.y, up.z*vz.x -\/ up.x*vz.z, up.x*vz.y -\/ up.y*vz.x \};}
\DoxyCodeLine{1565 }
\DoxyCodeLine{1566     \textcolor{comment}{// Vector3Normalize(x)}}
\DoxyCodeLine{1567     v = vx;}
\DoxyCodeLine{1568     length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);}
\DoxyCodeLine{1569     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{1570     ilength = 1.0f/length;}
\DoxyCodeLine{1571     vx.x *= ilength;}
\DoxyCodeLine{1572     vx.y *= ilength;}
\DoxyCodeLine{1573     vx.z *= ilength;}
\DoxyCodeLine{1574 }
\DoxyCodeLine{1575     \textcolor{comment}{// Vector3CrossProduct(vz, vx)}}
\DoxyCodeLine{1576     \mbox{\hyperlink{structVector3}{Vector3}} vy = \{ vz.y*vx.z -\/ vz.z*vx.y, vz.z*vx.x -\/ vz.x*vx.z, vz.x*vx.y -\/ vz.y*vx.x \};}
\DoxyCodeLine{1577 }
\DoxyCodeLine{1578     result.m0 = vx.x;}
\DoxyCodeLine{1579     result.m1 = vy.x;}
\DoxyCodeLine{1580     result.m2 = vz.x;}
\DoxyCodeLine{1581     result.m3 = 0.0f;}
\DoxyCodeLine{1582     result.m4 = vx.y;}
\DoxyCodeLine{1583     result.m5 = vy.y;}
\DoxyCodeLine{1584     result.m6 = vz.y;}
\DoxyCodeLine{1585     result.m7 = 0.0f;}
\DoxyCodeLine{1586     result.m8 = vx.z;}
\DoxyCodeLine{1587     result.m9 = vy.z;}
\DoxyCodeLine{1588     result.m10 = vz.z;}
\DoxyCodeLine{1589     result.m11 = 0.0f;}
\DoxyCodeLine{1590     result.m12 = -\/(vx.x*eye.x + vx.y*eye.y + vx.z*eye.z);   \textcolor{comment}{// Vector3DotProduct(vx, eye)}}
\DoxyCodeLine{1591     result.m13 = -\/(vy.x*eye.x + vy.y*eye.y + vy.z*eye.z);   \textcolor{comment}{// Vector3DotProduct(vy, eye)}}
\DoxyCodeLine{1592     result.m14 = -\/(vz.x*eye.x + vz.y*eye.y + vz.z*eye.z);   \textcolor{comment}{// Vector3DotProduct(vz, eye)}}
\DoxyCodeLine{1593     result.m15 = 1.0f;}
\DoxyCodeLine{1594 }
\DoxyCodeLine{1595     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1596 \}}
\DoxyCodeLine{1597 }
\DoxyCodeLine{1598 \textcolor{comment}{// Get float array of matrix data}}
\DoxyCodeLine{1599 RMAPI \mbox{\hyperlink{structfloat16}{float16}} MatrixToFloatV(\mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{1600 \{}
\DoxyCodeLine{1601     \mbox{\hyperlink{structfloat16}{float16}} result = \{ 0 \};}
\DoxyCodeLine{1602 }
\DoxyCodeLine{1603     result.v[0] = mat.m0;}
\DoxyCodeLine{1604     result.v[1] = mat.m1;}
\DoxyCodeLine{1605     result.v[2] = mat.m2;}
\DoxyCodeLine{1606     result.v[3] = mat.m3;}
\DoxyCodeLine{1607     result.v[4] = mat.m4;}
\DoxyCodeLine{1608     result.v[5] = mat.m5;}
\DoxyCodeLine{1609     result.v[6] = mat.m6;}
\DoxyCodeLine{1610     result.v[7] = mat.m7;}
\DoxyCodeLine{1611     result.v[8] = mat.m8;}
\DoxyCodeLine{1612     result.v[9] = mat.m9;}
\DoxyCodeLine{1613     result.v[10] = mat.m10;}
\DoxyCodeLine{1614     result.v[11] = mat.m11;}
\DoxyCodeLine{1615     result.v[12] = mat.m12;}
\DoxyCodeLine{1616     result.v[13] = mat.m13;}
\DoxyCodeLine{1617     result.v[14] = mat.m14;}
\DoxyCodeLine{1618     result.v[15] = mat.m15;}
\DoxyCodeLine{1619 }
\DoxyCodeLine{1620     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1621 \}}
\DoxyCodeLine{1622 }
\DoxyCodeLine{1623 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1624 \textcolor{comment}{// Module Functions Definition -\/ Quaternion math}}
\DoxyCodeLine{1625 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1626 }
\DoxyCodeLine{1627 \textcolor{comment}{// Add two quaternions}}
\DoxyCodeLine{1628 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionAdd(\mbox{\hyperlink{structVector4}{Quaternion}} q1, \mbox{\hyperlink{structVector4}{Quaternion}} q2)}
\DoxyCodeLine{1629 \{}
\DoxyCodeLine{1630     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{q1.x + q2.x, q1.y + q2.y, q1.z + q2.z, q1.w + q2.w\};}
\DoxyCodeLine{1631 }
\DoxyCodeLine{1632     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1633 \}}
\DoxyCodeLine{1634 }
\DoxyCodeLine{1635 \textcolor{comment}{// Add quaternion and float value}}
\DoxyCodeLine{1636 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionAddValue(\mbox{\hyperlink{structVector4}{Quaternion}} q, \textcolor{keywordtype}{float} add)}
\DoxyCodeLine{1637 \{}
\DoxyCodeLine{1638     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{q.x + add, q.y + add, q.z + add, q.w + add\};}
\DoxyCodeLine{1639 }
\DoxyCodeLine{1640     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1641 \}}
\DoxyCodeLine{1642 }
\DoxyCodeLine{1643 \textcolor{comment}{// Subtract two quaternions}}
\DoxyCodeLine{1644 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionSubtract(\mbox{\hyperlink{structVector4}{Quaternion}} q1, \mbox{\hyperlink{structVector4}{Quaternion}} q2)}
\DoxyCodeLine{1645 \{}
\DoxyCodeLine{1646     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{q1.x -\/ q2.x, q1.y -\/ q2.y, q1.z -\/ q2.z, q1.w -\/ q2.w\};}
\DoxyCodeLine{1647 }
\DoxyCodeLine{1648     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1649 \}}
\DoxyCodeLine{1650 }
\DoxyCodeLine{1651 \textcolor{comment}{// Subtract quaternion and float value}}
\DoxyCodeLine{1652 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionSubtractValue(\mbox{\hyperlink{structVector4}{Quaternion}} q, \textcolor{keywordtype}{float} sub)}
\DoxyCodeLine{1653 \{}
\DoxyCodeLine{1654     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{q.x -\/ sub, q.y -\/ sub, q.z -\/ sub, q.w -\/ sub\};}
\DoxyCodeLine{1655 }
\DoxyCodeLine{1656     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1657 \}}
\DoxyCodeLine{1658 }
\DoxyCodeLine{1659 \textcolor{comment}{// Get identity quaternion}}
\DoxyCodeLine{1660 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionIdentity(\textcolor{keywordtype}{void})}
\DoxyCodeLine{1661 \{}
\DoxyCodeLine{1662     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0.0f, 0.0f, 0.0f, 1.0f \};}
\DoxyCodeLine{1663 }
\DoxyCodeLine{1664     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1665 \}}
\DoxyCodeLine{1666 }
\DoxyCodeLine{1667 \textcolor{comment}{// Computes the length of a quaternion}}
\DoxyCodeLine{1668 RMAPI \textcolor{keywordtype}{float} QuaternionLength(\mbox{\hyperlink{structVector4}{Quaternion}} q)}
\DoxyCodeLine{1669 \{}
\DoxyCodeLine{1670     \textcolor{keywordtype}{float} result = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);}
\DoxyCodeLine{1671 }
\DoxyCodeLine{1672     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1673 \}}
\DoxyCodeLine{1674 }
\DoxyCodeLine{1675 \textcolor{comment}{// Normalize provided quaternion}}
\DoxyCodeLine{1676 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionNormalize(\mbox{\hyperlink{structVector4}{Quaternion}} q)}
\DoxyCodeLine{1677 \{}
\DoxyCodeLine{1678     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{1679 }
\DoxyCodeLine{1680     \textcolor{keywordtype}{float} length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);}
\DoxyCodeLine{1681     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{1682     \textcolor{keywordtype}{float} ilength = 1.0f/length;}
\DoxyCodeLine{1683 }
\DoxyCodeLine{1684     result.x = q.x*ilength;}
\DoxyCodeLine{1685     result.y = q.y*ilength;}
\DoxyCodeLine{1686     result.z = q.z*ilength;}
\DoxyCodeLine{1687     result.w = q.w*ilength;}
\DoxyCodeLine{1688 }
\DoxyCodeLine{1689     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1690 \}}
\DoxyCodeLine{1691 }
\DoxyCodeLine{1692 \textcolor{comment}{// Invert provided quaternion}}
\DoxyCodeLine{1693 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionInvert(\mbox{\hyperlink{structVector4}{Quaternion}} q)}
\DoxyCodeLine{1694 \{}
\DoxyCodeLine{1695     \mbox{\hyperlink{structVector4}{Quaternion}} result = q;}
\DoxyCodeLine{1696 }
\DoxyCodeLine{1697     \textcolor{keywordtype}{float} lengthSq = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;}
\DoxyCodeLine{1698 }
\DoxyCodeLine{1699     \textcolor{keywordflow}{if} (lengthSq != 0.0f)}
\DoxyCodeLine{1700     \{}
\DoxyCodeLine{1701         \textcolor{keywordtype}{float} invLength = 1.0f/lengthSq;}
\DoxyCodeLine{1702 }
\DoxyCodeLine{1703         result.x *= -\/invLength;}
\DoxyCodeLine{1704         result.y *= -\/invLength;}
\DoxyCodeLine{1705         result.z *= -\/invLength;}
\DoxyCodeLine{1706         result.w *= invLength;}
\DoxyCodeLine{1707     \}}
\DoxyCodeLine{1708 }
\DoxyCodeLine{1709     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1710 \}}
\DoxyCodeLine{1711 }
\DoxyCodeLine{1712 \textcolor{comment}{// Calculate two quaternion multiplication}}
\DoxyCodeLine{1713 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionMultiply(\mbox{\hyperlink{structVector4}{Quaternion}} q1, \mbox{\hyperlink{structVector4}{Quaternion}} q2)}
\DoxyCodeLine{1714 \{}
\DoxyCodeLine{1715     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{1716 }
\DoxyCodeLine{1717     \textcolor{keywordtype}{float} qax = q1.x, qay = q1.y, qaz = q1.z, qaw = q1.w;}
\DoxyCodeLine{1718     \textcolor{keywordtype}{float} qbx = q2.x, qby = q2.y, qbz = q2.z, qbw = q2.w;}
\DoxyCodeLine{1719 }
\DoxyCodeLine{1720     result.x = qax*qbw + qaw*qbx + qay*qbz -\/ qaz*qby;}
\DoxyCodeLine{1721     result.y = qay*qbw + qaw*qby + qaz*qbx -\/ qax*qbz;}
\DoxyCodeLine{1722     result.z = qaz*qbw + qaw*qbz + qax*qby -\/ qay*qbx;}
\DoxyCodeLine{1723     result.w = qaw*qbw -\/ qax*qbx -\/ qay*qby -\/ qaz*qbz;}
\DoxyCodeLine{1724 }
\DoxyCodeLine{1725     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1726 \}}
\DoxyCodeLine{1727 }
\DoxyCodeLine{1728 \textcolor{comment}{// Scale quaternion by float value}}
\DoxyCodeLine{1729 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionScale(\mbox{\hyperlink{structVector4}{Quaternion}} q, \textcolor{keywordtype}{float} mul)}
\DoxyCodeLine{1730 \{}
\DoxyCodeLine{1731     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{1732 }
\DoxyCodeLine{1733     result.x = q.x*mul;}
\DoxyCodeLine{1734     result.y = q.y*mul;}
\DoxyCodeLine{1735     result.z = q.z*mul;}
\DoxyCodeLine{1736     result.w = q.w*mul;}
\DoxyCodeLine{1737 }
\DoxyCodeLine{1738     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1739 \}}
\DoxyCodeLine{1740 }
\DoxyCodeLine{1741 \textcolor{comment}{// Divide two quaternions}}
\DoxyCodeLine{1742 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionDivide(\mbox{\hyperlink{structVector4}{Quaternion}} q1, \mbox{\hyperlink{structVector4}{Quaternion}} q2)}
\DoxyCodeLine{1743 \{}
\DoxyCodeLine{1744     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ q1.x/q2.x, q1.y/q2.y, q1.z/q2.z, q1.w/q2.w \};}
\DoxyCodeLine{1745 }
\DoxyCodeLine{1746     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1747 \}}
\DoxyCodeLine{1748 }
\DoxyCodeLine{1749 \textcolor{comment}{// Calculate linear interpolation between two quaternions}}
\DoxyCodeLine{1750 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionLerp(\mbox{\hyperlink{structVector4}{Quaternion}} q1, \mbox{\hyperlink{structVector4}{Quaternion}} q2, \textcolor{keywordtype}{float} amount)}
\DoxyCodeLine{1751 \{}
\DoxyCodeLine{1752     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{1753 }
\DoxyCodeLine{1754     result.x = q1.x + amount*(q2.x -\/ q1.x);}
\DoxyCodeLine{1755     result.y = q1.y + amount*(q2.y -\/ q1.y);}
\DoxyCodeLine{1756     result.z = q1.z + amount*(q2.z -\/ q1.z);}
\DoxyCodeLine{1757     result.w = q1.w + amount*(q2.w -\/ q1.w);}
\DoxyCodeLine{1758 }
\DoxyCodeLine{1759     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1760 \}}
\DoxyCodeLine{1761 }
\DoxyCodeLine{1762 \textcolor{comment}{// Calculate slerp-\/optimized interpolation between two quaternions}}
\DoxyCodeLine{1763 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionNlerp(\mbox{\hyperlink{structVector4}{Quaternion}} q1, \mbox{\hyperlink{structVector4}{Quaternion}} q2, \textcolor{keywordtype}{float} amount)}
\DoxyCodeLine{1764 \{}
\DoxyCodeLine{1765     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{1766 }
\DoxyCodeLine{1767     \textcolor{comment}{// QuaternionLerp(q1, q2, amount)}}
\DoxyCodeLine{1768     result.x = q1.x + amount*(q2.x -\/ q1.x);}
\DoxyCodeLine{1769     result.y = q1.y + amount*(q2.y -\/ q1.y);}
\DoxyCodeLine{1770     result.z = q1.z + amount*(q2.z -\/ q1.z);}
\DoxyCodeLine{1771     result.w = q1.w + amount*(q2.w -\/ q1.w);}
\DoxyCodeLine{1772 }
\DoxyCodeLine{1773     \textcolor{comment}{// QuaternionNormalize(q);}}
\DoxyCodeLine{1774     \mbox{\hyperlink{structVector4}{Quaternion}} q = result;}
\DoxyCodeLine{1775     \textcolor{keywordtype}{float} length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);}
\DoxyCodeLine{1776     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{1777     \textcolor{keywordtype}{float} ilength = 1.0f/length;}
\DoxyCodeLine{1778 }
\DoxyCodeLine{1779     result.x = q.x*ilength;}
\DoxyCodeLine{1780     result.y = q.y*ilength;}
\DoxyCodeLine{1781     result.z = q.z*ilength;}
\DoxyCodeLine{1782     result.w = q.w*ilength;}
\DoxyCodeLine{1783 }
\DoxyCodeLine{1784     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1785 \}}
\DoxyCodeLine{1786 }
\DoxyCodeLine{1787 \textcolor{comment}{// Calculates spherical linear interpolation between two quaternions}}
\DoxyCodeLine{1788 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionSlerp(\mbox{\hyperlink{structVector4}{Quaternion}} q1, \mbox{\hyperlink{structVector4}{Quaternion}} q2, \textcolor{keywordtype}{float} amount)}
\DoxyCodeLine{1789 \{}
\DoxyCodeLine{1790     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{1791 }
\DoxyCodeLine{1792     \textcolor{keywordtype}{float} cosHalfTheta = q1.x*q2.x + q1.y*q2.y + q1.z*q2.z + q1.w*q2.w;}
\DoxyCodeLine{1793 }
\DoxyCodeLine{1794     \textcolor{keywordflow}{if} (cosHalfTheta < 0)}
\DoxyCodeLine{1795     \{}
\DoxyCodeLine{1796         q2.x = -\/q2.x; q2.y = -\/q2.y; q2.z = -\/q2.z; q2.w = -\/q2.w;}
\DoxyCodeLine{1797         cosHalfTheta = -\/cosHalfTheta;}
\DoxyCodeLine{1798     \}}
\DoxyCodeLine{1799 }
\DoxyCodeLine{1800     \textcolor{keywordflow}{if} (fabsf(cosHalfTheta) >= 1.0f) result = q1;}
\DoxyCodeLine{1801     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cosHalfTheta > 0.95f) result = QuaternionNlerp(q1, q2, amount);}
\DoxyCodeLine{1802     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1803     \{}
\DoxyCodeLine{1804         \textcolor{keywordtype}{float} halfTheta = acosf(cosHalfTheta);}
\DoxyCodeLine{1805         \textcolor{keywordtype}{float} sinHalfTheta = sqrtf(1.0f -\/ cosHalfTheta*cosHalfTheta);}
\DoxyCodeLine{1806 }
\DoxyCodeLine{1807         \textcolor{keywordflow}{if} (fabsf(sinHalfTheta) < 0.001f)}
\DoxyCodeLine{1808         \{}
\DoxyCodeLine{1809             result.x = (q1.x*0.5f + q2.x*0.5f);}
\DoxyCodeLine{1810             result.y = (q1.y*0.5f + q2.y*0.5f);}
\DoxyCodeLine{1811             result.z = (q1.z*0.5f + q2.z*0.5f);}
\DoxyCodeLine{1812             result.w = (q1.w*0.5f + q2.w*0.5f);}
\DoxyCodeLine{1813         \}}
\DoxyCodeLine{1814         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1815         \{}
\DoxyCodeLine{1816             \textcolor{keywordtype}{float} ratioA = sinf((1 -\/ amount)*halfTheta)/sinHalfTheta;}
\DoxyCodeLine{1817             \textcolor{keywordtype}{float} ratioB = sinf(amount*halfTheta)/sinHalfTheta;}
\DoxyCodeLine{1818 }
\DoxyCodeLine{1819             result.x = (q1.x*ratioA + q2.x*ratioB);}
\DoxyCodeLine{1820             result.y = (q1.y*ratioA + q2.y*ratioB);}
\DoxyCodeLine{1821             result.z = (q1.z*ratioA + q2.z*ratioB);}
\DoxyCodeLine{1822             result.w = (q1.w*ratioA + q2.w*ratioB);}
\DoxyCodeLine{1823         \}}
\DoxyCodeLine{1824     \}}
\DoxyCodeLine{1825 }
\DoxyCodeLine{1826     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1827 \}}
\DoxyCodeLine{1828 }
\DoxyCodeLine{1829 \textcolor{comment}{// Calculate quaternion based on the rotation from one vector to another}}
\DoxyCodeLine{1830 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionFromVector3ToVector3(\mbox{\hyperlink{structVector3}{Vector3}} from, \mbox{\hyperlink{structVector3}{Vector3}} to)}
\DoxyCodeLine{1831 \{}
\DoxyCodeLine{1832     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{1833 }
\DoxyCodeLine{1834     \textcolor{keywordtype}{float} cos2Theta = (from.x*to.x + from.y*to.y + from.z*to.z);    \textcolor{comment}{// Vector3DotProduct(from, to)}}
\DoxyCodeLine{1835     \mbox{\hyperlink{structVector3}{Vector3}} cross = \{ from.y*to.z -\/ from.z*to.y, from.z*to.x -\/ from.x*to.z, from.x*to.y -\/ from.y*to.x \}; \textcolor{comment}{// Vector3CrossProduct(from, to)}}
\DoxyCodeLine{1836 }
\DoxyCodeLine{1837     result.x = cross.x;}
\DoxyCodeLine{1838     result.y = cross.y;}
\DoxyCodeLine{1839     result.z = cross.z;}
\DoxyCodeLine{1840     result.w = 1.0f + cos2Theta;}
\DoxyCodeLine{1841 }
\DoxyCodeLine{1842     \textcolor{comment}{// QuaternionNormalize(q);}}
\DoxyCodeLine{1843     \textcolor{comment}{// NOTE: Normalize to essentially nlerp the original and identity to 0.5}}
\DoxyCodeLine{1844     \mbox{\hyperlink{structVector4}{Quaternion}} q = result;}
\DoxyCodeLine{1845     \textcolor{keywordtype}{float} length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);}
\DoxyCodeLine{1846     \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{1847     \textcolor{keywordtype}{float} ilength = 1.0f/length;}
\DoxyCodeLine{1848 }
\DoxyCodeLine{1849     result.x = q.x*ilength;}
\DoxyCodeLine{1850     result.y = q.y*ilength;}
\DoxyCodeLine{1851     result.z = q.z*ilength;}
\DoxyCodeLine{1852     result.w = q.w*ilength;}
\DoxyCodeLine{1853 }
\DoxyCodeLine{1854     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1855 \}}
\DoxyCodeLine{1856 }
\DoxyCodeLine{1857 \textcolor{comment}{// Get a quaternion for a given rotation matrix}}
\DoxyCodeLine{1858 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionFromMatrix(\mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{1859 \{}
\DoxyCodeLine{1860     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{1861 }
\DoxyCodeLine{1862     \textcolor{keywordtype}{float} fourWSquaredMinus1 = mat.m0 + mat.m5 + mat.m10;}
\DoxyCodeLine{1863     \textcolor{keywordtype}{float} fourXSquaredMinus1 = mat.m0 -\/ mat.m5 -\/ mat.m10;}
\DoxyCodeLine{1864     \textcolor{keywordtype}{float} fourYSquaredMinus1 = mat.m5 -\/ mat.m0 -\/ mat.m10;}
\DoxyCodeLine{1865     \textcolor{keywordtype}{float} fourZSquaredMinus1 = mat.m10 -\/ mat.m0 -\/ mat.m5;}
\DoxyCodeLine{1866 }
\DoxyCodeLine{1867     \textcolor{keywordtype}{int} biggestIndex = 0;}
\DoxyCodeLine{1868     \textcolor{keywordtype}{float} fourBiggestSquaredMinus1 = fourWSquaredMinus1;}
\DoxyCodeLine{1869     \textcolor{keywordflow}{if} (fourXSquaredMinus1 > fourBiggestSquaredMinus1)}
\DoxyCodeLine{1870     \{}
\DoxyCodeLine{1871         fourBiggestSquaredMinus1 = fourXSquaredMinus1;}
\DoxyCodeLine{1872         biggestIndex = 1;}
\DoxyCodeLine{1873     \}}
\DoxyCodeLine{1874 }
\DoxyCodeLine{1875     \textcolor{keywordflow}{if} (fourYSquaredMinus1 > fourBiggestSquaredMinus1)}
\DoxyCodeLine{1876     \{}
\DoxyCodeLine{1877         fourBiggestSquaredMinus1 = fourYSquaredMinus1;}
\DoxyCodeLine{1878         biggestIndex = 2;}
\DoxyCodeLine{1879     \}}
\DoxyCodeLine{1880 }
\DoxyCodeLine{1881     \textcolor{keywordflow}{if} (fourZSquaredMinus1 > fourBiggestSquaredMinus1)}
\DoxyCodeLine{1882     \{}
\DoxyCodeLine{1883         fourBiggestSquaredMinus1 = fourZSquaredMinus1;}
\DoxyCodeLine{1884         biggestIndex = 3;}
\DoxyCodeLine{1885     \}}
\DoxyCodeLine{1886 }
\DoxyCodeLine{1887     \textcolor{keywordtype}{float} biggestVal = sqrtf(fourBiggestSquaredMinus1 + 1.0f) * 0.5f;}
\DoxyCodeLine{1888     \textcolor{keywordtype}{float} mult = 0.25f / biggestVal;}
\DoxyCodeLine{1889 }
\DoxyCodeLine{1890     \textcolor{keywordflow}{switch} (biggestIndex)}
\DoxyCodeLine{1891     \{}
\DoxyCodeLine{1892         \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{1893             result.w = biggestVal;}
\DoxyCodeLine{1894             result.x = (mat.m6 -\/ mat.m9) * mult;}
\DoxyCodeLine{1895             result.y = (mat.m8 -\/ mat.m2) * mult;}
\DoxyCodeLine{1896             result.z = (mat.m1 -\/ mat.m4) * mult;}
\DoxyCodeLine{1897             \textcolor{keywordflow}{break};}
\DoxyCodeLine{1898         \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{1899             result.x = biggestVal;}
\DoxyCodeLine{1900             result.w = (mat.m6 -\/ mat.m9) * mult;}
\DoxyCodeLine{1901             result.y = (mat.m1 + mat.m4) * mult;}
\DoxyCodeLine{1902             result.z = (mat.m8 + mat.m2) * mult;}
\DoxyCodeLine{1903             \textcolor{keywordflow}{break};}
\DoxyCodeLine{1904         \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{1905             result.y = biggestVal;}
\DoxyCodeLine{1906             result.w = (mat.m8 -\/ mat.m2) * mult;}
\DoxyCodeLine{1907             result.x = (mat.m1 + mat.m4) * mult;}
\DoxyCodeLine{1908             result.z = (mat.m6 + mat.m9) * mult;}
\DoxyCodeLine{1909             \textcolor{keywordflow}{break};}
\DoxyCodeLine{1910         \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{1911             result.z = biggestVal;}
\DoxyCodeLine{1912             result.w = (mat.m1 -\/ mat.m4) * mult;}
\DoxyCodeLine{1913             result.x = (mat.m8 + mat.m2) * mult;}
\DoxyCodeLine{1914             result.y = (mat.m6 + mat.m9) * mult;}
\DoxyCodeLine{1915             \textcolor{keywordflow}{break};}
\DoxyCodeLine{1916     \}}
\DoxyCodeLine{1917 }
\DoxyCodeLine{1918     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1919 \}}
\DoxyCodeLine{1920 }
\DoxyCodeLine{1921 \textcolor{comment}{// Get a matrix for a given quaternion}}
\DoxyCodeLine{1922 RMAPI \mbox{\hyperlink{structMatrix}{Matrix}} QuaternionToMatrix(\mbox{\hyperlink{structVector4}{Quaternion}} q)}
\DoxyCodeLine{1923 \{}
\DoxyCodeLine{1924     \mbox{\hyperlink{structMatrix}{Matrix}} result = \{ 1.0f, 0.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1925                       0.0f, 1.0f, 0.0f, 0.0f,}
\DoxyCodeLine{1926                       0.0f, 0.0f, 1.0f, 0.0f,}
\DoxyCodeLine{1927                       0.0f, 0.0f, 0.0f, 1.0f \}; \textcolor{comment}{// MatrixIdentity()}}
\DoxyCodeLine{1928 }
\DoxyCodeLine{1929     \textcolor{keywordtype}{float} a2 = q.x*q.x;}
\DoxyCodeLine{1930     \textcolor{keywordtype}{float} b2 = q.y*q.y;}
\DoxyCodeLine{1931     \textcolor{keywordtype}{float} c2 = q.z*q.z;}
\DoxyCodeLine{1932     \textcolor{keywordtype}{float} ac = q.x*q.z;}
\DoxyCodeLine{1933     \textcolor{keywordtype}{float} ab = q.x*q.y;}
\DoxyCodeLine{1934     \textcolor{keywordtype}{float} bc = q.y*q.z;}
\DoxyCodeLine{1935     \textcolor{keywordtype}{float} ad = q.w*q.x;}
\DoxyCodeLine{1936     \textcolor{keywordtype}{float} bd = q.w*q.y;}
\DoxyCodeLine{1937     \textcolor{keywordtype}{float} cd = q.w*q.z;}
\DoxyCodeLine{1938 }
\DoxyCodeLine{1939     result.m0 = 1 -\/ 2*(b2 + c2);}
\DoxyCodeLine{1940     result.m1 = 2*(ab + cd);}
\DoxyCodeLine{1941     result.m2 = 2*(ac -\/ bd);}
\DoxyCodeLine{1942 }
\DoxyCodeLine{1943     result.m4 = 2*(ab -\/ cd);}
\DoxyCodeLine{1944     result.m5 = 1 -\/ 2*(a2 + c2);}
\DoxyCodeLine{1945     result.m6 = 2*(bc + ad);}
\DoxyCodeLine{1946 }
\DoxyCodeLine{1947     result.m8 = 2*(ac + bd);}
\DoxyCodeLine{1948     result.m9 = 2*(bc -\/ ad);}
\DoxyCodeLine{1949     result.m10 = 1 -\/ 2*(a2 + b2);}
\DoxyCodeLine{1950 }
\DoxyCodeLine{1951     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1952 \}}
\DoxyCodeLine{1953 }
\DoxyCodeLine{1954 \textcolor{comment}{// Get rotation quaternion for an angle and axis}}
\DoxyCodeLine{1955 \textcolor{comment}{// NOTE: Angle must be provided in radians}}
\DoxyCodeLine{1956 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionFromAxisAngle(\mbox{\hyperlink{structVector3}{Vector3}} axis, \textcolor{keywordtype}{float} angle)}
\DoxyCodeLine{1957 \{}
\DoxyCodeLine{1958     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0.0f, 0.0f, 0.0f, 1.0f \};}
\DoxyCodeLine{1959 }
\DoxyCodeLine{1960     \textcolor{keywordtype}{float} axisLength = sqrtf(axis.x*axis.x + axis.y*axis.y + axis.z*axis.z);}
\DoxyCodeLine{1961 }
\DoxyCodeLine{1962     \textcolor{keywordflow}{if} (axisLength != 0.0f)}
\DoxyCodeLine{1963     \{}
\DoxyCodeLine{1964         angle *= 0.5f;}
\DoxyCodeLine{1965 }
\DoxyCodeLine{1966         \textcolor{keywordtype}{float} length = 0.0f;}
\DoxyCodeLine{1967         \textcolor{keywordtype}{float} ilength = 0.0f;}
\DoxyCodeLine{1968 }
\DoxyCodeLine{1969         \textcolor{comment}{// Vector3Normalize(axis)}}
\DoxyCodeLine{1970         \mbox{\hyperlink{structVector3}{Vector3}} v = axis;}
\DoxyCodeLine{1971         length = sqrtf(v.x*v.x + v.y*v.y + v.z*v.z);}
\DoxyCodeLine{1972         \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{1973         ilength = 1.0f/length;}
\DoxyCodeLine{1974         axis.x *= ilength;}
\DoxyCodeLine{1975         axis.y *= ilength;}
\DoxyCodeLine{1976         axis.z *= ilength;}
\DoxyCodeLine{1977 }
\DoxyCodeLine{1978         \textcolor{keywordtype}{float} sinres = sinf(angle);}
\DoxyCodeLine{1979         \textcolor{keywordtype}{float} cosres = cosf(angle);}
\DoxyCodeLine{1980 }
\DoxyCodeLine{1981         result.x = axis.x*sinres;}
\DoxyCodeLine{1982         result.y = axis.y*sinres;}
\DoxyCodeLine{1983         result.z = axis.z*sinres;}
\DoxyCodeLine{1984         result.w = cosres;}
\DoxyCodeLine{1985 }
\DoxyCodeLine{1986         \textcolor{comment}{// QuaternionNormalize(q);}}
\DoxyCodeLine{1987         \mbox{\hyperlink{structVector4}{Quaternion}} q = result;}
\DoxyCodeLine{1988         length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);}
\DoxyCodeLine{1989         \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{1990         ilength = 1.0f/length;}
\DoxyCodeLine{1991         result.x = q.x*ilength;}
\DoxyCodeLine{1992         result.y = q.y*ilength;}
\DoxyCodeLine{1993         result.z = q.z*ilength;}
\DoxyCodeLine{1994         result.w = q.w*ilength;}
\DoxyCodeLine{1995     \}}
\DoxyCodeLine{1996 }
\DoxyCodeLine{1997     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1998 \}}
\DoxyCodeLine{1999 }
\DoxyCodeLine{2000 \textcolor{comment}{// Get the rotation angle and axis for a given quaternion}}
\DoxyCodeLine{2001 RMAPI \textcolor{keywordtype}{void} QuaternionToAxisAngle(\mbox{\hyperlink{structVector4}{Quaternion}} q, \mbox{\hyperlink{structVector3}{Vector3}} *outAxis, \textcolor{keywordtype}{float} *outAngle)}
\DoxyCodeLine{2002 \{}
\DoxyCodeLine{2003     \textcolor{keywordflow}{if} (fabsf(q.w) > 1.0f)}
\DoxyCodeLine{2004     \{}
\DoxyCodeLine{2005         \textcolor{comment}{// QuaternionNormalize(q);}}
\DoxyCodeLine{2006         \textcolor{keywordtype}{float} length = sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);}
\DoxyCodeLine{2007         \textcolor{keywordflow}{if} (length == 0.0f) length = 1.0f;}
\DoxyCodeLine{2008         \textcolor{keywordtype}{float} ilength = 1.0f/length;}
\DoxyCodeLine{2009 }
\DoxyCodeLine{2010         q.x = q.x*ilength;}
\DoxyCodeLine{2011         q.y = q.y*ilength;}
\DoxyCodeLine{2012         q.z = q.z*ilength;}
\DoxyCodeLine{2013         q.w = q.w*ilength;}
\DoxyCodeLine{2014     \}}
\DoxyCodeLine{2015 }
\DoxyCodeLine{2016     \mbox{\hyperlink{structVector3}{Vector3}} resAxis = \{ 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{2017     \textcolor{keywordtype}{float} resAngle = 2.0f*acosf(q.w);}
\DoxyCodeLine{2018     \textcolor{keywordtype}{float} den = sqrtf(1.0f -\/ q.w*q.w);}
\DoxyCodeLine{2019 }
\DoxyCodeLine{2020     \textcolor{keywordflow}{if} (den > 0.0001f)}
\DoxyCodeLine{2021     \{}
\DoxyCodeLine{2022         resAxis.x = q.x/den;}
\DoxyCodeLine{2023         resAxis.y = q.y/den;}
\DoxyCodeLine{2024         resAxis.z = q.z/den;}
\DoxyCodeLine{2025     \}}
\DoxyCodeLine{2026     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2027     \{}
\DoxyCodeLine{2028         \textcolor{comment}{// This occurs when the angle is zero.}}
\DoxyCodeLine{2029         \textcolor{comment}{// Not a problem: just set an arbitrary normalized axis.}}
\DoxyCodeLine{2030         resAxis.x = 1.0f;}
\DoxyCodeLine{2031     \}}
\DoxyCodeLine{2032 }
\DoxyCodeLine{2033     *outAxis = resAxis;}
\DoxyCodeLine{2034     *outAngle = resAngle;}
\DoxyCodeLine{2035 \}}
\DoxyCodeLine{2036 }
\DoxyCodeLine{2037 \textcolor{comment}{// Get the quaternion equivalent to Euler angles}}
\DoxyCodeLine{2038 \textcolor{comment}{// NOTE: Rotation order is ZYX}}
\DoxyCodeLine{2039 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionFromEuler(\textcolor{keywordtype}{float} pitch, \textcolor{keywordtype}{float} yaw, \textcolor{keywordtype}{float} roll)}
\DoxyCodeLine{2040 \{}
\DoxyCodeLine{2041     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{2042 }
\DoxyCodeLine{2043     \textcolor{keywordtype}{float} x0 = cosf(pitch*0.5f);}
\DoxyCodeLine{2044     \textcolor{keywordtype}{float} x1 = sinf(pitch*0.5f);}
\DoxyCodeLine{2045     \textcolor{keywordtype}{float} y0 = cosf(yaw*0.5f);}
\DoxyCodeLine{2046     \textcolor{keywordtype}{float} y1 = sinf(yaw*0.5f);}
\DoxyCodeLine{2047     \textcolor{keywordtype}{float} z0 = cosf(roll*0.5f);}
\DoxyCodeLine{2048     \textcolor{keywordtype}{float} z1 = sinf(roll*0.5f);}
\DoxyCodeLine{2049 }
\DoxyCodeLine{2050     result.x = x1*y0*z0 -\/ x0*y1*z1;}
\DoxyCodeLine{2051     result.y = x0*y1*z0 + x1*y0*z1;}
\DoxyCodeLine{2052     result.z = x0*y0*z1 -\/ x1*y1*z0;}
\DoxyCodeLine{2053     result.w = x0*y0*z0 + x1*y1*z1;}
\DoxyCodeLine{2054 }
\DoxyCodeLine{2055     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2056 \}}
\DoxyCodeLine{2057 }
\DoxyCodeLine{2058 \textcolor{comment}{// Get the Euler angles equivalent to quaternion (roll, pitch, yaw)}}
\DoxyCodeLine{2059 \textcolor{comment}{// NOTE: Angles are returned in a Vector3 struct in radians}}
\DoxyCodeLine{2060 RMAPI \mbox{\hyperlink{structVector3}{Vector3}} QuaternionToEuler(\mbox{\hyperlink{structVector4}{Quaternion}} q)}
\DoxyCodeLine{2061 \{}
\DoxyCodeLine{2062     \mbox{\hyperlink{structVector3}{Vector3}} result = \{ 0 \};}
\DoxyCodeLine{2063 }
\DoxyCodeLine{2064     \textcolor{comment}{// Roll (x-\/axis rotation)}}
\DoxyCodeLine{2065     \textcolor{keywordtype}{float} x0 = 2.0f*(q.w*q.x + q.y*q.z);}
\DoxyCodeLine{2066     \textcolor{keywordtype}{float} x1 = 1.0f -\/ 2.0f*(q.x*q.x + q.y*q.y);}
\DoxyCodeLine{2067     result.x = atan2f(x0, x1);}
\DoxyCodeLine{2068 }
\DoxyCodeLine{2069     \textcolor{comment}{// Pitch (y-\/axis rotation)}}
\DoxyCodeLine{2070     \textcolor{keywordtype}{float} y0 = 2.0f*(q.w*q.y -\/ q.z*q.x);}
\DoxyCodeLine{2071     y0 = y0 > 1.0f ? 1.0f : y0;}
\DoxyCodeLine{2072     y0 = y0 < -\/1.0f ? -\/1.0f : y0;}
\DoxyCodeLine{2073     result.y = asinf(y0);}
\DoxyCodeLine{2074 }
\DoxyCodeLine{2075     \textcolor{comment}{// Yaw (z-\/axis rotation)}}
\DoxyCodeLine{2076     \textcolor{keywordtype}{float} z0 = 2.0f*(q.w*q.z + q.x*q.y);}
\DoxyCodeLine{2077     \textcolor{keywordtype}{float} z1 = 1.0f -\/ 2.0f*(q.y*q.y + q.z*q.z);}
\DoxyCodeLine{2078     result.z = atan2f(z0, z1);}
\DoxyCodeLine{2079 }
\DoxyCodeLine{2080     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2081 \}}
\DoxyCodeLine{2082 }
\DoxyCodeLine{2083 \textcolor{comment}{// Transform a quaternion given a transformation matrix}}
\DoxyCodeLine{2084 RMAPI \mbox{\hyperlink{structVector4}{Quaternion}} QuaternionTransform(\mbox{\hyperlink{structVector4}{Quaternion}} q, \mbox{\hyperlink{structMatrix}{Matrix}} mat)}
\DoxyCodeLine{2085 \{}
\DoxyCodeLine{2086     \mbox{\hyperlink{structVector4}{Quaternion}} result = \{ 0 \};}
\DoxyCodeLine{2087 }
\DoxyCodeLine{2088     result.x = mat.m0*q.x + mat.m4*q.y + mat.m8*q.z + mat.m12*q.w;}
\DoxyCodeLine{2089     result.y = mat.m1*q.x + mat.m5*q.y + mat.m9*q.z + mat.m13*q.w;}
\DoxyCodeLine{2090     result.z = mat.m2*q.x + mat.m6*q.y + mat.m10*q.z + mat.m14*q.w;}
\DoxyCodeLine{2091     result.w = mat.m3*q.x + mat.m7*q.y + mat.m11*q.z + mat.m15*q.w;}
\DoxyCodeLine{2092 }
\DoxyCodeLine{2093     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2094 \}}
\DoxyCodeLine{2095 }
\DoxyCodeLine{2096 \textcolor{comment}{// Check whether two given quaternions are almost equal}}
\DoxyCodeLine{2097 RMAPI \textcolor{keywordtype}{int} QuaternionEquals(\mbox{\hyperlink{structVector4}{Quaternion}} p, \mbox{\hyperlink{structVector4}{Quaternion}} q)}
\DoxyCodeLine{2098 \{}
\DoxyCodeLine{2099     \textcolor{keywordtype}{int} result = (((fabsf(p.x -\/ q.x)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.x), fabsf(q.x))))) \&\&}
\DoxyCodeLine{2100                   ((fabsf(p.y -\/ q.y)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.y), fabsf(q.y))))) \&\&}
\DoxyCodeLine{2101                   ((fabsf(p.z -\/ q.z)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.z), fabsf(q.z))))) \&\&}
\DoxyCodeLine{2102                   ((fabsf(p.w -\/ q.w)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.w), fabsf(q.w)))))) ||}
\DoxyCodeLine{2103                   (((fabsf(p.x + q.x)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.x), fabsf(q.x))))) \&\&}
\DoxyCodeLine{2104                   ((fabsf(p.y + q.y)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.y), fabsf(q.y))))) \&\&}
\DoxyCodeLine{2105                   ((fabsf(p.z + q.z)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.z), fabsf(q.z))))) \&\&}
\DoxyCodeLine{2106                   ((fabsf(p.w + q.w)) <= (EPSILON*fmaxf(1.0f, fmaxf(fabsf(p.w), fabsf(q.w))))));}
\DoxyCodeLine{2107 }
\DoxyCodeLine{2108     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2109 \}}
\DoxyCodeLine{2110 }
\DoxyCodeLine{2111 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// RAYMATH\_H}}

\end{DoxyCode}
