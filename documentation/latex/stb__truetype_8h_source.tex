\hypertarget{stb__truetype_8h_source}{}\doxysection{stb\+\_\+truetype.\+h}
\label{stb__truetype_8h_source}\index{build/\_deps/raylib-\/src/src/external/stb\_truetype.h@{build/\_deps/raylib-\/src/src/external/stb\_truetype.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// stb\_truetype.h -\/ v1.26 -\/ public domain}}
\DoxyCodeLine{2 \textcolor{comment}{// authored from 2009-\/2021 by Sean Barrett / RAD Game Tools}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// =======================================================================}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{//    NO SECURITY GUARANTEE -\/-\/ DO NOT USE THIS ON UNTRUSTED FONT FILES}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{// This library does no range checking of the offsets found in the file,}}
\DoxyCodeLine{9 \textcolor{comment}{// meaning an attacker can use it to read arbitrary memory.}}
\DoxyCodeLine{10 \textcolor{comment}{//}}
\DoxyCodeLine{11 \textcolor{comment}{// =======================================================================}}
\DoxyCodeLine{12 \textcolor{comment}{//}}
\DoxyCodeLine{13 \textcolor{comment}{//   This library processes TrueType files:}}
\DoxyCodeLine{14 \textcolor{comment}{//        parse files}}
\DoxyCodeLine{15 \textcolor{comment}{//        extract glyph metrics}}
\DoxyCodeLine{16 \textcolor{comment}{//        extract glyph shapes}}
\DoxyCodeLine{17 \textcolor{comment}{//        render glyphs to one-\/channel bitmaps with antialiasing (box filter)}}
\DoxyCodeLine{18 \textcolor{comment}{//        render glyphs to one-\/channel SDF bitmaps (signed-\/distance field/function)}}
\DoxyCodeLine{19 \textcolor{comment}{//}}
\DoxyCodeLine{20 \textcolor{comment}{//   Todo:}}
\DoxyCodeLine{21 \textcolor{comment}{//        non-\/MS cmaps}}
\DoxyCodeLine{22 \textcolor{comment}{//        crashproof on bad data}}
\DoxyCodeLine{23 \textcolor{comment}{//        hinting? (no longer patented)}}
\DoxyCodeLine{24 \textcolor{comment}{//        cleartype-\/style AA?}}
\DoxyCodeLine{25 \textcolor{comment}{//        optimize: use simple memory allocator for intermediates}}
\DoxyCodeLine{26 \textcolor{comment}{//        optimize: build edge-\/list directly from curves}}
\DoxyCodeLine{27 \textcolor{comment}{//        optimize: rasterize directly from curves?}}
\DoxyCodeLine{28 \textcolor{comment}{//}}
\DoxyCodeLine{29 \textcolor{comment}{// ADDITIONAL CONTRIBUTORS}}
\DoxyCodeLine{30 \textcolor{comment}{//}}
\DoxyCodeLine{31 \textcolor{comment}{//   Mikko Mononen: compound shape support, more cmap formats}}
\DoxyCodeLine{32 \textcolor{comment}{//   Tor Andersson: kerning, subpixel rendering}}
\DoxyCodeLine{33 \textcolor{comment}{//   Dougall Johnson: OpenType / Type 2 font handling}}
\DoxyCodeLine{34 \textcolor{comment}{//   Daniel Ribeiro Maciel: basic GPOS-\/based kerning}}
\DoxyCodeLine{35 \textcolor{comment}{//}}
\DoxyCodeLine{36 \textcolor{comment}{//   Misc other:}}
\DoxyCodeLine{37 \textcolor{comment}{//       Ryan Gordon}}
\DoxyCodeLine{38 \textcolor{comment}{//       Simon Glass}}
\DoxyCodeLine{39 \textcolor{comment}{//       github:IntellectualKitty}}
\DoxyCodeLine{40 \textcolor{comment}{//       Imanol Celaya}}
\DoxyCodeLine{41 \textcolor{comment}{//       Daniel Ribeiro Maciel}}
\DoxyCodeLine{42 \textcolor{comment}{//}}
\DoxyCodeLine{43 \textcolor{comment}{//   Bug/warning reports/fixes:}}
\DoxyCodeLine{44 \textcolor{comment}{//       "{}Zer"{} on mollyrocket       Fabian "{}ryg"{} Giesen   github:NiLuJe}}
\DoxyCodeLine{45 \textcolor{comment}{//       Cass Everitt               Martins Mozeiko       github:aloucks}}
\DoxyCodeLine{46 \textcolor{comment}{//       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam}}
\DoxyCodeLine{47 \textcolor{comment}{//       Brian Hook                 Omar Cornut           github:vassvik}}
\DoxyCodeLine{48 \textcolor{comment}{//       Walter van Niftrik         Ryan Griege}}
\DoxyCodeLine{49 \textcolor{comment}{//       David Gow                  Peter LaValle}}
\DoxyCodeLine{50 \textcolor{comment}{//       David Given                Sergey Popov}}
\DoxyCodeLine{51 \textcolor{comment}{//       Ivan-\/Assen Ivanov          Giumo X. Clanjor}}
\DoxyCodeLine{52 \textcolor{comment}{//       Anthony Pesch              Higor Euripedes}}
\DoxyCodeLine{53 \textcolor{comment}{//       Johan Duparc               Thomas Fields}}
\DoxyCodeLine{54 \textcolor{comment}{//       Hou Qiming                 Derek Vinyard}}
\DoxyCodeLine{55 \textcolor{comment}{//       Rob Loach                  Cort Stratton}}
\DoxyCodeLine{56 \textcolor{comment}{//       Kenney Phillis Jr.         Brian Costabile}}
\DoxyCodeLine{57 \textcolor{comment}{//       Ken Voskuil (kaesve)}}
\DoxyCodeLine{58 \textcolor{comment}{//}}
\DoxyCodeLine{59 \textcolor{comment}{// VERSION HISTORY}}
\DoxyCodeLine{60 \textcolor{comment}{//}}
\DoxyCodeLine{61 \textcolor{comment}{//   1.26 (2021-\/08-\/28) fix broken rasterizer}}
\DoxyCodeLine{62 \textcolor{comment}{//   1.25 (2021-\/07-\/11) many fixes}}
\DoxyCodeLine{63 \textcolor{comment}{//   1.24 (2020-\/02-\/05) fix warning}}
\DoxyCodeLine{64 \textcolor{comment}{//   1.23 (2020-\/02-\/02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)}}
\DoxyCodeLine{65 \textcolor{comment}{//   1.22 (2019-\/08-\/11) minimize missing-\/glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined}}
\DoxyCodeLine{66 \textcolor{comment}{//   1.21 (2019-\/02-\/25) fix warning}}
\DoxyCodeLine{67 \textcolor{comment}{//   1.20 (2019-\/02-\/07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()}}
\DoxyCodeLine{68 \textcolor{comment}{//   1.19 (2018-\/02-\/11) GPOS kerning, STBTT\_fmod}}
\DoxyCodeLine{69 \textcolor{comment}{//   1.18 (2018-\/01-\/29) add missing function}}
\DoxyCodeLine{70 \textcolor{comment}{//   1.17 (2017-\/07-\/23) make more arguments const; doc fix}}
\DoxyCodeLine{71 \textcolor{comment}{//   1.16 (2017-\/07-\/12) SDF support}}
\DoxyCodeLine{72 \textcolor{comment}{//   1.15 (2017-\/03-\/03) make more arguments const}}
\DoxyCodeLine{73 \textcolor{comment}{//   1.14 (2017-\/01-\/16) num-\/fonts-\/in-\/TTC function}}
\DoxyCodeLine{74 \textcolor{comment}{//   1.13 (2017-\/01-\/02) support OpenType fonts, certain Apple fonts}}
\DoxyCodeLine{75 \textcolor{comment}{//   1.12 (2016-\/10-\/25) suppress warnings about casting away const with -\/Wcast-\/qual}}
\DoxyCodeLine{76 \textcolor{comment}{//   1.11 (2016-\/04-\/02) fix unused-\/variable warning}}
\DoxyCodeLine{77 \textcolor{comment}{//   1.10 (2016-\/04-\/02) user-\/defined fabs(); rare memory leak; remove duplicate typedef}}
\DoxyCodeLine{78 \textcolor{comment}{//   1.09 (2016-\/01-\/16) warning fix; avoid crash on outofmem; use allocation userdata properly}}
\DoxyCodeLine{79 \textcolor{comment}{//   1.08 (2015-\/09-\/13) document stbtt\_Rasterize(); fixes for vertical \& horizontal edges}}
\DoxyCodeLine{80 \textcolor{comment}{//   1.07 (2015-\/08-\/01) allow PackFontRanges to accept arrays of sparse codepoints;}}
\DoxyCodeLine{81 \textcolor{comment}{//                     variant PackFontRanges to pack and render in separate phases;}}
\DoxyCodeLine{82 \textcolor{comment}{//                     fix stbtt\_GetFontOFfsetForIndex (never worked for non-\/0 input?);}}
\DoxyCodeLine{83 \textcolor{comment}{//                     fixed an assert() bug in the new rasterizer}}
\DoxyCodeLine{84 \textcolor{comment}{//                     replace assert() with STBTT\_assert() in new rasterizer}}
\DoxyCodeLine{85 \textcolor{comment}{//}}
\DoxyCodeLine{86 \textcolor{comment}{//   Full history can be found at the end of this file.}}
\DoxyCodeLine{87 \textcolor{comment}{//}}
\DoxyCodeLine{88 \textcolor{comment}{// LICENSE}}
\DoxyCodeLine{89 \textcolor{comment}{//}}
\DoxyCodeLine{90 \textcolor{comment}{//   See end of file for license information.}}
\DoxyCodeLine{91 \textcolor{comment}{//}}
\DoxyCodeLine{92 \textcolor{comment}{// USAGE}}
\DoxyCodeLine{93 \textcolor{comment}{//}}
\DoxyCodeLine{94 \textcolor{comment}{//   Include this file in whatever places need to refer to it. In ONE C/C++}}
\DoxyCodeLine{95 \textcolor{comment}{//   file, write:}}
\DoxyCodeLine{96 \textcolor{comment}{//      \#define STB\_TRUETYPE\_IMPLEMENTATION}}
\DoxyCodeLine{97 \textcolor{comment}{//   before the \#include of this file. This expands out the actual}}
\DoxyCodeLine{98 \textcolor{comment}{//   implementation into that C/C++ file.}}
\DoxyCodeLine{99 \textcolor{comment}{//}}
\DoxyCodeLine{100 \textcolor{comment}{//   To make the implementation private to the file that generates the implementation,}}
\DoxyCodeLine{101 \textcolor{comment}{//      \#define STBTT\_STATIC}}
\DoxyCodeLine{102 \textcolor{comment}{//}}
\DoxyCodeLine{103 \textcolor{comment}{//   Simple 3D API (don't ship this, but it's fine for tools and quick start)}}
\DoxyCodeLine{104 \textcolor{comment}{//           stbtt\_BakeFontBitmap()               -\/-\/ bake a font to a bitmap for use as texture}}
\DoxyCodeLine{105 \textcolor{comment}{//           stbtt\_GetBakedQuad()                 -\/-\/ compute quad to draw for a given char}}
\DoxyCodeLine{106 \textcolor{comment}{//}}
\DoxyCodeLine{107 \textcolor{comment}{//   Improved 3D API (more shippable):}}
\DoxyCodeLine{108 \textcolor{comment}{//           \#include "{}stb\_rect\_pack.h"{}           -\/-\/ optional, but you really want it}}
\DoxyCodeLine{109 \textcolor{comment}{//           stbtt\_PackBegin()}}
\DoxyCodeLine{110 \textcolor{comment}{//           stbtt\_PackSetOversampling()          -\/-\/ for improved quality on small fonts}}
\DoxyCodeLine{111 \textcolor{comment}{//           stbtt\_PackFontRanges()               -\/-\/ pack and renders}}
\DoxyCodeLine{112 \textcolor{comment}{//           stbtt\_PackEnd()}}
\DoxyCodeLine{113 \textcolor{comment}{//           stbtt\_GetPackedQuad()}}
\DoxyCodeLine{114 \textcolor{comment}{//}}
\DoxyCodeLine{115 \textcolor{comment}{//   "{}Load"{} a font file from a memory buffer (you have to keep the buffer loaded)}}
\DoxyCodeLine{116 \textcolor{comment}{//           stbtt\_InitFont()}}
\DoxyCodeLine{117 \textcolor{comment}{//           stbtt\_GetFontOffsetForIndex()        -\/-\/ indexing for TTC font collections}}
\DoxyCodeLine{118 \textcolor{comment}{//           stbtt\_GetNumberOfFonts()             -\/-\/ number of fonts for TTC font collections}}
\DoxyCodeLine{119 \textcolor{comment}{//}}
\DoxyCodeLine{120 \textcolor{comment}{//   Render a unicode codepoint to a bitmap}}
\DoxyCodeLine{121 \textcolor{comment}{//           stbtt\_GetCodepointBitmap()           -\/-\/ allocates and returns a bitmap}}
\DoxyCodeLine{122 \textcolor{comment}{//           stbtt\_MakeCodepointBitmap()          -\/-\/ renders into bitmap you provide}}
\DoxyCodeLine{123 \textcolor{comment}{//           stbtt\_GetCodepointBitmapBox()        -\/-\/ how big the bitmap must be}}
\DoxyCodeLine{124 \textcolor{comment}{//}}
\DoxyCodeLine{125 \textcolor{comment}{//   Character advance/positioning}}
\DoxyCodeLine{126 \textcolor{comment}{//           stbtt\_GetCodepointHMetrics()}}
\DoxyCodeLine{127 \textcolor{comment}{//           stbtt\_GetFontVMetrics()}}
\DoxyCodeLine{128 \textcolor{comment}{//           stbtt\_GetFontVMetricsOS2()}}
\DoxyCodeLine{129 \textcolor{comment}{//           stbtt\_GetCodepointKernAdvance()}}
\DoxyCodeLine{130 \textcolor{comment}{//}}
\DoxyCodeLine{131 \textcolor{comment}{//   Starting with version 1.06, the rasterizer was replaced with a new,}}
\DoxyCodeLine{132 \textcolor{comment}{//   faster and generally-\/more-\/precise rasterizer. The new rasterizer more}}
\DoxyCodeLine{133 \textcolor{comment}{//   accurately measures pixel coverage for anti-\/aliasing, except in the case}}
\DoxyCodeLine{134 \textcolor{comment}{//   where multiple shapes overlap, in which case it overestimates the AA pixel}}
\DoxyCodeLine{135 \textcolor{comment}{//   coverage. Thus, anti-\/aliasing of intersecting shapes may look wrong. If}}
\DoxyCodeLine{136 \textcolor{comment}{//   this turns out to be a problem, you can re-\/enable the old rasterizer with}}
\DoxyCodeLine{137 \textcolor{comment}{//        \#define STBTT\_RASTERIZER\_VERSION 1}}
\DoxyCodeLine{138 \textcolor{comment}{//   which will incur about a 15\% speed hit.}}
\DoxyCodeLine{139 \textcolor{comment}{//}}
\DoxyCodeLine{140 \textcolor{comment}{// ADDITIONAL DOCUMENTATION}}
\DoxyCodeLine{141 \textcolor{comment}{//}}
\DoxyCodeLine{142 \textcolor{comment}{//   Immediately after this block comment are a series of sample programs.}}
\DoxyCodeLine{143 \textcolor{comment}{//}}
\DoxyCodeLine{144 \textcolor{comment}{//   After the sample programs is the "{}header file"{} section. This section}}
\DoxyCodeLine{145 \textcolor{comment}{//   includes documentation for each API function.}}
\DoxyCodeLine{146 \textcolor{comment}{//}}
\DoxyCodeLine{147 \textcolor{comment}{//   Some important concepts to understand to use this library:}}
\DoxyCodeLine{148 \textcolor{comment}{//}}
\DoxyCodeLine{149 \textcolor{comment}{//      Codepoint}}
\DoxyCodeLine{150 \textcolor{comment}{//         Characters are defined by unicode codepoints, e.g. 65 is}}
\DoxyCodeLine{151 \textcolor{comment}{//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is}}
\DoxyCodeLine{152 \textcolor{comment}{//         the hiragana for "{}ma"{}.}}
\DoxyCodeLine{153 \textcolor{comment}{//}}
\DoxyCodeLine{154 \textcolor{comment}{//      Glyph}}
\DoxyCodeLine{155 \textcolor{comment}{//         A visual character shape (every codepoint is rendered as}}
\DoxyCodeLine{156 \textcolor{comment}{//         some glyph)}}
\DoxyCodeLine{157 \textcolor{comment}{//}}
\DoxyCodeLine{158 \textcolor{comment}{//      Glyph index}}
\DoxyCodeLine{159 \textcolor{comment}{//         A font-\/specific integer ID representing a glyph}}
\DoxyCodeLine{160 \textcolor{comment}{//}}
\DoxyCodeLine{161 \textcolor{comment}{//      Baseline}}
\DoxyCodeLine{162 \textcolor{comment}{//         Glyph shapes are defined relative to a baseline, which is the}}
\DoxyCodeLine{163 \textcolor{comment}{//         bottom of uppercase characters. Characters extend both above}}
\DoxyCodeLine{164 \textcolor{comment}{//         and below the baseline.}}
\DoxyCodeLine{165 \textcolor{comment}{//}}
\DoxyCodeLine{166 \textcolor{comment}{//      Current Point}}
\DoxyCodeLine{167 \textcolor{comment}{//         As you draw text to the screen, you keep track of a "{}current point"{}}}
\DoxyCodeLine{168 \textcolor{comment}{//         which is the origin of each character. The current point's vertical}}
\DoxyCodeLine{169 \textcolor{comment}{//         position is the baseline. Even "{}baked fonts"{} use this model.}}
\DoxyCodeLine{170 \textcolor{comment}{//}}
\DoxyCodeLine{171 \textcolor{comment}{//      Vertical Font Metrics}}
\DoxyCodeLine{172 \textcolor{comment}{//         The vertical qualities of the font, used to vertically position}}
\DoxyCodeLine{173 \textcolor{comment}{//         and space the characters. See docs for stbtt\_GetFontVMetrics.}}
\DoxyCodeLine{174 \textcolor{comment}{//}}
\DoxyCodeLine{175 \textcolor{comment}{//      Font Size in Pixels or Points}}
\DoxyCodeLine{176 \textcolor{comment}{//         The preferred interface for specifying font sizes in stb\_truetype}}
\DoxyCodeLine{177 \textcolor{comment}{//         is to specify how tall the font's vertical extent should be in pixels.}}
\DoxyCodeLine{178 \textcolor{comment}{//         If that sounds good enough, skip the next paragraph.}}
\DoxyCodeLine{179 \textcolor{comment}{//}}
\DoxyCodeLine{180 \textcolor{comment}{//         Most font APIs instead use "{}points"{}, which are a common typographic}}
\DoxyCodeLine{181 \textcolor{comment}{//         measurement for describing font size, defined as 72 points per inch.}}
\DoxyCodeLine{182 \textcolor{comment}{//         stb\_truetype provides a point API for compatibility. However, true}}
\DoxyCodeLine{183 \textcolor{comment}{//         "{}per inch"{} conventions don't make much sense on computer displays}}
\DoxyCodeLine{184 \textcolor{comment}{//         since different monitors have different number of pixels per}}
\DoxyCodeLine{185 \textcolor{comment}{//         inch. For example, Windows traditionally uses a convention that}}
\DoxyCodeLine{186 \textcolor{comment}{//         there are 96 pixels per inch, thus making 'inch' measurements have}}
\DoxyCodeLine{187 \textcolor{comment}{//         nothing to do with inches, and thus effectively defining a point to}}
\DoxyCodeLine{188 \textcolor{comment}{//         be 1.333 pixels. Additionally, the TrueType font data provides}}
\DoxyCodeLine{189 \textcolor{comment}{//         an explicit scale factor to scale a given font's glyphs to points,}}
\DoxyCodeLine{190 \textcolor{comment}{//         but the author has observed that this scale factor is often wrong}}
\DoxyCodeLine{191 \textcolor{comment}{//         for non-\/commercial fonts, thus making fonts scaled in points}}
\DoxyCodeLine{192 \textcolor{comment}{//         according to the TrueType spec incoherently sized in practice.}}
\DoxyCodeLine{193 \textcolor{comment}{//}}
\DoxyCodeLine{194 \textcolor{comment}{// DETAILED USAGE:}}
\DoxyCodeLine{195 \textcolor{comment}{//}}
\DoxyCodeLine{196 \textcolor{comment}{//  Scale:}}
\DoxyCodeLine{197 \textcolor{comment}{//    Select how high you want the font to be, in points or pixels.}}
\DoxyCodeLine{198 \textcolor{comment}{//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute}}
\DoxyCodeLine{199 \textcolor{comment}{//    a scale factor SF that will be used by all other functions.}}
\DoxyCodeLine{200 \textcolor{comment}{//}}
\DoxyCodeLine{201 \textcolor{comment}{//  Baseline:}}
\DoxyCodeLine{202 \textcolor{comment}{//    You need to select a y-\/coordinate that is the baseline of where}}
\DoxyCodeLine{203 \textcolor{comment}{//    your text will appear. Call GetFontBoundingBox to get the baseline-\/relative}}
\DoxyCodeLine{204 \textcolor{comment}{//    bounding box for all characters. SF*-\/y0 will be the distance in pixels}}
\DoxyCodeLine{205 \textcolor{comment}{//    that the worst-\/case character could extend above the baseline, so if}}
\DoxyCodeLine{206 \textcolor{comment}{//    you want the top edge of characters to appear at the top of the}}
\DoxyCodeLine{207 \textcolor{comment}{//    screen where y=0, then you would set the baseline to SF*-\/y0.}}
\DoxyCodeLine{208 \textcolor{comment}{//}}
\DoxyCodeLine{209 \textcolor{comment}{//  Current point:}}
\DoxyCodeLine{210 \textcolor{comment}{//    Set the current point where the first character will appear. The}}
\DoxyCodeLine{211 \textcolor{comment}{//    first character could extend left of the current point; this is font}}
\DoxyCodeLine{212 \textcolor{comment}{//    dependent. You can either choose a current point that is the leftmost}}
\DoxyCodeLine{213 \textcolor{comment}{//    point and hope, or add some padding, or check the bounding box or}}
\DoxyCodeLine{214 \textcolor{comment}{//    left-\/side-\/bearing of the first character to be displayed and set}}
\DoxyCodeLine{215 \textcolor{comment}{//    the current point based on that.}}
\DoxyCodeLine{216 \textcolor{comment}{//}}
\DoxyCodeLine{217 \textcolor{comment}{//  Displaying a character:}}
\DoxyCodeLine{218 \textcolor{comment}{//    Compute the bounding box of the character. It will contain signed values}}
\DoxyCodeLine{219 \textcolor{comment}{//    relative to <current\_point, baseline>. I.e. if it returns x0,y0,x1,y1,}}
\DoxyCodeLine{220 \textcolor{comment}{//    then the character should be displayed in the rectangle from}}
\DoxyCodeLine{221 \textcolor{comment}{//    <current\_point+SF*x0, baseline+SF*y0> to <current\_point+SF*x1,baseline+SF*y1).}}
\DoxyCodeLine{222 \textcolor{comment}{//}}
\DoxyCodeLine{223 \textcolor{comment}{//  Advancing for the next character:}}
\DoxyCodeLine{224 \textcolor{comment}{//    Call GlyphHMetrics, and compute 'current\_point += SF * advance'.}}
\DoxyCodeLine{225 \textcolor{comment}{//}}
\DoxyCodeLine{226 \textcolor{comment}{//}}
\DoxyCodeLine{227 \textcolor{comment}{// ADVANCED USAGE}}
\DoxyCodeLine{228 \textcolor{comment}{//}}
\DoxyCodeLine{229 \textcolor{comment}{//   Quality:}}
\DoxyCodeLine{230 \textcolor{comment}{//}}
\DoxyCodeLine{231 \textcolor{comment}{//    -\/ Use the functions with Subpixel at the end to allow your characters}}
\DoxyCodeLine{232 \textcolor{comment}{//      to have subpixel positioning. Since the font is anti-\/aliased, not}}
\DoxyCodeLine{233 \textcolor{comment}{//      hinted, this is very import for quality. (This is not possible with}}
\DoxyCodeLine{234 \textcolor{comment}{//      baked fonts.)}}
\DoxyCodeLine{235 \textcolor{comment}{//}}
\DoxyCodeLine{236 \textcolor{comment}{//    -\/ Kerning is now supported, and if you're supporting subpixel rendering}}
\DoxyCodeLine{237 \textcolor{comment}{//      then kerning is worth using to give your text a polished look.}}
\DoxyCodeLine{238 \textcolor{comment}{//}}
\DoxyCodeLine{239 \textcolor{comment}{//   Performance:}}
\DoxyCodeLine{240 \textcolor{comment}{//}}
\DoxyCodeLine{241 \textcolor{comment}{//    -\/ Convert Unicode codepoints to glyph indexes and operate on the glyphs;}}
\DoxyCodeLine{242 \textcolor{comment}{//      if you don't do this, stb\_truetype is forced to do the conversion on}}
\DoxyCodeLine{243 \textcolor{comment}{//      every call.}}
\DoxyCodeLine{244 \textcolor{comment}{//}}
\DoxyCodeLine{245 \textcolor{comment}{//    -\/ There are a lot of memory allocations. We should modify it to take}}
\DoxyCodeLine{246 \textcolor{comment}{//      a temp buffer and allocate from the temp buffer (without freeing),}}
\DoxyCodeLine{247 \textcolor{comment}{//      should help performance a lot.}}
\DoxyCodeLine{248 \textcolor{comment}{//}}
\DoxyCodeLine{249 \textcolor{comment}{// NOTES}}
\DoxyCodeLine{250 \textcolor{comment}{//}}
\DoxyCodeLine{251 \textcolor{comment}{//   The system uses the raw data found in the .ttf file without changing it}}
\DoxyCodeLine{252 \textcolor{comment}{//   and without building auxiliary data structures. This is a bit inefficient}}
\DoxyCodeLine{253 \textcolor{comment}{//   on little-\/endian systems (the data is big-\/endian), but assuming you're}}
\DoxyCodeLine{254 \textcolor{comment}{//   caching the bitmaps or glyph shapes this shouldn't be a big deal.}}
\DoxyCodeLine{255 \textcolor{comment}{//}}
\DoxyCodeLine{256 \textcolor{comment}{//   It appears to be very hard to programmatically determine what font a}}
\DoxyCodeLine{257 \textcolor{comment}{//   given file is in a general way. I provide an API for this, but I don't}}
\DoxyCodeLine{258 \textcolor{comment}{//   recommend it.}}
\DoxyCodeLine{259 \textcolor{comment}{//}}
\DoxyCodeLine{260 \textcolor{comment}{//}}
\DoxyCodeLine{261 \textcolor{comment}{// PERFORMANCE MEASUREMENTS FOR 1.06:}}
\DoxyCodeLine{262 \textcolor{comment}{//}}
\DoxyCodeLine{263 \textcolor{comment}{//                      32-\/bit     64-\/bit}}
\DoxyCodeLine{264 \textcolor{comment}{//   Previous release:  8.83 s     7.68 s}}
\DoxyCodeLine{265 \textcolor{comment}{//   Pool allocations:  7.72 s     6.34 s}}
\DoxyCodeLine{266 \textcolor{comment}{//   Inline sort     :  6.54 s     5.65 s}}
\DoxyCodeLine{267 \textcolor{comment}{//   New rasterizer  :  5.63 s     5.00 s}}
\DoxyCodeLine{268 }
\DoxyCodeLine{274 \textcolor{comment}{//}}
\DoxyCodeLine{275 \textcolor{comment}{//  Incomplete text-\/in-\/3d-\/api example, which draws quads properly aligned to be lossless.}}
\DoxyCodeLine{276 \textcolor{comment}{//  See "{}tests/truetype\_demo\_win32.c"{} for a complete version.}}
\DoxyCodeLine{277 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{278 \textcolor{preprocessor}{\#define STB\_TRUETYPE\_IMPLEMENTATION  }\textcolor{comment}{// force following include to generate implementation}}
\DoxyCodeLine{279 \textcolor{preprocessor}{\#include "{}stb\_truetype.h"{}}}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} ttf\_buffer[1<<20];}
\DoxyCodeLine{282 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} temp\_bitmap[512*512];}
\DoxyCodeLine{283 }
\DoxyCodeLine{284 \mbox{\hyperlink{structstbtt__bakedchar}{stbtt\_bakedchar}} cdata[96]; \textcolor{comment}{// ASCII 32..126 is 95 glyphs}}
\DoxyCodeLine{285 GLuint ftex;}
\DoxyCodeLine{286 }
\DoxyCodeLine{287 \textcolor{keywordtype}{void} my\_stbtt\_initfont(\textcolor{keywordtype}{void})}
\DoxyCodeLine{288 \{}
\DoxyCodeLine{289    fread(ttf\_buffer, 1, 1<<20, fopen(\textcolor{stringliteral}{"{}c:/windows/fonts/times.ttf"{}}, \textcolor{stringliteral}{"{}rb"{}}));}
\DoxyCodeLine{290    stbtt\_BakeFontBitmap(ttf\_buffer,0, 32.0, temp\_bitmap,512,512, 32,96, cdata); \textcolor{comment}{// no guarantee this fits!}}
\DoxyCodeLine{291    \textcolor{comment}{// can free ttf\_buffer at this point}}
\DoxyCodeLine{292    glGenTextures(1, \&ftex);}
\DoxyCodeLine{293    glBindTexture(GL\_TEXTURE\_2D, ftex);}
\DoxyCodeLine{294    glTexImage2D(GL\_TEXTURE\_2D, 0, GL\_ALPHA, 512,512, 0, GL\_ALPHA, GL\_UNSIGNED\_BYTE, temp\_bitmap);}
\DoxyCodeLine{295    \textcolor{comment}{// can free temp\_bitmap at this point}}
\DoxyCodeLine{296    glTexParameteri(GL\_TEXTURE\_2D, GL\_TEXTURE\_MIN\_FILTER, GL\_LINEAR);}
\DoxyCodeLine{297 \}}
\DoxyCodeLine{298 }
\DoxyCodeLine{299 \textcolor{keywordtype}{void} my\_stbtt\_print(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{char} *text)}
\DoxyCodeLine{300 \{}
\DoxyCodeLine{301    \textcolor{comment}{// assume orthographic projection with units = screen pixels, origin at top left}}
\DoxyCodeLine{302    glEnable(GL\_BLEND);}
\DoxyCodeLine{303    glBlendFunc(GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA);}
\DoxyCodeLine{304    glEnable(GL\_TEXTURE\_2D);}
\DoxyCodeLine{305    glBindTexture(GL\_TEXTURE\_2D, ftex);}
\DoxyCodeLine{306    glBegin(GL\_QUADS);}
\DoxyCodeLine{307    \textcolor{keywordflow}{while} (*text) \{}
\DoxyCodeLine{308       \textcolor{keywordflow}{if} (*text >= 32 \&\& *text < 128) \{}
\DoxyCodeLine{309          \mbox{\hyperlink{structstbtt__aligned__quad}{stbtt\_aligned\_quad}} q;}
\DoxyCodeLine{310          stbtt\_GetBakedQuad(cdata, 512,512, *text-\/32, \&x,\&y,\&q,1);\textcolor{comment}{//1=opengl \& d3d10+,0=d3d9}}
\DoxyCodeLine{311          glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);}
\DoxyCodeLine{312          glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);}
\DoxyCodeLine{313          glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);}
\DoxyCodeLine{314          glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);}
\DoxyCodeLine{315       \}}
\DoxyCodeLine{316       ++text;}
\DoxyCodeLine{317    \}}
\DoxyCodeLine{318    glEnd();}
\DoxyCodeLine{319 \}}
\DoxyCodeLine{320 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{321 \textcolor{comment}{//}}
\DoxyCodeLine{322 \textcolor{comment}{//}}
\DoxyCodeLine{324 \textcolor{comment}{}\textcolor{comment}{//}}
\DoxyCodeLine{325 \textcolor{comment}{// Complete program (this compiles): get a single bitmap, print as ASCII art}}
\DoxyCodeLine{326 \textcolor{comment}{//}}
\DoxyCodeLine{327 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{328 \textcolor{preprocessor}{\#include <stdio.h>}}
\DoxyCodeLine{329 \textcolor{preprocessor}{\#define STB\_TRUETYPE\_IMPLEMENTATION  }\textcolor{comment}{// force following include to generate implementation}}
\DoxyCodeLine{330 \textcolor{preprocessor}{\#include "{}stb\_truetype.h"{}}}
\DoxyCodeLine{331 }
\DoxyCodeLine{332 \textcolor{keywordtype}{char} ttf\_buffer[1<<25];}
\DoxyCodeLine{333 }
\DoxyCodeLine{334 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{335 \{}
\DoxyCodeLine{336    \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} font;}
\DoxyCodeLine{337    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap;}
\DoxyCodeLine{338    \textcolor{keywordtype}{int} w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : \textcolor{stringliteral}{'a'}), s = (argc > 2 ? atoi(argv[2]) : 20);}
\DoxyCodeLine{339 }
\DoxyCodeLine{340    fread(ttf\_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : \textcolor{stringliteral}{"{}c:/windows/fonts/arialbd.ttf"{}}, \textcolor{stringliteral}{"{}rb"{}}));}
\DoxyCodeLine{341 }
\DoxyCodeLine{342    stbtt\_InitFont(\&font, ttf\_buffer, stbtt\_GetFontOffsetForIndex(ttf\_buffer,0));}
\DoxyCodeLine{343    bitmap = stbtt\_GetCodepointBitmap(\&font, 0,stbtt\_ScaleForPixelHeight(\&font, s), c, \&w, \&h, 0,0);}
\DoxyCodeLine{344 }
\DoxyCodeLine{345    \textcolor{keywordflow}{for} (j=0; j < h; ++j) \{}
\DoxyCodeLine{346       \textcolor{keywordflow}{for} (i=0; i < w; ++i)}
\DoxyCodeLine{347          putchar(\textcolor{stringliteral}{"{} .:ioVM@"{}}[bitmap[j*w+i]>>5]);}
\DoxyCodeLine{348       putchar(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{349    \}}
\DoxyCodeLine{350    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{351 \}}
\DoxyCodeLine{352 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{353 \textcolor{comment}{//}}
\DoxyCodeLine{354 \textcolor{comment}{// Output:}}
\DoxyCodeLine{355 \textcolor{comment}{//}}
\DoxyCodeLine{356 \textcolor{comment}{//     .ii.}}
\DoxyCodeLine{357 \textcolor{comment}{//    @@@@@@.}}
\DoxyCodeLine{358 \textcolor{comment}{//   V@Mio@@o}}
\DoxyCodeLine{359 \textcolor{comment}{//   :i.  V@V}}
\DoxyCodeLine{360 \textcolor{comment}{//     :oM@@M}}
\DoxyCodeLine{361 \textcolor{comment}{//   :@@@MM@M}}
\DoxyCodeLine{362 \textcolor{comment}{//   @@o  o@M}}
\DoxyCodeLine{363 \textcolor{comment}{//  :@@.  M@M}}
\DoxyCodeLine{364 \textcolor{comment}{//   @@@o@@@@}}
\DoxyCodeLine{365 \textcolor{comment}{//   :M@@V:@@.}}
\DoxyCodeLine{366 \textcolor{comment}{//}}
\DoxyCodeLine{368 \textcolor{comment}{}\textcolor{comment}{//}}
\DoxyCodeLine{369 \textcolor{comment}{// Complete program: print "{}Hello World!"{} banner, with bugs}}
\DoxyCodeLine{370 \textcolor{comment}{//}}
\DoxyCodeLine{371 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{372 \textcolor{keywordtype}{char} buffer[24<<20];}
\DoxyCodeLine{373 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} screen[20][79];}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} arg, \textcolor{keywordtype}{char} **argv)}
\DoxyCodeLine{376 \{}
\DoxyCodeLine{377    \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} font;}
\DoxyCodeLine{378    \textcolor{keywordtype}{int} i,j,ascent,baseline,ch=0;}
\DoxyCodeLine{379    \textcolor{keywordtype}{float} scale, xpos=2; \textcolor{comment}{// leave a little padding in case the character extends left}}
\DoxyCodeLine{380    \textcolor{keywordtype}{char} *text = \textcolor{stringliteral}{"{}Heljo World!"{}}; \textcolor{comment}{// intentionally misspelled to show 'lj' brokenness}}
\DoxyCodeLine{381 }
\DoxyCodeLine{382    fread(buffer, 1, 1000000, fopen(\textcolor{stringliteral}{"{}c:/windows/fonts/arialbd.ttf"{}}, \textcolor{stringliteral}{"{}rb"{}}));}
\DoxyCodeLine{383    stbtt\_InitFont(\&font, buffer, 0);}
\DoxyCodeLine{384 }
\DoxyCodeLine{385    scale = stbtt\_ScaleForPixelHeight(\&font, 15);}
\DoxyCodeLine{386    stbtt\_GetFontVMetrics(\&font, \&ascent,0,0);}
\DoxyCodeLine{387    baseline = (int) (ascent*scale);}
\DoxyCodeLine{388 }
\DoxyCodeLine{389    \textcolor{keywordflow}{while} (text[ch]) \{}
\DoxyCodeLine{390       \textcolor{keywordtype}{int} advance,lsb,x0,y0,x1,y1;}
\DoxyCodeLine{391       \textcolor{keywordtype}{float} x\_shift = xpos -\/ (float) floor(xpos);}
\DoxyCodeLine{392       stbtt\_GetCodepointHMetrics(\&font, text[ch], \&advance, \&lsb);}
\DoxyCodeLine{393       stbtt\_GetCodepointBitmapBoxSubpixel(\&font, text[ch], scale,scale,x\_shift,0, \&x0,\&y0,\&x1,\&y1);}
\DoxyCodeLine{394       stbtt\_MakeCodepointBitmapSubpixel(\&font, \&screen[baseline + y0][(\textcolor{keywordtype}{int}) xpos + x0], x1-\/x0,y1-\/y0, 79, scale,scale,x\_shift,0, text[ch]);}
\DoxyCodeLine{395       \textcolor{comment}{// note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong}}
\DoxyCodeLine{396       \textcolor{comment}{// because this API is really for baking character bitmaps into textures. if you want to render}}
\DoxyCodeLine{397       \textcolor{comment}{// a sequence of characters, you really need to render each bitmap to a temp buffer, then}}
\DoxyCodeLine{398       \textcolor{comment}{// "{}alpha blend"{} that into the working buffer}}
\DoxyCodeLine{399       xpos += (advance * scale);}
\DoxyCodeLine{400       \textcolor{keywordflow}{if} (text[ch+1])}
\DoxyCodeLine{401          xpos += scale*stbtt\_GetCodepointKernAdvance(\&font, text[ch],text[ch+1]);}
\DoxyCodeLine{402       ++ch;}
\DoxyCodeLine{403    \}}
\DoxyCodeLine{404 }
\DoxyCodeLine{405    \textcolor{keywordflow}{for} (j=0; j < 20; ++j) \{}
\DoxyCodeLine{406       \textcolor{keywordflow}{for} (i=0; i < 78; ++i)}
\DoxyCodeLine{407          putchar(\textcolor{stringliteral}{"{} .:ioVM@"{}}[screen[j][i]>>5]);}
\DoxyCodeLine{408       putchar(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{409    \}}
\DoxyCodeLine{410 }
\DoxyCodeLine{411    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{412 \}}
\DoxyCodeLine{413 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{414 }
\DoxyCodeLine{415 }
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{preprocessor}{\#ifdef STB\_TRUETYPE\_IMPLEMENTATION}}
\DoxyCodeLine{426    \textcolor{comment}{// \#define your own (u)stbtt\_int8/16/32 before including to override this}}
\DoxyCodeLine{427 \textcolor{preprocessor}{   \#ifndef stbtt\_uint8}}
\DoxyCodeLine{428    \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}   stbtt\_uint8;}
\DoxyCodeLine{429    \textcolor{keyword}{typedef} \textcolor{keywordtype}{signed}   \textcolor{keywordtype}{char}   stbtt\_int8;}
\DoxyCodeLine{430    \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}  stbtt\_uint16;}
\DoxyCodeLine{431    \textcolor{keyword}{typedef} \textcolor{keywordtype}{signed}   \textcolor{keywordtype}{short}  stbtt\_int16;}
\DoxyCodeLine{432    \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}    stbtt\_uint32;}
\DoxyCodeLine{433    \textcolor{keyword}{typedef} \textcolor{keywordtype}{signed}   \textcolor{keywordtype}{int}    stbtt\_int32;}
\DoxyCodeLine{434 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{435 }
\DoxyCodeLine{436    \textcolor{keyword}{typedef} \textcolor{keywordtype}{char} stbtt\_\_check\_size32[\textcolor{keyword}{sizeof}(stbtt\_int32)==4 ? 1 : -\/1];}
\DoxyCodeLine{437    \textcolor{keyword}{typedef} \textcolor{keywordtype}{char} stbtt\_\_check\_size16[\textcolor{keyword}{sizeof}(stbtt\_int16)==2 ? 1 : -\/1];}
\DoxyCodeLine{438 }
\DoxyCodeLine{439    \textcolor{comment}{// e.g. \#define your own STBTT\_ifloor/STBTT\_iceil() to avoid math.h}}
\DoxyCodeLine{440 \textcolor{preprocessor}{   \#ifndef STBTT\_ifloor}}
\DoxyCodeLine{441 \textcolor{preprocessor}{   \#include <math.h>}}
\DoxyCodeLine{442 \textcolor{preprocessor}{   \#define STBTT\_ifloor(x)   ((int) floor(x))}}
\DoxyCodeLine{443 \textcolor{preprocessor}{   \#define STBTT\_iceil(x)    ((int) ceil(x))}}
\DoxyCodeLine{444 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{445 }
\DoxyCodeLine{446 \textcolor{preprocessor}{   \#ifndef STBTT\_sqrt}}
\DoxyCodeLine{447 \textcolor{preprocessor}{   \#include <math.h>}}
\DoxyCodeLine{448 \textcolor{preprocessor}{   \#define STBTT\_sqrt(x)      sqrt(x)}}
\DoxyCodeLine{449 \textcolor{preprocessor}{   \#define STBTT\_pow(x,y)     pow(x,y)}}
\DoxyCodeLine{450 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{451 }
\DoxyCodeLine{452 \textcolor{preprocessor}{   \#ifndef STBTT\_fmod}}
\DoxyCodeLine{453 \textcolor{preprocessor}{   \#include <math.h>}}
\DoxyCodeLine{454 \textcolor{preprocessor}{   \#define STBTT\_fmod(x,y)    fmod(x,y)}}
\DoxyCodeLine{455 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{456 }
\DoxyCodeLine{457 \textcolor{preprocessor}{   \#ifndef STBTT\_cos}}
\DoxyCodeLine{458 \textcolor{preprocessor}{   \#include <math.h>}}
\DoxyCodeLine{459 \textcolor{preprocessor}{   \#define STBTT\_cos(x)       cos(x)}}
\DoxyCodeLine{460 \textcolor{preprocessor}{   \#define STBTT\_acos(x)      acos(x)}}
\DoxyCodeLine{461 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{462 }
\DoxyCodeLine{463 \textcolor{preprocessor}{   \#ifndef STBTT\_fabs}}
\DoxyCodeLine{464 \textcolor{preprocessor}{   \#include <math.h>}}
\DoxyCodeLine{465 \textcolor{preprocessor}{   \#define STBTT\_fabs(x)      fabs(x)}}
\DoxyCodeLine{466 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{467 }
\DoxyCodeLine{468    \textcolor{comment}{// \#define your own functions "{}STBTT\_malloc"{} / "{}STBTT\_free"{} to avoid malloc.h}}
\DoxyCodeLine{469 \textcolor{preprocessor}{   \#ifndef STBTT\_malloc}}
\DoxyCodeLine{470 \textcolor{preprocessor}{   \#include <stdlib.h>}}
\DoxyCodeLine{471 \textcolor{preprocessor}{   \#define STBTT\_malloc(x,u)  ((void)(u),malloc(x))}}
\DoxyCodeLine{472 \textcolor{preprocessor}{   \#define STBTT\_free(x,u)    ((void)(u),free(x))}}
\DoxyCodeLine{473 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{474 }
\DoxyCodeLine{475 \textcolor{preprocessor}{   \#ifndef STBTT\_assert}}
\DoxyCodeLine{476 \textcolor{preprocessor}{   \#include <assert.h>}}
\DoxyCodeLine{477 \textcolor{preprocessor}{   \#define STBTT\_assert(x)    assert(x)}}
\DoxyCodeLine{478 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{479 }
\DoxyCodeLine{480 \textcolor{preprocessor}{   \#ifndef STBTT\_strlen}}
\DoxyCodeLine{481 \textcolor{preprocessor}{   \#include <string.h>}}
\DoxyCodeLine{482 \textcolor{preprocessor}{   \#define STBTT\_strlen(x)    strlen(x)}}
\DoxyCodeLine{483 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{484 }
\DoxyCodeLine{485 \textcolor{preprocessor}{   \#ifndef STBTT\_memcpy}}
\DoxyCodeLine{486 \textcolor{preprocessor}{   \#include <string.h>}}
\DoxyCodeLine{487 \textcolor{preprocessor}{   \#define STBTT\_memcpy       memcpy}}
\DoxyCodeLine{488 \textcolor{preprocessor}{   \#define STBTT\_memset       memset}}
\DoxyCodeLine{489 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{490 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{491 }
\DoxyCodeLine{498 }
\DoxyCodeLine{499 \textcolor{preprocessor}{\#ifndef \_\_STB\_INCLUDE\_STB\_TRUETYPE\_H\_\_}}
\DoxyCodeLine{500 \textcolor{preprocessor}{\#define \_\_STB\_INCLUDE\_STB\_TRUETYPE\_H\_\_}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502 \textcolor{preprocessor}{\#ifdef STBTT\_STATIC}}
\DoxyCodeLine{503 \textcolor{preprocessor}{\#define STBTT\_DEF static}}
\DoxyCodeLine{504 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{505 \textcolor{preprocessor}{\#define STBTT\_DEF extern}}
\DoxyCodeLine{506 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{507 }
\DoxyCodeLine{508 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{509 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{510 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{511 }
\DoxyCodeLine{512 \textcolor{comment}{// private structure}}
\DoxyCodeLine{513 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{514 \{}
\DoxyCodeLine{515    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data;}
\DoxyCodeLine{516    \textcolor{keywordtype}{int} cursor;}
\DoxyCodeLine{517    \textcolor{keywordtype}{int} size;}
\DoxyCodeLine{518 \} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}};}
\DoxyCodeLine{519 }
\DoxyCodeLine{521 \textcolor{comment}{//}}
\DoxyCodeLine{522 \textcolor{comment}{// TEXTURE BAKING API}}
\DoxyCodeLine{523 \textcolor{comment}{//}}
\DoxyCodeLine{524 \textcolor{comment}{// If you use this API, you only have to call two functions ever.}}
\DoxyCodeLine{525 \textcolor{comment}{//}}
\DoxyCodeLine{526 }
\DoxyCodeLine{527 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{528 \{}
\DoxyCodeLine{529    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} x0,y0,x1,y1; \textcolor{comment}{// coordinates of bbox in bitmap}}
\DoxyCodeLine{530    \textcolor{keywordtype}{float} xoff,yoff,xadvance;}
\DoxyCodeLine{531 \} \mbox{\hyperlink{structstbtt__bakedchar}{stbtt\_bakedchar}};}
\DoxyCodeLine{532 }
\DoxyCodeLine{533 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_BakeFontBitmap(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} offset,  \textcolor{comment}{// font location (use offset=0 for plain .ttf)}}
\DoxyCodeLine{534                                 \textcolor{keywordtype}{float} pixel\_height,                     \textcolor{comment}{// height of font in pixels}}
\DoxyCodeLine{535                                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph,  \textcolor{comment}{// bitmap to be filled in}}
\DoxyCodeLine{536                                 \textcolor{keywordtype}{int} first\_char, \textcolor{keywordtype}{int} num\_chars,          \textcolor{comment}{// characters to bake}}
\DoxyCodeLine{537                                 \mbox{\hyperlink{structstbtt__bakedchar}{stbtt\_bakedchar}} *chardata);             \textcolor{comment}{// you allocate this, it's num\_chars long}}
\DoxyCodeLine{538 \textcolor{comment}{// if return is positive, the first unused row of the bitmap}}
\DoxyCodeLine{539 \textcolor{comment}{// if return is negative, returns the negative of the number of characters that fit}}
\DoxyCodeLine{540 \textcolor{comment}{// if return is 0, no characters fit and no rows were used}}
\DoxyCodeLine{541 \textcolor{comment}{// This uses a very crappy packing.}}
\DoxyCodeLine{542 }
\DoxyCodeLine{543 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{544 \{}
\DoxyCodeLine{545    \textcolor{keywordtype}{float} x0,y0,s0,t0; \textcolor{comment}{// top-\/left}}
\DoxyCodeLine{546    \textcolor{keywordtype}{float} x1,y1,s1,t1; \textcolor{comment}{// bottom-\/right}}
\DoxyCodeLine{547 \} \mbox{\hyperlink{structstbtt__aligned__quad}{stbtt\_aligned\_quad}};}
\DoxyCodeLine{548 }
\DoxyCodeLine{549 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetBakedQuad(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__bakedchar}{stbtt\_bakedchar}} *chardata, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph,  \textcolor{comment}{// same data as above}}
\DoxyCodeLine{550                                \textcolor{keywordtype}{int} char\_index,             \textcolor{comment}{// character to display}}
\DoxyCodeLine{551                                \textcolor{keywordtype}{float} *xpos, \textcolor{keywordtype}{float} *ypos,   \textcolor{comment}{// pointers to current position in screen pixel space}}
\DoxyCodeLine{552                                \mbox{\hyperlink{structstbtt__aligned__quad}{stbtt\_aligned\_quad}} *q,      \textcolor{comment}{// output: quad to draw}}
\DoxyCodeLine{553                                \textcolor{keywordtype}{int} opengl\_fillrule);       \textcolor{comment}{// true if opengl fill rule; false if DX9 or earlier}}
\DoxyCodeLine{554 \textcolor{comment}{// Call GetBakedQuad with char\_index = 'character -\/ first\_char', and it}}
\DoxyCodeLine{555 \textcolor{comment}{// creates the quad you need to draw and advances the current position.}}
\DoxyCodeLine{556 \textcolor{comment}{//}}
\DoxyCodeLine{557 \textcolor{comment}{// The coordinate system used assumes y increases downwards.}}
\DoxyCodeLine{558 \textcolor{comment}{//}}
\DoxyCodeLine{559 \textcolor{comment}{// Characters will extend both above and below the current position;}}
\DoxyCodeLine{560 \textcolor{comment}{// see discussion of "{}BASELINE"{} above.}}
\DoxyCodeLine{561 \textcolor{comment}{//}}
\DoxyCodeLine{562 \textcolor{comment}{// It's inefficient; you might want to c\&p it and optimize it.}}
\DoxyCodeLine{563 }
\DoxyCodeLine{564 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetScaledFontVMetrics(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fontdata, \textcolor{keywordtype}{int} index, \textcolor{keywordtype}{float} size, \textcolor{keywordtype}{float} *ascent, \textcolor{keywordtype}{float} *descent, \textcolor{keywordtype}{float} *lineGap);}
\DoxyCodeLine{565 \textcolor{comment}{// Query the font vertical metrics without having to create a font first.}}
\DoxyCodeLine{566 }
\DoxyCodeLine{567 }
\DoxyCodeLine{569 \textcolor{comment}{//}}
\DoxyCodeLine{570 \textcolor{comment}{// NEW TEXTURE BAKING API}}
\DoxyCodeLine{571 \textcolor{comment}{//}}
\DoxyCodeLine{572 \textcolor{comment}{// This provides options for packing multiple fonts into one atlas, not}}
\DoxyCodeLine{573 \textcolor{comment}{// perfectly but better than nothing.}}
\DoxyCodeLine{574 }
\DoxyCodeLine{575 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{576 \{}
\DoxyCodeLine{577    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} x0,y0,x1,y1; \textcolor{comment}{// coordinates of bbox in bitmap}}
\DoxyCodeLine{578    \textcolor{keywordtype}{float} xoff,yoff,xadvance;}
\DoxyCodeLine{579    \textcolor{keywordtype}{float} xoff2,yoff2;}
\DoxyCodeLine{580 \} \mbox{\hyperlink{structstbtt__packedchar}{stbtt\_packedchar}};}
\DoxyCodeLine{581 }
\DoxyCodeLine{582 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} \mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}};}
\DoxyCodeLine{583 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}};}
\DoxyCodeLine{584 \textcolor{preprocessor}{\#ifndef STB\_RECT\_PACK\_VERSION}}
\DoxyCodeLine{585 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}};}
\DoxyCodeLine{586 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{587 }
\DoxyCodeLine{588 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_PackBegin(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels, \textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height, \textcolor{keywordtype}{int} stride\_in\_bytes, \textcolor{keywordtype}{int} padding, \textcolor{keywordtype}{void} *alloc\_context);}
\DoxyCodeLine{589 \textcolor{comment}{// Initializes a packing context stored in the passed-\/in stbtt\_pack\_context.}}
\DoxyCodeLine{590 \textcolor{comment}{// Future calls using this context will pack characters into the bitmap passed}}
\DoxyCodeLine{591 \textcolor{comment}{// in here: a 1-\/channel bitmap that is width * height. stride\_in\_bytes is}}
\DoxyCodeLine{592 \textcolor{comment}{// the distance from one row to the next (or 0 to mean they are packed tightly}}
\DoxyCodeLine{593 \textcolor{comment}{// together). "{}padding"{} is the amount of padding to leave between each}}
\DoxyCodeLine{594 \textcolor{comment}{// character (normally you want '1' for bitmaps you'll use as textures with}}
\DoxyCodeLine{595 \textcolor{comment}{// bilinear filtering).}}
\DoxyCodeLine{596 \textcolor{comment}{//}}
\DoxyCodeLine{597 \textcolor{comment}{// Returns 0 on failure, 1 on success.}}
\DoxyCodeLine{598 }
\DoxyCodeLine{599 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_PackEnd  (\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc);}
\DoxyCodeLine{600 \textcolor{comment}{// Cleans up the packing context and frees all memory.}}
\DoxyCodeLine{601 }
\DoxyCodeLine{602 \textcolor{preprocessor}{\#define STBTT\_POINT\_SIZE(x)   (-\/(x))}}
\DoxyCodeLine{603 }
\DoxyCodeLine{604 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_PackFontRange(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fontdata, \textcolor{keywordtype}{int} font\_index, \textcolor{keywordtype}{float} font\_size,}
\DoxyCodeLine{605                                 \textcolor{keywordtype}{int} first\_unicode\_char\_in\_range, \textcolor{keywordtype}{int} num\_chars\_in\_range, \mbox{\hyperlink{structstbtt__packedchar}{stbtt\_packedchar}} *chardata\_for\_range);}
\DoxyCodeLine{606 \textcolor{comment}{// Creates character bitmaps from the font\_index'th font found in fontdata (use}}
\DoxyCodeLine{607 \textcolor{comment}{// font\_index=0 if you don't know what that is). It creates num\_chars\_in\_range}}
\DoxyCodeLine{608 \textcolor{comment}{// bitmaps for characters with unicode values starting at first\_unicode\_char\_in\_range}}
\DoxyCodeLine{609 \textcolor{comment}{// and increasing. Data for how to render them is stored in chardata\_for\_range;}}
\DoxyCodeLine{610 \textcolor{comment}{// pass these to stbtt\_GetPackedQuad to get back renderable quads.}}
\DoxyCodeLine{611 \textcolor{comment}{//}}
\DoxyCodeLine{612 \textcolor{comment}{// font\_size is the full height of the character from ascender to descender,}}
\DoxyCodeLine{613 \textcolor{comment}{// as computed by stbtt\_ScaleForPixelHeight. To use a point size as computed}}
\DoxyCodeLine{614 \textcolor{comment}{// by stbtt\_ScaleForMappingEmToPixels, wrap the point size in STBTT\_POINT\_SIZE()}}
\DoxyCodeLine{615 \textcolor{comment}{// and pass that result as 'font\_size':}}
\DoxyCodeLine{616 \textcolor{comment}{//       ...,                  20 , ... // font max minus min y is 20 pixels tall}}
\DoxyCodeLine{617 \textcolor{comment}{//       ..., STBTT\_POINT\_SIZE(20), ... // 'M' is 20 pixels tall}}
\DoxyCodeLine{618 }
\DoxyCodeLine{619 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{620 \{}
\DoxyCodeLine{621    \textcolor{keywordtype}{float} font\_size;}
\DoxyCodeLine{622    \textcolor{keywordtype}{int} first\_unicode\_codepoint\_in\_range;  \textcolor{comment}{// if non-\/zero, then the chars are continuous, and this is the first codepoint}}
\DoxyCodeLine{623    \textcolor{keywordtype}{int} *array\_of\_unicode\_codepoints;       \textcolor{comment}{// if non-\/zero, then this is an array of unicode codepoints}}
\DoxyCodeLine{624    \textcolor{keywordtype}{int} num\_chars;}
\DoxyCodeLine{625    \mbox{\hyperlink{structstbtt__packedchar}{stbtt\_packedchar}} *chardata\_for\_range; \textcolor{comment}{// output}}
\DoxyCodeLine{626    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} h\_oversample, v\_oversample; \textcolor{comment}{// don't set these, they're used internally}}
\DoxyCodeLine{627 \} \mbox{\hyperlink{structstbtt__pack__range}{stbtt\_pack\_range}};}
\DoxyCodeLine{628 }
\DoxyCodeLine{629 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_PackFontRanges(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fontdata, \textcolor{keywordtype}{int} font\_index, \mbox{\hyperlink{structstbtt__pack__range}{stbtt\_pack\_range}} *ranges, \textcolor{keywordtype}{int} num\_ranges);}
\DoxyCodeLine{630 \textcolor{comment}{// Creates character bitmaps from multiple ranges of characters stored in}}
\DoxyCodeLine{631 \textcolor{comment}{// ranges. This will usually create a better-\/packed bitmap than multiple}}
\DoxyCodeLine{632 \textcolor{comment}{// calls to stbtt\_PackFontRange. Note that you can call this multiple}}
\DoxyCodeLine{633 \textcolor{comment}{// times within a single PackBegin/PackEnd.}}
\DoxyCodeLine{634 }
\DoxyCodeLine{635 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_PackSetOversampling(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h\_oversample, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} v\_oversample);}
\DoxyCodeLine{636 \textcolor{comment}{// Oversampling a font increases the quality by allowing higher-\/quality subpixel}}
\DoxyCodeLine{637 \textcolor{comment}{// positioning, and is especially valuable at smaller text sizes.}}
\DoxyCodeLine{638 \textcolor{comment}{//}}
\DoxyCodeLine{639 \textcolor{comment}{// This function sets the amount of oversampling for all following calls to}}
\DoxyCodeLine{640 \textcolor{comment}{// stbtt\_PackFontRange(s) or stbtt\_PackFontRangesGatherRects for a given}}
\DoxyCodeLine{641 \textcolor{comment}{// pack context. The default (no oversampling) is achieved by h\_oversample=1}}
\DoxyCodeLine{642 \textcolor{comment}{// and v\_oversample=1. The total number of pixels required is}}
\DoxyCodeLine{643 \textcolor{comment}{// h\_oversample*v\_oversample larger than the default; for example, 2x2}}
\DoxyCodeLine{644 \textcolor{comment}{// oversampling requires 4x the storage of 1x1. For best results, render}}
\DoxyCodeLine{645 \textcolor{comment}{// oversampled textures with bilinear filtering. Look at the readme in}}
\DoxyCodeLine{646 \textcolor{comment}{// stb/tests/oversample for information about oversampled fonts}}
\DoxyCodeLine{647 \textcolor{comment}{//}}
\DoxyCodeLine{648 \textcolor{comment}{// To use with PackFontRangesGather etc., you must set it before calls}}
\DoxyCodeLine{649 \textcolor{comment}{// call to PackFontRangesGatherRects.}}
\DoxyCodeLine{650 }
\DoxyCodeLine{651 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_PackSetSkipMissingCodepoints(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keywordtype}{int} skip);}
\DoxyCodeLine{652 \textcolor{comment}{// If skip != 0, this tells stb\_truetype to skip any codepoints for which}}
\DoxyCodeLine{653 \textcolor{comment}{// there is no corresponding glyph. If skip=0, which is the default, then}}
\DoxyCodeLine{654 \textcolor{comment}{// codepoints without a glyph recived the font's "{}missing character"{} glyph,}}
\DoxyCodeLine{655 \textcolor{comment}{// typically an empty box by convention.}}
\DoxyCodeLine{656 }
\DoxyCodeLine{657 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetPackedQuad(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__packedchar}{stbtt\_packedchar}} *chardata, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph,  \textcolor{comment}{// same data as above}}
\DoxyCodeLine{658                                \textcolor{keywordtype}{int} char\_index,             \textcolor{comment}{// character to display}}
\DoxyCodeLine{659                                \textcolor{keywordtype}{float} *xpos, \textcolor{keywordtype}{float} *ypos,   \textcolor{comment}{// pointers to current position in screen pixel space}}
\DoxyCodeLine{660                                \mbox{\hyperlink{structstbtt__aligned__quad}{stbtt\_aligned\_quad}} *q,      \textcolor{comment}{// output: quad to draw}}
\DoxyCodeLine{661                                \textcolor{keywordtype}{int} align\_to\_integer);}
\DoxyCodeLine{662 }
\DoxyCodeLine{663 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_PackFontRangesGatherRects(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \mbox{\hyperlink{structstbtt__pack__range}{stbtt\_pack\_range}} *ranges, \textcolor{keywordtype}{int} num\_ranges, \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *rects);}
\DoxyCodeLine{664 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_PackFontRangesPackRects(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *rects, \textcolor{keywordtype}{int} num\_rects);}
\DoxyCodeLine{665 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_PackFontRangesRenderIntoRects(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \mbox{\hyperlink{structstbtt__pack__range}{stbtt\_pack\_range}} *ranges, \textcolor{keywordtype}{int} num\_ranges, \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *rects);}
\DoxyCodeLine{666 \textcolor{comment}{// Calling these functions in sequence is roughly equivalent to calling}}
\DoxyCodeLine{667 \textcolor{comment}{// stbtt\_PackFontRanges(). If you more control over the packing of multiple}}
\DoxyCodeLine{668 \textcolor{comment}{// fonts, or if you want to pack custom data into a font texture, take a look}}
\DoxyCodeLine{669 \textcolor{comment}{// at the source to of stbtt\_PackFontRanges() and create a custom version}}
\DoxyCodeLine{670 \textcolor{comment}{// using these functions, e.g. call GatherRects multiple times,}}
\DoxyCodeLine{671 \textcolor{comment}{// building up a single array of rects, then call PackRects once,}}
\DoxyCodeLine{672 \textcolor{comment}{// then call RenderIntoRects repeatedly. This may result in a}}
\DoxyCodeLine{673 \textcolor{comment}{// better packing than calling PackFontRanges multiple times}}
\DoxyCodeLine{674 \textcolor{comment}{// (or it may not).}}
\DoxyCodeLine{675 }
\DoxyCodeLine{676 \textcolor{comment}{// this is an opaque structure that you shouldn't mess with which holds}}
\DoxyCodeLine{677 \textcolor{comment}{// all the context needed from PackBegin to PackEnd.}}
\DoxyCodeLine{678 \textcolor{keyword}{struct }\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} \{}
\DoxyCodeLine{679    \textcolor{keywordtype}{void} *user\_allocator\_context;}
\DoxyCodeLine{680    \textcolor{keywordtype}{void} *pack\_info;}
\DoxyCodeLine{681    \textcolor{keywordtype}{int}   width;}
\DoxyCodeLine{682    \textcolor{keywordtype}{int}   height;}
\DoxyCodeLine{683    \textcolor{keywordtype}{int}   stride\_in\_bytes;}
\DoxyCodeLine{684    \textcolor{keywordtype}{int}   padding;}
\DoxyCodeLine{685    \textcolor{keywordtype}{int}   skip\_missing;}
\DoxyCodeLine{686    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}   h\_oversample, v\_oversample;}
\DoxyCodeLine{687    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels;}
\DoxyCodeLine{688    \textcolor{keywordtype}{void}  *nodes;}
\DoxyCodeLine{689 \};}
\DoxyCodeLine{690 }
\DoxyCodeLine{692 \textcolor{comment}{//}}
\DoxyCodeLine{693 \textcolor{comment}{// FONT LOADING}}
\DoxyCodeLine{694 \textcolor{comment}{//}}
\DoxyCodeLine{695 \textcolor{comment}{//}}
\DoxyCodeLine{696 }
\DoxyCodeLine{697 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetNumberOfFonts(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data);}
\DoxyCodeLine{698 \textcolor{comment}{// This function will determine the number of fonts in a font file.  TrueType}}
\DoxyCodeLine{699 \textcolor{comment}{// collection (.ttc) files may contain multiple fonts, while TrueType font}}
\DoxyCodeLine{700 \textcolor{comment}{// (.ttf) files only contain one font. The number of fonts can be used for}}
\DoxyCodeLine{701 \textcolor{comment}{// indexing with the previous function where the index is between zero and one}}
\DoxyCodeLine{702 \textcolor{comment}{// less than the total fonts. If an error occurs, -\/1 is returned.}}
\DoxyCodeLine{703 }
\DoxyCodeLine{704 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetFontOffsetForIndex(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} index);}
\DoxyCodeLine{705 \textcolor{comment}{// Each .ttf/.ttc file may have more than one font. Each font has a sequential}}
\DoxyCodeLine{706 \textcolor{comment}{// index number starting from 0. Call this function to get the font offset for}}
\DoxyCodeLine{707 \textcolor{comment}{// a given index; it returns -\/1 if the index is out of range. A regular .ttf}}
\DoxyCodeLine{708 \textcolor{comment}{// file will only define one font and it always be at offset 0, so it will}}
\DoxyCodeLine{709 \textcolor{comment}{// return '0' for index 0, and -\/1 for all other indices.}}
\DoxyCodeLine{710 }
\DoxyCodeLine{711 \textcolor{comment}{// The following structure is defined publicly so you can declare one on}}
\DoxyCodeLine{712 \textcolor{comment}{// the stack or as a global or etc, but you should treat it as opaque.}}
\DoxyCodeLine{713 \textcolor{keyword}{struct }\mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}}}
\DoxyCodeLine{714 \{}
\DoxyCodeLine{715    \textcolor{keywordtype}{void}           * userdata;}
\DoxyCodeLine{716    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}  * data;              \textcolor{comment}{// pointer to .ttf file}}
\DoxyCodeLine{717    \textcolor{keywordtype}{int}              fontstart;         \textcolor{comment}{// offset of start of font}}
\DoxyCodeLine{718 }
\DoxyCodeLine{719    \textcolor{keywordtype}{int} numGlyphs;                     \textcolor{comment}{// number of glyphs, needed for range checking}}
\DoxyCodeLine{720 }
\DoxyCodeLine{721    \textcolor{keywordtype}{int} loca,head,glyf,hhea,hmtx,kern,gpos,svg; \textcolor{comment}{// table locations as offset from start of .ttf}}
\DoxyCodeLine{722    \textcolor{keywordtype}{int} index\_map;                     \textcolor{comment}{// a cmap mapping for our chosen character encoding}}
\DoxyCodeLine{723    \textcolor{keywordtype}{int} indexToLocFormat;              \textcolor{comment}{// format needed to map from glyph index to glyph}}
\DoxyCodeLine{724 }
\DoxyCodeLine{725    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} cff;                    \textcolor{comment}{// cff font data}}
\DoxyCodeLine{726    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} charstrings;            \textcolor{comment}{// the charstring index}}
\DoxyCodeLine{727    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} gsubrs;                 \textcolor{comment}{// global charstring subroutines index}}
\DoxyCodeLine{728    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} subrs;                  \textcolor{comment}{// private charstring subroutines index}}
\DoxyCodeLine{729    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} fontdicts;              \textcolor{comment}{// array of font dicts}}
\DoxyCodeLine{730    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} fdselect;               \textcolor{comment}{// map from glyph to fontdict}}
\DoxyCodeLine{731 \};}
\DoxyCodeLine{732 }
\DoxyCodeLine{733 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_InitFont(\mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} offset);}
\DoxyCodeLine{734 \textcolor{comment}{// Given an offset into the file that defines a font, this function builds}}
\DoxyCodeLine{735 \textcolor{comment}{// the necessary cached info for the rest of the system. You must allocate}}
\DoxyCodeLine{736 \textcolor{comment}{// the stbtt\_fontinfo yourself, and stbtt\_InitFont will fill it out. You don't}}
\DoxyCodeLine{737 \textcolor{comment}{// need to do anything special to free it, because the contents are pure}}
\DoxyCodeLine{738 \textcolor{comment}{// value data with no additional data structures. Returns 0 on failure.}}
\DoxyCodeLine{739 }
\DoxyCodeLine{740 }
\DoxyCodeLine{742 \textcolor{comment}{//}}
\DoxyCodeLine{743 \textcolor{comment}{// CHARACTER TO GLYPH-\/INDEX CONVERSIOn}}
\DoxyCodeLine{744 }
\DoxyCodeLine{745 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_FindGlyphIndex(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} unicode\_codepoint);}
\DoxyCodeLine{746 \textcolor{comment}{// If you're going to perform multiple operations on the same character}}
\DoxyCodeLine{747 \textcolor{comment}{// and you want a speed-\/up, call this function with the character you're}}
\DoxyCodeLine{748 \textcolor{comment}{// going to process, then use glyph-\/based functions instead of the}}
\DoxyCodeLine{749 \textcolor{comment}{// codepoint-\/based functions.}}
\DoxyCodeLine{750 \textcolor{comment}{// Returns 0 if the character codepoint is not defined in the font.}}
\DoxyCodeLine{751 }
\DoxyCodeLine{752 }
\DoxyCodeLine{754 \textcolor{comment}{//}}
\DoxyCodeLine{755 \textcolor{comment}{// CHARACTER PROPERTIES}}
\DoxyCodeLine{756 \textcolor{comment}{//}}
\DoxyCodeLine{757 }
\DoxyCodeLine{758 STBTT\_DEF \textcolor{keywordtype}{float} stbtt\_ScaleForPixelHeight(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} pixels);}
\DoxyCodeLine{759 \textcolor{comment}{// computes a scale factor to produce a font whose "{}height"{} is 'pixels' tall.}}
\DoxyCodeLine{760 \textcolor{comment}{// Height is measured as the distance from the highest ascender to the lowest}}
\DoxyCodeLine{761 \textcolor{comment}{// descender; in other words, it's equivalent to calling stbtt\_GetFontVMetrics}}
\DoxyCodeLine{762 \textcolor{comment}{// and computing:}}
\DoxyCodeLine{763 \textcolor{comment}{//       scale = pixels / (ascent -\/ descent)}}
\DoxyCodeLine{764 \textcolor{comment}{// so if you prefer to measure height by the ascent only, use a similar calculation.}}
\DoxyCodeLine{765 }
\DoxyCodeLine{766 STBTT\_DEF \textcolor{keywordtype}{float} stbtt\_ScaleForMappingEmToPixels(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} pixels);}
\DoxyCodeLine{767 \textcolor{comment}{// computes a scale factor to produce a font whose EM size is mapped to}}
\DoxyCodeLine{768 \textcolor{comment}{// 'pixels' tall. This is probably what traditional APIs compute, but}}
\DoxyCodeLine{769 \textcolor{comment}{// I'm not positive.}}
\DoxyCodeLine{770 }
\DoxyCodeLine{771 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetFontVMetrics(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} *ascent, \textcolor{keywordtype}{int} *descent, \textcolor{keywordtype}{int} *lineGap);}
\DoxyCodeLine{772 \textcolor{comment}{// ascent is the coordinate above the baseline the font extends; descent}}
\DoxyCodeLine{773 \textcolor{comment}{// is the coordinate below the baseline the font extends (i.e. it is typically negative)}}
\DoxyCodeLine{774 \textcolor{comment}{// lineGap is the spacing between one row's descent and the next row's ascent...}}
\DoxyCodeLine{775 \textcolor{comment}{// so you should advance the vertical position by "{}*ascent -\/ *descent + *lineGap"{}}}
\DoxyCodeLine{776 \textcolor{comment}{//   these are expressed in unscaled coordinates, so you must multiply by}}
\DoxyCodeLine{777 \textcolor{comment}{//   the scale factor for a given size}}
\DoxyCodeLine{778 }
\DoxyCodeLine{779 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetFontVMetricsOS2(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} *typoAscent, \textcolor{keywordtype}{int} *typoDescent, \textcolor{keywordtype}{int} *typoLineGap);}
\DoxyCodeLine{780 \textcolor{comment}{// analogous to GetFontVMetrics, but returns the "{}typographic"{} values from the OS/2}}
\DoxyCodeLine{781 \textcolor{comment}{// table (specific to MS/Windows TTF files).}}
\DoxyCodeLine{782 \textcolor{comment}{//}}
\DoxyCodeLine{783 \textcolor{comment}{// Returns 1 on success (table present), 0 on failure.}}
\DoxyCodeLine{784 }
\DoxyCodeLine{785 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetFontBoundingBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} *x0, \textcolor{keywordtype}{int} *y0, \textcolor{keywordtype}{int} *x1, \textcolor{keywordtype}{int} *y1);}
\DoxyCodeLine{786 \textcolor{comment}{// the bounding box around all possible characters}}
\DoxyCodeLine{787 }
\DoxyCodeLine{788 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetCodepointHMetrics(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} *advanceWidth, \textcolor{keywordtype}{int} *leftSideBearing);}
\DoxyCodeLine{789 \textcolor{comment}{// leftSideBearing is the offset from the current horizontal position to the left edge of the character}}
\DoxyCodeLine{790 \textcolor{comment}{// advanceWidth is the offset from the current horizontal position to the next horizontal position}}
\DoxyCodeLine{791 \textcolor{comment}{//   these are expressed in unscaled coordinates}}
\DoxyCodeLine{792 }
\DoxyCodeLine{793 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetCodepointKernAdvance(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} ch1, \textcolor{keywordtype}{int} ch2);}
\DoxyCodeLine{794 \textcolor{comment}{// an additional amount to add to the 'advance' value between ch1 and ch2}}
\DoxyCodeLine{795 }
\DoxyCodeLine{796 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetCodepointBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} *x0, \textcolor{keywordtype}{int} *y0, \textcolor{keywordtype}{int} *x1, \textcolor{keywordtype}{int} *y1);}
\DoxyCodeLine{797 \textcolor{comment}{// Gets the bounding box of the visible part of the glyph, in unscaled coordinates}}
\DoxyCodeLine{798 }
\DoxyCodeLine{799 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetGlyphHMetrics(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \textcolor{keywordtype}{int} *advanceWidth, \textcolor{keywordtype}{int} *leftSideBearing);}
\DoxyCodeLine{800 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetGlyphKernAdvance(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph1, \textcolor{keywordtype}{int} glyph2);}
\DoxyCodeLine{801 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetGlyphBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \textcolor{keywordtype}{int} *x0, \textcolor{keywordtype}{int} *y0, \textcolor{keywordtype}{int} *x1, \textcolor{keywordtype}{int} *y1);}
\DoxyCodeLine{802 \textcolor{comment}{// as above, but takes one or more glyph indices for greater efficiency}}
\DoxyCodeLine{803 }
\DoxyCodeLine{804 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structstbtt__kerningentry}{stbtt\_kerningentry}}}
\DoxyCodeLine{805 \{}
\DoxyCodeLine{806    \textcolor{keywordtype}{int} glyph1; \textcolor{comment}{// use stbtt\_FindGlyphIndex}}
\DoxyCodeLine{807    \textcolor{keywordtype}{int} glyph2;}
\DoxyCodeLine{808    \textcolor{keywordtype}{int} advance;}
\DoxyCodeLine{809 \} \mbox{\hyperlink{structstbtt__kerningentry}{stbtt\_kerningentry}};}
\DoxyCodeLine{810 }
\DoxyCodeLine{811 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetKerningTableLength(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info);}
\DoxyCodeLine{812 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetKerningTable(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \mbox{\hyperlink{structstbtt__kerningentry}{stbtt\_kerningentry}}* table, \textcolor{keywordtype}{int} table\_length);}
\DoxyCodeLine{813 \textcolor{comment}{// Retrieves a complete list of all of the kerning pairs provided by the font}}
\DoxyCodeLine{814 \textcolor{comment}{// stbtt\_GetKerningTable never writes more than table\_length entries and returns how many entries it did write.}}
\DoxyCodeLine{815 \textcolor{comment}{// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)}}
\DoxyCodeLine{816 }
\DoxyCodeLine{818 \textcolor{comment}{//}}
\DoxyCodeLine{819 \textcolor{comment}{// GLYPH SHAPES (you probably don't need these, but they have to go before}}
\DoxyCodeLine{820 \textcolor{comment}{// the bitmaps for C declaration-\/order reasons)}}
\DoxyCodeLine{821 \textcolor{comment}{//}}
\DoxyCodeLine{822 }
\DoxyCodeLine{823 \textcolor{preprocessor}{\#ifndef STBTT\_vmove }\textcolor{comment}{// you can predefine these to use different values (but why?)}}
\DoxyCodeLine{824    \textcolor{keyword}{enum} \{}
\DoxyCodeLine{825       STBTT\_vmove=1,}
\DoxyCodeLine{826       STBTT\_vline,}
\DoxyCodeLine{827       STBTT\_vcurve,}
\DoxyCodeLine{828       STBTT\_vcubic}
\DoxyCodeLine{829    \};}
\DoxyCodeLine{830 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{831 }
\DoxyCodeLine{832 \textcolor{preprocessor}{\#ifndef stbtt\_vertex }\textcolor{comment}{// you can predefine this to use different values}}
\DoxyCodeLine{833                    \textcolor{comment}{// (we share this with other code at RAD)}}
\DoxyCodeLine{834 \textcolor{preprocessor}{   \#define stbtt\_vertex\_type short }\textcolor{comment}{// can't use stbtt\_int16 because that's not visible in the header file}}
\DoxyCodeLine{835    \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{836    \{}
\DoxyCodeLine{837       stbtt\_vertex\_type x,y,cx,cy,cx1,cy1;}
\DoxyCodeLine{838       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} type,padding;}
\DoxyCodeLine{839    \} \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}};}
\DoxyCodeLine{840 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{841 }
\DoxyCodeLine{842 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_IsGlyphEmpty(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index);}
\DoxyCodeLine{843 \textcolor{comment}{// returns non-\/zero if nothing is drawn for this glyph}}
\DoxyCodeLine{844 }
\DoxyCodeLine{845 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetCodepointShape(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} unicode\_codepoint, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} **vertices);}
\DoxyCodeLine{846 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetGlyphShape(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} **vertices);}
\DoxyCodeLine{847 \textcolor{comment}{// returns \# of vertices and fills *vertices with the pointer to them}}
\DoxyCodeLine{848 \textcolor{comment}{//   these are expressed in "{}unscaled"{} coordinates}}
\DoxyCodeLine{849 \textcolor{comment}{//}}
\DoxyCodeLine{850 \textcolor{comment}{// The shape is a series of contours. Each one starts with}}
\DoxyCodeLine{851 \textcolor{comment}{// a STBTT\_moveto, then consists of a series of mixed}}
\DoxyCodeLine{852 \textcolor{comment}{// STBTT\_lineto and STBTT\_curveto segments. A lineto}}
\DoxyCodeLine{853 \textcolor{comment}{// draws a line from previous endpoint to its x,y; a curveto}}
\DoxyCodeLine{854 \textcolor{comment}{// draws a quadratic bezier from previous endpoint to}}
\DoxyCodeLine{855 \textcolor{comment}{// its x,y, using cx,cy as the bezier control point.}}
\DoxyCodeLine{856 }
\DoxyCodeLine{857 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_FreeShape(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *vertices);}
\DoxyCodeLine{858 \textcolor{comment}{// frees the data allocated above}}
\DoxyCodeLine{859 }
\DoxyCodeLine{860 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_FindSVGDoc(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} gl);}
\DoxyCodeLine{861 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetCodepointSVG(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} unicode\_codepoint, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **svg);}
\DoxyCodeLine{862 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetGlyphSVG(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} gl, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **svg);}
\DoxyCodeLine{863 \textcolor{comment}{// fills svg with the character's SVG data.}}
\DoxyCodeLine{864 \textcolor{comment}{// returns data size or 0 if SVG not found.}}
\DoxyCodeLine{865 }
\DoxyCodeLine{867 \textcolor{comment}{//}}
\DoxyCodeLine{868 \textcolor{comment}{// BITMAP RENDERING}}
\DoxyCodeLine{869 \textcolor{comment}{//}}
\DoxyCodeLine{870 }
\DoxyCodeLine{871 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_FreeBitmap(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap, \textcolor{keywordtype}{void} *userdata);}
\DoxyCodeLine{872 \textcolor{comment}{// frees the bitmap allocated below}}
\DoxyCodeLine{873 }
\DoxyCodeLine{874 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_GetCodepointBitmap(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff);}
\DoxyCodeLine{875 \textcolor{comment}{// allocates a large-\/enough single-\/channel 8bpp bitmap and renders the}}
\DoxyCodeLine{876 \textcolor{comment}{// specified character/glyph at the specified scale into it, with}}
\DoxyCodeLine{877 \textcolor{comment}{// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).}}
\DoxyCodeLine{878 \textcolor{comment}{// *width \& *height are filled out with the width \& height of the bitmap,}}
\DoxyCodeLine{879 \textcolor{comment}{// which is stored left-\/to-\/right, top-\/to-\/bottom.}}
\DoxyCodeLine{880 \textcolor{comment}{//}}
\DoxyCodeLine{881 \textcolor{comment}{// xoff/yoff are the offset it pixel space from the glyph origin to the top-\/left of the bitmap}}
\DoxyCodeLine{882 }
\DoxyCodeLine{883 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_GetCodepointBitmapSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff);}
\DoxyCodeLine{884 \textcolor{comment}{// the same as stbtt\_GetCodepoitnBitmap, but you can specify a subpixel}}
\DoxyCodeLine{885 \textcolor{comment}{// shift for the character}}
\DoxyCodeLine{886 }
\DoxyCodeLine{887 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeCodepointBitmap(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} codepoint);}
\DoxyCodeLine{888 \textcolor{comment}{// the same as stbtt\_GetCodepointBitmap, but you pass in storage for the bitmap}}
\DoxyCodeLine{889 \textcolor{comment}{// in the form of 'output', with row spacing of 'out\_stride' bytes. the bitmap}}
\DoxyCodeLine{890 \textcolor{comment}{// is clipped to out\_w/out\_h bytes. Call stbtt\_GetCodepointBitmapBox to get the}}
\DoxyCodeLine{891 \textcolor{comment}{// width and height and positioning info for it first.}}
\DoxyCodeLine{892 }
\DoxyCodeLine{893 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeCodepointBitmapSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} codepoint);}
\DoxyCodeLine{894 \textcolor{comment}{// same as stbtt\_MakeCodepointBitmap, but you can specify a subpixel}}
\DoxyCodeLine{895 \textcolor{comment}{// shift for the character}}
\DoxyCodeLine{896 }
\DoxyCodeLine{897 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeCodepointBitmapSubpixelPrefilter(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} oversample\_x, \textcolor{keywordtype}{int} oversample\_y, \textcolor{keywordtype}{float} *sub\_x, \textcolor{keywordtype}{float} *sub\_y, \textcolor{keywordtype}{int} codepoint);}
\DoxyCodeLine{898 \textcolor{comment}{// same as stbtt\_MakeCodepointBitmapSubpixel, but prefiltering}}
\DoxyCodeLine{899 \textcolor{comment}{// is performed (see stbtt\_PackSetOversampling)}}
\DoxyCodeLine{900 }
\DoxyCodeLine{901 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetCodepointBitmapBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} *ix0, \textcolor{keywordtype}{int} *iy0, \textcolor{keywordtype}{int} *ix1, \textcolor{keywordtype}{int} *iy1);}
\DoxyCodeLine{902 \textcolor{comment}{// get the bbox of the bitmap centered around the glyph origin; so the}}
\DoxyCodeLine{903 \textcolor{comment}{// bitmap width is ix1-\/ix0, height is iy1-\/iy0, and location to place}}
\DoxyCodeLine{904 \textcolor{comment}{// the bitmap top left is (leftSideBearing*scale,iy0).}}
\DoxyCodeLine{905 \textcolor{comment}{// (Note that the bitmap uses y-\/increases-\/down, but the shape uses}}
\DoxyCodeLine{906 \textcolor{comment}{// y-\/increases-\/up, so CodepointBitmapBox and CodepointBox are inverted.)}}
\DoxyCodeLine{907 }
\DoxyCodeLine{908 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetCodepointBitmapBoxSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} *ix0, \textcolor{keywordtype}{int} *iy0, \textcolor{keywordtype}{int} *ix1, \textcolor{keywordtype}{int} *iy1);}
\DoxyCodeLine{909 \textcolor{comment}{// same as stbtt\_GetCodepointBitmapBox, but you can specify a subpixel}}
\DoxyCodeLine{910 \textcolor{comment}{// shift for the character}}
\DoxyCodeLine{911 }
\DoxyCodeLine{912 \textcolor{comment}{// the following functions are equivalent to the above functions, but operate}}
\DoxyCodeLine{913 \textcolor{comment}{// on glyph indices instead of Unicode codepoints (for efficiency)}}
\DoxyCodeLine{914 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_GetGlyphBitmap(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff);}
\DoxyCodeLine{915 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_GetGlyphBitmapSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff);}
\DoxyCodeLine{916 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeGlyphBitmap(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} glyph);}
\DoxyCodeLine{917 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeGlyphBitmapSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} glyph);}
\DoxyCodeLine{918 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeGlyphBitmapSubpixelPrefilter(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} oversample\_x, \textcolor{keywordtype}{int} oversample\_y, \textcolor{keywordtype}{float} *sub\_x, \textcolor{keywordtype}{float} *sub\_y, \textcolor{keywordtype}{int} glyph);}
\DoxyCodeLine{919 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetGlyphBitmapBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} *ix0, \textcolor{keywordtype}{int} *iy0, \textcolor{keywordtype}{int} *ix1, \textcolor{keywordtype}{int} *iy1);}
\DoxyCodeLine{920 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetGlyphBitmapBoxSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y,\textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} *ix0, \textcolor{keywordtype}{int} *iy0, \textcolor{keywordtype}{int} *ix1, \textcolor{keywordtype}{int} *iy1);}
\DoxyCodeLine{921 }
\DoxyCodeLine{922 }
\DoxyCodeLine{923 \textcolor{comment}{// @TODO: don't expose this structure}}
\DoxyCodeLine{924 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{925 \{}
\DoxyCodeLine{926    \textcolor{keywordtype}{int} w,h,stride;}
\DoxyCodeLine{927    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels;}
\DoxyCodeLine{928 \} \mbox{\hyperlink{structstbtt____bitmap}{stbtt\_\_bitmap}};}
\DoxyCodeLine{929 }
\DoxyCodeLine{930 \textcolor{comment}{// rasterize a shape with quadratic beziers into a bitmap}}
\DoxyCodeLine{931 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_Rasterize(\mbox{\hyperlink{structstbtt____bitmap}{stbtt\_\_bitmap}} *result,        \textcolor{comment}{// 1-\/channel bitmap to draw into}}
\DoxyCodeLine{932                                \textcolor{keywordtype}{float} flatness\_in\_pixels,     \textcolor{comment}{// allowable error of curve in pixels}}
\DoxyCodeLine{933                                \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *vertices,       \textcolor{comment}{// array of vertices defining shape}}
\DoxyCodeLine{934                                \textcolor{keywordtype}{int} num\_verts,                \textcolor{comment}{// number of vertices in above array}}
\DoxyCodeLine{935                                \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{comment}{// scale applied to input vertices}}
\DoxyCodeLine{936                                \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{comment}{// translation applied to input vertices}}
\DoxyCodeLine{937                                \textcolor{keywordtype}{int} x\_off, \textcolor{keywordtype}{int} y\_off,         \textcolor{comment}{// another translation applied to input}}
\DoxyCodeLine{938                                \textcolor{keywordtype}{int} invert,                   \textcolor{comment}{// if non-\/zero, vertically flip shape}}
\DoxyCodeLine{939                                \textcolor{keywordtype}{void} *userdata);              \textcolor{comment}{// context for to STBTT\_MALLOC}}
\DoxyCodeLine{940 }
\DoxyCodeLine{942 \textcolor{comment}{//}}
\DoxyCodeLine{943 \textcolor{comment}{// Signed Distance Function (or Field) rendering}}
\DoxyCodeLine{944 }
\DoxyCodeLine{945 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_FreeSDF(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap, \textcolor{keywordtype}{void} *userdata);}
\DoxyCodeLine{946 \textcolor{comment}{// frees the SDF bitmap allocated below}}
\DoxyCodeLine{947 }
\DoxyCodeLine{948 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} * stbtt\_GetGlyphSDF(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{int} padding, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} onedge\_value, \textcolor{keywordtype}{float} pixel\_dist\_scale, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff);}
\DoxyCodeLine{949 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} * stbtt\_GetCodepointSDF(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} padding, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} onedge\_value, \textcolor{keywordtype}{float} pixel\_dist\_scale, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff);}
\DoxyCodeLine{950 \textcolor{comment}{// These functions compute a discretized SDF field for a single character, suitable for storing}}
\DoxyCodeLine{951 \textcolor{comment}{// in a single-\/channel texture, sampling with bilinear filtering, and testing against}}
\DoxyCodeLine{952 \textcolor{comment}{// larger than some threshold to produce scalable fonts.}}
\DoxyCodeLine{953 \textcolor{comment}{//        info              -\/-\/  the font}}
\DoxyCodeLine{954 \textcolor{comment}{//        scale             -\/-\/  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap}}
\DoxyCodeLine{955 \textcolor{comment}{//        glyph/codepoint   -\/-\/  the character to generate the SDF for}}
\DoxyCodeLine{956 \textcolor{comment}{//        padding           -\/-\/  extra "{}pixels"{} around the character which are filled with the distance to the character (not 0),}}
\DoxyCodeLine{957 \textcolor{comment}{//                                 which allows effects like bit outlines}}
\DoxyCodeLine{958 \textcolor{comment}{//        onedge\_value      -\/-\/  value 0-\/255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)}}
\DoxyCodeLine{959 \textcolor{comment}{//        pixel\_dist\_scale  -\/-\/  what value the SDF should increase by when moving one SDF "{}pixel"{} away from the edge (on the 0..255 scale)}}
\DoxyCodeLine{960 \textcolor{comment}{//                                 if positive, > onedge\_value is inside; if negative, < onedge\_value is inside}}
\DoxyCodeLine{961 \textcolor{comment}{//        width,height      -\/-\/  output height \& width of the SDF bitmap (including padding)}}
\DoxyCodeLine{962 \textcolor{comment}{//        xoff,yoff         -\/-\/  output origin of the character}}
\DoxyCodeLine{963 \textcolor{comment}{//        return value      -\/-\/  a 2D array of bytes 0..255, width*height in size}}
\DoxyCodeLine{964 \textcolor{comment}{//}}
\DoxyCodeLine{965 \textcolor{comment}{// pixel\_dist\_scale \& onedge\_value are a scale \& bias that allows you to make}}
\DoxyCodeLine{966 \textcolor{comment}{// optimal use of the limited 0..255 for your application, trading off precision}}
\DoxyCodeLine{967 \textcolor{comment}{// and special effects. SDF values outside the range 0..255 are clamped to 0..255.}}
\DoxyCodeLine{968 \textcolor{comment}{//}}
\DoxyCodeLine{969 \textcolor{comment}{// Example:}}
\DoxyCodeLine{970 \textcolor{comment}{//      scale = stbtt\_ScaleForPixelHeight(22)}}
\DoxyCodeLine{971 \textcolor{comment}{//      padding = 5}}
\DoxyCodeLine{972 \textcolor{comment}{//      onedge\_value = 180}}
\DoxyCodeLine{973 \textcolor{comment}{//      pixel\_dist\_scale = 180/5.0 = 36.0}}
\DoxyCodeLine{974 \textcolor{comment}{//}}
\DoxyCodeLine{975 \textcolor{comment}{//      This will create an SDF bitmap in which the character is about 22 pixels}}
\DoxyCodeLine{976 \textcolor{comment}{//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled}}
\DoxyCodeLine{977 \textcolor{comment}{//      shape, sample the SDF at each pixel and fill the pixel if the SDF value}}
\DoxyCodeLine{978 \textcolor{comment}{//      is greater than or equal to 180/255. (You'll actually want to antialias,}}
\DoxyCodeLine{979 \textcolor{comment}{//      which is beyond the scope of this example.) Additionally, you can compute}}
\DoxyCodeLine{980 \textcolor{comment}{//      offset outlines (e.g. to stroke the character border inside \& outside,}}
\DoxyCodeLine{981 \textcolor{comment}{//      or only outside). For example, to fill outside the character up to 3 SDF}}
\DoxyCodeLine{982 \textcolor{comment}{//      pixels, you would compare against (180-\/36.0*3)/255 = 72/255. The above}}
\DoxyCodeLine{983 \textcolor{comment}{//      choice of variables maps a range from 5 pixels outside the shape to}}
\DoxyCodeLine{984 \textcolor{comment}{//      2 pixels inside the shape to 0..255; this is intended primarily for apply}}
\DoxyCodeLine{985 \textcolor{comment}{//      outside effects only (the interior range is needed to allow proper}}
\DoxyCodeLine{986 \textcolor{comment}{//      antialiasing of the font at *smaller* sizes)}}
\DoxyCodeLine{987 \textcolor{comment}{//}}
\DoxyCodeLine{988 \textcolor{comment}{// The function computes the SDF analytically at each SDF pixel, not by e.g.}}
\DoxyCodeLine{989 \textcolor{comment}{// building a higher-\/res bitmap and approximating it. In theory the quality}}
\DoxyCodeLine{990 \textcolor{comment}{// should be as high as possible for an SDF of this size \& representation, but}}
\DoxyCodeLine{991 \textcolor{comment}{// unclear if this is true in practice (perhaps building a higher-\/res bitmap}}
\DoxyCodeLine{992 \textcolor{comment}{// and computing from that can allow drop-\/out prevention).}}
\DoxyCodeLine{993 \textcolor{comment}{//}}
\DoxyCodeLine{994 \textcolor{comment}{// The algorithm has not been optimized at all, so expect it to be slow}}
\DoxyCodeLine{995 \textcolor{comment}{// if computing lots of characters or very large sizes.}}
\DoxyCodeLine{996 }
\DoxyCodeLine{997 }
\DoxyCodeLine{998 }
\DoxyCodeLine{1000 \textcolor{comment}{//}}
\DoxyCodeLine{1001 \textcolor{comment}{// Finding the right font...}}
\DoxyCodeLine{1002 \textcolor{comment}{//}}
\DoxyCodeLine{1003 \textcolor{comment}{// You should really just solve this offline, keep your own tables}}
\DoxyCodeLine{1004 \textcolor{comment}{// of what font is what, and don't try to get it out of the .ttf file.}}
\DoxyCodeLine{1005 \textcolor{comment}{// That's because getting it out of the .ttf file is really hard, because}}
\DoxyCodeLine{1006 \textcolor{comment}{// the names in the file can appear in many possible encodings, in many}}
\DoxyCodeLine{1007 \textcolor{comment}{// possible languages, and e.g. if you need a case-\/insensitive comparison,}}
\DoxyCodeLine{1008 \textcolor{comment}{// the details of that depend on the encoding \& language in a complex way}}
\DoxyCodeLine{1009 \textcolor{comment}{// (actually underspecified in truetype, but also gigantic).}}
\DoxyCodeLine{1010 \textcolor{comment}{//}}
\DoxyCodeLine{1011 \textcolor{comment}{// But you can use the provided functions in two possible ways:}}
\DoxyCodeLine{1012 \textcolor{comment}{//     stbtt\_FindMatchingFont() will use *case-\/sensitive* comparisons on}}
\DoxyCodeLine{1013 \textcolor{comment}{//             unicode-\/encoded names to try to find the font you want;}}
\DoxyCodeLine{1014 \textcolor{comment}{//             you can run this before calling stbtt\_InitFont()}}
\DoxyCodeLine{1015 \textcolor{comment}{//}}
\DoxyCodeLine{1016 \textcolor{comment}{//     stbtt\_GetFontNameString() lets you get any of the various strings}}
\DoxyCodeLine{1017 \textcolor{comment}{//             from the file yourself and do your own comparisons on them.}}
\DoxyCodeLine{1018 \textcolor{comment}{//             You have to have called stbtt\_InitFont() first.}}
\DoxyCodeLine{1019 }
\DoxyCodeLine{1020 }
\DoxyCodeLine{1021 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_FindMatchingFont(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fontdata, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *name, \textcolor{keywordtype}{int} flags);}
\DoxyCodeLine{1022 \textcolor{comment}{// returns the offset (not index) of the font that matches, or -\/1 if none}}
\DoxyCodeLine{1023 \textcolor{comment}{//   if you use STBTT\_MACSTYLE\_DONTCARE, use a font name like "{}Arial Bold"{}.}}
\DoxyCodeLine{1024 \textcolor{comment}{//   if you use any other flag, use a font name like "{}Arial"{}; this checks}}
\DoxyCodeLine{1025 \textcolor{comment}{//     the 'macStyle' header field; i don't know if fonts set this consistently}}
\DoxyCodeLine{1026 \textcolor{preprocessor}{\#define STBTT\_MACSTYLE\_DONTCARE     0}}
\DoxyCodeLine{1027 \textcolor{preprocessor}{\#define STBTT\_MACSTYLE\_BOLD         1}}
\DoxyCodeLine{1028 \textcolor{preprocessor}{\#define STBTT\_MACSTYLE\_ITALIC       2}}
\DoxyCodeLine{1029 \textcolor{preprocessor}{\#define STBTT\_MACSTYLE\_UNDERSCORE   4}}
\DoxyCodeLine{1030 \textcolor{preprocessor}{\#define STBTT\_MACSTYLE\_NONE         8   }\textcolor{comment}{// <= not same as 0, this makes us check the bitfield is 0}}
\DoxyCodeLine{1031 }
\DoxyCodeLine{1032 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_CompareUTF8toUTF16\_bigendian(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s1, \textcolor{keywordtype}{int} len1, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s2, \textcolor{keywordtype}{int} len2);}
\DoxyCodeLine{1033 \textcolor{comment}{// returns 1/0 whether the first string interpreted as utf8 is identical to}}
\DoxyCodeLine{1034 \textcolor{comment}{// the second string interpreted as big-\/endian utf16... useful for strings from next func}}
\DoxyCodeLine{1035 }
\DoxyCodeLine{1036 STBTT\_DEF \textcolor{keyword}{const} \textcolor{keywordtype}{char} *stbtt\_GetFontNameString(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} *length, \textcolor{keywordtype}{int} platformID, \textcolor{keywordtype}{int} encodingID, \textcolor{keywordtype}{int} languageID, \textcolor{keywordtype}{int} nameID);}
\DoxyCodeLine{1037 \textcolor{comment}{// returns the string (which may be big-\/endian double byte, e.g. for unicode)}}
\DoxyCodeLine{1038 \textcolor{comment}{// and puts the length in bytes in *length.}}
\DoxyCodeLine{1039 \textcolor{comment}{//}}
\DoxyCodeLine{1040 \textcolor{comment}{// some of the values for the IDs are below; for more see the truetype spec:}}
\DoxyCodeLine{1041 \textcolor{comment}{//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html}}
\DoxyCodeLine{1042 \textcolor{comment}{//     http://www.microsoft.com/typography/otspec/name.htm}}
\DoxyCodeLine{1043 }
\DoxyCodeLine{1044 \textcolor{keyword}{enum} \{ \textcolor{comment}{// platformID}}
\DoxyCodeLine{1045    STBTT\_PLATFORM\_ID\_UNICODE   =0,}
\DoxyCodeLine{1046    STBTT\_PLATFORM\_ID\_MAC       =1,}
\DoxyCodeLine{1047    STBTT\_PLATFORM\_ID\_ISO       =2,}
\DoxyCodeLine{1048    STBTT\_PLATFORM\_ID\_MICROSOFT =3}
\DoxyCodeLine{1049 \};}
\DoxyCodeLine{1050 }
\DoxyCodeLine{1051 \textcolor{keyword}{enum} \{ \textcolor{comment}{// encodingID for STBTT\_PLATFORM\_ID\_UNICODE}}
\DoxyCodeLine{1052    STBTT\_UNICODE\_EID\_UNICODE\_1\_0    =0,}
\DoxyCodeLine{1053    STBTT\_UNICODE\_EID\_UNICODE\_1\_1    =1,}
\DoxyCodeLine{1054    STBTT\_UNICODE\_EID\_ISO\_10646      =2,}
\DoxyCodeLine{1055    STBTT\_UNICODE\_EID\_UNICODE\_2\_0\_BMP=3,}
\DoxyCodeLine{1056    STBTT\_UNICODE\_EID\_UNICODE\_2\_0\_FULL=4}
\DoxyCodeLine{1057 \};}
\DoxyCodeLine{1058 }
\DoxyCodeLine{1059 \textcolor{keyword}{enum} \{ \textcolor{comment}{// encodingID for STBTT\_PLATFORM\_ID\_MICROSOFT}}
\DoxyCodeLine{1060    STBTT\_MS\_EID\_SYMBOL        =0,}
\DoxyCodeLine{1061    STBTT\_MS\_EID\_UNICODE\_BMP   =1,}
\DoxyCodeLine{1062    STBTT\_MS\_EID\_SHIFTJIS      =2,}
\DoxyCodeLine{1063    STBTT\_MS\_EID\_UNICODE\_FULL  =10}
\DoxyCodeLine{1064 \};}
\DoxyCodeLine{1065 }
\DoxyCodeLine{1066 \textcolor{keyword}{enum} \{ \textcolor{comment}{// encodingID for STBTT\_PLATFORM\_ID\_MAC; same as Script Manager codes}}
\DoxyCodeLine{1067    STBTT\_MAC\_EID\_ROMAN        =0,   STBTT\_MAC\_EID\_ARABIC       =4,}
\DoxyCodeLine{1068    STBTT\_MAC\_EID\_JAPANESE     =1,   STBTT\_MAC\_EID\_HEBREW       =5,}
\DoxyCodeLine{1069    STBTT\_MAC\_EID\_CHINESE\_TRAD =2,   STBTT\_MAC\_EID\_GREEK        =6,}
\DoxyCodeLine{1070    STBTT\_MAC\_EID\_KOREAN       =3,   STBTT\_MAC\_EID\_RUSSIAN      =7}
\DoxyCodeLine{1071 \};}
\DoxyCodeLine{1072 }
\DoxyCodeLine{1073 \textcolor{keyword}{enum} \{ \textcolor{comment}{// languageID for STBTT\_PLATFORM\_ID\_MICROSOFT; same as LCID...}}
\DoxyCodeLine{1074        \textcolor{comment}{// problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs}}
\DoxyCodeLine{1075    STBTT\_MS\_LANG\_ENGLISH     =0x0409,   STBTT\_MS\_LANG\_ITALIAN     =0x0410,}
\DoxyCodeLine{1076    STBTT\_MS\_LANG\_CHINESE     =0x0804,   STBTT\_MS\_LANG\_JAPANESE    =0x0411,}
\DoxyCodeLine{1077    STBTT\_MS\_LANG\_DUTCH       =0x0413,   STBTT\_MS\_LANG\_KOREAN      =0x0412,}
\DoxyCodeLine{1078    STBTT\_MS\_LANG\_FRENCH      =0x040c,   STBTT\_MS\_LANG\_RUSSIAN     =0x0419,}
\DoxyCodeLine{1079    STBTT\_MS\_LANG\_GERMAN      =0x0407,   STBTT\_MS\_LANG\_SPANISH     =0x0409,}
\DoxyCodeLine{1080    STBTT\_MS\_LANG\_HEBREW      =0x040d,   STBTT\_MS\_LANG\_SWEDISH     =0x041D}
\DoxyCodeLine{1081 \};}
\DoxyCodeLine{1082 }
\DoxyCodeLine{1083 \textcolor{keyword}{enum} \{ \textcolor{comment}{// languageID for STBTT\_PLATFORM\_ID\_MAC}}
\DoxyCodeLine{1084    STBTT\_MAC\_LANG\_ENGLISH      =0 ,   STBTT\_MAC\_LANG\_JAPANESE     =11,}
\DoxyCodeLine{1085    STBTT\_MAC\_LANG\_ARABIC       =12,   STBTT\_MAC\_LANG\_KOREAN       =23,}
\DoxyCodeLine{1086    STBTT\_MAC\_LANG\_DUTCH        =4 ,   STBTT\_MAC\_LANG\_RUSSIAN      =32,}
\DoxyCodeLine{1087    STBTT\_MAC\_LANG\_FRENCH       =1 ,   STBTT\_MAC\_LANG\_SPANISH      =6 ,}
\DoxyCodeLine{1088    STBTT\_MAC\_LANG\_GERMAN       =2 ,   STBTT\_MAC\_LANG\_SWEDISH      =5 ,}
\DoxyCodeLine{1089    STBTT\_MAC\_LANG\_HEBREW       =10,   STBTT\_MAC\_LANG\_CHINESE\_SIMPLIFIED =33,}
\DoxyCodeLine{1090    STBTT\_MAC\_LANG\_ITALIAN      =3 ,   STBTT\_MAC\_LANG\_CHINESE\_TRAD =19}
\DoxyCodeLine{1091 \};}
\DoxyCodeLine{1092 }
\DoxyCodeLine{1093 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{1094 \}}
\DoxyCodeLine{1095 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1096 }
\DoxyCodeLine{1097 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_STB\_INCLUDE\_STB\_TRUETYPE\_H\_\_}}
\DoxyCodeLine{1098 }
\DoxyCodeLine{1105 }
\DoxyCodeLine{1106 \textcolor{preprocessor}{\#ifdef STB\_TRUETYPE\_IMPLEMENTATION}}
\DoxyCodeLine{1107 }
\DoxyCodeLine{1108 \textcolor{preprocessor}{\#ifndef STBTT\_MAX\_OVERSAMPLE}}
\DoxyCodeLine{1109 \textcolor{preprocessor}{\#define STBTT\_MAX\_OVERSAMPLE   8}}
\DoxyCodeLine{1110 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1111 }
\DoxyCodeLine{1112 \textcolor{preprocessor}{\#if STBTT\_MAX\_OVERSAMPLE > 255}}
\DoxyCodeLine{1113 \textcolor{preprocessor}{\#error "{}STBTT\_MAX\_OVERSAMPLE cannot be > 255"{}}}
\DoxyCodeLine{1114 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1115 }
\DoxyCodeLine{1116 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} stbtt\_\_test\_oversample\_pow2[(STBTT\_MAX\_OVERSAMPLE \& (STBTT\_MAX\_OVERSAMPLE-\/1)) == 0 ? 1 : -\/1];}
\DoxyCodeLine{1117 }
\DoxyCodeLine{1118 \textcolor{preprocessor}{\#ifndef STBTT\_RASTERIZER\_VERSION}}
\DoxyCodeLine{1119 \textcolor{preprocessor}{\#define STBTT\_RASTERIZER\_VERSION 2}}
\DoxyCodeLine{1120 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1121 }
\DoxyCodeLine{1122 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{1123 \textcolor{preprocessor}{\#define STBTT\_\_NOTUSED(v)  (void)(v)}}
\DoxyCodeLine{1124 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1125 \textcolor{preprocessor}{\#define STBTT\_\_NOTUSED(v)  (void)sizeof(v)}}
\DoxyCodeLine{1126 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1127 }
\DoxyCodeLine{1129 \textcolor{comment}{//}}
\DoxyCodeLine{1130 \textcolor{comment}{// stbtt\_\_buf helpers to parse data from file}}
\DoxyCodeLine{1131 \textcolor{comment}{//}}
\DoxyCodeLine{1132 }
\DoxyCodeLine{1133 \textcolor{keyword}{static} stbtt\_uint8 stbtt\_\_buf\_get8(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b)}
\DoxyCodeLine{1134 \{}
\DoxyCodeLine{1135    \textcolor{keywordflow}{if} (b-\/>cursor >= b-\/>size)}
\DoxyCodeLine{1136       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1137    \textcolor{keywordflow}{return} b-\/>data[b-\/>cursor++];}
\DoxyCodeLine{1138 \}}
\DoxyCodeLine{1139 }
\DoxyCodeLine{1140 \textcolor{keyword}{static} stbtt\_uint8 stbtt\_\_buf\_peek8(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b)}
\DoxyCodeLine{1141 \{}
\DoxyCodeLine{1142    \textcolor{keywordflow}{if} (b-\/>cursor >= b-\/>size)}
\DoxyCodeLine{1143       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1144    \textcolor{keywordflow}{return} b-\/>data[b-\/>cursor];}
\DoxyCodeLine{1145 \}}
\DoxyCodeLine{1146 }
\DoxyCodeLine{1147 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_buf\_seek(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b, \textcolor{keywordtype}{int} o)}
\DoxyCodeLine{1148 \{}
\DoxyCodeLine{1149    STBTT\_assert(!(o > b-\/>size || o < 0));}
\DoxyCodeLine{1150    b-\/>cursor = (o > b-\/>size || o < 0) ? b-\/>size : o;}
\DoxyCodeLine{1151 \}}
\DoxyCodeLine{1152 }
\DoxyCodeLine{1153 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_buf\_skip(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b, \textcolor{keywordtype}{int} o)}
\DoxyCodeLine{1154 \{}
\DoxyCodeLine{1155    stbtt\_\_buf\_seek(b, b-\/>cursor + o);}
\DoxyCodeLine{1156 \}}
\DoxyCodeLine{1157 }
\DoxyCodeLine{1158 \textcolor{keyword}{static} stbtt\_uint32 stbtt\_\_buf\_get(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{1159 \{}
\DoxyCodeLine{1160    stbtt\_uint32 v = 0;}
\DoxyCodeLine{1161    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{1162    STBTT\_assert(n >= 1 \&\& n <= 4);}
\DoxyCodeLine{1163    \textcolor{keywordflow}{for} (i = 0; i < n; i++)}
\DoxyCodeLine{1164       v = (v << 8) | stbtt\_\_buf\_get8(b);}
\DoxyCodeLine{1165    \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{1166 \}}
\DoxyCodeLine{1167 }
\DoxyCodeLine{1168 \textcolor{keyword}{static} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} stbtt\_\_new\_buf(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *p, \textcolor{keywordtype}{size\_t} size)}
\DoxyCodeLine{1169 \{}
\DoxyCodeLine{1170    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} r;}
\DoxyCodeLine{1171    STBTT\_assert(size < 0x40000000);}
\DoxyCodeLine{1172    r.data = (stbtt\_uint8*) p;}
\DoxyCodeLine{1173    r.size = (int) size;}
\DoxyCodeLine{1174    r.cursor = 0;}
\DoxyCodeLine{1175    \textcolor{keywordflow}{return} r;}
\DoxyCodeLine{1176 \}}
\DoxyCodeLine{1177 }
\DoxyCodeLine{1178 \textcolor{preprocessor}{\#define stbtt\_\_buf\_get16(b)  stbtt\_\_buf\_get((b), 2)}}
\DoxyCodeLine{1179 \textcolor{preprocessor}{\#define stbtt\_\_buf\_get32(b)  stbtt\_\_buf\_get((b), 4)}}
\DoxyCodeLine{1180 }
\DoxyCodeLine{1181 \textcolor{keyword}{static} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} stbtt\_\_buf\_range(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b, \textcolor{keywordtype}{int} o, \textcolor{keywordtype}{int} s)}
\DoxyCodeLine{1182 \{}
\DoxyCodeLine{1183    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} r = stbtt\_\_new\_buf(NULL, 0);}
\DoxyCodeLine{1184    \textcolor{keywordflow}{if} (o < 0 || s < 0 || o > b-\/>size || s > b-\/>size -\/ o) \textcolor{keywordflow}{return} r;}
\DoxyCodeLine{1185    r.data = b-\/>data + o;}
\DoxyCodeLine{1186    r.size = s;}
\DoxyCodeLine{1187    \textcolor{keywordflow}{return} r;}
\DoxyCodeLine{1188 \}}
\DoxyCodeLine{1189 }
\DoxyCodeLine{1190 \textcolor{keyword}{static} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} stbtt\_\_cff\_get\_index(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b)}
\DoxyCodeLine{1191 \{}
\DoxyCodeLine{1192    \textcolor{keywordtype}{int} count, start, offsize;}
\DoxyCodeLine{1193    start = b-\/>cursor;}
\DoxyCodeLine{1194    count = stbtt\_\_buf\_get16(b);}
\DoxyCodeLine{1195    \textcolor{keywordflow}{if} (count) \{}
\DoxyCodeLine{1196       offsize = stbtt\_\_buf\_get8(b);}
\DoxyCodeLine{1197       STBTT\_assert(offsize >= 1 \&\& offsize <= 4);}
\DoxyCodeLine{1198       stbtt\_\_buf\_skip(b, offsize * count);}
\DoxyCodeLine{1199       stbtt\_\_buf\_skip(b, stbtt\_\_buf\_get(b, offsize) -\/ 1);}
\DoxyCodeLine{1200    \}}
\DoxyCodeLine{1201    \textcolor{keywordflow}{return} stbtt\_\_buf\_range(b, start, b-\/>cursor -\/ start);}
\DoxyCodeLine{1202 \}}
\DoxyCodeLine{1203 }
\DoxyCodeLine{1204 \textcolor{keyword}{static} stbtt\_uint32 stbtt\_\_cff\_int(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b)}
\DoxyCodeLine{1205 \{}
\DoxyCodeLine{1206    \textcolor{keywordtype}{int} b0 = stbtt\_\_buf\_get8(b);}
\DoxyCodeLine{1207    \textcolor{keywordflow}{if} (b0 >= 32 \&\& b0 <= 246)       \textcolor{keywordflow}{return} b0 -\/ 139;}
\DoxyCodeLine{1208    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (b0 >= 247 \&\& b0 <= 250) \textcolor{keywordflow}{return} (b0 -\/ 247)*256 + stbtt\_\_buf\_get8(b) + 108;}
\DoxyCodeLine{1209    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (b0 >= 251 \&\& b0 <= 254) \textcolor{keywordflow}{return} -\/(b0 -\/ 251)*256 -\/ stbtt\_\_buf\_get8(b) -\/ 108;}
\DoxyCodeLine{1210    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (b0 == 28)               \textcolor{keywordflow}{return} stbtt\_\_buf\_get16(b);}
\DoxyCodeLine{1211    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (b0 == 29)               \textcolor{keywordflow}{return} stbtt\_\_buf\_get32(b);}
\DoxyCodeLine{1212    STBTT\_assert(0);}
\DoxyCodeLine{1213    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1214 \}}
\DoxyCodeLine{1215 }
\DoxyCodeLine{1216 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_cff\_skip\_operand(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b) \{}
\DoxyCodeLine{1217    \textcolor{keywordtype}{int} v, b0 = stbtt\_\_buf\_peek8(b);}
\DoxyCodeLine{1218    STBTT\_assert(b0 >= 28);}
\DoxyCodeLine{1219    \textcolor{keywordflow}{if} (b0 == 30) \{}
\DoxyCodeLine{1220       stbtt\_\_buf\_skip(b, 1);}
\DoxyCodeLine{1221       \textcolor{keywordflow}{while} (b-\/>cursor < b-\/>size) \{}
\DoxyCodeLine{1222          v = stbtt\_\_buf\_get8(b);}
\DoxyCodeLine{1223          \textcolor{keywordflow}{if} ((v \& 0xF) == 0xF || (v >> 4) == 0xF)}
\DoxyCodeLine{1224             \textcolor{keywordflow}{break};}
\DoxyCodeLine{1225       \}}
\DoxyCodeLine{1226    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1227       stbtt\_\_cff\_int(b);}
\DoxyCodeLine{1228    \}}
\DoxyCodeLine{1229 \}}
\DoxyCodeLine{1230 }
\DoxyCodeLine{1231 \textcolor{keyword}{static} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} stbtt\_\_dict\_get(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b, \textcolor{keywordtype}{int} key)}
\DoxyCodeLine{1232 \{}
\DoxyCodeLine{1233    stbtt\_\_buf\_seek(b, 0);}
\DoxyCodeLine{1234    \textcolor{keywordflow}{while} (b-\/>cursor < b-\/>size) \{}
\DoxyCodeLine{1235       \textcolor{keywordtype}{int} start = b-\/>cursor, end, op;}
\DoxyCodeLine{1236       \textcolor{keywordflow}{while} (stbtt\_\_buf\_peek8(b) >= 28)}
\DoxyCodeLine{1237          stbtt\_\_cff\_skip\_operand(b);}
\DoxyCodeLine{1238       end = b-\/>cursor;}
\DoxyCodeLine{1239       op = stbtt\_\_buf\_get8(b);}
\DoxyCodeLine{1240       \textcolor{keywordflow}{if} (op == 12)  op = stbtt\_\_buf\_get8(b) | 0x100;}
\DoxyCodeLine{1241       \textcolor{keywordflow}{if} (op == key) \textcolor{keywordflow}{return} stbtt\_\_buf\_range(b, start, end-\/start);}
\DoxyCodeLine{1242    \}}
\DoxyCodeLine{1243    \textcolor{keywordflow}{return} stbtt\_\_buf\_range(b, 0, 0);}
\DoxyCodeLine{1244 \}}
\DoxyCodeLine{1245 }
\DoxyCodeLine{1246 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_dict\_get\_ints(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b, \textcolor{keywordtype}{int} key, \textcolor{keywordtype}{int} outcount, stbtt\_uint32 *out)}
\DoxyCodeLine{1247 \{}
\DoxyCodeLine{1248    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{1249    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} operands = stbtt\_\_dict\_get(b, key);}
\DoxyCodeLine{1250    \textcolor{keywordflow}{for} (i = 0; i < outcount \&\& operands.cursor < operands.size; i++)}
\DoxyCodeLine{1251       out[i] = stbtt\_\_cff\_int(\&operands);}
\DoxyCodeLine{1252 \}}
\DoxyCodeLine{1253 }
\DoxyCodeLine{1254 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_cff\_index\_count(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} *b)}
\DoxyCodeLine{1255 \{}
\DoxyCodeLine{1256    stbtt\_\_buf\_seek(b, 0);}
\DoxyCodeLine{1257    \textcolor{keywordflow}{return} stbtt\_\_buf\_get16(b);}
\DoxyCodeLine{1258 \}}
\DoxyCodeLine{1259 }
\DoxyCodeLine{1260 \textcolor{keyword}{static} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} stbtt\_\_cff\_index\_get(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} b, \textcolor{keywordtype}{int} i)}
\DoxyCodeLine{1261 \{}
\DoxyCodeLine{1262    \textcolor{keywordtype}{int} count, offsize, start, end;}
\DoxyCodeLine{1263    stbtt\_\_buf\_seek(\&b, 0);}
\DoxyCodeLine{1264    count = stbtt\_\_buf\_get16(\&b);}
\DoxyCodeLine{1265    offsize = stbtt\_\_buf\_get8(\&b);}
\DoxyCodeLine{1266    STBTT\_assert(i >= 0 \&\& i < count);}
\DoxyCodeLine{1267    STBTT\_assert(offsize >= 1 \&\& offsize <= 4);}
\DoxyCodeLine{1268    stbtt\_\_buf\_skip(\&b, i*offsize);}
\DoxyCodeLine{1269    start = stbtt\_\_buf\_get(\&b, offsize);}
\DoxyCodeLine{1270    end = stbtt\_\_buf\_get(\&b, offsize);}
\DoxyCodeLine{1271    \textcolor{keywordflow}{return} stbtt\_\_buf\_range(\&b, 2+(count+1)*offsize+start, end -\/ start);}
\DoxyCodeLine{1272 \}}
\DoxyCodeLine{1273 }
\DoxyCodeLine{1275 \textcolor{comment}{//}}
\DoxyCodeLine{1276 \textcolor{comment}{// accessors to parse data from file}}
\DoxyCodeLine{1277 \textcolor{comment}{//}}
\DoxyCodeLine{1278 }
\DoxyCodeLine{1279 \textcolor{comment}{// on platforms that don't allow misaligned reads, if we want to allow}}
\DoxyCodeLine{1280 \textcolor{comment}{// truetype fonts that aren't padded to alignment, define ALLOW\_UNALIGNED\_TRUETYPE}}
\DoxyCodeLine{1281 }
\DoxyCodeLine{1282 \textcolor{preprocessor}{\#define ttBYTE(p)     (* (stbtt\_uint8 *) (p))}}
\DoxyCodeLine{1283 \textcolor{preprocessor}{\#define ttCHAR(p)     (* (stbtt\_int8 *) (p))}}
\DoxyCodeLine{1284 \textcolor{preprocessor}{\#define ttFixed(p)    ttLONG(p)}}
\DoxyCodeLine{1285 }
\DoxyCodeLine{1286 \textcolor{keyword}{static} stbtt\_uint16 ttUSHORT(stbtt\_uint8 *p) \{ \textcolor{keywordflow}{return} p[0]*256 + p[1]; \}}
\DoxyCodeLine{1287 \textcolor{keyword}{static} stbtt\_int16 ttSHORT(stbtt\_uint8 *p)   \{ \textcolor{keywordflow}{return} p[0]*256 + p[1]; \}}
\DoxyCodeLine{1288 \textcolor{keyword}{static} stbtt\_uint32 ttULONG(stbtt\_uint8 *p)  \{ \textcolor{keywordflow}{return} (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; \}}
\DoxyCodeLine{1289 \textcolor{keyword}{static} stbtt\_int32 ttLONG(stbtt\_uint8 *p)    \{ \textcolor{keywordflow}{return} (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; \}}
\DoxyCodeLine{1290 }
\DoxyCodeLine{1291 \textcolor{preprocessor}{\#define stbtt\_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) \&\& (p)[1] == (c1) \&\& (p)[2] == (c2) \&\& (p)[3] == (c3))}}
\DoxyCodeLine{1292 \textcolor{preprocessor}{\#define stbtt\_tag(p,str)           stbtt\_tag4(p,str[0],str[1],str[2],str[3])}}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_isfont(stbtt\_uint8 *font)}
\DoxyCodeLine{1295 \{}
\DoxyCodeLine{1296    \textcolor{comment}{// check the version number}}
\DoxyCodeLine{1297    \textcolor{keywordflow}{if} (stbtt\_tag4(font, \textcolor{charliteral}{'1'},0,0,0))  \textcolor{keywordflow}{return} 1; \textcolor{comment}{// TrueType 1}}
\DoxyCodeLine{1298    \textcolor{keywordflow}{if} (stbtt\_tag(font, \textcolor{stringliteral}{"{}typ1"{}}))   \textcolor{keywordflow}{return} 1; \textcolor{comment}{// TrueType with type 1 font -\/-\/ we don't support this!}}
\DoxyCodeLine{1299    \textcolor{keywordflow}{if} (stbtt\_tag(font, \textcolor{stringliteral}{"{}OTTO"{}}))   \textcolor{keywordflow}{return} 1; \textcolor{comment}{// OpenType with CFF}}
\DoxyCodeLine{1300    \textcolor{keywordflow}{if} (stbtt\_tag4(font, 0,1,0,0)) \textcolor{keywordflow}{return} 1; \textcolor{comment}{// OpenType 1.0}}
\DoxyCodeLine{1301    \textcolor{keywordflow}{if} (stbtt\_tag(font, \textcolor{stringliteral}{"{}true"{}}))   \textcolor{keywordflow}{return} 1; \textcolor{comment}{// Apple specification for TrueType fonts}}
\DoxyCodeLine{1302    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1303 \}}
\DoxyCodeLine{1304 }
\DoxyCodeLine{1305 \textcolor{comment}{// @OPTIMIZE: binary search}}
\DoxyCodeLine{1306 \textcolor{keyword}{static} stbtt\_uint32 stbtt\_\_find\_table(stbtt\_uint8 *data, stbtt\_uint32 fontstart, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *tag)}
\DoxyCodeLine{1307 \{}
\DoxyCodeLine{1308    stbtt\_int32 num\_tables = ttUSHORT(data+fontstart+4);}
\DoxyCodeLine{1309    stbtt\_uint32 tabledir = fontstart + 12;}
\DoxyCodeLine{1310    stbtt\_int32 i;}
\DoxyCodeLine{1311    \textcolor{keywordflow}{for} (i=0; i < num\_tables; ++i) \{}
\DoxyCodeLine{1312       stbtt\_uint32 loc = tabledir + 16*i;}
\DoxyCodeLine{1313       \textcolor{keywordflow}{if} (stbtt\_tag(data+loc+0, tag))}
\DoxyCodeLine{1314          \textcolor{keywordflow}{return} ttULONG(data+loc+8);}
\DoxyCodeLine{1315    \}}
\DoxyCodeLine{1316    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1317 \}}
\DoxyCodeLine{1318 }
\DoxyCodeLine{1319 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_GetFontOffsetForIndex\_internal(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *font\_collection, \textcolor{keywordtype}{int} index)}
\DoxyCodeLine{1320 \{}
\DoxyCodeLine{1321    \textcolor{comment}{// if it's just a font, there's only one valid index}}
\DoxyCodeLine{1322    \textcolor{keywordflow}{if} (stbtt\_\_isfont(font\_collection))}
\DoxyCodeLine{1323       \textcolor{keywordflow}{return} index == 0 ? 0 : -\/1;}
\DoxyCodeLine{1324 }
\DoxyCodeLine{1325    \textcolor{comment}{// check if it's a TTC}}
\DoxyCodeLine{1326    \textcolor{keywordflow}{if} (stbtt\_tag(font\_collection, \textcolor{stringliteral}{"{}ttcf"{}})) \{}
\DoxyCodeLine{1327       \textcolor{comment}{// version 1?}}
\DoxyCodeLine{1328       \textcolor{keywordflow}{if} (ttULONG(font\_collection+4) == 0x00010000 || ttULONG(font\_collection+4) == 0x00020000) \{}
\DoxyCodeLine{1329          stbtt\_int32 n = ttLONG(font\_collection+8);}
\DoxyCodeLine{1330          \textcolor{keywordflow}{if} (index >= n)}
\DoxyCodeLine{1331             \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{1332          \textcolor{keywordflow}{return} ttULONG(font\_collection+12+index*4);}
\DoxyCodeLine{1333       \}}
\DoxyCodeLine{1334    \}}
\DoxyCodeLine{1335    \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{1336 \}}
\DoxyCodeLine{1337 }
\DoxyCodeLine{1338 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_GetNumberOfFonts\_internal(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *font\_collection)}
\DoxyCodeLine{1339 \{}
\DoxyCodeLine{1340    \textcolor{comment}{// if it's just a font, there's only one valid font}}
\DoxyCodeLine{1341    \textcolor{keywordflow}{if} (stbtt\_\_isfont(font\_collection))}
\DoxyCodeLine{1342       \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1343 }
\DoxyCodeLine{1344    \textcolor{comment}{// check if it's a TTC}}
\DoxyCodeLine{1345    \textcolor{keywordflow}{if} (stbtt\_tag(font\_collection, \textcolor{stringliteral}{"{}ttcf"{}})) \{}
\DoxyCodeLine{1346       \textcolor{comment}{// version 1?}}
\DoxyCodeLine{1347       \textcolor{keywordflow}{if} (ttULONG(font\_collection+4) == 0x00010000 || ttULONG(font\_collection+4) == 0x00020000) \{}
\DoxyCodeLine{1348          \textcolor{keywordflow}{return} ttLONG(font\_collection+8);}
\DoxyCodeLine{1349       \}}
\DoxyCodeLine{1350    \}}
\DoxyCodeLine{1351    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1352 \}}
\DoxyCodeLine{1353 }
\DoxyCodeLine{1354 \textcolor{keyword}{static} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} stbtt\_\_get\_subrs(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} cff, \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} fontdict)}
\DoxyCodeLine{1355 \{}
\DoxyCodeLine{1356    stbtt\_uint32 subrsoff = 0, private\_loc[2] = \{ 0, 0 \};}
\DoxyCodeLine{1357    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} pdict;}
\DoxyCodeLine{1358    stbtt\_\_dict\_get\_ints(\&fontdict, 18, 2, private\_loc);}
\DoxyCodeLine{1359    \textcolor{keywordflow}{if} (!private\_loc[1] || !private\_loc[0]) \textcolor{keywordflow}{return} stbtt\_\_new\_buf(NULL, 0);}
\DoxyCodeLine{1360    pdict = stbtt\_\_buf\_range(\&cff, private\_loc[1], private\_loc[0]);}
\DoxyCodeLine{1361    stbtt\_\_dict\_get\_ints(\&pdict, 19, 1, \&subrsoff);}
\DoxyCodeLine{1362    \textcolor{keywordflow}{if} (!subrsoff) \textcolor{keywordflow}{return} stbtt\_\_new\_buf(NULL, 0);}
\DoxyCodeLine{1363    stbtt\_\_buf\_seek(\&cff, private\_loc[1]+subrsoff);}
\DoxyCodeLine{1364    \textcolor{keywordflow}{return} stbtt\_\_cff\_get\_index(\&cff);}
\DoxyCodeLine{1365 \}}
\DoxyCodeLine{1366 }
\DoxyCodeLine{1367 \textcolor{comment}{// since most people won't use this, find this table the first time it's needed}}
\DoxyCodeLine{1368 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_get\_svg(\mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info)}
\DoxyCodeLine{1369 \{}
\DoxyCodeLine{1370    stbtt\_uint32 t;}
\DoxyCodeLine{1371    \textcolor{keywordflow}{if} (info-\/>svg < 0) \{}
\DoxyCodeLine{1372       t = stbtt\_\_find\_table(info-\/>data, info-\/>fontstart, \textcolor{stringliteral}{"{}SVG "{}});}
\DoxyCodeLine{1373       \textcolor{keywordflow}{if} (t) \{}
\DoxyCodeLine{1374          stbtt\_uint32 offset = ttULONG(info-\/>data + t + 2);}
\DoxyCodeLine{1375          info-\/>svg = t + offset;}
\DoxyCodeLine{1376       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1377          info-\/>svg = 0;}
\DoxyCodeLine{1378       \}}
\DoxyCodeLine{1379    \}}
\DoxyCodeLine{1380    \textcolor{keywordflow}{return} info-\/>svg;}
\DoxyCodeLine{1381 \}}
\DoxyCodeLine{1382 }
\DoxyCodeLine{1383 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_InitFont\_internal(\mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} fontstart)}
\DoxyCodeLine{1384 \{}
\DoxyCodeLine{1385    stbtt\_uint32 cmap, t;}
\DoxyCodeLine{1386    stbtt\_int32 i,numTables;}
\DoxyCodeLine{1387 }
\DoxyCodeLine{1388    info-\/>data = data;}
\DoxyCodeLine{1389    info-\/>fontstart = fontstart;}
\DoxyCodeLine{1390    info-\/>cff = stbtt\_\_new\_buf(NULL, 0);}
\DoxyCodeLine{1391 }
\DoxyCodeLine{1392    cmap = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}cmap"{}});       \textcolor{comment}{// required}}
\DoxyCodeLine{1393    info-\/>loca = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}loca"{}}); \textcolor{comment}{// required}}
\DoxyCodeLine{1394    info-\/>head = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}head"{}}); \textcolor{comment}{// required}}
\DoxyCodeLine{1395    info-\/>glyf = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}glyf"{}}); \textcolor{comment}{// required}}
\DoxyCodeLine{1396    info-\/>hhea = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}hhea"{}}); \textcolor{comment}{// required}}
\DoxyCodeLine{1397    info-\/>hmtx = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}hmtx"{}}); \textcolor{comment}{// required}}
\DoxyCodeLine{1398    info-\/>kern = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}kern"{}}); \textcolor{comment}{// not required}}
\DoxyCodeLine{1399    info-\/>gpos = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}GPOS"{}}); \textcolor{comment}{// not required}}
\DoxyCodeLine{1400 }
\DoxyCodeLine{1401    \textcolor{keywordflow}{if} (!cmap || !info-\/>head || !info-\/>hhea || !info-\/>hmtx)}
\DoxyCodeLine{1402       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1403    \textcolor{keywordflow}{if} (info-\/>glyf) \{}
\DoxyCodeLine{1404       \textcolor{comment}{// required for truetype}}
\DoxyCodeLine{1405       \textcolor{keywordflow}{if} (!info-\/>loca) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1406    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1407       \textcolor{comment}{// initialization for CFF / Type2 fonts (OTF)}}
\DoxyCodeLine{1408       \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} b, topdict, topdictidx;}
\DoxyCodeLine{1409       stbtt\_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;}
\DoxyCodeLine{1410       stbtt\_uint32 cff;}
\DoxyCodeLine{1411 }
\DoxyCodeLine{1412       cff = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}CFF "{}});}
\DoxyCodeLine{1413       \textcolor{keywordflow}{if} (!cff) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1414 }
\DoxyCodeLine{1415       info-\/>fontdicts = stbtt\_\_new\_buf(NULL, 0);}
\DoxyCodeLine{1416       info-\/>fdselect = stbtt\_\_new\_buf(NULL, 0);}
\DoxyCodeLine{1417 }
\DoxyCodeLine{1418       \textcolor{comment}{// @TODO this should use size from table (not 512MB)}}
\DoxyCodeLine{1419       info-\/>cff = stbtt\_\_new\_buf(data+cff, 512*1024*1024);}
\DoxyCodeLine{1420       b = info-\/>cff;}
\DoxyCodeLine{1421 }
\DoxyCodeLine{1422       \textcolor{comment}{// read the header}}
\DoxyCodeLine{1423       stbtt\_\_buf\_skip(\&b, 2);}
\DoxyCodeLine{1424       stbtt\_\_buf\_seek(\&b, stbtt\_\_buf\_get8(\&b)); \textcolor{comment}{// hdrsize}}
\DoxyCodeLine{1425 }
\DoxyCodeLine{1426       \textcolor{comment}{// @TODO the name INDEX could list multiple fonts,}}
\DoxyCodeLine{1427       \textcolor{comment}{// but we just use the first one.}}
\DoxyCodeLine{1428       stbtt\_\_cff\_get\_index(\&b);  \textcolor{comment}{// name INDEX}}
\DoxyCodeLine{1429       topdictidx = stbtt\_\_cff\_get\_index(\&b);}
\DoxyCodeLine{1430       topdict = stbtt\_\_cff\_index\_get(topdictidx, 0);}
\DoxyCodeLine{1431       stbtt\_\_cff\_get\_index(\&b);  \textcolor{comment}{// string INDEX}}
\DoxyCodeLine{1432       info-\/>gsubrs = stbtt\_\_cff\_get\_index(\&b);}
\DoxyCodeLine{1433 }
\DoxyCodeLine{1434       stbtt\_\_dict\_get\_ints(\&topdict, 17, 1, \&charstrings);}
\DoxyCodeLine{1435       stbtt\_\_dict\_get\_ints(\&topdict, 0x100 | 6, 1, \&cstype);}
\DoxyCodeLine{1436       stbtt\_\_dict\_get\_ints(\&topdict, 0x100 | 36, 1, \&fdarrayoff);}
\DoxyCodeLine{1437       stbtt\_\_dict\_get\_ints(\&topdict, 0x100 | 37, 1, \&fdselectoff);}
\DoxyCodeLine{1438       info-\/>subrs = stbtt\_\_get\_subrs(b, topdict);}
\DoxyCodeLine{1439 }
\DoxyCodeLine{1440       \textcolor{comment}{// we only support Type 2 charstrings}}
\DoxyCodeLine{1441       \textcolor{keywordflow}{if} (cstype != 2) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1442       \textcolor{keywordflow}{if} (charstrings == 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1443 }
\DoxyCodeLine{1444       \textcolor{keywordflow}{if} (fdarrayoff) \{}
\DoxyCodeLine{1445          \textcolor{comment}{// looks like a CID font}}
\DoxyCodeLine{1446          \textcolor{keywordflow}{if} (!fdselectoff) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1447          stbtt\_\_buf\_seek(\&b, fdarrayoff);}
\DoxyCodeLine{1448          info-\/>fontdicts = stbtt\_\_cff\_get\_index(\&b);}
\DoxyCodeLine{1449          info-\/>fdselect = stbtt\_\_buf\_range(\&b, fdselectoff, b.size-\/fdselectoff);}
\DoxyCodeLine{1450       \}}
\DoxyCodeLine{1451 }
\DoxyCodeLine{1452       stbtt\_\_buf\_seek(\&b, charstrings);}
\DoxyCodeLine{1453       info-\/>charstrings = stbtt\_\_cff\_get\_index(\&b);}
\DoxyCodeLine{1454    \}}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456    t = stbtt\_\_find\_table(data, fontstart, \textcolor{stringliteral}{"{}maxp"{}});}
\DoxyCodeLine{1457    \textcolor{keywordflow}{if} (t)}
\DoxyCodeLine{1458       info-\/>numGlyphs = ttUSHORT(data+t+4);}
\DoxyCodeLine{1459    \textcolor{keywordflow}{else}}
\DoxyCodeLine{1460       info-\/>numGlyphs = 0xffff;}
\DoxyCodeLine{1461 }
\DoxyCodeLine{1462    info-\/>svg = -\/1;}
\DoxyCodeLine{1463 }
\DoxyCodeLine{1464    \textcolor{comment}{// find a cmap encoding table we understand *now* to avoid searching}}
\DoxyCodeLine{1465    \textcolor{comment}{// later. (todo: could make this installable)}}
\DoxyCodeLine{1466    \textcolor{comment}{// the same regardless of glyph.}}
\DoxyCodeLine{1467    numTables = ttUSHORT(data + cmap + 2);}
\DoxyCodeLine{1468    info-\/>index\_map = 0;}
\DoxyCodeLine{1469    \textcolor{keywordflow}{for} (i=0; i < numTables; ++i) \{}
\DoxyCodeLine{1470       stbtt\_uint32 encoding\_record = cmap + 4 + 8 * i;}
\DoxyCodeLine{1471       \textcolor{comment}{// find an encoding we understand:}}
\DoxyCodeLine{1472       \textcolor{keywordflow}{switch}(ttUSHORT(data+encoding\_record)) \{}
\DoxyCodeLine{1473          \textcolor{keywordflow}{case} STBTT\_PLATFORM\_ID\_MICROSOFT:}
\DoxyCodeLine{1474             \textcolor{keywordflow}{switch} (ttUSHORT(data+encoding\_record+2)) \{}
\DoxyCodeLine{1475                \textcolor{keywordflow}{case} STBTT\_MS\_EID\_UNICODE\_BMP:}
\DoxyCodeLine{1476                \textcolor{keywordflow}{case} STBTT\_MS\_EID\_UNICODE\_FULL:}
\DoxyCodeLine{1477                   \textcolor{comment}{// MS/Unicode}}
\DoxyCodeLine{1478                   info-\/>index\_map = cmap + ttULONG(data+encoding\_record+4);}
\DoxyCodeLine{1479                   \textcolor{keywordflow}{break};}
\DoxyCodeLine{1480             \}}
\DoxyCodeLine{1481             \textcolor{keywordflow}{break};}
\DoxyCodeLine{1482         \textcolor{keywordflow}{case} STBTT\_PLATFORM\_ID\_UNICODE:}
\DoxyCodeLine{1483             \textcolor{comment}{// Mac/iOS has these}}
\DoxyCodeLine{1484             \textcolor{comment}{// all the encodingIDs are unicode, so we don't bother to check it}}
\DoxyCodeLine{1485             info-\/>index\_map = cmap + ttULONG(data+encoding\_record+4);}
\DoxyCodeLine{1486             \textcolor{keywordflow}{break};}
\DoxyCodeLine{1487       \}}
\DoxyCodeLine{1488    \}}
\DoxyCodeLine{1489    \textcolor{keywordflow}{if} (info-\/>index\_map == 0)}
\DoxyCodeLine{1490       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1491 }
\DoxyCodeLine{1492    info-\/>indexToLocFormat = ttUSHORT(data+info-\/>head + 50);}
\DoxyCodeLine{1493    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1494 \}}
\DoxyCodeLine{1495 }
\DoxyCodeLine{1496 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_FindGlyphIndex(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} unicode\_codepoint)}
\DoxyCodeLine{1497 \{}
\DoxyCodeLine{1498    stbtt\_uint8 *data = info-\/>data;}
\DoxyCodeLine{1499    stbtt\_uint32 index\_map = info-\/>index\_map;}
\DoxyCodeLine{1500 }
\DoxyCodeLine{1501    stbtt\_uint16 format = ttUSHORT(data + index\_map + 0);}
\DoxyCodeLine{1502    \textcolor{keywordflow}{if} (format == 0) \{ \textcolor{comment}{// apple byte encoding}}
\DoxyCodeLine{1503       stbtt\_int32 bytes = ttUSHORT(data + index\_map + 2);}
\DoxyCodeLine{1504       \textcolor{keywordflow}{if} (unicode\_codepoint < bytes-\/6)}
\DoxyCodeLine{1505          \textcolor{keywordflow}{return} ttBYTE(data + index\_map + 6 + unicode\_codepoint);}
\DoxyCodeLine{1506       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1507    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (format == 6) \{}
\DoxyCodeLine{1508       stbtt\_uint32 first = ttUSHORT(data + index\_map + 6);}
\DoxyCodeLine{1509       stbtt\_uint32 count = ttUSHORT(data + index\_map + 8);}
\DoxyCodeLine{1510       \textcolor{keywordflow}{if} ((stbtt\_uint32) unicode\_codepoint >= first \&\& (stbtt\_uint32) unicode\_codepoint < first+count)}
\DoxyCodeLine{1511          \textcolor{keywordflow}{return} ttUSHORT(data + index\_map + 10 + (unicode\_codepoint -\/ first)*2);}
\DoxyCodeLine{1512       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1513    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (format == 2) \{}
\DoxyCodeLine{1514       STBTT\_assert(0); \textcolor{comment}{// @TODO: high-\/byte mapping for japanese/chinese/korean}}
\DoxyCodeLine{1515       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1516    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (format == 4) \{ \textcolor{comment}{// standard mapping for windows fonts: binary search collection of ranges}}
\DoxyCodeLine{1517       stbtt\_uint16 segcount = ttUSHORT(data+index\_map+6) >> 1;}
\DoxyCodeLine{1518       stbtt\_uint16 searchRange = ttUSHORT(data+index\_map+8) >> 1;}
\DoxyCodeLine{1519       stbtt\_uint16 entrySelector = ttUSHORT(data+index\_map+10);}
\DoxyCodeLine{1520       stbtt\_uint16 rangeShift = ttUSHORT(data+index\_map+12) >> 1;}
\DoxyCodeLine{1521 }
\DoxyCodeLine{1522       \textcolor{comment}{// do a binary search of the segments}}
\DoxyCodeLine{1523       stbtt\_uint32 endCount = index\_map + 14;}
\DoxyCodeLine{1524       stbtt\_uint32 search = endCount;}
\DoxyCodeLine{1525 }
\DoxyCodeLine{1526       \textcolor{keywordflow}{if} (unicode\_codepoint > 0xffff)}
\DoxyCodeLine{1527          \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1528 }
\DoxyCodeLine{1529       \textcolor{comment}{// they lie from endCount .. endCount + segCount}}
\DoxyCodeLine{1530       \textcolor{comment}{// but searchRange is the nearest power of two, so...}}
\DoxyCodeLine{1531       \textcolor{keywordflow}{if} (unicode\_codepoint >= ttUSHORT(data + search + rangeShift*2))}
\DoxyCodeLine{1532          search += rangeShift*2;}
\DoxyCodeLine{1533 }
\DoxyCodeLine{1534       \textcolor{comment}{// now decrement to bias correctly to find smallest}}
\DoxyCodeLine{1535       search -\/= 2;}
\DoxyCodeLine{1536       \textcolor{keywordflow}{while} (entrySelector) \{}
\DoxyCodeLine{1537          stbtt\_uint16 end;}
\DoxyCodeLine{1538          searchRange >>= 1;}
\DoxyCodeLine{1539          end = ttUSHORT(data + search + searchRange*2);}
\DoxyCodeLine{1540          \textcolor{keywordflow}{if} (unicode\_codepoint > end)}
\DoxyCodeLine{1541             search += searchRange*2;}
\DoxyCodeLine{1542          -\/-\/entrySelector;}
\DoxyCodeLine{1543       \}}
\DoxyCodeLine{1544       search += 2;}
\DoxyCodeLine{1545 }
\DoxyCodeLine{1546       \{}
\DoxyCodeLine{1547          stbtt\_uint16 offset, start, last;}
\DoxyCodeLine{1548          stbtt\_uint16 item = (stbtt\_uint16) ((search -\/ endCount) >> 1);}
\DoxyCodeLine{1549 }
\DoxyCodeLine{1550          start = ttUSHORT(data + index\_map + 14 + segcount*2 + 2 + 2*item);}
\DoxyCodeLine{1551          last = ttUSHORT(data + endCount + 2*item);}
\DoxyCodeLine{1552          \textcolor{keywordflow}{if} (unicode\_codepoint < start || unicode\_codepoint > last)}
\DoxyCodeLine{1553             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1554 }
\DoxyCodeLine{1555          offset = ttUSHORT(data + index\_map + 14 + segcount*6 + 2 + 2*item);}
\DoxyCodeLine{1556          \textcolor{keywordflow}{if} (offset == 0)}
\DoxyCodeLine{1557             \textcolor{keywordflow}{return} (stbtt\_uint16) (unicode\_codepoint + ttSHORT(data + index\_map + 14 + segcount*4 + 2 + 2*item));}
\DoxyCodeLine{1558 }
\DoxyCodeLine{1559          \textcolor{keywordflow}{return} ttUSHORT(data + offset + (unicode\_codepoint-\/start)*2 + index\_map + 14 + segcount*6 + 2 + 2*item);}
\DoxyCodeLine{1560       \}}
\DoxyCodeLine{1561    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (format == 12 || format == 13) \{}
\DoxyCodeLine{1562       stbtt\_uint32 ngroups = ttULONG(data+index\_map+12);}
\DoxyCodeLine{1563       stbtt\_int32 low,high;}
\DoxyCodeLine{1564       low = 0; high = (stbtt\_int32)ngroups;}
\DoxyCodeLine{1565       \textcolor{comment}{// Binary search the right group.}}
\DoxyCodeLine{1566       \textcolor{keywordflow}{while} (low < high) \{}
\DoxyCodeLine{1567          stbtt\_int32 mid = low + ((high-\/low) >> 1); \textcolor{comment}{// rounds down, so low <= mid < high}}
\DoxyCodeLine{1568          stbtt\_uint32 start\_char = ttULONG(data+index\_map+16+mid*12);}
\DoxyCodeLine{1569          stbtt\_uint32 end\_char = ttULONG(data+index\_map+16+mid*12+4);}
\DoxyCodeLine{1570          \textcolor{keywordflow}{if} ((stbtt\_uint32) unicode\_codepoint < start\_char)}
\DoxyCodeLine{1571             high = mid;}
\DoxyCodeLine{1572          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((stbtt\_uint32) unicode\_codepoint > end\_char)}
\DoxyCodeLine{1573             low = mid+1;}
\DoxyCodeLine{1574          \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1575             stbtt\_uint32 start\_glyph = ttULONG(data+index\_map+16+mid*12+8);}
\DoxyCodeLine{1576             \textcolor{keywordflow}{if} (format == 12)}
\DoxyCodeLine{1577                \textcolor{keywordflow}{return} start\_glyph + unicode\_codepoint-\/start\_char;}
\DoxyCodeLine{1578             \textcolor{keywordflow}{else} \textcolor{comment}{// format == 13}}
\DoxyCodeLine{1579                \textcolor{keywordflow}{return} start\_glyph;}
\DoxyCodeLine{1580          \}}
\DoxyCodeLine{1581       \}}
\DoxyCodeLine{1582       \textcolor{keywordflow}{return} 0; \textcolor{comment}{// not found}}
\DoxyCodeLine{1583    \}}
\DoxyCodeLine{1584    \textcolor{comment}{// @TODO}}
\DoxyCodeLine{1585    STBTT\_assert(0);}
\DoxyCodeLine{1586    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1587 \}}
\DoxyCodeLine{1588 }
\DoxyCodeLine{1589 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetCodepointShape(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} unicode\_codepoint, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} **vertices)}
\DoxyCodeLine{1590 \{}
\DoxyCodeLine{1591    \textcolor{keywordflow}{return} stbtt\_GetGlyphShape(info, stbtt\_FindGlyphIndex(info, unicode\_codepoint), vertices);}
\DoxyCodeLine{1592 \}}
\DoxyCodeLine{1593 }
\DoxyCodeLine{1594 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_setvertex(\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *v, stbtt\_uint8 type, stbtt\_int32 x, stbtt\_int32 y, stbtt\_int32 cx, stbtt\_int32 cy)}
\DoxyCodeLine{1595 \{}
\DoxyCodeLine{1596    v-\/>type = type;}
\DoxyCodeLine{1597    v-\/>x = (stbtt\_int16) x;}
\DoxyCodeLine{1598    v-\/>y = (stbtt\_int16) y;}
\DoxyCodeLine{1599    v-\/>cx = (stbtt\_int16) cx;}
\DoxyCodeLine{1600    v-\/>cy = (stbtt\_int16) cy;}
\DoxyCodeLine{1601 \}}
\DoxyCodeLine{1602 }
\DoxyCodeLine{1603 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_GetGlyfOffset(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index)}
\DoxyCodeLine{1604 \{}
\DoxyCodeLine{1605    \textcolor{keywordtype}{int} g1,g2;}
\DoxyCodeLine{1606 }
\DoxyCodeLine{1607    STBTT\_assert(!info-\/>cff.size);}
\DoxyCodeLine{1608 }
\DoxyCodeLine{1609    \textcolor{keywordflow}{if} (glyph\_index >= info-\/>numGlyphs) \textcolor{keywordflow}{return} -\/1; \textcolor{comment}{// glyph index out of range}}
\DoxyCodeLine{1610    \textcolor{keywordflow}{if} (info-\/>indexToLocFormat >= 2)    \textcolor{keywordflow}{return} -\/1; \textcolor{comment}{// unknown index-\/>glyph map format}}
\DoxyCodeLine{1611 }
\DoxyCodeLine{1612    \textcolor{keywordflow}{if} (info-\/>indexToLocFormat == 0) \{}
\DoxyCodeLine{1613       g1 = info-\/>glyf + ttUSHORT(info-\/>data + info-\/>loca + glyph\_index * 2) * 2;}
\DoxyCodeLine{1614       g2 = info-\/>glyf + ttUSHORT(info-\/>data + info-\/>loca + glyph\_index * 2 + 2) * 2;}
\DoxyCodeLine{1615    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1616       g1 = info-\/>glyf + ttULONG (info-\/>data + info-\/>loca + glyph\_index * 4);}
\DoxyCodeLine{1617       g2 = info-\/>glyf + ttULONG (info-\/>data + info-\/>loca + glyph\_index * 4 + 4);}
\DoxyCodeLine{1618    \}}
\DoxyCodeLine{1619 }
\DoxyCodeLine{1620    \textcolor{keywordflow}{return} g1==g2 ? -\/1 : g1; \textcolor{comment}{// if length is 0, return -\/1}}
\DoxyCodeLine{1621 \}}
\DoxyCodeLine{1622 }
\DoxyCodeLine{1623 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_GetGlyphInfoT2(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \textcolor{keywordtype}{int} *x0, \textcolor{keywordtype}{int} *y0, \textcolor{keywordtype}{int} *x1, \textcolor{keywordtype}{int} *y1);}
\DoxyCodeLine{1624 }
\DoxyCodeLine{1625 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetGlyphBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \textcolor{keywordtype}{int} *x0, \textcolor{keywordtype}{int} *y0, \textcolor{keywordtype}{int} *x1, \textcolor{keywordtype}{int} *y1)}
\DoxyCodeLine{1626 \{}
\DoxyCodeLine{1627    \textcolor{keywordflow}{if} (info-\/>cff.size) \{}
\DoxyCodeLine{1628       stbtt\_\_GetGlyphInfoT2(info, glyph\_index, x0, y0, x1, y1);}
\DoxyCodeLine{1629    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1630       \textcolor{keywordtype}{int} g = stbtt\_\_GetGlyfOffset(info, glyph\_index);}
\DoxyCodeLine{1631       \textcolor{keywordflow}{if} (g < 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1632 }
\DoxyCodeLine{1633       \textcolor{keywordflow}{if} (x0) *x0 = ttSHORT(info-\/>data + g + 2);}
\DoxyCodeLine{1634       \textcolor{keywordflow}{if} (y0) *y0 = ttSHORT(info-\/>data + g + 4);}
\DoxyCodeLine{1635       \textcolor{keywordflow}{if} (x1) *x1 = ttSHORT(info-\/>data + g + 6);}
\DoxyCodeLine{1636       \textcolor{keywordflow}{if} (y1) *y1 = ttSHORT(info-\/>data + g + 8);}
\DoxyCodeLine{1637    \}}
\DoxyCodeLine{1638    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1639 \}}
\DoxyCodeLine{1640 }
\DoxyCodeLine{1641 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetCodepointBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} *x0, \textcolor{keywordtype}{int} *y0, \textcolor{keywordtype}{int} *x1, \textcolor{keywordtype}{int} *y1)}
\DoxyCodeLine{1642 \{}
\DoxyCodeLine{1643    \textcolor{keywordflow}{return} stbtt\_GetGlyphBox(info, stbtt\_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);}
\DoxyCodeLine{1644 \}}
\DoxyCodeLine{1645 }
\DoxyCodeLine{1646 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_IsGlyphEmpty(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index)}
\DoxyCodeLine{1647 \{}
\DoxyCodeLine{1648    stbtt\_int16 numberOfContours;}
\DoxyCodeLine{1649    \textcolor{keywordtype}{int} g;}
\DoxyCodeLine{1650    \textcolor{keywordflow}{if} (info-\/>cff.size)}
\DoxyCodeLine{1651       \textcolor{keywordflow}{return} stbtt\_\_GetGlyphInfoT2(info, glyph\_index, NULL, NULL, NULL, NULL) == 0;}
\DoxyCodeLine{1652    g = stbtt\_\_GetGlyfOffset(info, glyph\_index);}
\DoxyCodeLine{1653    \textcolor{keywordflow}{if} (g < 0) \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1654    numberOfContours = ttSHORT(info-\/>data + g);}
\DoxyCodeLine{1655    \textcolor{keywordflow}{return} numberOfContours == 0;}
\DoxyCodeLine{1656 \}}
\DoxyCodeLine{1657 }
\DoxyCodeLine{1658 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_close\_shape(\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *vertices, \textcolor{keywordtype}{int} num\_vertices, \textcolor{keywordtype}{int} was\_off, \textcolor{keywordtype}{int} start\_off,}
\DoxyCodeLine{1659     stbtt\_int32 sx, stbtt\_int32 sy, stbtt\_int32 scx, stbtt\_int32 scy, stbtt\_int32 cx, stbtt\_int32 cy)}
\DoxyCodeLine{1660 \{}
\DoxyCodeLine{1661    \textcolor{keywordflow}{if} (start\_off) \{}
\DoxyCodeLine{1662       \textcolor{keywordflow}{if} (was\_off)}
\DoxyCodeLine{1663          stbtt\_setvertex(\&vertices[num\_vertices++], STBTT\_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);}
\DoxyCodeLine{1664       stbtt\_setvertex(\&vertices[num\_vertices++], STBTT\_vcurve, sx,sy,scx,scy);}
\DoxyCodeLine{1665    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1666       \textcolor{keywordflow}{if} (was\_off)}
\DoxyCodeLine{1667          stbtt\_setvertex(\&vertices[num\_vertices++], STBTT\_vcurve,sx,sy,cx,cy);}
\DoxyCodeLine{1668       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1669          stbtt\_setvertex(\&vertices[num\_vertices++], STBTT\_vline,sx,sy,0,0);}
\DoxyCodeLine{1670    \}}
\DoxyCodeLine{1671    \textcolor{keywordflow}{return} num\_vertices;}
\DoxyCodeLine{1672 \}}
\DoxyCodeLine{1673 }
\DoxyCodeLine{1674 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_GetGlyphShapeTT(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} **pvertices)}
\DoxyCodeLine{1675 \{}
\DoxyCodeLine{1676    stbtt\_int16 numberOfContours;}
\DoxyCodeLine{1677    stbtt\_uint8 *endPtsOfContours;}
\DoxyCodeLine{1678    stbtt\_uint8 *data = info-\/>data;}
\DoxyCodeLine{1679    \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *vertices=0;}
\DoxyCodeLine{1680    \textcolor{keywordtype}{int} num\_vertices=0;}
\DoxyCodeLine{1681    \textcolor{keywordtype}{int} g = stbtt\_\_GetGlyfOffset(info, glyph\_index);}
\DoxyCodeLine{1682 }
\DoxyCodeLine{1683    *pvertices = NULL;}
\DoxyCodeLine{1684 }
\DoxyCodeLine{1685    \textcolor{keywordflow}{if} (g < 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1686 }
\DoxyCodeLine{1687    numberOfContours = ttSHORT(data + g);}
\DoxyCodeLine{1688 }
\DoxyCodeLine{1689    \textcolor{keywordflow}{if} (numberOfContours > 0) \{}
\DoxyCodeLine{1690       stbtt\_uint8 flags=0,flagcount;}
\DoxyCodeLine{1691       stbtt\_int32 ins, i,j=0,m,n, next\_move, was\_off=0, off, start\_off=0;}
\DoxyCodeLine{1692       stbtt\_int32 x,y,cx,cy,sx,sy, scx,scy;}
\DoxyCodeLine{1693       stbtt\_uint8 *points;}
\DoxyCodeLine{1694       endPtsOfContours = (data + g + 10);}
\DoxyCodeLine{1695       ins = ttUSHORT(data + g + 10 + numberOfContours * 2);}
\DoxyCodeLine{1696       points = data + g + 10 + numberOfContours * 2 + 2 + ins;}
\DoxyCodeLine{1697 }
\DoxyCodeLine{1698       n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-\/2);}
\DoxyCodeLine{1699 }
\DoxyCodeLine{1700       m = n + 2*numberOfContours;  \textcolor{comment}{// a loose bound on how many vertices we might need}}
\DoxyCodeLine{1701       vertices = (\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *) STBTT\_malloc(m * \textcolor{keyword}{sizeof}(vertices[0]), info-\/>userdata);}
\DoxyCodeLine{1702       \textcolor{keywordflow}{if} (vertices == 0)}
\DoxyCodeLine{1703          \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1704 }
\DoxyCodeLine{1705       next\_move = 0;}
\DoxyCodeLine{1706       flagcount=0;}
\DoxyCodeLine{1707 }
\DoxyCodeLine{1708       \textcolor{comment}{// in first pass, we load uninterpreted data into the allocated array}}
\DoxyCodeLine{1709       \textcolor{comment}{// above, shifted to the end of the array so we won't overwrite it when}}
\DoxyCodeLine{1710       \textcolor{comment}{// we create our final data starting from the front}}
\DoxyCodeLine{1711 }
\DoxyCodeLine{1712       off = m -\/ n; \textcolor{comment}{// starting offset for uninterpreted data, regardless of how m ends up being calculated}}
\DoxyCodeLine{1713 }
\DoxyCodeLine{1714       \textcolor{comment}{// first load flags}}
\DoxyCodeLine{1715 }
\DoxyCodeLine{1716       \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{1717          \textcolor{keywordflow}{if} (flagcount == 0) \{}
\DoxyCodeLine{1718             flags = *points++;}
\DoxyCodeLine{1719             \textcolor{keywordflow}{if} (flags \& 8)}
\DoxyCodeLine{1720                flagcount = *points++;}
\DoxyCodeLine{1721          \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{1722             -\/-\/flagcount;}
\DoxyCodeLine{1723          vertices[off+i].type = flags;}
\DoxyCodeLine{1724       \}}
\DoxyCodeLine{1725 }
\DoxyCodeLine{1726       \textcolor{comment}{// now load x coordinates}}
\DoxyCodeLine{1727       x=0;}
\DoxyCodeLine{1728       \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{1729          flags = vertices[off+i].type;}
\DoxyCodeLine{1730          \textcolor{keywordflow}{if} (flags \& 2) \{}
\DoxyCodeLine{1731             stbtt\_int16 dx = *points++;}
\DoxyCodeLine{1732             x += (flags \& 16) ? dx : -\/dx; \textcolor{comment}{// ???}}
\DoxyCodeLine{1733          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1734             \textcolor{keywordflow}{if} (!(flags \& 16)) \{}
\DoxyCodeLine{1735                x = x + (stbtt\_int16) (points[0]*256 + points[1]);}
\DoxyCodeLine{1736                points += 2;}
\DoxyCodeLine{1737             \}}
\DoxyCodeLine{1738          \}}
\DoxyCodeLine{1739          vertices[off+i].x = (stbtt\_int16) x;}
\DoxyCodeLine{1740       \}}
\DoxyCodeLine{1741 }
\DoxyCodeLine{1742       \textcolor{comment}{// now load y coordinates}}
\DoxyCodeLine{1743       y=0;}
\DoxyCodeLine{1744       \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{1745          flags = vertices[off+i].type;}
\DoxyCodeLine{1746          \textcolor{keywordflow}{if} (flags \& 4) \{}
\DoxyCodeLine{1747             stbtt\_int16 dy = *points++;}
\DoxyCodeLine{1748             y += (flags \& 32) ? dy : -\/dy; \textcolor{comment}{// ???}}
\DoxyCodeLine{1749          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1750             \textcolor{keywordflow}{if} (!(flags \& 32)) \{}
\DoxyCodeLine{1751                y = y + (stbtt\_int16) (points[0]*256 + points[1]);}
\DoxyCodeLine{1752                points += 2;}
\DoxyCodeLine{1753             \}}
\DoxyCodeLine{1754          \}}
\DoxyCodeLine{1755          vertices[off+i].y = (stbtt\_int16) y;}
\DoxyCodeLine{1756       \}}
\DoxyCodeLine{1757 }
\DoxyCodeLine{1758       \textcolor{comment}{// now convert them to our format}}
\DoxyCodeLine{1759       num\_vertices=0;}
\DoxyCodeLine{1760       sx = sy = cx = cy = scx = scy = 0;}
\DoxyCodeLine{1761       \textcolor{keywordflow}{for} (i=0; i < n; ++i) \{}
\DoxyCodeLine{1762          flags = vertices[off+i].type;}
\DoxyCodeLine{1763          x     = (stbtt\_int16) vertices[off+i].x;}
\DoxyCodeLine{1764          y     = (stbtt\_int16) vertices[off+i].y;}
\DoxyCodeLine{1765 }
\DoxyCodeLine{1766          \textcolor{keywordflow}{if} (next\_move == i) \{}
\DoxyCodeLine{1767             \textcolor{keywordflow}{if} (i != 0)}
\DoxyCodeLine{1768                num\_vertices = stbtt\_\_close\_shape(vertices, num\_vertices, was\_off, start\_off, sx,sy,scx,scy,cx,cy);}
\DoxyCodeLine{1769 }
\DoxyCodeLine{1770             \textcolor{comment}{// now start the new one}}
\DoxyCodeLine{1771             start\_off = !(flags \& 1);}
\DoxyCodeLine{1772             \textcolor{keywordflow}{if} (start\_off) \{}
\DoxyCodeLine{1773                \textcolor{comment}{// if we start off with an off-\/curve point, then when we need to find a point on the curve}}
\DoxyCodeLine{1774                \textcolor{comment}{// where we can start, and we need to save some state for when we wraparound.}}
\DoxyCodeLine{1775                scx = x;}
\DoxyCodeLine{1776                scy = y;}
\DoxyCodeLine{1777                \textcolor{keywordflow}{if} (!(vertices[off+i+1].type \& 1)) \{}
\DoxyCodeLine{1778                   \textcolor{comment}{// next point is also a curve point, so interpolate an on-\/point curve}}
\DoxyCodeLine{1779                   sx = (x + (stbtt\_int32) vertices[off+i+1].x) >> 1;}
\DoxyCodeLine{1780                   sy = (y + (stbtt\_int32) vertices[off+i+1].y) >> 1;}
\DoxyCodeLine{1781                \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1782                   \textcolor{comment}{// otherwise just use the next point as our start point}}
\DoxyCodeLine{1783                   sx = (stbtt\_int32) vertices[off+i+1].x;}
\DoxyCodeLine{1784                   sy = (stbtt\_int32) vertices[off+i+1].y;}
\DoxyCodeLine{1785                   ++i; \textcolor{comment}{// we're using point i+1 as the starting point, so skip it}}
\DoxyCodeLine{1786                \}}
\DoxyCodeLine{1787             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1788                sx = x;}
\DoxyCodeLine{1789                sy = y;}
\DoxyCodeLine{1790             \}}
\DoxyCodeLine{1791             stbtt\_setvertex(\&vertices[num\_vertices++], STBTT\_vmove,sx,sy,0,0);}
\DoxyCodeLine{1792             was\_off = 0;}
\DoxyCodeLine{1793             next\_move = 1 + ttUSHORT(endPtsOfContours+j*2);}
\DoxyCodeLine{1794             ++j;}
\DoxyCodeLine{1795          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1796             \textcolor{keywordflow}{if} (!(flags \& 1)) \{ \textcolor{comment}{// if it's a curve}}
\DoxyCodeLine{1797                \textcolor{keywordflow}{if} (was\_off) \textcolor{comment}{// two off-\/curve control points in a row means interpolate an on-\/curve midpoint}}
\DoxyCodeLine{1798                   stbtt\_setvertex(\&vertices[num\_vertices++], STBTT\_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);}
\DoxyCodeLine{1799                cx = x;}
\DoxyCodeLine{1800                cy = y;}
\DoxyCodeLine{1801                was\_off = 1;}
\DoxyCodeLine{1802             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1803                \textcolor{keywordflow}{if} (was\_off)}
\DoxyCodeLine{1804                   stbtt\_setvertex(\&vertices[num\_vertices++], STBTT\_vcurve, x,y, cx, cy);}
\DoxyCodeLine{1805                \textcolor{keywordflow}{else}}
\DoxyCodeLine{1806                   stbtt\_setvertex(\&vertices[num\_vertices++], STBTT\_vline, x,y,0,0);}
\DoxyCodeLine{1807                was\_off = 0;}
\DoxyCodeLine{1808             \}}
\DoxyCodeLine{1809          \}}
\DoxyCodeLine{1810       \}}
\DoxyCodeLine{1811       num\_vertices = stbtt\_\_close\_shape(vertices, num\_vertices, was\_off, start\_off, sx,sy,scx,scy,cx,cy);}
\DoxyCodeLine{1812    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (numberOfContours < 0) \{}
\DoxyCodeLine{1813       \textcolor{comment}{// Compound shapes.}}
\DoxyCodeLine{1814       \textcolor{keywordtype}{int} more = 1;}
\DoxyCodeLine{1815       stbtt\_uint8 *comp = data + g + 10;}
\DoxyCodeLine{1816       num\_vertices = 0;}
\DoxyCodeLine{1817       vertices = 0;}
\DoxyCodeLine{1818       \textcolor{keywordflow}{while} (more) \{}
\DoxyCodeLine{1819          stbtt\_uint16 flags, gidx;}
\DoxyCodeLine{1820          \textcolor{keywordtype}{int} comp\_num\_verts = 0, i;}
\DoxyCodeLine{1821          \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *comp\_verts = 0, *tmp = 0;}
\DoxyCodeLine{1822          \textcolor{keywordtype}{float} mtx[6] = \{1,0,0,1,0,0\}, m, n;}
\DoxyCodeLine{1823 }
\DoxyCodeLine{1824          flags = ttSHORT(comp); comp+=2;}
\DoxyCodeLine{1825          gidx = ttSHORT(comp); comp+=2;}
\DoxyCodeLine{1826 }
\DoxyCodeLine{1827          \textcolor{keywordflow}{if} (flags \& 2) \{ \textcolor{comment}{// XY values}}
\DoxyCodeLine{1828             \textcolor{keywordflow}{if} (flags \& 1) \{ \textcolor{comment}{// shorts}}
\DoxyCodeLine{1829                mtx[4] = ttSHORT(comp); comp+=2;}
\DoxyCodeLine{1830                mtx[5] = ttSHORT(comp); comp+=2;}
\DoxyCodeLine{1831             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1832                mtx[4] = ttCHAR(comp); comp+=1;}
\DoxyCodeLine{1833                mtx[5] = ttCHAR(comp); comp+=1;}
\DoxyCodeLine{1834             \}}
\DoxyCodeLine{1835          \}}
\DoxyCodeLine{1836          \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1837             \textcolor{comment}{// @TODO handle matching point}}
\DoxyCodeLine{1838             STBTT\_assert(0);}
\DoxyCodeLine{1839          \}}
\DoxyCodeLine{1840          \textcolor{keywordflow}{if} (flags \& (1<<3)) \{ \textcolor{comment}{// WE\_HAVE\_A\_SCALE}}
\DoxyCodeLine{1841             mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;}
\DoxyCodeLine{1842             mtx[1] = mtx[2] = 0;}
\DoxyCodeLine{1843          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (flags \& (1<<6)) \{ \textcolor{comment}{// WE\_HAVE\_AN\_X\_AND\_YSCALE}}
\DoxyCodeLine{1844             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;}
\DoxyCodeLine{1845             mtx[1] = mtx[2] = 0;}
\DoxyCodeLine{1846             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;}
\DoxyCodeLine{1847          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (flags \& (1<<7)) \{ \textcolor{comment}{// WE\_HAVE\_A\_TWO\_BY\_TWO}}
\DoxyCodeLine{1848             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;}
\DoxyCodeLine{1849             mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;}
\DoxyCodeLine{1850             mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;}
\DoxyCodeLine{1851             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;}
\DoxyCodeLine{1852          \}}
\DoxyCodeLine{1853 }
\DoxyCodeLine{1854          \textcolor{comment}{// Find transformation scales.}}
\DoxyCodeLine{1855          m = (float) STBTT\_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);}
\DoxyCodeLine{1856          n = (float) STBTT\_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);}
\DoxyCodeLine{1857 }
\DoxyCodeLine{1858          \textcolor{comment}{// Get indexed glyph.}}
\DoxyCodeLine{1859          comp\_num\_verts = stbtt\_GetGlyphShape(info, gidx, \&comp\_verts);}
\DoxyCodeLine{1860          \textcolor{keywordflow}{if} (comp\_num\_verts > 0) \{}
\DoxyCodeLine{1861             \textcolor{comment}{// Transform vertices.}}
\DoxyCodeLine{1862             \textcolor{keywordflow}{for} (i = 0; i < comp\_num\_verts; ++i) \{}
\DoxyCodeLine{1863                \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}}* v = \&comp\_verts[i];}
\DoxyCodeLine{1864                stbtt\_vertex\_type x,y;}
\DoxyCodeLine{1865                x=v-\/>x; y=v-\/>y;}
\DoxyCodeLine{1866                v-\/>x = (stbtt\_vertex\_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));}
\DoxyCodeLine{1867                v-\/>y = (stbtt\_vertex\_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));}
\DoxyCodeLine{1868                x=v-\/>cx; y=v-\/>cy;}
\DoxyCodeLine{1869                v-\/>cx = (stbtt\_vertex\_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));}
\DoxyCodeLine{1870                v-\/>cy = (stbtt\_vertex\_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));}
\DoxyCodeLine{1871             \}}
\DoxyCodeLine{1872             \textcolor{comment}{// Append vertices.}}
\DoxyCodeLine{1873             tmp = (\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}}*)STBTT\_malloc((num\_vertices+comp\_num\_verts)*\textcolor{keyword}{sizeof}(\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}}), info-\/>userdata);}
\DoxyCodeLine{1874             \textcolor{keywordflow}{if} (!tmp) \{}
\DoxyCodeLine{1875                \textcolor{keywordflow}{if} (vertices) STBTT\_free(vertices, info-\/>userdata);}
\DoxyCodeLine{1876                \textcolor{keywordflow}{if} (comp\_verts) STBTT\_free(comp\_verts, info-\/>userdata);}
\DoxyCodeLine{1877                \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1878             \}}
\DoxyCodeLine{1879             \textcolor{keywordflow}{if} (num\_vertices > 0 \&\& vertices) STBTT\_memcpy(tmp, vertices, num\_vertices*\textcolor{keyword}{sizeof}(\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}}));}
\DoxyCodeLine{1880             STBTT\_memcpy(tmp+num\_vertices, comp\_verts, comp\_num\_verts*\textcolor{keyword}{sizeof}(\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}}));}
\DoxyCodeLine{1881             \textcolor{keywordflow}{if} (vertices) STBTT\_free(vertices, info-\/>userdata);}
\DoxyCodeLine{1882             vertices = tmp;}
\DoxyCodeLine{1883             STBTT\_free(comp\_verts, info-\/>userdata);}
\DoxyCodeLine{1884             num\_vertices += comp\_num\_verts;}
\DoxyCodeLine{1885          \}}
\DoxyCodeLine{1886          \textcolor{comment}{// More components ?}}
\DoxyCodeLine{1887          more = flags \& (1<<5);}
\DoxyCodeLine{1888       \}}
\DoxyCodeLine{1889    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1890       \textcolor{comment}{// numberOfCounters == 0, do nothing}}
\DoxyCodeLine{1891    \}}
\DoxyCodeLine{1892 }
\DoxyCodeLine{1893    *pvertices = vertices;}
\DoxyCodeLine{1894    \textcolor{keywordflow}{return} num\_vertices;}
\DoxyCodeLine{1895 \}}
\DoxyCodeLine{1896 }
\DoxyCodeLine{1897 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{1898 \{}
\DoxyCodeLine{1899    \textcolor{keywordtype}{int} bounds;}
\DoxyCodeLine{1900    \textcolor{keywordtype}{int} started;}
\DoxyCodeLine{1901    \textcolor{keywordtype}{float} first\_x, first\_y;}
\DoxyCodeLine{1902    \textcolor{keywordtype}{float} x, y;}
\DoxyCodeLine{1903    stbtt\_int32 min\_x, max\_x, min\_y, max\_y;}
\DoxyCodeLine{1904 }
\DoxyCodeLine{1905    \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *pvertices;}
\DoxyCodeLine{1906    \textcolor{keywordtype}{int} num\_vertices;}
\DoxyCodeLine{1907 \} stbtt\_\_csctx;}
\DoxyCodeLine{1908 }
\DoxyCodeLine{1909 \textcolor{preprocessor}{\#define STBTT\_\_CSCTX\_INIT(bounds) \{bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0\}}}
\DoxyCodeLine{1910 }
\DoxyCodeLine{1911 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_track\_vertex(stbtt\_\_csctx *c, stbtt\_int32 x, stbtt\_int32 y)}
\DoxyCodeLine{1912 \{}
\DoxyCodeLine{1913    \textcolor{keywordflow}{if} (x > c-\/>max\_x || !c-\/>started) c-\/>max\_x = x;}
\DoxyCodeLine{1914    \textcolor{keywordflow}{if} (y > c-\/>max\_y || !c-\/>started) c-\/>max\_y = y;}
\DoxyCodeLine{1915    \textcolor{keywordflow}{if} (x < c-\/>min\_x || !c-\/>started) c-\/>min\_x = x;}
\DoxyCodeLine{1916    \textcolor{keywordflow}{if} (y < c-\/>min\_y || !c-\/>started) c-\/>min\_y = y;}
\DoxyCodeLine{1917    c-\/>started = 1;}
\DoxyCodeLine{1918 \}}
\DoxyCodeLine{1919 }
\DoxyCodeLine{1920 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_csctx\_v(stbtt\_\_csctx *c, stbtt\_uint8 type, stbtt\_int32 x, stbtt\_int32 y, stbtt\_int32 cx, stbtt\_int32 cy, stbtt\_int32 cx1, stbtt\_int32 cy1)}
\DoxyCodeLine{1921 \{}
\DoxyCodeLine{1922    \textcolor{keywordflow}{if} (c-\/>bounds) \{}
\DoxyCodeLine{1923       stbtt\_\_track\_vertex(c, x, y);}
\DoxyCodeLine{1924       \textcolor{keywordflow}{if} (type == STBTT\_vcubic) \{}
\DoxyCodeLine{1925          stbtt\_\_track\_vertex(c, cx, cy);}
\DoxyCodeLine{1926          stbtt\_\_track\_vertex(c, cx1, cy1);}
\DoxyCodeLine{1927       \}}
\DoxyCodeLine{1928    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1929       stbtt\_setvertex(\&c-\/>pvertices[c-\/>num\_vertices], type, x, y, cx, cy);}
\DoxyCodeLine{1930       c-\/>pvertices[c-\/>num\_vertices].cx1 = (stbtt\_int16) cx1;}
\DoxyCodeLine{1931       c-\/>pvertices[c-\/>num\_vertices].cy1 = (stbtt\_int16) cy1;}
\DoxyCodeLine{1932    \}}
\DoxyCodeLine{1933    c-\/>num\_vertices++;}
\DoxyCodeLine{1934 \}}
\DoxyCodeLine{1935 }
\DoxyCodeLine{1936 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_csctx\_close\_shape(stbtt\_\_csctx *ctx)}
\DoxyCodeLine{1937 \{}
\DoxyCodeLine{1938    \textcolor{keywordflow}{if} (ctx-\/>first\_x != ctx-\/>x || ctx-\/>first\_y != ctx-\/>y)}
\DoxyCodeLine{1939       stbtt\_\_csctx\_v(ctx, STBTT\_vline, (\textcolor{keywordtype}{int})ctx-\/>first\_x, (\textcolor{keywordtype}{int})ctx-\/>first\_y, 0, 0, 0, 0);}
\DoxyCodeLine{1940 \}}
\DoxyCodeLine{1941 }
\DoxyCodeLine{1942 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_csctx\_rmove\_to(stbtt\_\_csctx *ctx, \textcolor{keywordtype}{float} dx, \textcolor{keywordtype}{float} dy)}
\DoxyCodeLine{1943 \{}
\DoxyCodeLine{1944    stbtt\_\_csctx\_close\_shape(ctx);}
\DoxyCodeLine{1945    ctx-\/>first\_x = ctx-\/>x = ctx-\/>x + dx;}
\DoxyCodeLine{1946    ctx-\/>first\_y = ctx-\/>y = ctx-\/>y + dy;}
\DoxyCodeLine{1947    stbtt\_\_csctx\_v(ctx, STBTT\_vmove, (\textcolor{keywordtype}{int})ctx-\/>x, (\textcolor{keywordtype}{int})ctx-\/>y, 0, 0, 0, 0);}
\DoxyCodeLine{1948 \}}
\DoxyCodeLine{1949 }
\DoxyCodeLine{1950 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_csctx\_rline\_to(stbtt\_\_csctx *ctx, \textcolor{keywordtype}{float} dx, \textcolor{keywordtype}{float} dy)}
\DoxyCodeLine{1951 \{}
\DoxyCodeLine{1952    ctx-\/>x += dx;}
\DoxyCodeLine{1953    ctx-\/>y += dy;}
\DoxyCodeLine{1954    stbtt\_\_csctx\_v(ctx, STBTT\_vline, (\textcolor{keywordtype}{int})ctx-\/>x, (\textcolor{keywordtype}{int})ctx-\/>y, 0, 0, 0, 0);}
\DoxyCodeLine{1955 \}}
\DoxyCodeLine{1956 }
\DoxyCodeLine{1957 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_csctx\_rccurve\_to(stbtt\_\_csctx *ctx, \textcolor{keywordtype}{float} dx1, \textcolor{keywordtype}{float} dy1, \textcolor{keywordtype}{float} dx2, \textcolor{keywordtype}{float} dy2, \textcolor{keywordtype}{float} dx3, \textcolor{keywordtype}{float} dy3)}
\DoxyCodeLine{1958 \{}
\DoxyCodeLine{1959    \textcolor{keywordtype}{float} cx1 = ctx-\/>x + dx1;}
\DoxyCodeLine{1960    \textcolor{keywordtype}{float} cy1 = ctx-\/>y + dy1;}
\DoxyCodeLine{1961    \textcolor{keywordtype}{float} cx2 = cx1 + dx2;}
\DoxyCodeLine{1962    \textcolor{keywordtype}{float} cy2 = cy1 + dy2;}
\DoxyCodeLine{1963    ctx-\/>x = cx2 + dx3;}
\DoxyCodeLine{1964    ctx-\/>y = cy2 + dy3;}
\DoxyCodeLine{1965    stbtt\_\_csctx\_v(ctx, STBTT\_vcubic, (\textcolor{keywordtype}{int})ctx-\/>x, (\textcolor{keywordtype}{int})ctx-\/>y, (\textcolor{keywordtype}{int})cx1, (\textcolor{keywordtype}{int})cy1, (\textcolor{keywordtype}{int})cx2, (\textcolor{keywordtype}{int})cy2);}
\DoxyCodeLine{1966 \}}
\DoxyCodeLine{1967 }
\DoxyCodeLine{1968 \textcolor{keyword}{static} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} stbtt\_\_get\_subr(\mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} idx, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{1969 \{}
\DoxyCodeLine{1970    \textcolor{keywordtype}{int} count = stbtt\_\_cff\_index\_count(\&idx);}
\DoxyCodeLine{1971    \textcolor{keywordtype}{int} bias = 107;}
\DoxyCodeLine{1972    \textcolor{keywordflow}{if} (count >= 33900)}
\DoxyCodeLine{1973       bias = 32768;}
\DoxyCodeLine{1974    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (count >= 1240)}
\DoxyCodeLine{1975       bias = 1131;}
\DoxyCodeLine{1976    n += bias;}
\DoxyCodeLine{1977    \textcolor{keywordflow}{if} (n < 0 || n >= count)}
\DoxyCodeLine{1978       \textcolor{keywordflow}{return} stbtt\_\_new\_buf(NULL, 0);}
\DoxyCodeLine{1979    \textcolor{keywordflow}{return} stbtt\_\_cff\_index\_get(idx, n);}
\DoxyCodeLine{1980 \}}
\DoxyCodeLine{1981 }
\DoxyCodeLine{1982 \textcolor{keyword}{static} \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} stbtt\_\_cid\_get\_glyph\_subrs(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index)}
\DoxyCodeLine{1983 \{}
\DoxyCodeLine{1984    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} fdselect = info-\/>fdselect;}
\DoxyCodeLine{1985    \textcolor{keywordtype}{int} nranges, start, end, v, fmt, fdselector = -\/1, i;}
\DoxyCodeLine{1986 }
\DoxyCodeLine{1987    stbtt\_\_buf\_seek(\&fdselect, 0);}
\DoxyCodeLine{1988    fmt = stbtt\_\_buf\_get8(\&fdselect);}
\DoxyCodeLine{1989    \textcolor{keywordflow}{if} (fmt == 0) \{}
\DoxyCodeLine{1990       \textcolor{comment}{// untested}}
\DoxyCodeLine{1991       stbtt\_\_buf\_skip(\&fdselect, glyph\_index);}
\DoxyCodeLine{1992       fdselector = stbtt\_\_buf\_get8(\&fdselect);}
\DoxyCodeLine{1993    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (fmt == 3) \{}
\DoxyCodeLine{1994       nranges = stbtt\_\_buf\_get16(\&fdselect);}
\DoxyCodeLine{1995       start = stbtt\_\_buf\_get16(\&fdselect);}
\DoxyCodeLine{1996       \textcolor{keywordflow}{for} (i = 0; i < nranges; i++) \{}
\DoxyCodeLine{1997          v = stbtt\_\_buf\_get8(\&fdselect);}
\DoxyCodeLine{1998          end = stbtt\_\_buf\_get16(\&fdselect);}
\DoxyCodeLine{1999          \textcolor{keywordflow}{if} (glyph\_index >= start \&\& glyph\_index < end) \{}
\DoxyCodeLine{2000             fdselector = v;}
\DoxyCodeLine{2001             \textcolor{keywordflow}{break};}
\DoxyCodeLine{2002          \}}
\DoxyCodeLine{2003          start = end;}
\DoxyCodeLine{2004       \}}
\DoxyCodeLine{2005    \}}
\DoxyCodeLine{2006    \textcolor{keywordflow}{if} (fdselector == -\/1) stbtt\_\_new\_buf(NULL, 0);}
\DoxyCodeLine{2007    \textcolor{keywordflow}{return} stbtt\_\_get\_subrs(info-\/>cff, stbtt\_\_cff\_index\_get(info-\/>fontdicts, fdselector));}
\DoxyCodeLine{2008 \}}
\DoxyCodeLine{2009 }
\DoxyCodeLine{2010 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_run\_charstring(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, stbtt\_\_csctx *c)}
\DoxyCodeLine{2011 \{}
\DoxyCodeLine{2012    \textcolor{keywordtype}{int} in\_header = 1, maskbits = 0, subr\_stack\_height = 0, sp = 0, v, i, b0;}
\DoxyCodeLine{2013    \textcolor{keywordtype}{int} has\_subrs = 0, clear\_stack;}
\DoxyCodeLine{2014    \textcolor{keywordtype}{float} s[48];}
\DoxyCodeLine{2015    \mbox{\hyperlink{structstbtt____buf}{stbtt\_\_buf}} subr\_stack[10], subrs = info-\/>subrs, b;}
\DoxyCodeLine{2016    \textcolor{keywordtype}{float} f;}
\DoxyCodeLine{2017 }
\DoxyCodeLine{2018 \textcolor{preprocessor}{\#define STBTT\_\_CSERR(s) (0)}}
\DoxyCodeLine{2019 }
\DoxyCodeLine{2020    \textcolor{comment}{// this currently ignores the initial width value, which isn't needed if we have hmtx}}
\DoxyCodeLine{2021    b = stbtt\_\_cff\_index\_get(info-\/>charstrings, glyph\_index);}
\DoxyCodeLine{2022    \textcolor{keywordflow}{while} (b.cursor < b.size) \{}
\DoxyCodeLine{2023       i = 0;}
\DoxyCodeLine{2024       clear\_stack = 1;}
\DoxyCodeLine{2025       b0 = stbtt\_\_buf\_get8(\&b);}
\DoxyCodeLine{2026       \textcolor{keywordflow}{switch} (b0) \{}
\DoxyCodeLine{2027       \textcolor{comment}{// @TODO implement hinting}}
\DoxyCodeLine{2028       \textcolor{keywordflow}{case} 0x13: \textcolor{comment}{// hintmask}}
\DoxyCodeLine{2029       \textcolor{keywordflow}{case} 0x14: \textcolor{comment}{// cntrmask}}
\DoxyCodeLine{2030          \textcolor{keywordflow}{if} (in\_header)}
\DoxyCodeLine{2031             maskbits += (sp / 2); \textcolor{comment}{// implicit "{}vstem"{}}}
\DoxyCodeLine{2032          in\_header = 0;}
\DoxyCodeLine{2033          stbtt\_\_buf\_skip(\&b, (maskbits + 7) / 8);}
\DoxyCodeLine{2034          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2035 }
\DoxyCodeLine{2036       \textcolor{keywordflow}{case} 0x01: \textcolor{comment}{// hstem}}
\DoxyCodeLine{2037       \textcolor{keywordflow}{case} 0x03: \textcolor{comment}{// vstem}}
\DoxyCodeLine{2038       \textcolor{keywordflow}{case} 0x12: \textcolor{comment}{// hstemhm}}
\DoxyCodeLine{2039       \textcolor{keywordflow}{case} 0x17: \textcolor{comment}{// vstemhm}}
\DoxyCodeLine{2040          maskbits += (sp / 2);}
\DoxyCodeLine{2041          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2042 }
\DoxyCodeLine{2043       \textcolor{keywordflow}{case} 0x15: \textcolor{comment}{// rmoveto}}
\DoxyCodeLine{2044          in\_header = 0;}
\DoxyCodeLine{2045          \textcolor{keywordflow}{if} (sp < 2) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}rmoveto stack"{}});}
\DoxyCodeLine{2046          stbtt\_\_csctx\_rmove\_to(c, s[sp-\/2], s[sp-\/1]);}
\DoxyCodeLine{2047          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2048       \textcolor{keywordflow}{case} 0x04: \textcolor{comment}{// vmoveto}}
\DoxyCodeLine{2049          in\_header = 0;}
\DoxyCodeLine{2050          \textcolor{keywordflow}{if} (sp < 1) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}vmoveto stack"{}});}
\DoxyCodeLine{2051          stbtt\_\_csctx\_rmove\_to(c, 0, s[sp-\/1]);}
\DoxyCodeLine{2052          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2053       \textcolor{keywordflow}{case} 0x16: \textcolor{comment}{// hmoveto}}
\DoxyCodeLine{2054          in\_header = 0;}
\DoxyCodeLine{2055          \textcolor{keywordflow}{if} (sp < 1) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}hmoveto stack"{}});}
\DoxyCodeLine{2056          stbtt\_\_csctx\_rmove\_to(c, s[sp-\/1], 0);}
\DoxyCodeLine{2057          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2058 }
\DoxyCodeLine{2059       \textcolor{keywordflow}{case} 0x05: \textcolor{comment}{// rlineto}}
\DoxyCodeLine{2060          \textcolor{keywordflow}{if} (sp < 2) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}rlineto stack"{}});}
\DoxyCodeLine{2061          \textcolor{keywordflow}{for} (; i + 1 < sp; i += 2)}
\DoxyCodeLine{2062             stbtt\_\_csctx\_rline\_to(c, s[i], s[i+1]);}
\DoxyCodeLine{2063          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2064 }
\DoxyCodeLine{2065       \textcolor{comment}{// hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical}}
\DoxyCodeLine{2066       \textcolor{comment}{// starting from a different place.}}
\DoxyCodeLine{2067 }
\DoxyCodeLine{2068       \textcolor{keywordflow}{case} 0x07: \textcolor{comment}{// vlineto}}
\DoxyCodeLine{2069          \textcolor{keywordflow}{if} (sp < 1) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}vlineto stack"{}});}
\DoxyCodeLine{2070          \textcolor{keywordflow}{goto} vlineto;}
\DoxyCodeLine{2071       \textcolor{keywordflow}{case} 0x06: \textcolor{comment}{// hlineto}}
\DoxyCodeLine{2072          \textcolor{keywordflow}{if} (sp < 1) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}hlineto stack"{}});}
\DoxyCodeLine{2073          \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2074             \textcolor{keywordflow}{if} (i >= sp) \textcolor{keywordflow}{break};}
\DoxyCodeLine{2075             stbtt\_\_csctx\_rline\_to(c, s[i], 0);}
\DoxyCodeLine{2076             i++;}
\DoxyCodeLine{2077       vlineto:}
\DoxyCodeLine{2078             \textcolor{keywordflow}{if} (i >= sp) \textcolor{keywordflow}{break};}
\DoxyCodeLine{2079             stbtt\_\_csctx\_rline\_to(c, 0, s[i]);}
\DoxyCodeLine{2080             i++;}
\DoxyCodeLine{2081          \}}
\DoxyCodeLine{2082          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2083 }
\DoxyCodeLine{2084       \textcolor{keywordflow}{case} 0x1F: \textcolor{comment}{// hvcurveto}}
\DoxyCodeLine{2085          \textcolor{keywordflow}{if} (sp < 4) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}hvcurveto stack"{}});}
\DoxyCodeLine{2086          \textcolor{keywordflow}{goto} hvcurveto;}
\DoxyCodeLine{2087       \textcolor{keywordflow}{case} 0x1E: \textcolor{comment}{// vhcurveto}}
\DoxyCodeLine{2088          \textcolor{keywordflow}{if} (sp < 4) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}vhcurveto stack"{}});}
\DoxyCodeLine{2089          \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2090             \textcolor{keywordflow}{if} (i + 3 >= sp) \textcolor{keywordflow}{break};}
\DoxyCodeLine{2091             stbtt\_\_csctx\_rccurve\_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp -\/ i == 5) ? s[i + 4] : 0.0f);}
\DoxyCodeLine{2092             i += 4;}
\DoxyCodeLine{2093       hvcurveto:}
\DoxyCodeLine{2094             \textcolor{keywordflow}{if} (i + 3 >= sp) \textcolor{keywordflow}{break};}
\DoxyCodeLine{2095             stbtt\_\_csctx\_rccurve\_to(c, s[i], 0, s[i+1], s[i+2], (sp -\/ i == 5) ? s[i+4] : 0.0f, s[i+3]);}
\DoxyCodeLine{2096             i += 4;}
\DoxyCodeLine{2097          \}}
\DoxyCodeLine{2098          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2099 }
\DoxyCodeLine{2100       \textcolor{keywordflow}{case} 0x08: \textcolor{comment}{// rrcurveto}}
\DoxyCodeLine{2101          \textcolor{keywordflow}{if} (sp < 6) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}rcurveline stack"{}});}
\DoxyCodeLine{2102          \textcolor{keywordflow}{for} (; i + 5 < sp; i += 6)}
\DoxyCodeLine{2103             stbtt\_\_csctx\_rccurve\_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);}
\DoxyCodeLine{2104          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2105 }
\DoxyCodeLine{2106       \textcolor{keywordflow}{case} 0x18: \textcolor{comment}{// rcurveline}}
\DoxyCodeLine{2107          \textcolor{keywordflow}{if} (sp < 8) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}rcurveline stack"{}});}
\DoxyCodeLine{2108          \textcolor{keywordflow}{for} (; i + 5 < sp -\/ 2; i += 6)}
\DoxyCodeLine{2109             stbtt\_\_csctx\_rccurve\_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);}
\DoxyCodeLine{2110          \textcolor{keywordflow}{if} (i + 1 >= sp) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}rcurveline stack"{}});}
\DoxyCodeLine{2111          stbtt\_\_csctx\_rline\_to(c, s[i], s[i+1]);}
\DoxyCodeLine{2112          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2113 }
\DoxyCodeLine{2114       \textcolor{keywordflow}{case} 0x19: \textcolor{comment}{// rlinecurve}}
\DoxyCodeLine{2115          \textcolor{keywordflow}{if} (sp < 8) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}rlinecurve stack"{}});}
\DoxyCodeLine{2116          \textcolor{keywordflow}{for} (; i + 1 < sp -\/ 6; i += 2)}
\DoxyCodeLine{2117             stbtt\_\_csctx\_rline\_to(c, s[i], s[i+1]);}
\DoxyCodeLine{2118          \textcolor{keywordflow}{if} (i + 5 >= sp) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}rlinecurve stack"{}});}
\DoxyCodeLine{2119          stbtt\_\_csctx\_rccurve\_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);}
\DoxyCodeLine{2120          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2121 }
\DoxyCodeLine{2122       \textcolor{keywordflow}{case} 0x1A: \textcolor{comment}{// vvcurveto}}
\DoxyCodeLine{2123       \textcolor{keywordflow}{case} 0x1B: \textcolor{comment}{// hhcurveto}}
\DoxyCodeLine{2124          \textcolor{keywordflow}{if} (sp < 4) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}(vv|hh)curveto stack"{}});}
\DoxyCodeLine{2125          f = 0.0;}
\DoxyCodeLine{2126          \textcolor{keywordflow}{if} (sp \& 1) \{ f = s[i]; i++; \}}
\DoxyCodeLine{2127          \textcolor{keywordflow}{for} (; i + 3 < sp; i += 4) \{}
\DoxyCodeLine{2128             \textcolor{keywordflow}{if} (b0 == 0x1B)}
\DoxyCodeLine{2129                stbtt\_\_csctx\_rccurve\_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);}
\DoxyCodeLine{2130             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2131                stbtt\_\_csctx\_rccurve\_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);}
\DoxyCodeLine{2132             f = 0.0;}
\DoxyCodeLine{2133          \}}
\DoxyCodeLine{2134          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2135 }
\DoxyCodeLine{2136       \textcolor{keywordflow}{case} 0x0A: \textcolor{comment}{// callsubr}}
\DoxyCodeLine{2137          \textcolor{keywordflow}{if} (!has\_subrs) \{}
\DoxyCodeLine{2138             \textcolor{keywordflow}{if} (info-\/>fdselect.size)}
\DoxyCodeLine{2139                subrs = stbtt\_\_cid\_get\_glyph\_subrs(info, glyph\_index);}
\DoxyCodeLine{2140             has\_subrs = 1;}
\DoxyCodeLine{2141          \}}
\DoxyCodeLine{2142          \textcolor{comment}{// FALLTHROUGH}}
\DoxyCodeLine{2143       \textcolor{keywordflow}{case} 0x1D: \textcolor{comment}{// callgsubr}}
\DoxyCodeLine{2144          \textcolor{keywordflow}{if} (sp < 1) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}call(g|)subr stack"{}});}
\DoxyCodeLine{2145          v = (int) s[-\/-\/sp];}
\DoxyCodeLine{2146          \textcolor{keywordflow}{if} (subr\_stack\_height >= 10) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}recursion limit"{}});}
\DoxyCodeLine{2147          subr\_stack[subr\_stack\_height++] = b;}
\DoxyCodeLine{2148          b = stbtt\_\_get\_subr(b0 == 0x0A ? subrs : info-\/>gsubrs, v);}
\DoxyCodeLine{2149          \textcolor{keywordflow}{if} (b.size == 0) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}subr not found"{}});}
\DoxyCodeLine{2150          b.cursor = 0;}
\DoxyCodeLine{2151          clear\_stack = 0;}
\DoxyCodeLine{2152          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2153 }
\DoxyCodeLine{2154       \textcolor{keywordflow}{case} 0x0B: \textcolor{comment}{// return}}
\DoxyCodeLine{2155          \textcolor{keywordflow}{if} (subr\_stack\_height <= 0) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}return outside subr"{}});}
\DoxyCodeLine{2156          b = subr\_stack[-\/-\/subr\_stack\_height];}
\DoxyCodeLine{2157          clear\_stack = 0;}
\DoxyCodeLine{2158          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2159 }
\DoxyCodeLine{2160       \textcolor{keywordflow}{case} 0x0E: \textcolor{comment}{// endchar}}
\DoxyCodeLine{2161          stbtt\_\_csctx\_close\_shape(c);}
\DoxyCodeLine{2162          \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{2163 }
\DoxyCodeLine{2164       \textcolor{keywordflow}{case} 0x0C: \{ \textcolor{comment}{// two-\/byte escape}}
\DoxyCodeLine{2165          \textcolor{keywordtype}{float} dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;}
\DoxyCodeLine{2166          \textcolor{keywordtype}{float} dx, dy;}
\DoxyCodeLine{2167          \textcolor{keywordtype}{int} b1 = stbtt\_\_buf\_get8(\&b);}
\DoxyCodeLine{2168          \textcolor{keywordflow}{switch} (b1) \{}
\DoxyCodeLine{2169          \textcolor{comment}{// @TODO These "{}flex"{} implementations ignore the flex-\/depth and resolution,}}
\DoxyCodeLine{2170          \textcolor{comment}{// and always draw beziers.}}
\DoxyCodeLine{2171          \textcolor{keywordflow}{case} 0x22: \textcolor{comment}{// hflex}}
\DoxyCodeLine{2172             \textcolor{keywordflow}{if} (sp < 7) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}hflex stack"{}});}
\DoxyCodeLine{2173             dx1 = s[0];}
\DoxyCodeLine{2174             dx2 = s[1];}
\DoxyCodeLine{2175             dy2 = s[2];}
\DoxyCodeLine{2176             dx3 = s[3];}
\DoxyCodeLine{2177             dx4 = s[4];}
\DoxyCodeLine{2178             dx5 = s[5];}
\DoxyCodeLine{2179             dx6 = s[6];}
\DoxyCodeLine{2180             stbtt\_\_csctx\_rccurve\_to(c, dx1, 0, dx2, dy2, dx3, 0);}
\DoxyCodeLine{2181             stbtt\_\_csctx\_rccurve\_to(c, dx4, 0, dx5, -\/dy2, dx6, 0);}
\DoxyCodeLine{2182             \textcolor{keywordflow}{break};}
\DoxyCodeLine{2183 }
\DoxyCodeLine{2184          \textcolor{keywordflow}{case} 0x23: \textcolor{comment}{// flex}}
\DoxyCodeLine{2185             \textcolor{keywordflow}{if} (sp < 13) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}flex stack"{}});}
\DoxyCodeLine{2186             dx1 = s[0];}
\DoxyCodeLine{2187             dy1 = s[1];}
\DoxyCodeLine{2188             dx2 = s[2];}
\DoxyCodeLine{2189             dy2 = s[3];}
\DoxyCodeLine{2190             dx3 = s[4];}
\DoxyCodeLine{2191             dy3 = s[5];}
\DoxyCodeLine{2192             dx4 = s[6];}
\DoxyCodeLine{2193             dy4 = s[7];}
\DoxyCodeLine{2194             dx5 = s[8];}
\DoxyCodeLine{2195             dy5 = s[9];}
\DoxyCodeLine{2196             dx6 = s[10];}
\DoxyCodeLine{2197             dy6 = s[11];}
\DoxyCodeLine{2198             \textcolor{comment}{//fd is s[12]}}
\DoxyCodeLine{2199             stbtt\_\_csctx\_rccurve\_to(c, dx1, dy1, dx2, dy2, dx3, dy3);}
\DoxyCodeLine{2200             stbtt\_\_csctx\_rccurve\_to(c, dx4, dy4, dx5, dy5, dx6, dy6);}
\DoxyCodeLine{2201             \textcolor{keywordflow}{break};}
\DoxyCodeLine{2202 }
\DoxyCodeLine{2203          \textcolor{keywordflow}{case} 0x24: \textcolor{comment}{// hflex1}}
\DoxyCodeLine{2204             \textcolor{keywordflow}{if} (sp < 9) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}hflex1 stack"{}});}
\DoxyCodeLine{2205             dx1 = s[0];}
\DoxyCodeLine{2206             dy1 = s[1];}
\DoxyCodeLine{2207             dx2 = s[2];}
\DoxyCodeLine{2208             dy2 = s[3];}
\DoxyCodeLine{2209             dx3 = s[4];}
\DoxyCodeLine{2210             dx4 = s[5];}
\DoxyCodeLine{2211             dx5 = s[6];}
\DoxyCodeLine{2212             dy5 = s[7];}
\DoxyCodeLine{2213             dx6 = s[8];}
\DoxyCodeLine{2214             stbtt\_\_csctx\_rccurve\_to(c, dx1, dy1, dx2, dy2, dx3, 0);}
\DoxyCodeLine{2215             stbtt\_\_csctx\_rccurve\_to(c, dx4, 0, dx5, dy5, dx6, -\/(dy1+dy2+dy5));}
\DoxyCodeLine{2216             \textcolor{keywordflow}{break};}
\DoxyCodeLine{2217 }
\DoxyCodeLine{2218          \textcolor{keywordflow}{case} 0x25: \textcolor{comment}{// flex1}}
\DoxyCodeLine{2219             \textcolor{keywordflow}{if} (sp < 11) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}flex1 stack"{}});}
\DoxyCodeLine{2220             dx1 = s[0];}
\DoxyCodeLine{2221             dy1 = s[1];}
\DoxyCodeLine{2222             dx2 = s[2];}
\DoxyCodeLine{2223             dy2 = s[3];}
\DoxyCodeLine{2224             dx3 = s[4];}
\DoxyCodeLine{2225             dy3 = s[5];}
\DoxyCodeLine{2226             dx4 = s[6];}
\DoxyCodeLine{2227             dy4 = s[7];}
\DoxyCodeLine{2228             dx5 = s[8];}
\DoxyCodeLine{2229             dy5 = s[9];}
\DoxyCodeLine{2230             dx6 = dy6 = s[10];}
\DoxyCodeLine{2231             dx = dx1+dx2+dx3+dx4+dx5;}
\DoxyCodeLine{2232             dy = dy1+dy2+dy3+dy4+dy5;}
\DoxyCodeLine{2233             \textcolor{keywordflow}{if} (STBTT\_fabs(dx) > STBTT\_fabs(dy))}
\DoxyCodeLine{2234                dy6 = -\/dy;}
\DoxyCodeLine{2235             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2236                dx6 = -\/dx;}
\DoxyCodeLine{2237             stbtt\_\_csctx\_rccurve\_to(c, dx1, dy1, dx2, dy2, dx3, dy3);}
\DoxyCodeLine{2238             stbtt\_\_csctx\_rccurve\_to(c, dx4, dy4, dx5, dy5, dx6, dy6);}
\DoxyCodeLine{2239             \textcolor{keywordflow}{break};}
\DoxyCodeLine{2240 }
\DoxyCodeLine{2241          \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2242             \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}unimplemented"{}});}
\DoxyCodeLine{2243          \}}
\DoxyCodeLine{2244       \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{2245 }
\DoxyCodeLine{2246       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2247          \textcolor{keywordflow}{if} (b0 != 255 \&\& b0 != 28 \&\& b0 < 32)}
\DoxyCodeLine{2248             \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}reserved operator"{}});}
\DoxyCodeLine{2249 }
\DoxyCodeLine{2250          \textcolor{comment}{// push immediate}}
\DoxyCodeLine{2251          \textcolor{keywordflow}{if} (b0 == 255) \{}
\DoxyCodeLine{2252             f = (float)(stbtt\_int32)stbtt\_\_buf\_get32(\&b) / 0x10000;}
\DoxyCodeLine{2253          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2254             stbtt\_\_buf\_skip(\&b, -\/1);}
\DoxyCodeLine{2255             f = (float)(stbtt\_int16)stbtt\_\_cff\_int(\&b);}
\DoxyCodeLine{2256          \}}
\DoxyCodeLine{2257          \textcolor{keywordflow}{if} (sp >= 48) \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}push stack overflow"{}});}
\DoxyCodeLine{2258          s[sp++] = f;}
\DoxyCodeLine{2259          clear\_stack = 0;}
\DoxyCodeLine{2260          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2261       \}}
\DoxyCodeLine{2262       \textcolor{keywordflow}{if} (clear\_stack) sp = 0;}
\DoxyCodeLine{2263    \}}
\DoxyCodeLine{2264    \textcolor{keywordflow}{return} STBTT\_\_CSERR(\textcolor{stringliteral}{"{}no endchar"{}});}
\DoxyCodeLine{2265 }
\DoxyCodeLine{2266 \textcolor{preprocessor}{\#undef STBTT\_\_CSERR}}
\DoxyCodeLine{2267 \}}
\DoxyCodeLine{2268 }
\DoxyCodeLine{2269 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_GetGlyphShapeT2(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} **pvertices)}
\DoxyCodeLine{2270 \{}
\DoxyCodeLine{2271    \textcolor{comment}{// runs the charstring twice, once to count and once to output (to avoid realloc)}}
\DoxyCodeLine{2272    stbtt\_\_csctx count\_ctx = STBTT\_\_CSCTX\_INIT(1);}
\DoxyCodeLine{2273    stbtt\_\_csctx output\_ctx = STBTT\_\_CSCTX\_INIT(0);}
\DoxyCodeLine{2274    \textcolor{keywordflow}{if} (stbtt\_\_run\_charstring(info, glyph\_index, \&count\_ctx)) \{}
\DoxyCodeLine{2275       *pvertices = (\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}}*)STBTT\_malloc(count\_ctx.num\_vertices*\textcolor{keyword}{sizeof}(\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}}), info-\/>userdata);}
\DoxyCodeLine{2276       output\_ctx.pvertices = *pvertices;}
\DoxyCodeLine{2277       \textcolor{keywordflow}{if} (stbtt\_\_run\_charstring(info, glyph\_index, \&output\_ctx)) \{}
\DoxyCodeLine{2278          STBTT\_assert(output\_ctx.num\_vertices == count\_ctx.num\_vertices);}
\DoxyCodeLine{2279          \textcolor{keywordflow}{return} output\_ctx.num\_vertices;}
\DoxyCodeLine{2280       \}}
\DoxyCodeLine{2281    \}}
\DoxyCodeLine{2282    *pvertices = NULL;}
\DoxyCodeLine{2283    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2284 \}}
\DoxyCodeLine{2285 }
\DoxyCodeLine{2286 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_GetGlyphInfoT2(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \textcolor{keywordtype}{int} *x0, \textcolor{keywordtype}{int} *y0, \textcolor{keywordtype}{int} *x1, \textcolor{keywordtype}{int} *y1)}
\DoxyCodeLine{2287 \{}
\DoxyCodeLine{2288    stbtt\_\_csctx c = STBTT\_\_CSCTX\_INIT(1);}
\DoxyCodeLine{2289    \textcolor{keywordtype}{int} r = stbtt\_\_run\_charstring(info, glyph\_index, \&c);}
\DoxyCodeLine{2290    \textcolor{keywordflow}{if} (x0)  *x0 = r ? c.min\_x : 0;}
\DoxyCodeLine{2291    \textcolor{keywordflow}{if} (y0)  *y0 = r ? c.min\_y : 0;}
\DoxyCodeLine{2292    \textcolor{keywordflow}{if} (x1)  *x1 = r ? c.max\_x : 0;}
\DoxyCodeLine{2293    \textcolor{keywordflow}{if} (y1)  *y1 = r ? c.max\_y : 0;}
\DoxyCodeLine{2294    \textcolor{keywordflow}{return} r ? c.num\_vertices : 0;}
\DoxyCodeLine{2295 \}}
\DoxyCodeLine{2296 }
\DoxyCodeLine{2297 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetGlyphShape(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} **pvertices)}
\DoxyCodeLine{2298 \{}
\DoxyCodeLine{2299    \textcolor{keywordflow}{if} (!info-\/>cff.size)}
\DoxyCodeLine{2300       \textcolor{keywordflow}{return} stbtt\_\_GetGlyphShapeTT(info, glyph\_index, pvertices);}
\DoxyCodeLine{2301    \textcolor{keywordflow}{else}}
\DoxyCodeLine{2302       \textcolor{keywordflow}{return} stbtt\_\_GetGlyphShapeT2(info, glyph\_index, pvertices);}
\DoxyCodeLine{2303 \}}
\DoxyCodeLine{2304 }
\DoxyCodeLine{2305 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetGlyphHMetrics(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph\_index, \textcolor{keywordtype}{int} *advanceWidth, \textcolor{keywordtype}{int} *leftSideBearing)}
\DoxyCodeLine{2306 \{}
\DoxyCodeLine{2307    stbtt\_uint16 numOfLongHorMetrics = ttUSHORT(info-\/>data+info-\/>hhea + 34);}
\DoxyCodeLine{2308    \textcolor{keywordflow}{if} (glyph\_index < numOfLongHorMetrics) \{}
\DoxyCodeLine{2309       \textcolor{keywordflow}{if} (advanceWidth)     *advanceWidth    = ttSHORT(info-\/>data + info-\/>hmtx + 4*glyph\_index);}
\DoxyCodeLine{2310       \textcolor{keywordflow}{if} (leftSideBearing)  *leftSideBearing = ttSHORT(info-\/>data + info-\/>hmtx + 4*glyph\_index + 2);}
\DoxyCodeLine{2311    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2312       \textcolor{keywordflow}{if} (advanceWidth)     *advanceWidth    = ttSHORT(info-\/>data + info-\/>hmtx + 4*(numOfLongHorMetrics-\/1));}
\DoxyCodeLine{2313       \textcolor{keywordflow}{if} (leftSideBearing)  *leftSideBearing = ttSHORT(info-\/>data + info-\/>hmtx + 4*numOfLongHorMetrics + 2*(glyph\_index -\/ numOfLongHorMetrics));}
\DoxyCodeLine{2314    \}}
\DoxyCodeLine{2315 \}}
\DoxyCodeLine{2316 }
\DoxyCodeLine{2317 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetKerningTableLength(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info)}
\DoxyCodeLine{2318 \{}
\DoxyCodeLine{2319    stbtt\_uint8 *data = info-\/>data + info-\/>kern;}
\DoxyCodeLine{2320 }
\DoxyCodeLine{2321    \textcolor{comment}{// we only look at the first table. it must be 'horizontal' and format 0.}}
\DoxyCodeLine{2322    \textcolor{keywordflow}{if} (!info-\/>kern)}
\DoxyCodeLine{2323       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2324    \textcolor{keywordflow}{if} (ttUSHORT(data+2) < 1) \textcolor{comment}{// number of tables, need at least 1}}
\DoxyCodeLine{2325       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2326    \textcolor{keywordflow}{if} (ttUSHORT(data+8) != 1) \textcolor{comment}{// horizontal flag must be set in format}}
\DoxyCodeLine{2327       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2328 }
\DoxyCodeLine{2329    \textcolor{keywordflow}{return} ttUSHORT(data+10);}
\DoxyCodeLine{2330 \}}
\DoxyCodeLine{2331 }
\DoxyCodeLine{2332 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetKerningTable(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \mbox{\hyperlink{structstbtt__kerningentry}{stbtt\_kerningentry}}* table, \textcolor{keywordtype}{int} table\_length)}
\DoxyCodeLine{2333 \{}
\DoxyCodeLine{2334    stbtt\_uint8 *data = info-\/>data + info-\/>kern;}
\DoxyCodeLine{2335    \textcolor{keywordtype}{int} k, length;}
\DoxyCodeLine{2336 }
\DoxyCodeLine{2337    \textcolor{comment}{// we only look at the first table. it must be 'horizontal' and format 0.}}
\DoxyCodeLine{2338    \textcolor{keywordflow}{if} (!info-\/>kern)}
\DoxyCodeLine{2339       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2340    \textcolor{keywordflow}{if} (ttUSHORT(data+2) < 1) \textcolor{comment}{// number of tables, need at least 1}}
\DoxyCodeLine{2341       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2342    \textcolor{keywordflow}{if} (ttUSHORT(data+8) != 1) \textcolor{comment}{// horizontal flag must be set in format}}
\DoxyCodeLine{2343       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2344 }
\DoxyCodeLine{2345    length = ttUSHORT(data+10);}
\DoxyCodeLine{2346    \textcolor{keywordflow}{if} (table\_length < length)}
\DoxyCodeLine{2347       length = table\_length;}
\DoxyCodeLine{2348 }
\DoxyCodeLine{2349    \textcolor{keywordflow}{for} (k = 0; k < length; k++)}
\DoxyCodeLine{2350    \{}
\DoxyCodeLine{2351       table[k].glyph1 = ttUSHORT(data+18+(k*6));}
\DoxyCodeLine{2352       table[k].glyph2 = ttUSHORT(data+20+(k*6));}
\DoxyCodeLine{2353       table[k].advance = ttSHORT(data+22+(k*6));}
\DoxyCodeLine{2354    \}}
\DoxyCodeLine{2355 }
\DoxyCodeLine{2356    \textcolor{keywordflow}{return} length;}
\DoxyCodeLine{2357 \}}
\DoxyCodeLine{2358 }
\DoxyCodeLine{2359 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_GetGlyphKernInfoAdvance(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph1, \textcolor{keywordtype}{int} glyph2)}
\DoxyCodeLine{2360 \{}
\DoxyCodeLine{2361    stbtt\_uint8 *data = info-\/>data + info-\/>kern;}
\DoxyCodeLine{2362    stbtt\_uint32 needle, straw;}
\DoxyCodeLine{2363    \textcolor{keywordtype}{int} l, r, m;}
\DoxyCodeLine{2364 }
\DoxyCodeLine{2365    \textcolor{comment}{// we only look at the first table. it must be 'horizontal' and format 0.}}
\DoxyCodeLine{2366    \textcolor{keywordflow}{if} (!info-\/>kern)}
\DoxyCodeLine{2367       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2368    \textcolor{keywordflow}{if} (ttUSHORT(data+2) < 1) \textcolor{comment}{// number of tables, need at least 1}}
\DoxyCodeLine{2369       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2370    \textcolor{keywordflow}{if} (ttUSHORT(data+8) != 1) \textcolor{comment}{// horizontal flag must be set in format}}
\DoxyCodeLine{2371       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2372 }
\DoxyCodeLine{2373    l = 0;}
\DoxyCodeLine{2374    r = ttUSHORT(data+10) -\/ 1;}
\DoxyCodeLine{2375    needle = glyph1 << 16 | glyph2;}
\DoxyCodeLine{2376    \textcolor{keywordflow}{while} (l <= r) \{}
\DoxyCodeLine{2377       m = (l + r) >> 1;}
\DoxyCodeLine{2378       straw = ttULONG(data+18+(m*6)); \textcolor{comment}{// note: unaligned read}}
\DoxyCodeLine{2379       \textcolor{keywordflow}{if} (needle < straw)}
\DoxyCodeLine{2380          r = m -\/ 1;}
\DoxyCodeLine{2381       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (needle > straw)}
\DoxyCodeLine{2382          l = m + 1;}
\DoxyCodeLine{2383       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2384          \textcolor{keywordflow}{return} ttSHORT(data+22+(m*6));}
\DoxyCodeLine{2385    \}}
\DoxyCodeLine{2386    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2387 \}}
\DoxyCodeLine{2388 }
\DoxyCodeLine{2389 \textcolor{keyword}{static} stbtt\_int32 stbtt\_\_GetCoverageIndex(stbtt\_uint8 *coverageTable, \textcolor{keywordtype}{int} glyph)}
\DoxyCodeLine{2390 \{}
\DoxyCodeLine{2391    stbtt\_uint16 coverageFormat = ttUSHORT(coverageTable);}
\DoxyCodeLine{2392    \textcolor{keywordflow}{switch} (coverageFormat) \{}
\DoxyCodeLine{2393       \textcolor{keywordflow}{case} 1: \{}
\DoxyCodeLine{2394          stbtt\_uint16 glyphCount = ttUSHORT(coverageTable + 2);}
\DoxyCodeLine{2395 }
\DoxyCodeLine{2396          \textcolor{comment}{// Binary search.}}
\DoxyCodeLine{2397          stbtt\_int32 l=0, r=glyphCount-\/1, m;}
\DoxyCodeLine{2398          \textcolor{keywordtype}{int} straw, needle=glyph;}
\DoxyCodeLine{2399          \textcolor{keywordflow}{while} (l <= r) \{}
\DoxyCodeLine{2400             stbtt\_uint8 *glyphArray = coverageTable + 4;}
\DoxyCodeLine{2401             stbtt\_uint16 glyphID;}
\DoxyCodeLine{2402             m = (l + r) >> 1;}
\DoxyCodeLine{2403             glyphID = ttUSHORT(glyphArray + 2 * m);}
\DoxyCodeLine{2404             straw = glyphID;}
\DoxyCodeLine{2405             \textcolor{keywordflow}{if} (needle < straw)}
\DoxyCodeLine{2406                r = m -\/ 1;}
\DoxyCodeLine{2407             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (needle > straw)}
\DoxyCodeLine{2408                l = m + 1;}
\DoxyCodeLine{2409             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2410                \textcolor{keywordflow}{return} m;}
\DoxyCodeLine{2411             \}}
\DoxyCodeLine{2412          \}}
\DoxyCodeLine{2413          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2414       \}}
\DoxyCodeLine{2415 }
\DoxyCodeLine{2416       \textcolor{keywordflow}{case} 2: \{}
\DoxyCodeLine{2417          stbtt\_uint16 rangeCount = ttUSHORT(coverageTable + 2);}
\DoxyCodeLine{2418          stbtt\_uint8 *rangeArray = coverageTable + 4;}
\DoxyCodeLine{2419 }
\DoxyCodeLine{2420          \textcolor{comment}{// Binary search.}}
\DoxyCodeLine{2421          stbtt\_int32 l=0, r=rangeCount-\/1, m;}
\DoxyCodeLine{2422          \textcolor{keywordtype}{int} strawStart, strawEnd, needle=glyph;}
\DoxyCodeLine{2423          \textcolor{keywordflow}{while} (l <= r) \{}
\DoxyCodeLine{2424             stbtt\_uint8 *rangeRecord;}
\DoxyCodeLine{2425             m = (l + r) >> 1;}
\DoxyCodeLine{2426             rangeRecord = rangeArray + 6 * m;}
\DoxyCodeLine{2427             strawStart = ttUSHORT(rangeRecord);}
\DoxyCodeLine{2428             strawEnd = ttUSHORT(rangeRecord + 2);}
\DoxyCodeLine{2429             \textcolor{keywordflow}{if} (needle < strawStart)}
\DoxyCodeLine{2430                r = m -\/ 1;}
\DoxyCodeLine{2431             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (needle > strawEnd)}
\DoxyCodeLine{2432                l = m + 1;}
\DoxyCodeLine{2433             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2434                stbtt\_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);}
\DoxyCodeLine{2435                \textcolor{keywordflow}{return} startCoverageIndex + glyph -\/ strawStart;}
\DoxyCodeLine{2436             \}}
\DoxyCodeLine{2437          \}}
\DoxyCodeLine{2438          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2439       \}}
\DoxyCodeLine{2440 }
\DoxyCodeLine{2441       \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} -\/1; \textcolor{comment}{// unsupported}}
\DoxyCodeLine{2442    \}}
\DoxyCodeLine{2443 }
\DoxyCodeLine{2444    \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2445 \}}
\DoxyCodeLine{2446 }
\DoxyCodeLine{2447 \textcolor{keyword}{static} stbtt\_int32  stbtt\_\_GetGlyphClass(stbtt\_uint8 *classDefTable, \textcolor{keywordtype}{int} glyph)}
\DoxyCodeLine{2448 \{}
\DoxyCodeLine{2449    stbtt\_uint16 classDefFormat = ttUSHORT(classDefTable);}
\DoxyCodeLine{2450    \textcolor{keywordflow}{switch} (classDefFormat)}
\DoxyCodeLine{2451    \{}
\DoxyCodeLine{2452       \textcolor{keywordflow}{case} 1: \{}
\DoxyCodeLine{2453          stbtt\_uint16 startGlyphID = ttUSHORT(classDefTable + 2);}
\DoxyCodeLine{2454          stbtt\_uint16 glyphCount = ttUSHORT(classDefTable + 4);}
\DoxyCodeLine{2455          stbtt\_uint8 *classDef1ValueArray = classDefTable + 6;}
\DoxyCodeLine{2456 }
\DoxyCodeLine{2457          \textcolor{keywordflow}{if} (glyph >= startGlyphID \&\& glyph < startGlyphID + glyphCount)}
\DoxyCodeLine{2458             \textcolor{keywordflow}{return} (stbtt\_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph -\/ startGlyphID));}
\DoxyCodeLine{2459          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2460       \}}
\DoxyCodeLine{2461 }
\DoxyCodeLine{2462       \textcolor{keywordflow}{case} 2: \{}
\DoxyCodeLine{2463          stbtt\_uint16 classRangeCount = ttUSHORT(classDefTable + 2);}
\DoxyCodeLine{2464          stbtt\_uint8 *classRangeRecords = classDefTable + 4;}
\DoxyCodeLine{2465 }
\DoxyCodeLine{2466          \textcolor{comment}{// Binary search.}}
\DoxyCodeLine{2467          stbtt\_int32 l=0, r=classRangeCount-\/1, m;}
\DoxyCodeLine{2468          \textcolor{keywordtype}{int} strawStart, strawEnd, needle=glyph;}
\DoxyCodeLine{2469          \textcolor{keywordflow}{while} (l <= r) \{}
\DoxyCodeLine{2470             stbtt\_uint8 *classRangeRecord;}
\DoxyCodeLine{2471             m = (l + r) >> 1;}
\DoxyCodeLine{2472             classRangeRecord = classRangeRecords + 6 * m;}
\DoxyCodeLine{2473             strawStart = ttUSHORT(classRangeRecord);}
\DoxyCodeLine{2474             strawEnd = ttUSHORT(classRangeRecord + 2);}
\DoxyCodeLine{2475             \textcolor{keywordflow}{if} (needle < strawStart)}
\DoxyCodeLine{2476                r = m -\/ 1;}
\DoxyCodeLine{2477             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (needle > strawEnd)}
\DoxyCodeLine{2478                l = m + 1;}
\DoxyCodeLine{2479             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2480                \textcolor{keywordflow}{return} (stbtt\_int32)ttUSHORT(classRangeRecord + 4);}
\DoxyCodeLine{2481          \}}
\DoxyCodeLine{2482          \textcolor{keywordflow}{break};}
\DoxyCodeLine{2483       \}}
\DoxyCodeLine{2484 }
\DoxyCodeLine{2485       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2486          \textcolor{keywordflow}{return} -\/1; \textcolor{comment}{// Unsupported definition type, return an error.}}
\DoxyCodeLine{2487    \}}
\DoxyCodeLine{2488 }
\DoxyCodeLine{2489    \textcolor{comment}{// "{}All glyphs not assigned to a class fall into class 0"{}. (OpenType spec)}}
\DoxyCodeLine{2490    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2491 \}}
\DoxyCodeLine{2492 }
\DoxyCodeLine{2493 \textcolor{comment}{// Define to STBTT\_assert(x) if you want to break on unimplemented formats.}}
\DoxyCodeLine{2494 \textcolor{preprocessor}{\#define STBTT\_GPOS\_TODO\_assert(x)}}
\DoxyCodeLine{2495 }
\DoxyCodeLine{2496 \textcolor{keyword}{static} stbtt\_int32 stbtt\_\_GetGlyphGPOSInfoAdvance(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} glyph1, \textcolor{keywordtype}{int} glyph2)}
\DoxyCodeLine{2497 \{}
\DoxyCodeLine{2498    stbtt\_uint16 lookupListOffset;}
\DoxyCodeLine{2499    stbtt\_uint8 *lookupList;}
\DoxyCodeLine{2500    stbtt\_uint16 lookupCount;}
\DoxyCodeLine{2501    stbtt\_uint8 *data;}
\DoxyCodeLine{2502    stbtt\_int32 i, sti;}
\DoxyCodeLine{2503 }
\DoxyCodeLine{2504    \textcolor{keywordflow}{if} (!info-\/>gpos) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2505 }
\DoxyCodeLine{2506    data = info-\/>data + info-\/>gpos;}
\DoxyCodeLine{2507 }
\DoxyCodeLine{2508    \textcolor{keywordflow}{if} (ttUSHORT(data+0) != 1) \textcolor{keywordflow}{return} 0; \textcolor{comment}{// Major version 1}}
\DoxyCodeLine{2509    \textcolor{keywordflow}{if} (ttUSHORT(data+2) != 0) \textcolor{keywordflow}{return} 0; \textcolor{comment}{// Minor version 0}}
\DoxyCodeLine{2510 }
\DoxyCodeLine{2511    lookupListOffset = ttUSHORT(data+8);}
\DoxyCodeLine{2512    lookupList = data + lookupListOffset;}
\DoxyCodeLine{2513    lookupCount = ttUSHORT(lookupList);}
\DoxyCodeLine{2514 }
\DoxyCodeLine{2515    \textcolor{keywordflow}{for} (i=0; i<lookupCount; ++i) \{}
\DoxyCodeLine{2516       stbtt\_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);}
\DoxyCodeLine{2517       stbtt\_uint8 *lookupTable = lookupList + lookupOffset;}
\DoxyCodeLine{2518 }
\DoxyCodeLine{2519       stbtt\_uint16 lookupType = ttUSHORT(lookupTable);}
\DoxyCodeLine{2520       stbtt\_uint16 subTableCount = ttUSHORT(lookupTable + 4);}
\DoxyCodeLine{2521       stbtt\_uint8 *subTableOffsets = lookupTable + 6;}
\DoxyCodeLine{2522       \textcolor{keywordflow}{if} (lookupType != 2) \textcolor{comment}{// Pair Adjustment Positioning Subtable}}
\DoxyCodeLine{2523          \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2524 }
\DoxyCodeLine{2525       \textcolor{keywordflow}{for} (sti=0; sti<subTableCount; sti++) \{}
\DoxyCodeLine{2526          stbtt\_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);}
\DoxyCodeLine{2527          stbtt\_uint8 *table = lookupTable + subtableOffset;}
\DoxyCodeLine{2528          stbtt\_uint16 posFormat = ttUSHORT(table);}
\DoxyCodeLine{2529          stbtt\_uint16 coverageOffset = ttUSHORT(table + 2);}
\DoxyCodeLine{2530          stbtt\_int32 coverageIndex = stbtt\_\_GetCoverageIndex(table + coverageOffset, glyph1);}
\DoxyCodeLine{2531          \textcolor{keywordflow}{if} (coverageIndex == -\/1) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2532 }
\DoxyCodeLine{2533          \textcolor{keywordflow}{switch} (posFormat) \{}
\DoxyCodeLine{2534             \textcolor{keywordflow}{case} 1: \{}
\DoxyCodeLine{2535                stbtt\_int32 l, r, m;}
\DoxyCodeLine{2536                \textcolor{keywordtype}{int} straw, needle;}
\DoxyCodeLine{2537                stbtt\_uint16 valueFormat1 = ttUSHORT(table + 4);}
\DoxyCodeLine{2538                stbtt\_uint16 valueFormat2 = ttUSHORT(table + 6);}
\DoxyCodeLine{2539                \textcolor{keywordflow}{if} (valueFormat1 == 4 \&\& valueFormat2 == 0) \{ \textcolor{comment}{// Support more formats?}}
\DoxyCodeLine{2540                   stbtt\_int32 valueRecordPairSizeInBytes = 2;}
\DoxyCodeLine{2541                   stbtt\_uint16 pairSetCount = ttUSHORT(table + 8);}
\DoxyCodeLine{2542                   stbtt\_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);}
\DoxyCodeLine{2543                   stbtt\_uint8 *pairValueTable = table + pairPosOffset;}
\DoxyCodeLine{2544                   stbtt\_uint16 pairValueCount = ttUSHORT(pairValueTable);}
\DoxyCodeLine{2545                   stbtt\_uint8 *pairValueArray = pairValueTable + 2;}
\DoxyCodeLine{2546 }
\DoxyCodeLine{2547                   \textcolor{keywordflow}{if} (coverageIndex >= pairSetCount) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2548 }
\DoxyCodeLine{2549                   needle=glyph2;}
\DoxyCodeLine{2550                   r=pairValueCount-\/1;}
\DoxyCodeLine{2551                   l=0;}
\DoxyCodeLine{2552 }
\DoxyCodeLine{2553                   \textcolor{comment}{// Binary search.}}
\DoxyCodeLine{2554                   \textcolor{keywordflow}{while} (l <= r) \{}
\DoxyCodeLine{2555                      stbtt\_uint16 secondGlyph;}
\DoxyCodeLine{2556                      stbtt\_uint8 *pairValue;}
\DoxyCodeLine{2557                      m = (l + r) >> 1;}
\DoxyCodeLine{2558                      pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;}
\DoxyCodeLine{2559                      secondGlyph = ttUSHORT(pairValue);}
\DoxyCodeLine{2560                      straw = secondGlyph;}
\DoxyCodeLine{2561                      \textcolor{keywordflow}{if} (needle < straw)}
\DoxyCodeLine{2562                         r = m -\/ 1;}
\DoxyCodeLine{2563                      \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (needle > straw)}
\DoxyCodeLine{2564                         l = m + 1;}
\DoxyCodeLine{2565                      \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2566                         stbtt\_int16 xAdvance = ttSHORT(pairValue + 2);}
\DoxyCodeLine{2567                         \textcolor{keywordflow}{return} xAdvance;}
\DoxyCodeLine{2568                      \}}
\DoxyCodeLine{2569                   \}}
\DoxyCodeLine{2570                \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{2571                   \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2572                \textcolor{keywordflow}{break};}
\DoxyCodeLine{2573             \}}
\DoxyCodeLine{2574 }
\DoxyCodeLine{2575             \textcolor{keywordflow}{case} 2: \{}
\DoxyCodeLine{2576                stbtt\_uint16 valueFormat1 = ttUSHORT(table + 4);}
\DoxyCodeLine{2577                stbtt\_uint16 valueFormat2 = ttUSHORT(table + 6);}
\DoxyCodeLine{2578                \textcolor{keywordflow}{if} (valueFormat1 == 4 \&\& valueFormat2 == 0) \{ \textcolor{comment}{// Support more formats?}}
\DoxyCodeLine{2579                   stbtt\_uint16 classDef1Offset = ttUSHORT(table + 8);}
\DoxyCodeLine{2580                   stbtt\_uint16 classDef2Offset = ttUSHORT(table + 10);}
\DoxyCodeLine{2581                   \textcolor{keywordtype}{int} glyph1class = stbtt\_\_GetGlyphClass(table + classDef1Offset, glyph1);}
\DoxyCodeLine{2582                   \textcolor{keywordtype}{int} glyph2class = stbtt\_\_GetGlyphClass(table + classDef2Offset, glyph2);}
\DoxyCodeLine{2583 }
\DoxyCodeLine{2584                   stbtt\_uint16 class1Count = ttUSHORT(table + 12);}
\DoxyCodeLine{2585                   stbtt\_uint16 class2Count = ttUSHORT(table + 14);}
\DoxyCodeLine{2586                   stbtt\_uint8 *class1Records, *class2Records;}
\DoxyCodeLine{2587                   stbtt\_int16 xAdvance;}
\DoxyCodeLine{2588 }
\DoxyCodeLine{2589                   \textcolor{keywordflow}{if} (glyph1class < 0 || glyph1class >= class1Count) \textcolor{keywordflow}{return} 0; \textcolor{comment}{// malformed}}
\DoxyCodeLine{2590                   \textcolor{keywordflow}{if} (glyph2class < 0 || glyph2class >= class2Count) \textcolor{keywordflow}{return} 0; \textcolor{comment}{// malformed}}
\DoxyCodeLine{2591 }
\DoxyCodeLine{2592                   class1Records = table + 16;}
\DoxyCodeLine{2593                   class2Records = class1Records + 2 * (glyph1class * class2Count);}
\DoxyCodeLine{2594                   xAdvance = ttSHORT(class2Records + 2 * glyph2class);}
\DoxyCodeLine{2595                   \textcolor{keywordflow}{return} xAdvance;}
\DoxyCodeLine{2596                \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{2597                   \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2598                \textcolor{keywordflow}{break};}
\DoxyCodeLine{2599             \}}
\DoxyCodeLine{2600 }
\DoxyCodeLine{2601             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2602                \textcolor{keywordflow}{return} 0; \textcolor{comment}{// Unsupported position format}}
\DoxyCodeLine{2603          \}}
\DoxyCodeLine{2604       \}}
\DoxyCodeLine{2605    \}}
\DoxyCodeLine{2606 }
\DoxyCodeLine{2607    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2608 \}}
\DoxyCodeLine{2609 }
\DoxyCodeLine{2610 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetGlyphKernAdvance(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} g1, \textcolor{keywordtype}{int} g2)}
\DoxyCodeLine{2611 \{}
\DoxyCodeLine{2612    \textcolor{keywordtype}{int} xAdvance = 0;}
\DoxyCodeLine{2613 }
\DoxyCodeLine{2614    \textcolor{keywordflow}{if} (info-\/>gpos)}
\DoxyCodeLine{2615       xAdvance += stbtt\_\_GetGlyphGPOSInfoAdvance(info, g1, g2);}
\DoxyCodeLine{2616    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (info-\/>kern)}
\DoxyCodeLine{2617       xAdvance += stbtt\_\_GetGlyphKernInfoAdvance(info, g1, g2);}
\DoxyCodeLine{2618 }
\DoxyCodeLine{2619    \textcolor{keywordflow}{return} xAdvance;}
\DoxyCodeLine{2620 \}}
\DoxyCodeLine{2621 }
\DoxyCodeLine{2622 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetCodepointKernAdvance(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} ch1, \textcolor{keywordtype}{int} ch2)}
\DoxyCodeLine{2623 \{}
\DoxyCodeLine{2624    \textcolor{keywordflow}{if} (!info-\/>kern \&\& !info-\/>gpos) \textcolor{comment}{// if no kerning table, don't waste time looking up both codepoint-\/>glyphs}}
\DoxyCodeLine{2625       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2626    \textcolor{keywordflow}{return} stbtt\_GetGlyphKernAdvance(info, stbtt\_FindGlyphIndex(info,ch1), stbtt\_FindGlyphIndex(info,ch2));}
\DoxyCodeLine{2627 \}}
\DoxyCodeLine{2628 }
\DoxyCodeLine{2629 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetCodepointHMetrics(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} *advanceWidth, \textcolor{keywordtype}{int} *leftSideBearing)}
\DoxyCodeLine{2630 \{}
\DoxyCodeLine{2631    stbtt\_GetGlyphHMetrics(info, stbtt\_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);}
\DoxyCodeLine{2632 \}}
\DoxyCodeLine{2633 }
\DoxyCodeLine{2634 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetFontVMetrics(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} *ascent, \textcolor{keywordtype}{int} *descent, \textcolor{keywordtype}{int} *lineGap)}
\DoxyCodeLine{2635 \{}
\DoxyCodeLine{2636    \textcolor{keywordflow}{if} (ascent ) *ascent  = ttSHORT(info-\/>data+info-\/>hhea + 4);}
\DoxyCodeLine{2637    \textcolor{keywordflow}{if} (descent) *descent = ttSHORT(info-\/>data+info-\/>hhea + 6);}
\DoxyCodeLine{2638    \textcolor{keywordflow}{if} (lineGap) *lineGap = ttSHORT(info-\/>data+info-\/>hhea + 8);}
\DoxyCodeLine{2639 \}}
\DoxyCodeLine{2640 }
\DoxyCodeLine{2641 STBTT\_DEF \textcolor{keywordtype}{int}  stbtt\_GetFontVMetricsOS2(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} *typoAscent, \textcolor{keywordtype}{int} *typoDescent, \textcolor{keywordtype}{int} *typoLineGap)}
\DoxyCodeLine{2642 \{}
\DoxyCodeLine{2643    \textcolor{keywordtype}{int} tab = stbtt\_\_find\_table(info-\/>data, info-\/>fontstart, \textcolor{stringliteral}{"{}OS/2"{}});}
\DoxyCodeLine{2644    \textcolor{keywordflow}{if} (!tab)}
\DoxyCodeLine{2645       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2646    \textcolor{keywordflow}{if} (typoAscent ) *typoAscent  = ttSHORT(info-\/>data+tab + 68);}
\DoxyCodeLine{2647    \textcolor{keywordflow}{if} (typoDescent) *typoDescent = ttSHORT(info-\/>data+tab + 70);}
\DoxyCodeLine{2648    \textcolor{keywordflow}{if} (typoLineGap) *typoLineGap = ttSHORT(info-\/>data+tab + 72);}
\DoxyCodeLine{2649    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{2650 \}}
\DoxyCodeLine{2651 }
\DoxyCodeLine{2652 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetFontBoundingBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} *x0, \textcolor{keywordtype}{int} *y0, \textcolor{keywordtype}{int} *x1, \textcolor{keywordtype}{int} *y1)}
\DoxyCodeLine{2653 \{}
\DoxyCodeLine{2654    *x0 = ttSHORT(info-\/>data + info-\/>head + 36);}
\DoxyCodeLine{2655    *y0 = ttSHORT(info-\/>data + info-\/>head + 38);}
\DoxyCodeLine{2656    *x1 = ttSHORT(info-\/>data + info-\/>head + 40);}
\DoxyCodeLine{2657    *y1 = ttSHORT(info-\/>data + info-\/>head + 42);}
\DoxyCodeLine{2658 \}}
\DoxyCodeLine{2659 }
\DoxyCodeLine{2660 STBTT\_DEF \textcolor{keywordtype}{float} stbtt\_ScaleForPixelHeight(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} height)}
\DoxyCodeLine{2661 \{}
\DoxyCodeLine{2662    \textcolor{keywordtype}{int} fheight = ttSHORT(info-\/>data + info-\/>hhea + 4) -\/ ttSHORT(info-\/>data + info-\/>hhea + 6);}
\DoxyCodeLine{2663    \textcolor{keywordflow}{return} (\textcolor{keywordtype}{float}) height / fheight;}
\DoxyCodeLine{2664 \}}
\DoxyCodeLine{2665 }
\DoxyCodeLine{2666 STBTT\_DEF \textcolor{keywordtype}{float} stbtt\_ScaleForMappingEmToPixels(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} pixels)}
\DoxyCodeLine{2667 \{}
\DoxyCodeLine{2668    \textcolor{keywordtype}{int} unitsPerEm = ttUSHORT(info-\/>data + info-\/>head + 18);}
\DoxyCodeLine{2669    \textcolor{keywordflow}{return} pixels / unitsPerEm;}
\DoxyCodeLine{2670 \}}
\DoxyCodeLine{2671 }
\DoxyCodeLine{2672 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_FreeShape(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *v)}
\DoxyCodeLine{2673 \{}
\DoxyCodeLine{2674    STBTT\_free(v, info-\/>userdata);}
\DoxyCodeLine{2675 \}}
\DoxyCodeLine{2676 }
\DoxyCodeLine{2677 STBTT\_DEF stbtt\_uint8 *stbtt\_FindSVGDoc(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} gl)}
\DoxyCodeLine{2678 \{}
\DoxyCodeLine{2679    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{2680    stbtt\_uint8 *data = info-\/>data;}
\DoxyCodeLine{2681    stbtt\_uint8 *svg\_doc\_list = data + stbtt\_\_get\_svg((\mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *) info);}
\DoxyCodeLine{2682 }
\DoxyCodeLine{2683    \textcolor{keywordtype}{int} numEntries = ttUSHORT(svg\_doc\_list);}
\DoxyCodeLine{2684    stbtt\_uint8 *svg\_docs = svg\_doc\_list + 2;}
\DoxyCodeLine{2685 }
\DoxyCodeLine{2686    \textcolor{keywordflow}{for}(i=0; i<numEntries; i++) \{}
\DoxyCodeLine{2687       stbtt\_uint8 *svg\_doc = svg\_docs + (12 * i);}
\DoxyCodeLine{2688       \textcolor{keywordflow}{if} ((gl >= ttUSHORT(svg\_doc)) \&\& (gl <= ttUSHORT(svg\_doc + 2)))}
\DoxyCodeLine{2689          \textcolor{keywordflow}{return} svg\_doc;}
\DoxyCodeLine{2690    \}}
\DoxyCodeLine{2691    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2692 \}}
\DoxyCodeLine{2693 }
\DoxyCodeLine{2694 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetGlyphSVG(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} gl, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **svg)}
\DoxyCodeLine{2695 \{}
\DoxyCodeLine{2696    stbtt\_uint8 *data = info-\/>data;}
\DoxyCodeLine{2697    stbtt\_uint8 *svg\_doc;}
\DoxyCodeLine{2698 }
\DoxyCodeLine{2699    \textcolor{keywordflow}{if} (info-\/>svg == 0)}
\DoxyCodeLine{2700       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2701 }
\DoxyCodeLine{2702    svg\_doc = stbtt\_FindSVGDoc(info, gl);}
\DoxyCodeLine{2703    \textcolor{keywordflow}{if} (svg\_doc != NULL) \{}
\DoxyCodeLine{2704       *svg = (\textcolor{keywordtype}{char} *) data + info-\/>svg + ttULONG(svg\_doc + 4);}
\DoxyCodeLine{2705       \textcolor{keywordflow}{return} ttULONG(svg\_doc + 8);}
\DoxyCodeLine{2706    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2707       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2708    \}}
\DoxyCodeLine{2709 \}}
\DoxyCodeLine{2710 }
\DoxyCodeLine{2711 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetCodepointSVG(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{int} unicode\_codepoint, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **svg)}
\DoxyCodeLine{2712 \{}
\DoxyCodeLine{2713    \textcolor{keywordflow}{return} stbtt\_GetGlyphSVG(info, stbtt\_FindGlyphIndex(info, unicode\_codepoint), svg);}
\DoxyCodeLine{2714 \}}
\DoxyCodeLine{2715 }
\DoxyCodeLine{2717 \textcolor{comment}{//}}
\DoxyCodeLine{2718 \textcolor{comment}{// antialiasing software rasterizer}}
\DoxyCodeLine{2719 \textcolor{comment}{//}}
\DoxyCodeLine{2720 }
\DoxyCodeLine{2721 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetGlyphBitmapBoxSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y,\textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} *ix0, \textcolor{keywordtype}{int} *iy0, \textcolor{keywordtype}{int} *ix1, \textcolor{keywordtype}{int} *iy1)}
\DoxyCodeLine{2722 \{}
\DoxyCodeLine{2723    \textcolor{keywordtype}{int} x0=0,y0=0,x1,y1; \textcolor{comment}{// =0 suppresses compiler warning}}
\DoxyCodeLine{2724    \textcolor{keywordflow}{if} (!stbtt\_GetGlyphBox(font, glyph, \&x0,\&y0,\&x1,\&y1)) \{}
\DoxyCodeLine{2725       \textcolor{comment}{// e.g. space character}}
\DoxyCodeLine{2726       \textcolor{keywordflow}{if} (ix0) *ix0 = 0;}
\DoxyCodeLine{2727       \textcolor{keywordflow}{if} (iy0) *iy0 = 0;}
\DoxyCodeLine{2728       \textcolor{keywordflow}{if} (ix1) *ix1 = 0;}
\DoxyCodeLine{2729       \textcolor{keywordflow}{if} (iy1) *iy1 = 0;}
\DoxyCodeLine{2730    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2731       \textcolor{comment}{// move to integral bboxes (treating pixels as little squares, what pixels get touched)?}}
\DoxyCodeLine{2732       \textcolor{keywordflow}{if} (ix0) *ix0 = STBTT\_ifloor( x0 * scale\_x + shift\_x);}
\DoxyCodeLine{2733       \textcolor{keywordflow}{if} (iy0) *iy0 = STBTT\_ifloor(-\/y1 * scale\_y + shift\_y);}
\DoxyCodeLine{2734       \textcolor{keywordflow}{if} (ix1) *ix1 = STBTT\_iceil ( x1 * scale\_x + shift\_x);}
\DoxyCodeLine{2735       \textcolor{keywordflow}{if} (iy1) *iy1 = STBTT\_iceil (-\/y0 * scale\_y + shift\_y);}
\DoxyCodeLine{2736    \}}
\DoxyCodeLine{2737 \}}
\DoxyCodeLine{2738 }
\DoxyCodeLine{2739 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetGlyphBitmapBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} *ix0, \textcolor{keywordtype}{int} *iy0, \textcolor{keywordtype}{int} *ix1, \textcolor{keywordtype}{int} *iy1)}
\DoxyCodeLine{2740 \{}
\DoxyCodeLine{2741    stbtt\_GetGlyphBitmapBoxSubpixel(font, glyph, scale\_x, scale\_y,0.0f,0.0f, ix0, iy0, ix1, iy1);}
\DoxyCodeLine{2742 \}}
\DoxyCodeLine{2743 }
\DoxyCodeLine{2744 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetCodepointBitmapBoxSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} *ix0, \textcolor{keywordtype}{int} *iy0, \textcolor{keywordtype}{int} *ix1, \textcolor{keywordtype}{int} *iy1)}
\DoxyCodeLine{2745 \{}
\DoxyCodeLine{2746    stbtt\_GetGlyphBitmapBoxSubpixel(font, stbtt\_FindGlyphIndex(font,codepoint), scale\_x, scale\_y,shift\_x,shift\_y, ix0,iy0,ix1,iy1);}
\DoxyCodeLine{2747 \}}
\DoxyCodeLine{2748 }
\DoxyCodeLine{2749 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetCodepointBitmapBox(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} *ix0, \textcolor{keywordtype}{int} *iy0, \textcolor{keywordtype}{int} *ix1, \textcolor{keywordtype}{int} *iy1)}
\DoxyCodeLine{2750 \{}
\DoxyCodeLine{2751    stbtt\_GetCodepointBitmapBoxSubpixel(font, codepoint, scale\_x, scale\_y,0.0f,0.0f, ix0,iy0,ix1,iy1);}
\DoxyCodeLine{2752 \}}
\DoxyCodeLine{2753 }
\DoxyCodeLine{2755 \textcolor{comment}{//}}
\DoxyCodeLine{2756 \textcolor{comment}{//  Rasterizer}}
\DoxyCodeLine{2757 }
\DoxyCodeLine{2758 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }stbtt\_\_hheap\_chunk}
\DoxyCodeLine{2759 \{}
\DoxyCodeLine{2760    \textcolor{keyword}{struct }stbtt\_\_hheap\_chunk *next;}
\DoxyCodeLine{2761 \} stbtt\_\_hheap\_chunk;}
\DoxyCodeLine{2762 }
\DoxyCodeLine{2763 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }stbtt\_\_hheap}
\DoxyCodeLine{2764 \{}
\DoxyCodeLine{2765    \textcolor{keyword}{struct }stbtt\_\_hheap\_chunk *head;}
\DoxyCodeLine{2766    \textcolor{keywordtype}{void}   *first\_free;}
\DoxyCodeLine{2767    \textcolor{keywordtype}{int}    num\_remaining\_in\_head\_chunk;}
\DoxyCodeLine{2768 \} stbtt\_\_hheap;}
\DoxyCodeLine{2769 }
\DoxyCodeLine{2770 \textcolor{keyword}{static} \textcolor{keywordtype}{void} *stbtt\_\_hheap\_alloc(stbtt\_\_hheap *hh, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{2771 \{}
\DoxyCodeLine{2772    \textcolor{keywordflow}{if} (hh-\/>first\_free) \{}
\DoxyCodeLine{2773       \textcolor{keywordtype}{void} *p = hh-\/>first\_free;}
\DoxyCodeLine{2774       hh-\/>first\_free = * (\textcolor{keywordtype}{void} **) p;}
\DoxyCodeLine{2775       \textcolor{keywordflow}{return} p;}
\DoxyCodeLine{2776    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2777       \textcolor{keywordflow}{if} (hh-\/>num\_remaining\_in\_head\_chunk == 0) \{}
\DoxyCodeLine{2778          \textcolor{keywordtype}{int} count = (size < 32 ? 2000 : size < 128 ? 800 : 100);}
\DoxyCodeLine{2779          stbtt\_\_hheap\_chunk *c = (stbtt\_\_hheap\_chunk *) STBTT\_malloc(\textcolor{keyword}{sizeof}(stbtt\_\_hheap\_chunk) + size * count, userdata);}
\DoxyCodeLine{2780          \textcolor{keywordflow}{if} (c == NULL)}
\DoxyCodeLine{2781             \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{2782          c-\/>next = hh-\/>head;}
\DoxyCodeLine{2783          hh-\/>head = c;}
\DoxyCodeLine{2784          hh-\/>num\_remaining\_in\_head\_chunk = count;}
\DoxyCodeLine{2785       \}}
\DoxyCodeLine{2786       -\/-\/hh-\/>num\_remaining\_in\_head\_chunk;}
\DoxyCodeLine{2787       \textcolor{keywordflow}{return} (\textcolor{keywordtype}{char} *) (hh-\/>head) + \textcolor{keyword}{sizeof}(stbtt\_\_hheap\_chunk) + size * hh-\/>num\_remaining\_in\_head\_chunk;}
\DoxyCodeLine{2788    \}}
\DoxyCodeLine{2789 \}}
\DoxyCodeLine{2790 }
\DoxyCodeLine{2791 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_hheap\_free(stbtt\_\_hheap *hh, \textcolor{keywordtype}{void} *p)}
\DoxyCodeLine{2792 \{}
\DoxyCodeLine{2793    *(\textcolor{keywordtype}{void} **) p = hh-\/>first\_free;}
\DoxyCodeLine{2794    hh-\/>first\_free = p;}
\DoxyCodeLine{2795 \}}
\DoxyCodeLine{2796 }
\DoxyCodeLine{2797 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_hheap\_cleanup(stbtt\_\_hheap *hh, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{2798 \{}
\DoxyCodeLine{2799    stbtt\_\_hheap\_chunk *c = hh-\/>head;}
\DoxyCodeLine{2800    \textcolor{keywordflow}{while} (c) \{}
\DoxyCodeLine{2801       stbtt\_\_hheap\_chunk *n = c-\/>next;}
\DoxyCodeLine{2802       STBTT\_free(c, userdata);}
\DoxyCodeLine{2803       c = n;}
\DoxyCodeLine{2804    \}}
\DoxyCodeLine{2805 \}}
\DoxyCodeLine{2806 }
\DoxyCodeLine{2807 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }stbtt\_\_edge \{}
\DoxyCodeLine{2808    \textcolor{keywordtype}{float} x0,y0, x1,y1;}
\DoxyCodeLine{2809    \textcolor{keywordtype}{int} invert;}
\DoxyCodeLine{2810 \} stbtt\_\_edge;}
\DoxyCodeLine{2811 }
\DoxyCodeLine{2812 }
\DoxyCodeLine{2813 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }stbtt\_\_active\_edge}
\DoxyCodeLine{2814 \{}
\DoxyCodeLine{2815    \textcolor{keyword}{struct }stbtt\_\_active\_edge *next;}
\DoxyCodeLine{2816 \textcolor{preprocessor}{   \#if STBTT\_RASTERIZER\_VERSION==1}}
\DoxyCodeLine{2817    \textcolor{keywordtype}{int} x,dx;}
\DoxyCodeLine{2818    \textcolor{keywordtype}{float} ey;}
\DoxyCodeLine{2819    \textcolor{keywordtype}{int} direction;}
\DoxyCodeLine{2820 \textcolor{preprocessor}{   \#elif STBTT\_RASTERIZER\_VERSION==2}}
\DoxyCodeLine{2821    \textcolor{keywordtype}{float} fx,fdx,fdy;}
\DoxyCodeLine{2822    \textcolor{keywordtype}{float} direction;}
\DoxyCodeLine{2823    \textcolor{keywordtype}{float} sy;}
\DoxyCodeLine{2824    \textcolor{keywordtype}{float} ey;}
\DoxyCodeLine{2825 \textcolor{preprocessor}{   \#else}}
\DoxyCodeLine{2826 \textcolor{preprocessor}{   \#error "{}Unrecognized value of STBTT\_RASTERIZER\_VERSION"{}}}
\DoxyCodeLine{2827 \textcolor{preprocessor}{   \#endif}}
\DoxyCodeLine{2828 \} stbtt\_\_active\_edge;}
\DoxyCodeLine{2829 }
\DoxyCodeLine{2830 \textcolor{preprocessor}{\#if STBTT\_RASTERIZER\_VERSION == 1}}
\DoxyCodeLine{2831 \textcolor{preprocessor}{\#define STBTT\_FIXSHIFT   10}}
\DoxyCodeLine{2832 \textcolor{preprocessor}{\#define STBTT\_FIX        (1 << STBTT\_FIXSHIFT)}}
\DoxyCodeLine{2833 \textcolor{preprocessor}{\#define STBTT\_FIXMASK    (STBTT\_FIX-\/1)}}
\DoxyCodeLine{2834 }
\DoxyCodeLine{2835 \textcolor{keyword}{static} stbtt\_\_active\_edge *stbtt\_\_new\_active(stbtt\_\_hheap *hh, stbtt\_\_edge *e, \textcolor{keywordtype}{int} off\_x, \textcolor{keywordtype}{float} start\_point, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{2836 \{}
\DoxyCodeLine{2837    stbtt\_\_active\_edge *z = (stbtt\_\_active\_edge *) stbtt\_\_hheap\_alloc(hh, \textcolor{keyword}{sizeof}(*z), userdata);}
\DoxyCodeLine{2838    \textcolor{keywordtype}{float} dxdy = (e-\/>x1 -\/ e-\/>x0) / (e-\/>y1 -\/ e-\/>y0);}
\DoxyCodeLine{2839    STBTT\_assert(z != NULL);}
\DoxyCodeLine{2840    \textcolor{keywordflow}{if} (!z) \textcolor{keywordflow}{return} z;}
\DoxyCodeLine{2841 }
\DoxyCodeLine{2842    \textcolor{comment}{// round dx down to avoid overshooting}}
\DoxyCodeLine{2843    \textcolor{keywordflow}{if} (dxdy < 0)}
\DoxyCodeLine{2844       z-\/>dx = -\/STBTT\_ifloor(STBTT\_FIX * -\/dxdy);}
\DoxyCodeLine{2845    \textcolor{keywordflow}{else}}
\DoxyCodeLine{2846       z-\/>dx = STBTT\_ifloor(STBTT\_FIX * dxdy);}
\DoxyCodeLine{2847 }
\DoxyCodeLine{2848    z-\/>x = STBTT\_ifloor(STBTT\_FIX * e-\/>x0 + z-\/>dx * (start\_point -\/ e-\/>y0)); \textcolor{comment}{// use z-\/>dx so when we offset later it's by the same amount}}
\DoxyCodeLine{2849    z-\/>x -\/= off\_x * STBTT\_FIX;}
\DoxyCodeLine{2850 }
\DoxyCodeLine{2851    z-\/>ey = e-\/>y1;}
\DoxyCodeLine{2852    z-\/>next = 0;}
\DoxyCodeLine{2853    z-\/>direction = e-\/>invert ? 1 : -\/1;}
\DoxyCodeLine{2854    \textcolor{keywordflow}{return} z;}
\DoxyCodeLine{2855 \}}
\DoxyCodeLine{2856 \textcolor{preprocessor}{\#elif STBTT\_RASTERIZER\_VERSION == 2}}
\DoxyCodeLine{2857 \textcolor{keyword}{static} stbtt\_\_active\_edge *stbtt\_\_new\_active(stbtt\_\_hheap *hh, stbtt\_\_edge *e, \textcolor{keywordtype}{int} off\_x, \textcolor{keywordtype}{float} start\_point, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{2858 \{}
\DoxyCodeLine{2859    stbtt\_\_active\_edge *z = (stbtt\_\_active\_edge *) stbtt\_\_hheap\_alloc(hh, \textcolor{keyword}{sizeof}(*z), userdata);}
\DoxyCodeLine{2860    \textcolor{keywordtype}{float} dxdy = (e-\/>x1 -\/ e-\/>x0) / (e-\/>y1 -\/ e-\/>y0);}
\DoxyCodeLine{2861    STBTT\_assert(z != NULL);}
\DoxyCodeLine{2862    \textcolor{comment}{//STBTT\_assert(e-\/>y0 <= start\_point);}}
\DoxyCodeLine{2863    \textcolor{keywordflow}{if} (!z) \textcolor{keywordflow}{return} z;}
\DoxyCodeLine{2864    z-\/>fdx = dxdy;}
\DoxyCodeLine{2865    z-\/>fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;}
\DoxyCodeLine{2866    z-\/>fx = e-\/>x0 + dxdy * (start\_point -\/ e-\/>y0);}
\DoxyCodeLine{2867    z-\/>fx -\/= off\_x;}
\DoxyCodeLine{2868    z-\/>direction = e-\/>invert ? 1.0f : -\/1.0f;}
\DoxyCodeLine{2869    z-\/>sy = e-\/>y0;}
\DoxyCodeLine{2870    z-\/>ey = e-\/>y1;}
\DoxyCodeLine{2871    z-\/>next = 0;}
\DoxyCodeLine{2872    \textcolor{keywordflow}{return} z;}
\DoxyCodeLine{2873 \}}
\DoxyCodeLine{2874 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2875 \textcolor{preprocessor}{\#error "{}Unrecognized value of STBTT\_RASTERIZER\_VERSION"{}}}
\DoxyCodeLine{2876 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2877 }
\DoxyCodeLine{2878 \textcolor{preprocessor}{\#if STBTT\_RASTERIZER\_VERSION == 1}}
\DoxyCodeLine{2879 \textcolor{comment}{// note: this routine clips fills that extend off the edges... ideally this}}
\DoxyCodeLine{2880 \textcolor{comment}{// wouldn't happen, but it could happen if the truetype glyph bounding boxes}}
\DoxyCodeLine{2881 \textcolor{comment}{// are wrong, or if the user supplies a too-\/small bitmap}}
\DoxyCodeLine{2882 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_fill\_active\_edges(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *scanline, \textcolor{keywordtype}{int} len, stbtt\_\_active\_edge *e, \textcolor{keywordtype}{int} max\_weight)}
\DoxyCodeLine{2883 \{}
\DoxyCodeLine{2884    \textcolor{comment}{// non-\/zero winding fill}}
\DoxyCodeLine{2885    \textcolor{keywordtype}{int} x0=0, w=0;}
\DoxyCodeLine{2886 }
\DoxyCodeLine{2887    \textcolor{keywordflow}{while} (e) \{}
\DoxyCodeLine{2888       \textcolor{keywordflow}{if} (w == 0) \{}
\DoxyCodeLine{2889          \textcolor{comment}{// if we're currently at zero, we need to record the edge start point}}
\DoxyCodeLine{2890          x0 = e-\/>x; w += e-\/>direction;}
\DoxyCodeLine{2891       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2892          \textcolor{keywordtype}{int} x1 = e-\/>x; w += e-\/>direction;}
\DoxyCodeLine{2893          \textcolor{comment}{// if we went to zero, we need to draw}}
\DoxyCodeLine{2894          \textcolor{keywordflow}{if} (w == 0) \{}
\DoxyCodeLine{2895             \textcolor{keywordtype}{int} i = x0 >> STBTT\_FIXSHIFT;}
\DoxyCodeLine{2896             \textcolor{keywordtype}{int} j = x1 >> STBTT\_FIXSHIFT;}
\DoxyCodeLine{2897 }
\DoxyCodeLine{2898             \textcolor{keywordflow}{if} (i < len \&\& j >= 0) \{}
\DoxyCodeLine{2899                \textcolor{keywordflow}{if} (i == j) \{}
\DoxyCodeLine{2900                   \textcolor{comment}{// x0,x1 are the same pixel, so compute combined coverage}}
\DoxyCodeLine{2901                   scanline[i] = scanline[i] + (stbtt\_uint8) ((x1 -\/ x0) * max\_weight >> STBTT\_FIXSHIFT);}
\DoxyCodeLine{2902                \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2903                   \textcolor{keywordflow}{if} (i >= 0) \textcolor{comment}{// add antialiasing for x0}}
\DoxyCodeLine{2904                      scanline[i] = scanline[i] + (stbtt\_uint8) (((STBTT\_FIX -\/ (x0 \& STBTT\_FIXMASK)) * max\_weight) >> STBTT\_FIXSHIFT);}
\DoxyCodeLine{2905                   \textcolor{keywordflow}{else}}
\DoxyCodeLine{2906                      i = -\/1; \textcolor{comment}{// clip}}
\DoxyCodeLine{2907 }
\DoxyCodeLine{2908                   \textcolor{keywordflow}{if} (j < len) \textcolor{comment}{// add antialiasing for x1}}
\DoxyCodeLine{2909                      scanline[j] = scanline[j] + (stbtt\_uint8) (((x1 \& STBTT\_FIXMASK) * max\_weight) >> STBTT\_FIXSHIFT);}
\DoxyCodeLine{2910                   \textcolor{keywordflow}{else}}
\DoxyCodeLine{2911                      j = len; \textcolor{comment}{// clip}}
\DoxyCodeLine{2912 }
\DoxyCodeLine{2913                   \textcolor{keywordflow}{for} (++i; i < j; ++i) \textcolor{comment}{// fill pixels between x0 and x1}}
\DoxyCodeLine{2914                      scanline[i] = scanline[i] + (stbtt\_uint8) max\_weight;}
\DoxyCodeLine{2915                \}}
\DoxyCodeLine{2916             \}}
\DoxyCodeLine{2917          \}}
\DoxyCodeLine{2918       \}}
\DoxyCodeLine{2919 }
\DoxyCodeLine{2920       e = e-\/>next;}
\DoxyCodeLine{2921    \}}
\DoxyCodeLine{2922 \}}
\DoxyCodeLine{2923 }
\DoxyCodeLine{2924 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_rasterize\_sorted\_edges(\mbox{\hyperlink{structstbtt____bitmap}{stbtt\_\_bitmap}} *result, stbtt\_\_edge *e, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} vsubsample, \textcolor{keywordtype}{int} off\_x, \textcolor{keywordtype}{int} off\_y, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{2925 \{}
\DoxyCodeLine{2926    stbtt\_\_hheap hh = \{ 0, 0, 0 \};}
\DoxyCodeLine{2927    stbtt\_\_active\_edge *active = NULL;}
\DoxyCodeLine{2928    \textcolor{keywordtype}{int} y,j=0;}
\DoxyCodeLine{2929    \textcolor{keywordtype}{int} max\_weight = (255 / vsubsample);  \textcolor{comment}{// weight per vertical scanline}}
\DoxyCodeLine{2930    \textcolor{keywordtype}{int} s; \textcolor{comment}{// vertical subsample index}}
\DoxyCodeLine{2931    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} scanline\_data[512], *scanline;}
\DoxyCodeLine{2932 }
\DoxyCodeLine{2933    \textcolor{keywordflow}{if} (result-\/>w > 512)}
\DoxyCodeLine{2934       scanline = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) STBTT\_malloc(result-\/>w, userdata);}
\DoxyCodeLine{2935    \textcolor{keywordflow}{else}}
\DoxyCodeLine{2936       scanline = scanline\_data;}
\DoxyCodeLine{2937 }
\DoxyCodeLine{2938    y = off\_y * vsubsample;}
\DoxyCodeLine{2939    e[n].y0 = (off\_y + result-\/>h) * (\textcolor{keywordtype}{float}) vsubsample + 1;}
\DoxyCodeLine{2940 }
\DoxyCodeLine{2941    \textcolor{keywordflow}{while} (j < result-\/>h) \{}
\DoxyCodeLine{2942       STBTT\_memset(scanline, 0, result-\/>w);}
\DoxyCodeLine{2943       \textcolor{keywordflow}{for} (s=0; s < vsubsample; ++s) \{}
\DoxyCodeLine{2944          \textcolor{comment}{// find center of pixel for this scanline}}
\DoxyCodeLine{2945          \textcolor{keywordtype}{float} scan\_y = y + 0.5f;}
\DoxyCodeLine{2946          stbtt\_\_active\_edge **step = \&active;}
\DoxyCodeLine{2947 }
\DoxyCodeLine{2948          \textcolor{comment}{// update all active edges;}}
\DoxyCodeLine{2949          \textcolor{comment}{// remove all active edges that terminate before the center of this scanline}}
\DoxyCodeLine{2950          \textcolor{keywordflow}{while} (*step) \{}
\DoxyCodeLine{2951             stbtt\_\_active\_edge * z = *step;}
\DoxyCodeLine{2952             \textcolor{keywordflow}{if} (z-\/>ey <= scan\_y) \{}
\DoxyCodeLine{2953                *step = z-\/>next; \textcolor{comment}{// delete from list}}
\DoxyCodeLine{2954                STBTT\_assert(z-\/>direction);}
\DoxyCodeLine{2955                z-\/>direction = 0;}
\DoxyCodeLine{2956                stbtt\_\_hheap\_free(\&hh, z);}
\DoxyCodeLine{2957             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2958                z-\/>x += z-\/>dx; \textcolor{comment}{// advance to position for current scanline}}
\DoxyCodeLine{2959                step = \&((*step)-\/>next); \textcolor{comment}{// advance through list}}
\DoxyCodeLine{2960             \}}
\DoxyCodeLine{2961          \}}
\DoxyCodeLine{2962 }
\DoxyCodeLine{2963          \textcolor{comment}{// resort the list if needed}}
\DoxyCodeLine{2964          \textcolor{keywordflow}{for}(;;) \{}
\DoxyCodeLine{2965             \textcolor{keywordtype}{int} changed=0;}
\DoxyCodeLine{2966             step = \&active;}
\DoxyCodeLine{2967             \textcolor{keywordflow}{while} (*step \&\& (*step)-\/>next) \{}
\DoxyCodeLine{2968                \textcolor{keywordflow}{if} ((*step)-\/>x > (*step)-\/>next-\/>x) \{}
\DoxyCodeLine{2969                   stbtt\_\_active\_edge *t = *step;}
\DoxyCodeLine{2970                   stbtt\_\_active\_edge *q = t-\/>next;}
\DoxyCodeLine{2971 }
\DoxyCodeLine{2972                   t-\/>next = q-\/>next;}
\DoxyCodeLine{2973                   q-\/>next = t;}
\DoxyCodeLine{2974                   *step = q;}
\DoxyCodeLine{2975                   changed = 1;}
\DoxyCodeLine{2976                \}}
\DoxyCodeLine{2977                step = \&(*step)-\/>next;}
\DoxyCodeLine{2978             \}}
\DoxyCodeLine{2979             \textcolor{keywordflow}{if} (!changed) \textcolor{keywordflow}{break};}
\DoxyCodeLine{2980          \}}
\DoxyCodeLine{2981 }
\DoxyCodeLine{2982          \textcolor{comment}{// insert all edges that start before the center of this scanline -\/-\/ omit ones that also end on this scanline}}
\DoxyCodeLine{2983          \textcolor{keywordflow}{while} (e-\/>y0 <= scan\_y) \{}
\DoxyCodeLine{2984             \textcolor{keywordflow}{if} (e-\/>y1 > scan\_y) \{}
\DoxyCodeLine{2985                stbtt\_\_active\_edge *z = stbtt\_\_new\_active(\&hh, e, off\_x, scan\_y, userdata);}
\DoxyCodeLine{2986                \textcolor{keywordflow}{if} (z != NULL) \{}
\DoxyCodeLine{2987                   \textcolor{comment}{// find insertion point}}
\DoxyCodeLine{2988                   \textcolor{keywordflow}{if} (active == NULL)}
\DoxyCodeLine{2989                      active = z;}
\DoxyCodeLine{2990                   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (z-\/>x < active-\/>x) \{}
\DoxyCodeLine{2991                      \textcolor{comment}{// insert at front}}
\DoxyCodeLine{2992                      z-\/>next = active;}
\DoxyCodeLine{2993                      active = z;}
\DoxyCodeLine{2994                   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2995                      \textcolor{comment}{// find thing to insert AFTER}}
\DoxyCodeLine{2996                      stbtt\_\_active\_edge *p = active;}
\DoxyCodeLine{2997                      \textcolor{keywordflow}{while} (p-\/>next \&\& p-\/>next-\/>x < z-\/>x)}
\DoxyCodeLine{2998                         p = p-\/>next;}
\DoxyCodeLine{2999                      \textcolor{comment}{// at this point, p-\/>next-\/>x is NOT < z-\/>x}}
\DoxyCodeLine{3000                      z-\/>next = p-\/>next;}
\DoxyCodeLine{3001                      p-\/>next = z;}
\DoxyCodeLine{3002                   \}}
\DoxyCodeLine{3003                \}}
\DoxyCodeLine{3004             \}}
\DoxyCodeLine{3005             ++e;}
\DoxyCodeLine{3006          \}}
\DoxyCodeLine{3007 }
\DoxyCodeLine{3008          \textcolor{comment}{// now process all active edges in XOR fashion}}
\DoxyCodeLine{3009          \textcolor{keywordflow}{if} (active)}
\DoxyCodeLine{3010             stbtt\_\_fill\_active\_edges(scanline, result-\/>w, active, max\_weight);}
\DoxyCodeLine{3011 }
\DoxyCodeLine{3012          ++y;}
\DoxyCodeLine{3013       \}}
\DoxyCodeLine{3014       STBTT\_memcpy(result-\/>pixels + j * result-\/>stride, scanline, result-\/>w);}
\DoxyCodeLine{3015       ++j;}
\DoxyCodeLine{3016    \}}
\DoxyCodeLine{3017 }
\DoxyCodeLine{3018    stbtt\_\_hheap\_cleanup(\&hh, userdata);}
\DoxyCodeLine{3019 }
\DoxyCodeLine{3020    \textcolor{keywordflow}{if} (scanline != scanline\_data)}
\DoxyCodeLine{3021       STBTT\_free(scanline, userdata);}
\DoxyCodeLine{3022 \}}
\DoxyCodeLine{3023 }
\DoxyCodeLine{3024 \textcolor{preprocessor}{\#elif STBTT\_RASTERIZER\_VERSION == 2}}
\DoxyCodeLine{3025 }
\DoxyCodeLine{3026 \textcolor{comment}{// the edge passed in here does not cross the vertical line at x or the vertical line at x+1}}
\DoxyCodeLine{3027 \textcolor{comment}{// (i.e. it has already been clipped to those)}}
\DoxyCodeLine{3028 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_handle\_clipped\_edge(\textcolor{keywordtype}{float} *scanline, \textcolor{keywordtype}{int} x, stbtt\_\_active\_edge *e, \textcolor{keywordtype}{float} x0, \textcolor{keywordtype}{float} y0, \textcolor{keywordtype}{float} x1, \textcolor{keywordtype}{float} y1)}
\DoxyCodeLine{3029 \{}
\DoxyCodeLine{3030    \textcolor{keywordflow}{if} (y0 == y1) \textcolor{keywordflow}{return};}
\DoxyCodeLine{3031    STBTT\_assert(y0 < y1);}
\DoxyCodeLine{3032    STBTT\_assert(e-\/>sy <= e-\/>ey);}
\DoxyCodeLine{3033    \textcolor{keywordflow}{if} (y0 > e-\/>ey) \textcolor{keywordflow}{return};}
\DoxyCodeLine{3034    \textcolor{keywordflow}{if} (y1 < e-\/>sy) \textcolor{keywordflow}{return};}
\DoxyCodeLine{3035    \textcolor{keywordflow}{if} (y0 < e-\/>sy) \{}
\DoxyCodeLine{3036       x0 += (x1-\/x0) * (e-\/>sy -\/ y0) / (y1-\/y0);}
\DoxyCodeLine{3037       y0 = e-\/>sy;}
\DoxyCodeLine{3038    \}}
\DoxyCodeLine{3039    \textcolor{keywordflow}{if} (y1 > e-\/>ey) \{}
\DoxyCodeLine{3040       x1 += (x1-\/x0) * (e-\/>ey -\/ y1) / (y1-\/y0);}
\DoxyCodeLine{3041       y1 = e-\/>ey;}
\DoxyCodeLine{3042    \}}
\DoxyCodeLine{3043 }
\DoxyCodeLine{3044    \textcolor{keywordflow}{if} (x0 == x)}
\DoxyCodeLine{3045       STBTT\_assert(x1 <= x+1);}
\DoxyCodeLine{3046    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x0 == x+1)}
\DoxyCodeLine{3047       STBTT\_assert(x1 >= x);}
\DoxyCodeLine{3048    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x0 <= x)}
\DoxyCodeLine{3049       STBTT\_assert(x1 <= x);}
\DoxyCodeLine{3050    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x0 >= x+1)}
\DoxyCodeLine{3051       STBTT\_assert(x1 >= x+1);}
\DoxyCodeLine{3052    \textcolor{keywordflow}{else}}
\DoxyCodeLine{3053       STBTT\_assert(x1 >= x \&\& x1 <= x+1);}
\DoxyCodeLine{3054 }
\DoxyCodeLine{3055    \textcolor{keywordflow}{if} (x0 <= x \&\& x1 <= x)}
\DoxyCodeLine{3056       scanline[x] += e-\/>direction * (y1-\/y0);}
\DoxyCodeLine{3057    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x0 >= x+1 \&\& x1 >= x+1)}
\DoxyCodeLine{3058       ;}
\DoxyCodeLine{3059    \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3060       STBTT\_assert(x0 >= x \&\& x0 <= x+1 \&\& x1 >= x \&\& x1 <= x+1);}
\DoxyCodeLine{3061       scanline[x] += e-\/>direction * (y1-\/y0) * (1-\/((x0-\/x)+(x1-\/x))/2); \textcolor{comment}{// coverage = 1 -\/ average x position}}
\DoxyCodeLine{3062    \}}
\DoxyCodeLine{3063 \}}
\DoxyCodeLine{3064 }
\DoxyCodeLine{3065 \textcolor{keyword}{static} \textcolor{keywordtype}{float} stbtt\_\_sized\_trapezoid\_area(\textcolor{keywordtype}{float} height, \textcolor{keywordtype}{float} top\_width, \textcolor{keywordtype}{float} bottom\_width)}
\DoxyCodeLine{3066 \{}
\DoxyCodeLine{3067    STBTT\_assert(top\_width >= 0);}
\DoxyCodeLine{3068    STBTT\_assert(bottom\_width >= 0);}
\DoxyCodeLine{3069    \textcolor{keywordflow}{return} (top\_width + bottom\_width) / 2.0f * height;}
\DoxyCodeLine{3070 \}}
\DoxyCodeLine{3071 }
\DoxyCodeLine{3072 \textcolor{keyword}{static} \textcolor{keywordtype}{float} stbtt\_\_position\_trapezoid\_area(\textcolor{keywordtype}{float} height, \textcolor{keywordtype}{float} tx0, \textcolor{keywordtype}{float} tx1, \textcolor{keywordtype}{float} bx0, \textcolor{keywordtype}{float} bx1)}
\DoxyCodeLine{3073 \{}
\DoxyCodeLine{3074    \textcolor{keywordflow}{return} stbtt\_\_sized\_trapezoid\_area(height, tx1 -\/ tx0, bx1 -\/ bx0);}
\DoxyCodeLine{3075 \}}
\DoxyCodeLine{3076 }
\DoxyCodeLine{3077 \textcolor{keyword}{static} \textcolor{keywordtype}{float} stbtt\_\_sized\_triangle\_area(\textcolor{keywordtype}{float} height, \textcolor{keywordtype}{float} width)}
\DoxyCodeLine{3078 \{}
\DoxyCodeLine{3079    \textcolor{keywordflow}{return} height * width / 2;}
\DoxyCodeLine{3080 \}}
\DoxyCodeLine{3081 }
\DoxyCodeLine{3082 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_fill\_active\_edges\_new(\textcolor{keywordtype}{float} *scanline, \textcolor{keywordtype}{float} *scanline\_fill, \textcolor{keywordtype}{int} len, stbtt\_\_active\_edge *e, \textcolor{keywordtype}{float} y\_top)}
\DoxyCodeLine{3083 \{}
\DoxyCodeLine{3084    \textcolor{keywordtype}{float} y\_bottom = y\_top+1;}
\DoxyCodeLine{3085 }
\DoxyCodeLine{3086    \textcolor{keywordflow}{while} (e) \{}
\DoxyCodeLine{3087       \textcolor{comment}{// brute force every pixel}}
\DoxyCodeLine{3088 }
\DoxyCodeLine{3089       \textcolor{comment}{// compute intersection points with top \& bottom}}
\DoxyCodeLine{3090       STBTT\_assert(e-\/>ey >= y\_top);}
\DoxyCodeLine{3091 }
\DoxyCodeLine{3092       \textcolor{keywordflow}{if} (e-\/>fdx == 0) \{}
\DoxyCodeLine{3093          \textcolor{keywordtype}{float} x0 = e-\/>fx;}
\DoxyCodeLine{3094          \textcolor{keywordflow}{if} (x0 < len) \{}
\DoxyCodeLine{3095             \textcolor{keywordflow}{if} (x0 >= 0) \{}
\DoxyCodeLine{3096                stbtt\_\_handle\_clipped\_edge(scanline,(\textcolor{keywordtype}{int}) x0,e, x0,y\_top, x0,y\_bottom);}
\DoxyCodeLine{3097                stbtt\_\_handle\_clipped\_edge(scanline\_fill-\/1,(\textcolor{keywordtype}{int}) x0+1,e, x0,y\_top, x0,y\_bottom);}
\DoxyCodeLine{3098             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3099                stbtt\_\_handle\_clipped\_edge(scanline\_fill-\/1,0,e, x0,y\_top, x0,y\_bottom);}
\DoxyCodeLine{3100             \}}
\DoxyCodeLine{3101          \}}
\DoxyCodeLine{3102       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3103          \textcolor{keywordtype}{float} x0 = e-\/>fx;}
\DoxyCodeLine{3104          \textcolor{keywordtype}{float} dx = e-\/>fdx;}
\DoxyCodeLine{3105          \textcolor{keywordtype}{float} xb = x0 + dx;}
\DoxyCodeLine{3106          \textcolor{keywordtype}{float} x\_top, x\_bottom;}
\DoxyCodeLine{3107          \textcolor{keywordtype}{float} sy0,sy1;}
\DoxyCodeLine{3108          \textcolor{keywordtype}{float} dy = e-\/>fdy;}
\DoxyCodeLine{3109          STBTT\_assert(e-\/>sy <= y\_bottom \&\& e-\/>ey >= y\_top);}
\DoxyCodeLine{3110 }
\DoxyCodeLine{3111          \textcolor{comment}{// compute endpoints of line segment clipped to this scanline (if the}}
\DoxyCodeLine{3112          \textcolor{comment}{// line segment starts on this scanline. x0 is the intersection of the}}
\DoxyCodeLine{3113          \textcolor{comment}{// line with y\_top, but that may be off the line segment.}}
\DoxyCodeLine{3114          \textcolor{keywordflow}{if} (e-\/>sy > y\_top) \{}
\DoxyCodeLine{3115             x\_top = x0 + dx * (e-\/>sy -\/ y\_top);}
\DoxyCodeLine{3116             sy0 = e-\/>sy;}
\DoxyCodeLine{3117          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3118             x\_top = x0;}
\DoxyCodeLine{3119             sy0 = y\_top;}
\DoxyCodeLine{3120          \}}
\DoxyCodeLine{3121          \textcolor{keywordflow}{if} (e-\/>ey < y\_bottom) \{}
\DoxyCodeLine{3122             x\_bottom = x0 + dx * (e-\/>ey -\/ y\_top);}
\DoxyCodeLine{3123             sy1 = e-\/>ey;}
\DoxyCodeLine{3124          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3125             x\_bottom = xb;}
\DoxyCodeLine{3126             sy1 = y\_bottom;}
\DoxyCodeLine{3127          \}}
\DoxyCodeLine{3128 }
\DoxyCodeLine{3129          \textcolor{keywordflow}{if} (x\_top >= 0 \&\& x\_bottom >= 0 \&\& x\_top < len \&\& x\_bottom < len) \{}
\DoxyCodeLine{3130             \textcolor{comment}{// from here on, we don't have to range check x values}}
\DoxyCodeLine{3131 }
\DoxyCodeLine{3132             \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int}) x\_top == (int) x\_bottom) \{}
\DoxyCodeLine{3133                \textcolor{keywordtype}{float} height;}
\DoxyCodeLine{3134                \textcolor{comment}{// simple case, only spans one pixel}}
\DoxyCodeLine{3135                \textcolor{keywordtype}{int} x = (int) x\_top;}
\DoxyCodeLine{3136                height = (sy1 -\/ sy0) * e-\/>direction;}
\DoxyCodeLine{3137                STBTT\_assert(x >= 0 \&\& x < len);}
\DoxyCodeLine{3138                scanline[x]      += stbtt\_\_position\_trapezoid\_area(height, x\_top, x+1.0f, x\_bottom, x+1.0f);}
\DoxyCodeLine{3139                scanline\_fill[x] += height; \textcolor{comment}{// everything right of this pixel is filled}}
\DoxyCodeLine{3140             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3141                \textcolor{keywordtype}{int} x,x1,x2;}
\DoxyCodeLine{3142                \textcolor{keywordtype}{float} y\_crossing, y\_final, step, sign, area;}
\DoxyCodeLine{3143                \textcolor{comment}{// covers 2+ pixels}}
\DoxyCodeLine{3144                \textcolor{keywordflow}{if} (x\_top > x\_bottom) \{}
\DoxyCodeLine{3145                   \textcolor{comment}{// flip scanline vertically; signed area is the same}}
\DoxyCodeLine{3146                   \textcolor{keywordtype}{float} t;}
\DoxyCodeLine{3147                   sy0 = y\_bottom -\/ (sy0 -\/ y\_top);}
\DoxyCodeLine{3148                   sy1 = y\_bottom -\/ (sy1 -\/ y\_top);}
\DoxyCodeLine{3149                   t = sy0, sy0 = sy1, sy1 = t;}
\DoxyCodeLine{3150                   t = x\_bottom, x\_bottom = x\_top, x\_top = t;}
\DoxyCodeLine{3151                   dx = -\/dx;}
\DoxyCodeLine{3152                   dy = -\/dy;}
\DoxyCodeLine{3153                   t = x0, x0 = xb, xb = t;}
\DoxyCodeLine{3154                \}}
\DoxyCodeLine{3155                STBTT\_assert(dy >= 0);}
\DoxyCodeLine{3156                STBTT\_assert(dx >= 0);}
\DoxyCodeLine{3157 }
\DoxyCodeLine{3158                x1 = (int) x\_top;}
\DoxyCodeLine{3159                x2 = (int) x\_bottom;}
\DoxyCodeLine{3160                \textcolor{comment}{// compute intersection with y axis at x1+1}}
\DoxyCodeLine{3161                y\_crossing = y\_top + dy * (x1+1 -\/ x0);}
\DoxyCodeLine{3162 }
\DoxyCodeLine{3163                \textcolor{comment}{// compute intersection with y axis at x2}}
\DoxyCodeLine{3164                y\_final = y\_top + dy * (x2 -\/ x0);}
\DoxyCodeLine{3165 }
\DoxyCodeLine{3166                \textcolor{comment}{//           x1    x\_top                            x2    x\_bottom}}
\DoxyCodeLine{3167                \textcolor{comment}{//     y\_top  +-\/-\/-\/-\/-\/-\/|-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/|-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+}}
\DoxyCodeLine{3168                \textcolor{comment}{//            |            |            |            |            |            |}}
\DoxyCodeLine{3169                \textcolor{comment}{//            |            |            |            |            |            |}}
\DoxyCodeLine{3170                \textcolor{comment}{//       sy0  |      Txxxxx|............|............|............|............|}}
\DoxyCodeLine{3171                \textcolor{comment}{// y\_crossing |            *xxxxx.......|............|............|............|}}
\DoxyCodeLine{3172                \textcolor{comment}{//            |            |     xxxxx..|............|............|............|}}
\DoxyCodeLine{3173                \textcolor{comment}{//            |            |     /-\/   xx*xxxx........|............|............|}}
\DoxyCodeLine{3174                \textcolor{comment}{//            |            | dy <       |    xxxxxx..|............|............|}}
\DoxyCodeLine{3175                \textcolor{comment}{//   y\_final  |            |     \(\backslash\)-\/     |          xx*xxx.........|............|}}
\DoxyCodeLine{3176                \textcolor{comment}{//       sy1  |            |            |            |   xxxxxB...|............|}}
\DoxyCodeLine{3177                \textcolor{comment}{//            |            |            |            |            |            |}}
\DoxyCodeLine{3178                \textcolor{comment}{//            |            |            |            |            |            |}}
\DoxyCodeLine{3179                \textcolor{comment}{//  y\_bottom  +-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+}}
\DoxyCodeLine{3180                \textcolor{comment}{//}}
\DoxyCodeLine{3181                \textcolor{comment}{// goal is to measure the area covered by '.' in each pixel}}
\DoxyCodeLine{3182 }
\DoxyCodeLine{3183                \textcolor{comment}{// if x2 is right at the right edge of x1, y\_crossing can blow up, github \#1057}}
\DoxyCodeLine{3184                \textcolor{comment}{// @TODO: maybe test against sy1 rather than y\_bottom?}}
\DoxyCodeLine{3185                \textcolor{keywordflow}{if} (y\_crossing > y\_bottom)}
\DoxyCodeLine{3186                   y\_crossing = y\_bottom;}
\DoxyCodeLine{3187 }
\DoxyCodeLine{3188                sign = e-\/>direction;}
\DoxyCodeLine{3189 }
\DoxyCodeLine{3190                \textcolor{comment}{// area of the rectangle covered from sy0..y\_crossing}}
\DoxyCodeLine{3191                area = sign * (y\_crossing-\/sy0);}
\DoxyCodeLine{3192 }
\DoxyCodeLine{3193                \textcolor{comment}{// area of the triangle (x\_top,sy0), (x1+1,sy0), (x1+1,y\_crossing)}}
\DoxyCodeLine{3194                scanline[x1] += stbtt\_\_sized\_triangle\_area(area, x1+1 -\/ x\_top);}
\DoxyCodeLine{3195 }
\DoxyCodeLine{3196                \textcolor{comment}{// check if final y\_crossing is blown up; no test case for this}}
\DoxyCodeLine{3197                \textcolor{keywordflow}{if} (y\_final > y\_bottom) \{}
\DoxyCodeLine{3198                   y\_final = y\_bottom;}
\DoxyCodeLine{3199                   dy = (y\_final -\/ y\_crossing ) / (x2 -\/ (x1+1)); \textcolor{comment}{// if denom=0, y\_final = y\_crossing, so y\_final <= y\_bottom}}
\DoxyCodeLine{3200                \}}
\DoxyCodeLine{3201 }
\DoxyCodeLine{3202                \textcolor{comment}{// in second pixel, area covered by line segment found in first pixel}}
\DoxyCodeLine{3203                \textcolor{comment}{// is always a rectangle 1 wide * the height of that line segment; this}}
\DoxyCodeLine{3204                \textcolor{comment}{// is exactly what the variable 'area' stores. it also gets a contribution}}
\DoxyCodeLine{3205                \textcolor{comment}{// from the line segment within it. the THIRD pixel will get the first}}
\DoxyCodeLine{3206                \textcolor{comment}{// pixel's rectangle contribution, the second pixel's rectangle contribution,}}
\DoxyCodeLine{3207                \textcolor{comment}{// and its own contribution. the 'own contribution' is the same in every pixel except}}
\DoxyCodeLine{3208                \textcolor{comment}{// the leftmost and rightmost, a trapezoid that slides down in each pixel.}}
\DoxyCodeLine{3209                \textcolor{comment}{// the second pixel's contribution to the third pixel will be the}}
\DoxyCodeLine{3210                \textcolor{comment}{// rectangle 1 wide times the height change in the second pixel, which is dy.}}
\DoxyCodeLine{3211 }
\DoxyCodeLine{3212                step = sign * dy * 1; \textcolor{comment}{// dy is dy/dx, change in y for every 1 change in x,}}
\DoxyCodeLine{3213                \textcolor{comment}{// which multiplied by 1-\/pixel-\/width is how much pixel area changes for each step in x}}
\DoxyCodeLine{3214                \textcolor{comment}{// so the area advances by 'step' every time}}
\DoxyCodeLine{3215 }
\DoxyCodeLine{3216                \textcolor{keywordflow}{for} (x = x1+1; x < x2; ++x) \{}
\DoxyCodeLine{3217                   scanline[x] += area + step/2; \textcolor{comment}{// area of trapezoid is 1*step/2}}
\DoxyCodeLine{3218                   area += step;}
\DoxyCodeLine{3219                \}}
\DoxyCodeLine{3220                STBTT\_assert(STBTT\_fabs(area) <= 1.01f); \textcolor{comment}{// accumulated error from area += step unless we round step down}}
\DoxyCodeLine{3221                STBTT\_assert(sy1 > y\_final-\/0.01f);}
\DoxyCodeLine{3222 }
\DoxyCodeLine{3223                \textcolor{comment}{// area covered in the last pixel is the rectangle from all the pixels to the left,}}
\DoxyCodeLine{3224                \textcolor{comment}{// plus the trapezoid filled by the line segment in this pixel all the way to the right edge}}
\DoxyCodeLine{3225                scanline[x2] += area + sign * stbtt\_\_position\_trapezoid\_area(sy1-\/y\_final, (\textcolor{keywordtype}{float}) x2, x2+1.0f, x\_bottom, x2+1.0f);}
\DoxyCodeLine{3226 }
\DoxyCodeLine{3227                \textcolor{comment}{// the rest of the line is filled based on the total height of the line segment in this pixel}}
\DoxyCodeLine{3228                scanline\_fill[x2] += sign * (sy1-\/sy0);}
\DoxyCodeLine{3229             \}}
\DoxyCodeLine{3230          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3231             \textcolor{comment}{// if edge goes outside of box we're drawing, we require}}
\DoxyCodeLine{3232             \textcolor{comment}{// clipping logic. since this does not match the intended use}}
\DoxyCodeLine{3233             \textcolor{comment}{// of this library, we use a different, very slow brute}}
\DoxyCodeLine{3234             \textcolor{comment}{// force implementation}}
\DoxyCodeLine{3235             \textcolor{comment}{// note though that this does happen some of the time because}}
\DoxyCodeLine{3236             \textcolor{comment}{// x\_top and x\_bottom can be extrapolated at the top \& bottom of}}
\DoxyCodeLine{3237             \textcolor{comment}{// the shape and actually lie outside the bounding box}}
\DoxyCodeLine{3238             \textcolor{keywordtype}{int} x;}
\DoxyCodeLine{3239             \textcolor{keywordflow}{for} (x=0; x < len; ++x) \{}
\DoxyCodeLine{3240                \textcolor{comment}{// cases:}}
\DoxyCodeLine{3241                \textcolor{comment}{//}}
\DoxyCodeLine{3242                \textcolor{comment}{// there can be up to two intersections with the pixel. any intersection}}
\DoxyCodeLine{3243                \textcolor{comment}{// with left or right edges can be handled by splitting into two (or three)}}
\DoxyCodeLine{3244                \textcolor{comment}{// regions. intersections with top \& bottom do not necessitate case-\/wise logic.}}
\DoxyCodeLine{3245                \textcolor{comment}{//}}
\DoxyCodeLine{3246                \textcolor{comment}{// the old way of doing this found the intersections with the left \& right edges,}}
\DoxyCodeLine{3247                \textcolor{comment}{// then used some simple logic to produce up to three segments in sorted order}}
\DoxyCodeLine{3248                \textcolor{comment}{// from top-\/to-\/bottom. however, this had a problem: if an x edge was epsilon}}
\DoxyCodeLine{3249                \textcolor{comment}{// across the x border, then the corresponding y position might not be distinct}}
\DoxyCodeLine{3250                \textcolor{comment}{// from the other y segment, and it might ignored as an empty segment. to avoid}}
\DoxyCodeLine{3251                \textcolor{comment}{// that, we need to explicitly produce segments based on x positions.}}
\DoxyCodeLine{3252 }
\DoxyCodeLine{3253                \textcolor{comment}{// rename variables to clearly-\/defined pairs}}
\DoxyCodeLine{3254                \textcolor{keywordtype}{float} y0 = y\_top;}
\DoxyCodeLine{3255                \textcolor{keywordtype}{float} x1 = (float) (x);}
\DoxyCodeLine{3256                \textcolor{keywordtype}{float} x2 = (float) (x+1);}
\DoxyCodeLine{3257                \textcolor{keywordtype}{float} x3 = xb;}
\DoxyCodeLine{3258                \textcolor{keywordtype}{float} y3 = y\_bottom;}
\DoxyCodeLine{3259 }
\DoxyCodeLine{3260                \textcolor{comment}{// x = e-\/>x + e-\/>dx * (y-\/y\_top)}}
\DoxyCodeLine{3261                \textcolor{comment}{// (y-\/y\_top) = (x -\/ e-\/>x) / e-\/>dx}}
\DoxyCodeLine{3262                \textcolor{comment}{// y = (x -\/ e-\/>x) / e-\/>dx + y\_top}}
\DoxyCodeLine{3263                \textcolor{keywordtype}{float} y1 = (x -\/ x0) / dx + y\_top;}
\DoxyCodeLine{3264                \textcolor{keywordtype}{float} y2 = (x+1 -\/ x0) / dx + y\_top;}
\DoxyCodeLine{3265 }
\DoxyCodeLine{3266                \textcolor{keywordflow}{if} (x0 < x1 \&\& x3 > x2) \{         \textcolor{comment}{// three segments descending down-\/right}}
\DoxyCodeLine{3267                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x0,y0, x1,y1);}
\DoxyCodeLine{3268                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x1,y1, x2,y2);}
\DoxyCodeLine{3269                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x2,y2, x3,y3);}
\DoxyCodeLine{3270                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x3 < x1 \&\& x0 > x2) \{  \textcolor{comment}{// three segments descending down-\/left}}
\DoxyCodeLine{3271                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x0,y0, x2,y2);}
\DoxyCodeLine{3272                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x2,y2, x1,y1);}
\DoxyCodeLine{3273                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x1,y1, x3,y3);}
\DoxyCodeLine{3274                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x0 < x1 \&\& x3 > x1) \{  \textcolor{comment}{// two segments across x, down-\/right}}
\DoxyCodeLine{3275                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x0,y0, x1,y1);}
\DoxyCodeLine{3276                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x1,y1, x3,y3);}
\DoxyCodeLine{3277                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x3 < x1 \&\& x0 > x1) \{  \textcolor{comment}{// two segments across x, down-\/left}}
\DoxyCodeLine{3278                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x0,y0, x1,y1);}
\DoxyCodeLine{3279                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x1,y1, x3,y3);}
\DoxyCodeLine{3280                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x0 < x2 \&\& x3 > x2) \{  \textcolor{comment}{// two segments across x+1, down-\/right}}
\DoxyCodeLine{3281                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x0,y0, x2,y2);}
\DoxyCodeLine{3282                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x2,y2, x3,y3);}
\DoxyCodeLine{3283                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x3 < x2 \&\& x0 > x2) \{  \textcolor{comment}{// two segments across x+1, down-\/left}}
\DoxyCodeLine{3284                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x0,y0, x2,y2);}
\DoxyCodeLine{3285                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x2,y2, x3,y3);}
\DoxyCodeLine{3286                \} \textcolor{keywordflow}{else} \{  \textcolor{comment}{// one segment}}
\DoxyCodeLine{3287                   stbtt\_\_handle\_clipped\_edge(scanline,x,e, x0,y0, x3,y3);}
\DoxyCodeLine{3288                \}}
\DoxyCodeLine{3289             \}}
\DoxyCodeLine{3290          \}}
\DoxyCodeLine{3291       \}}
\DoxyCodeLine{3292       e = e-\/>next;}
\DoxyCodeLine{3293    \}}
\DoxyCodeLine{3294 \}}
\DoxyCodeLine{3295 }
\DoxyCodeLine{3296 \textcolor{comment}{// directly AA rasterize edges w/o supersampling}}
\DoxyCodeLine{3297 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_rasterize\_sorted\_edges(\mbox{\hyperlink{structstbtt____bitmap}{stbtt\_\_bitmap}} *result, stbtt\_\_edge *e, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{int} vsubsample, \textcolor{keywordtype}{int} off\_x, \textcolor{keywordtype}{int} off\_y, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{3298 \{}
\DoxyCodeLine{3299    stbtt\_\_hheap hh = \{ 0, 0, 0 \};}
\DoxyCodeLine{3300    stbtt\_\_active\_edge *active = NULL;}
\DoxyCodeLine{3301    \textcolor{keywordtype}{int} y,j=0, i;}
\DoxyCodeLine{3302    \textcolor{keywordtype}{float} scanline\_data[129], *scanline, *scanline2;}
\DoxyCodeLine{3303 }
\DoxyCodeLine{3304    STBTT\_\_NOTUSED(vsubsample);}
\DoxyCodeLine{3305 }
\DoxyCodeLine{3306    \textcolor{keywordflow}{if} (result-\/>w > 64)}
\DoxyCodeLine{3307       scanline = (\textcolor{keywordtype}{float} *) STBTT\_malloc((result-\/>w*2+1) * \textcolor{keyword}{sizeof}(float), userdata);}
\DoxyCodeLine{3308    \textcolor{keywordflow}{else}}
\DoxyCodeLine{3309       scanline = scanline\_data;}
\DoxyCodeLine{3310 }
\DoxyCodeLine{3311    scanline2 = scanline + result-\/>w;}
\DoxyCodeLine{3312 }
\DoxyCodeLine{3313    y = off\_y;}
\DoxyCodeLine{3314    e[n].y0 = (float) (off\_y + result-\/>h) + 1;}
\DoxyCodeLine{3315 }
\DoxyCodeLine{3316    \textcolor{keywordflow}{while} (j < result-\/>h) \{}
\DoxyCodeLine{3317       \textcolor{comment}{// find center of pixel for this scanline}}
\DoxyCodeLine{3318       \textcolor{keywordtype}{float} scan\_y\_top    = y + 0.0f;}
\DoxyCodeLine{3319       \textcolor{keywordtype}{float} scan\_y\_bottom = y + 1.0f;}
\DoxyCodeLine{3320       stbtt\_\_active\_edge **step = \&active;}
\DoxyCodeLine{3321 }
\DoxyCodeLine{3322       STBTT\_memset(scanline , 0, result-\/>w*\textcolor{keyword}{sizeof}(scanline[0]));}
\DoxyCodeLine{3323       STBTT\_memset(scanline2, 0, (result-\/>w+1)*\textcolor{keyword}{sizeof}(scanline[0]));}
\DoxyCodeLine{3324 }
\DoxyCodeLine{3325       \textcolor{comment}{// update all active edges;}}
\DoxyCodeLine{3326       \textcolor{comment}{// remove all active edges that terminate before the top of this scanline}}
\DoxyCodeLine{3327       \textcolor{keywordflow}{while} (*step) \{}
\DoxyCodeLine{3328          stbtt\_\_active\_edge * z = *step;}
\DoxyCodeLine{3329          \textcolor{keywordflow}{if} (z-\/>ey <= scan\_y\_top) \{}
\DoxyCodeLine{3330             *step = z-\/>next; \textcolor{comment}{// delete from list}}
\DoxyCodeLine{3331             STBTT\_assert(z-\/>direction);}
\DoxyCodeLine{3332             z-\/>direction = 0;}
\DoxyCodeLine{3333             stbtt\_\_hheap\_free(\&hh, z);}
\DoxyCodeLine{3334          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3335             step = \&((*step)-\/>next); \textcolor{comment}{// advance through list}}
\DoxyCodeLine{3336          \}}
\DoxyCodeLine{3337       \}}
\DoxyCodeLine{3338 }
\DoxyCodeLine{3339       \textcolor{comment}{// insert all edges that start before the bottom of this scanline}}
\DoxyCodeLine{3340       \textcolor{keywordflow}{while} (e-\/>y0 <= scan\_y\_bottom) \{}
\DoxyCodeLine{3341          \textcolor{keywordflow}{if} (e-\/>y0 != e-\/>y1) \{}
\DoxyCodeLine{3342             stbtt\_\_active\_edge *z = stbtt\_\_new\_active(\&hh, e, off\_x, scan\_y\_top, userdata);}
\DoxyCodeLine{3343             \textcolor{keywordflow}{if} (z != NULL) \{}
\DoxyCodeLine{3344                \textcolor{keywordflow}{if} (j == 0 \&\& off\_y != 0) \{}
\DoxyCodeLine{3345                   \textcolor{keywordflow}{if} (z-\/>ey < scan\_y\_top) \{}
\DoxyCodeLine{3346                      \textcolor{comment}{// this can happen due to subpixel positioning and some kind of fp rounding error i think}}
\DoxyCodeLine{3347                      z-\/>ey = scan\_y\_top;}
\DoxyCodeLine{3348                   \}}
\DoxyCodeLine{3349                \}}
\DoxyCodeLine{3350                STBTT\_assert(z-\/>ey >= scan\_y\_top); \textcolor{comment}{// if we get really unlucky a tiny bit of an edge can be out of bounds}}
\DoxyCodeLine{3351                \textcolor{comment}{// insert at front}}
\DoxyCodeLine{3352                z-\/>next = active;}
\DoxyCodeLine{3353                active = z;}
\DoxyCodeLine{3354             \}}
\DoxyCodeLine{3355          \}}
\DoxyCodeLine{3356          ++e;}
\DoxyCodeLine{3357       \}}
\DoxyCodeLine{3358 }
\DoxyCodeLine{3359       \textcolor{comment}{// now process all active edges}}
\DoxyCodeLine{3360       \textcolor{keywordflow}{if} (active)}
\DoxyCodeLine{3361          stbtt\_\_fill\_active\_edges\_new(scanline, scanline2+1, result-\/>w, active, scan\_y\_top);}
\DoxyCodeLine{3362 }
\DoxyCodeLine{3363       \{}
\DoxyCodeLine{3364          \textcolor{keywordtype}{float} sum = 0;}
\DoxyCodeLine{3365          \textcolor{keywordflow}{for} (i=0; i < result-\/>w; ++i) \{}
\DoxyCodeLine{3366             \textcolor{keywordtype}{float} k;}
\DoxyCodeLine{3367             \textcolor{keywordtype}{int} m;}
\DoxyCodeLine{3368             sum += scanline2[i];}
\DoxyCodeLine{3369             k = scanline[i] + sum;}
\DoxyCodeLine{3370             k = (float) STBTT\_fabs(k)*255 + 0.5f;}
\DoxyCodeLine{3371             m = (int) k;}
\DoxyCodeLine{3372             \textcolor{keywordflow}{if} (m > 255) m = 255;}
\DoxyCodeLine{3373             result-\/>pixels[j*result-\/>stride + i] = (\textcolor{keywordtype}{unsigned} char) m;}
\DoxyCodeLine{3374          \}}
\DoxyCodeLine{3375       \}}
\DoxyCodeLine{3376       \textcolor{comment}{// advance all the edges}}
\DoxyCodeLine{3377       step = \&active;}
\DoxyCodeLine{3378       \textcolor{keywordflow}{while} (*step) \{}
\DoxyCodeLine{3379          stbtt\_\_active\_edge *z = *step;}
\DoxyCodeLine{3380          z-\/>fx += z-\/>fdx; \textcolor{comment}{// advance to position for current scanline}}
\DoxyCodeLine{3381          step = \&((*step)-\/>next); \textcolor{comment}{// advance through list}}
\DoxyCodeLine{3382       \}}
\DoxyCodeLine{3383 }
\DoxyCodeLine{3384       ++y;}
\DoxyCodeLine{3385       ++j;}
\DoxyCodeLine{3386    \}}
\DoxyCodeLine{3387 }
\DoxyCodeLine{3388    stbtt\_\_hheap\_cleanup(\&hh, userdata);}
\DoxyCodeLine{3389 }
\DoxyCodeLine{3390    \textcolor{keywordflow}{if} (scanline != scanline\_data)}
\DoxyCodeLine{3391       STBTT\_free(scanline, userdata);}
\DoxyCodeLine{3392 \}}
\DoxyCodeLine{3393 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3394 \textcolor{preprocessor}{\#error "{}Unrecognized value of STBTT\_RASTERIZER\_VERSION"{}}}
\DoxyCodeLine{3395 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3396 }
\DoxyCodeLine{3397 \textcolor{preprocessor}{\#define STBTT\_\_COMPARE(a,b)  ((a)-\/>y0 < (b)-\/>y0)}}
\DoxyCodeLine{3398 }
\DoxyCodeLine{3399 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_sort\_edges\_ins\_sort(stbtt\_\_edge *p, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{3400 \{}
\DoxyCodeLine{3401    \textcolor{keywordtype}{int} i,j;}
\DoxyCodeLine{3402    \textcolor{keywordflow}{for} (i=1; i < n; ++i) \{}
\DoxyCodeLine{3403       stbtt\_\_edge t = p[i], *a = \&t;}
\DoxyCodeLine{3404       j = i;}
\DoxyCodeLine{3405       \textcolor{keywordflow}{while} (j > 0) \{}
\DoxyCodeLine{3406          stbtt\_\_edge *b = \&p[j-\/1];}
\DoxyCodeLine{3407          \textcolor{keywordtype}{int} c = STBTT\_\_COMPARE(a,b);}
\DoxyCodeLine{3408          \textcolor{keywordflow}{if} (!c) \textcolor{keywordflow}{break};}
\DoxyCodeLine{3409          p[j] = p[j-\/1];}
\DoxyCodeLine{3410          -\/-\/j;}
\DoxyCodeLine{3411       \}}
\DoxyCodeLine{3412       \textcolor{keywordflow}{if} (i != j)}
\DoxyCodeLine{3413          p[j] = t;}
\DoxyCodeLine{3414    \}}
\DoxyCodeLine{3415 \}}
\DoxyCodeLine{3416 }
\DoxyCodeLine{3417 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_sort\_edges\_quicksort(stbtt\_\_edge *p, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{3418 \{}
\DoxyCodeLine{3419    \textcolor{comment}{/* threshold for transitioning to insertion sort */}}
\DoxyCodeLine{3420    \textcolor{keywordflow}{while} (n > 12) \{}
\DoxyCodeLine{3421       stbtt\_\_edge t;}
\DoxyCodeLine{3422       \textcolor{keywordtype}{int} c01,c12,c,m,i,j;}
\DoxyCodeLine{3423 }
\DoxyCodeLine{3424       \textcolor{comment}{/* compute median of three */}}
\DoxyCodeLine{3425       m = n >> 1;}
\DoxyCodeLine{3426       c01 = STBTT\_\_COMPARE(\&p[0],\&p[m]);}
\DoxyCodeLine{3427       c12 = STBTT\_\_COMPARE(\&p[m],\&p[n-\/1]);}
\DoxyCodeLine{3428       \textcolor{comment}{/* if 0 >= mid >= end, or 0 < mid < end, then use mid */}}
\DoxyCodeLine{3429       \textcolor{keywordflow}{if} (c01 != c12) \{}
\DoxyCodeLine{3430          \textcolor{comment}{/* otherwise, we'll need to swap something else to middle */}}
\DoxyCodeLine{3431          \textcolor{keywordtype}{int} z;}
\DoxyCodeLine{3432          c = STBTT\_\_COMPARE(\&p[0],\&p[n-\/1]);}
\DoxyCodeLine{3433          \textcolor{comment}{/* 0>mid \&\& mid<n:  0>n => n; 0<n => 0 */}}
\DoxyCodeLine{3434          \textcolor{comment}{/* 0<mid \&\& mid>n:  0>n => 0; 0<n => n */}}
\DoxyCodeLine{3435          z = (c == c12) ? 0 : n-\/1;}
\DoxyCodeLine{3436          t = p[z];}
\DoxyCodeLine{3437          p[z] = p[m];}
\DoxyCodeLine{3438          p[m] = t;}
\DoxyCodeLine{3439       \}}
\DoxyCodeLine{3440       \textcolor{comment}{/* now p[m] is the median-\/of-\/three */}}
\DoxyCodeLine{3441       \textcolor{comment}{/* swap it to the beginning so it won't move around */}}
\DoxyCodeLine{3442       t = p[0];}
\DoxyCodeLine{3443       p[0] = p[m];}
\DoxyCodeLine{3444       p[m] = t;}
\DoxyCodeLine{3445 }
\DoxyCodeLine{3446       \textcolor{comment}{/* partition loop */}}
\DoxyCodeLine{3447       i=1;}
\DoxyCodeLine{3448       j=n-\/1;}
\DoxyCodeLine{3449       \textcolor{keywordflow}{for}(;;) \{}
\DoxyCodeLine{3450          \textcolor{comment}{/* handling of equality is crucial here */}}
\DoxyCodeLine{3451          \textcolor{comment}{/* for sentinels \& efficiency with duplicates */}}
\DoxyCodeLine{3452          \textcolor{keywordflow}{for} (;;++i) \{}
\DoxyCodeLine{3453             \textcolor{keywordflow}{if} (!STBTT\_\_COMPARE(\&p[i], \&p[0])) \textcolor{keywordflow}{break};}
\DoxyCodeLine{3454          \}}
\DoxyCodeLine{3455          \textcolor{keywordflow}{for} (;;-\/-\/j) \{}
\DoxyCodeLine{3456             \textcolor{keywordflow}{if} (!STBTT\_\_COMPARE(\&p[0], \&p[j])) \textcolor{keywordflow}{break};}
\DoxyCodeLine{3457          \}}
\DoxyCodeLine{3458          \textcolor{comment}{/* make sure we haven't crossed */}}
\DoxyCodeLine{3459          \textcolor{keywordflow}{if} (i >= j) \textcolor{keywordflow}{break};}
\DoxyCodeLine{3460          t = p[i];}
\DoxyCodeLine{3461          p[i] = p[j];}
\DoxyCodeLine{3462          p[j] = t;}
\DoxyCodeLine{3463 }
\DoxyCodeLine{3464          ++i;}
\DoxyCodeLine{3465          -\/-\/j;}
\DoxyCodeLine{3466       \}}
\DoxyCodeLine{3467       \textcolor{comment}{/* recurse on smaller side, iterate on larger */}}
\DoxyCodeLine{3468       \textcolor{keywordflow}{if} (j < (n-\/i)) \{}
\DoxyCodeLine{3469          stbtt\_\_sort\_edges\_quicksort(p,j);}
\DoxyCodeLine{3470          p = p+i;}
\DoxyCodeLine{3471          n = n-\/i;}
\DoxyCodeLine{3472       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3473          stbtt\_\_sort\_edges\_quicksort(p+i, n-\/i);}
\DoxyCodeLine{3474          n = j;}
\DoxyCodeLine{3475       \}}
\DoxyCodeLine{3476    \}}
\DoxyCodeLine{3477 \}}
\DoxyCodeLine{3478 }
\DoxyCodeLine{3479 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_sort\_edges(stbtt\_\_edge *p, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{3480 \{}
\DoxyCodeLine{3481    stbtt\_\_sort\_edges\_quicksort(p, n);}
\DoxyCodeLine{3482    stbtt\_\_sort\_edges\_ins\_sort(p, n);}
\DoxyCodeLine{3483 \}}
\DoxyCodeLine{3484 }
\DoxyCodeLine{3485 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{3486 \{}
\DoxyCodeLine{3487    \textcolor{keywordtype}{float} x,y;}
\DoxyCodeLine{3488 \} stbtt\_\_point;}
\DoxyCodeLine{3489 }
\DoxyCodeLine{3490 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_rasterize(\mbox{\hyperlink{structstbtt____bitmap}{stbtt\_\_bitmap}} *result, stbtt\_\_point *pts, \textcolor{keywordtype}{int} *wcount, \textcolor{keywordtype}{int} windings, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} off\_x, \textcolor{keywordtype}{int} off\_y, \textcolor{keywordtype}{int} invert, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{3491 \{}
\DoxyCodeLine{3492    \textcolor{keywordtype}{float} y\_scale\_inv = invert ? -\/scale\_y : scale\_y;}
\DoxyCodeLine{3493    stbtt\_\_edge *e;}
\DoxyCodeLine{3494    \textcolor{keywordtype}{int} n,i,j,k,m;}
\DoxyCodeLine{3495 \textcolor{preprocessor}{\#if STBTT\_RASTERIZER\_VERSION == 1}}
\DoxyCodeLine{3496    \textcolor{keywordtype}{int} vsubsample = result-\/>h < 8 ? 15 : 5;}
\DoxyCodeLine{3497 \textcolor{preprocessor}{\#elif STBTT\_RASTERIZER\_VERSION == 2}}
\DoxyCodeLine{3498    \textcolor{keywordtype}{int} vsubsample = 1;}
\DoxyCodeLine{3499 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3500 \textcolor{preprocessor}{   \#error "{}Unrecognized value of STBTT\_RASTERIZER\_VERSION"{}}}
\DoxyCodeLine{3501 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3502    \textcolor{comment}{// vsubsample should divide 255 evenly; otherwise we won't reach full opacity}}
\DoxyCodeLine{3503 }
\DoxyCodeLine{3504    \textcolor{comment}{// now we have to blow out the windings into explicit edge lists}}
\DoxyCodeLine{3505    n = 0;}
\DoxyCodeLine{3506    \textcolor{keywordflow}{for} (i=0; i < windings; ++i)}
\DoxyCodeLine{3507       n += wcount[i];}
\DoxyCodeLine{3508 }
\DoxyCodeLine{3509    e = (stbtt\_\_edge *) STBTT\_malloc(\textcolor{keyword}{sizeof}(*e) * (n+1), userdata); \textcolor{comment}{// add an extra one as a sentinel}}
\DoxyCodeLine{3510    \textcolor{keywordflow}{if} (e == 0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{3511    n = 0;}
\DoxyCodeLine{3512 }
\DoxyCodeLine{3513    m=0;}
\DoxyCodeLine{3514    \textcolor{keywordflow}{for} (i=0; i < windings; ++i) \{}
\DoxyCodeLine{3515       stbtt\_\_point *p = pts + m;}
\DoxyCodeLine{3516       m += wcount[i];}
\DoxyCodeLine{3517       j = wcount[i]-\/1;}
\DoxyCodeLine{3518       \textcolor{keywordflow}{for} (k=0; k < wcount[i]; j=k++) \{}
\DoxyCodeLine{3519          \textcolor{keywordtype}{int} a=k,b=j;}
\DoxyCodeLine{3520          \textcolor{comment}{// skip the edge if horizontal}}
\DoxyCodeLine{3521          \textcolor{keywordflow}{if} (p[j].y == p[k].y)}
\DoxyCodeLine{3522             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{3523          \textcolor{comment}{// add edge from j to k to the list}}
\DoxyCodeLine{3524          e[n].invert = 0;}
\DoxyCodeLine{3525          \textcolor{keywordflow}{if} (invert ? p[j].y > p[k].y : p[j].y < p[k].y) \{}
\DoxyCodeLine{3526             e[n].invert = 1;}
\DoxyCodeLine{3527             a=j,b=k;}
\DoxyCodeLine{3528          \}}
\DoxyCodeLine{3529          e[n].x0 = p[a].x * scale\_x + shift\_x;}
\DoxyCodeLine{3530          e[n].y0 = (p[a].y * y\_scale\_inv + shift\_y) * vsubsample;}
\DoxyCodeLine{3531          e[n].x1 = p[b].x * scale\_x + shift\_x;}
\DoxyCodeLine{3532          e[n].y1 = (p[b].y * y\_scale\_inv + shift\_y) * vsubsample;}
\DoxyCodeLine{3533          ++n;}
\DoxyCodeLine{3534       \}}
\DoxyCodeLine{3535    \}}
\DoxyCodeLine{3536 }
\DoxyCodeLine{3537    \textcolor{comment}{// now sort the edges by their highest point (should snap to integer, and then by x)}}
\DoxyCodeLine{3538    \textcolor{comment}{//STBTT\_sort(e, n, sizeof(e[0]), stbtt\_\_edge\_compare);}}
\DoxyCodeLine{3539    stbtt\_\_sort\_edges(e, n);}
\DoxyCodeLine{3540 }
\DoxyCodeLine{3541    \textcolor{comment}{// now, traverse the scanlines and find the intersections on each scanline, use xor winding rule}}
\DoxyCodeLine{3542    stbtt\_\_rasterize\_sorted\_edges(result, e, n, vsubsample, off\_x, off\_y, userdata);}
\DoxyCodeLine{3543 }
\DoxyCodeLine{3544    STBTT\_free(e, userdata);}
\DoxyCodeLine{3545 \}}
\DoxyCodeLine{3546 }
\DoxyCodeLine{3547 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_add\_point(stbtt\_\_point *points, \textcolor{keywordtype}{int} n, \textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y)}
\DoxyCodeLine{3548 \{}
\DoxyCodeLine{3549    \textcolor{keywordflow}{if} (!points) \textcolor{keywordflow}{return}; \textcolor{comment}{// during first pass, it's unallocated}}
\DoxyCodeLine{3550    points[n].x = x;}
\DoxyCodeLine{3551    points[n].y = y;}
\DoxyCodeLine{3552 \}}
\DoxyCodeLine{3553 }
\DoxyCodeLine{3554 \textcolor{comment}{// tessellate until threshold p is happy... @TODO warped to compensate for non-\/linear stretching}}
\DoxyCodeLine{3555 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_tesselate\_curve(stbtt\_\_point *points, \textcolor{keywordtype}{int} *num\_points, \textcolor{keywordtype}{float} x0, \textcolor{keywordtype}{float} y0, \textcolor{keywordtype}{float} x1, \textcolor{keywordtype}{float} y1, \textcolor{keywordtype}{float} x2, \textcolor{keywordtype}{float} y2, \textcolor{keywordtype}{float} objspace\_flatness\_squared, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{3556 \{}
\DoxyCodeLine{3557    \textcolor{comment}{// midpoint}}
\DoxyCodeLine{3558    \textcolor{keywordtype}{float} mx = (x0 + 2*x1 + x2)/4;}
\DoxyCodeLine{3559    \textcolor{keywordtype}{float} my = (y0 + 2*y1 + y2)/4;}
\DoxyCodeLine{3560    \textcolor{comment}{// versus directly drawn line}}
\DoxyCodeLine{3561    \textcolor{keywordtype}{float} dx = (x0+x2)/2 -\/ mx;}
\DoxyCodeLine{3562    \textcolor{keywordtype}{float} dy = (y0+y2)/2 -\/ my;}
\DoxyCodeLine{3563    \textcolor{keywordflow}{if} (n > 16) \textcolor{comment}{// 65536 segments on one curve better be enough!}}
\DoxyCodeLine{3564       \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{3565    \textcolor{keywordflow}{if} (dx*dx+dy*dy > objspace\_flatness\_squared) \{ \textcolor{comment}{// half-\/pixel error allowed... need to be smaller if AA}}
\DoxyCodeLine{3566       stbtt\_\_tesselate\_curve(points, num\_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace\_flatness\_squared,n+1);}
\DoxyCodeLine{3567       stbtt\_\_tesselate\_curve(points, num\_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace\_flatness\_squared,n+1);}
\DoxyCodeLine{3568    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3569       stbtt\_\_add\_point(points, *num\_points,x2,y2);}
\DoxyCodeLine{3570       *num\_points = *num\_points+1;}
\DoxyCodeLine{3571    \}}
\DoxyCodeLine{3572    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{3573 \}}
\DoxyCodeLine{3574 }
\DoxyCodeLine{3575 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_tesselate\_cubic(stbtt\_\_point *points, \textcolor{keywordtype}{int} *num\_points, \textcolor{keywordtype}{float} x0, \textcolor{keywordtype}{float} y0, \textcolor{keywordtype}{float} x1, \textcolor{keywordtype}{float} y1, \textcolor{keywordtype}{float} x2, \textcolor{keywordtype}{float} y2, \textcolor{keywordtype}{float} x3, \textcolor{keywordtype}{float} y3, \textcolor{keywordtype}{float} objspace\_flatness\_squared, \textcolor{keywordtype}{int} n)}
\DoxyCodeLine{3576 \{}
\DoxyCodeLine{3577    \textcolor{comment}{// @TODO this "{}flatness"{} calculation is just made-\/up nonsense that seems to work well enough}}
\DoxyCodeLine{3578    \textcolor{keywordtype}{float} dx0 = x1-\/x0;}
\DoxyCodeLine{3579    \textcolor{keywordtype}{float} dy0 = y1-\/y0;}
\DoxyCodeLine{3580    \textcolor{keywordtype}{float} dx1 = x2-\/x1;}
\DoxyCodeLine{3581    \textcolor{keywordtype}{float} dy1 = y2-\/y1;}
\DoxyCodeLine{3582    \textcolor{keywordtype}{float} dx2 = x3-\/x2;}
\DoxyCodeLine{3583    \textcolor{keywordtype}{float} dy2 = y3-\/y2;}
\DoxyCodeLine{3584    \textcolor{keywordtype}{float} dx = x3-\/x0;}
\DoxyCodeLine{3585    \textcolor{keywordtype}{float} dy = y3-\/y0;}
\DoxyCodeLine{3586    \textcolor{keywordtype}{float} longlen = (float) (STBTT\_sqrt(dx0*dx0+dy0*dy0)+STBTT\_sqrt(dx1*dx1+dy1*dy1)+STBTT\_sqrt(dx2*dx2+dy2*dy2));}
\DoxyCodeLine{3587    \textcolor{keywordtype}{float} shortlen = (float) STBTT\_sqrt(dx*dx+dy*dy);}
\DoxyCodeLine{3588    \textcolor{keywordtype}{float} flatness\_squared = longlen*longlen-\/shortlen*shortlen;}
\DoxyCodeLine{3589 }
\DoxyCodeLine{3590    \textcolor{keywordflow}{if} (n > 16) \textcolor{comment}{// 65536 segments on one curve better be enough!}}
\DoxyCodeLine{3591       \textcolor{keywordflow}{return};}
\DoxyCodeLine{3592 }
\DoxyCodeLine{3593    \textcolor{keywordflow}{if} (flatness\_squared > objspace\_flatness\_squared) \{}
\DoxyCodeLine{3594       \textcolor{keywordtype}{float} x01 = (x0+x1)/2;}
\DoxyCodeLine{3595       \textcolor{keywordtype}{float} y01 = (y0+y1)/2;}
\DoxyCodeLine{3596       \textcolor{keywordtype}{float} x12 = (x1+x2)/2;}
\DoxyCodeLine{3597       \textcolor{keywordtype}{float} y12 = (y1+y2)/2;}
\DoxyCodeLine{3598       \textcolor{keywordtype}{float} x23 = (x2+x3)/2;}
\DoxyCodeLine{3599       \textcolor{keywordtype}{float} y23 = (y2+y3)/2;}
\DoxyCodeLine{3600 }
\DoxyCodeLine{3601       \textcolor{keywordtype}{float} xa = (x01+x12)/2;}
\DoxyCodeLine{3602       \textcolor{keywordtype}{float} ya = (y01+y12)/2;}
\DoxyCodeLine{3603       \textcolor{keywordtype}{float} xb = (x12+x23)/2;}
\DoxyCodeLine{3604       \textcolor{keywordtype}{float} yb = (y12+y23)/2;}
\DoxyCodeLine{3605 }
\DoxyCodeLine{3606       \textcolor{keywordtype}{float} mx = (xa+xb)/2;}
\DoxyCodeLine{3607       \textcolor{keywordtype}{float} my = (ya+yb)/2;}
\DoxyCodeLine{3608 }
\DoxyCodeLine{3609       stbtt\_\_tesselate\_cubic(points, num\_points, x0,y0, x01,y01, xa,ya, mx,my, objspace\_flatness\_squared,n+1);}
\DoxyCodeLine{3610       stbtt\_\_tesselate\_cubic(points, num\_points, mx,my, xb,yb, x23,y23, x3,y3, objspace\_flatness\_squared,n+1);}
\DoxyCodeLine{3611    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3612       stbtt\_\_add\_point(points, *num\_points,x3,y3);}
\DoxyCodeLine{3613       *num\_points = *num\_points+1;}
\DoxyCodeLine{3614    \}}
\DoxyCodeLine{3615 \}}
\DoxyCodeLine{3616 }
\DoxyCodeLine{3617 \textcolor{comment}{// returns number of contours}}
\DoxyCodeLine{3618 \textcolor{keyword}{static} stbtt\_\_point *stbtt\_FlattenCurves(\mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *vertices, \textcolor{keywordtype}{int} num\_verts, \textcolor{keywordtype}{float} objspace\_flatness, \textcolor{keywordtype}{int} **contour\_lengths, \textcolor{keywordtype}{int} *num\_contours, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{3619 \{}
\DoxyCodeLine{3620    stbtt\_\_point *points=0;}
\DoxyCodeLine{3621    \textcolor{keywordtype}{int} num\_points=0;}
\DoxyCodeLine{3622 }
\DoxyCodeLine{3623    \textcolor{keywordtype}{float} objspace\_flatness\_squared = objspace\_flatness * objspace\_flatness;}
\DoxyCodeLine{3624    \textcolor{keywordtype}{int} i,n=0,start=0, pass;}
\DoxyCodeLine{3625 }
\DoxyCodeLine{3626    \textcolor{comment}{// count how many "{}moves"{} there are to get the contour count}}
\DoxyCodeLine{3627    \textcolor{keywordflow}{for} (i=0; i < num\_verts; ++i)}
\DoxyCodeLine{3628       \textcolor{keywordflow}{if} (vertices[i].type == STBTT\_vmove)}
\DoxyCodeLine{3629          ++n;}
\DoxyCodeLine{3630 }
\DoxyCodeLine{3631    *num\_contours = n;}
\DoxyCodeLine{3632    \textcolor{keywordflow}{if} (n == 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3633 }
\DoxyCodeLine{3634    *contour\_lengths = (\textcolor{keywordtype}{int} *) STBTT\_malloc(\textcolor{keyword}{sizeof}(**contour\_lengths) * n, userdata);}
\DoxyCodeLine{3635 }
\DoxyCodeLine{3636    \textcolor{keywordflow}{if} (*contour\_lengths == 0) \{}
\DoxyCodeLine{3637       *num\_contours = 0;}
\DoxyCodeLine{3638       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3639    \}}
\DoxyCodeLine{3640 }
\DoxyCodeLine{3641    \textcolor{comment}{// make two passes through the points so we don't need to realloc}}
\DoxyCodeLine{3642    \textcolor{keywordflow}{for} (pass=0; pass < 2; ++pass) \{}
\DoxyCodeLine{3643       \textcolor{keywordtype}{float} x=0,y=0;}
\DoxyCodeLine{3644       \textcolor{keywordflow}{if} (pass == 1) \{}
\DoxyCodeLine{3645          points = (stbtt\_\_point *) STBTT\_malloc(num\_points * \textcolor{keyword}{sizeof}(points[0]), userdata);}
\DoxyCodeLine{3646          \textcolor{keywordflow}{if} (points == NULL) \textcolor{keywordflow}{goto} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}};}
\DoxyCodeLine{3647       \}}
\DoxyCodeLine{3648       num\_points = 0;}
\DoxyCodeLine{3649       n= -\/1;}
\DoxyCodeLine{3650       \textcolor{keywordflow}{for} (i=0; i < num\_verts; ++i) \{}
\DoxyCodeLine{3651          \textcolor{keywordflow}{switch} (vertices[i].type) \{}
\DoxyCodeLine{3652             \textcolor{keywordflow}{case} STBTT\_vmove:}
\DoxyCodeLine{3653                \textcolor{comment}{// start the next contour}}
\DoxyCodeLine{3654                \textcolor{keywordflow}{if} (n >= 0)}
\DoxyCodeLine{3655                   (*contour\_lengths)[n] = num\_points -\/ start;}
\DoxyCodeLine{3656                ++n;}
\DoxyCodeLine{3657                start = num\_points;}
\DoxyCodeLine{3658 }
\DoxyCodeLine{3659                x = vertices[i].x, y = vertices[i].y;}
\DoxyCodeLine{3660                stbtt\_\_add\_point(points, num\_points++, x,y);}
\DoxyCodeLine{3661                \textcolor{keywordflow}{break};}
\DoxyCodeLine{3662             \textcolor{keywordflow}{case} STBTT\_vline:}
\DoxyCodeLine{3663                x = vertices[i].x, y = vertices[i].y;}
\DoxyCodeLine{3664                stbtt\_\_add\_point(points, num\_points++, x, y);}
\DoxyCodeLine{3665                \textcolor{keywordflow}{break};}
\DoxyCodeLine{3666             \textcolor{keywordflow}{case} STBTT\_vcurve:}
\DoxyCodeLine{3667                stbtt\_\_tesselate\_curve(points, \&num\_points, x,y,}
\DoxyCodeLine{3668                                         vertices[i].cx, vertices[i].cy,}
\DoxyCodeLine{3669                                         vertices[i].x,  vertices[i].y,}
\DoxyCodeLine{3670                                         objspace\_flatness\_squared, 0);}
\DoxyCodeLine{3671                x = vertices[i].x, y = vertices[i].y;}
\DoxyCodeLine{3672                \textcolor{keywordflow}{break};}
\DoxyCodeLine{3673             \textcolor{keywordflow}{case} STBTT\_vcubic:}
\DoxyCodeLine{3674                stbtt\_\_tesselate\_cubic(points, \&num\_points, x,y,}
\DoxyCodeLine{3675                                         vertices[i].cx, vertices[i].cy,}
\DoxyCodeLine{3676                                         vertices[i].cx1, vertices[i].cy1,}
\DoxyCodeLine{3677                                         vertices[i].x,  vertices[i].y,}
\DoxyCodeLine{3678                                         objspace\_flatness\_squared, 0);}
\DoxyCodeLine{3679                x = vertices[i].x, y = vertices[i].y;}
\DoxyCodeLine{3680                \textcolor{keywordflow}{break};}
\DoxyCodeLine{3681          \}}
\DoxyCodeLine{3682       \}}
\DoxyCodeLine{3683       (*contour\_lengths)[n] = num\_points -\/ start;}
\DoxyCodeLine{3684    \}}
\DoxyCodeLine{3685 }
\DoxyCodeLine{3686    \textcolor{keywordflow}{return} points;}
\DoxyCodeLine{3687 \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}}:}
\DoxyCodeLine{3688    STBTT\_free(points, userdata);}
\DoxyCodeLine{3689    STBTT\_free(*contour\_lengths, userdata);}
\DoxyCodeLine{3690    *contour\_lengths = 0;}
\DoxyCodeLine{3691    *num\_contours = 0;}
\DoxyCodeLine{3692    \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{3693 \}}
\DoxyCodeLine{3694 }
\DoxyCodeLine{3695 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_Rasterize(\mbox{\hyperlink{structstbtt____bitmap}{stbtt\_\_bitmap}} *result, \textcolor{keywordtype}{float} flatness\_in\_pixels, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *vertices, \textcolor{keywordtype}{int} num\_verts, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} x\_off, \textcolor{keywordtype}{int} y\_off, \textcolor{keywordtype}{int} invert, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{3696 \{}
\DoxyCodeLine{3697    \textcolor{keywordtype}{float} scale            = scale\_x > scale\_y ? scale\_y : scale\_x;}
\DoxyCodeLine{3698    \textcolor{keywordtype}{int} winding\_count      = 0;}
\DoxyCodeLine{3699    \textcolor{keywordtype}{int} *winding\_lengths   = NULL;}
\DoxyCodeLine{3700    stbtt\_\_point *windings = stbtt\_FlattenCurves(vertices, num\_verts, flatness\_in\_pixels / scale, \&winding\_lengths, \&winding\_count, userdata);}
\DoxyCodeLine{3701    \textcolor{keywordflow}{if} (windings) \{}
\DoxyCodeLine{3702       stbtt\_\_rasterize(result, windings, winding\_lengths, winding\_count, scale\_x, scale\_y, shift\_x, shift\_y, x\_off, y\_off, invert, userdata);}
\DoxyCodeLine{3703       STBTT\_free(winding\_lengths, userdata);}
\DoxyCodeLine{3704       STBTT\_free(windings, userdata);}
\DoxyCodeLine{3705    \}}
\DoxyCodeLine{3706 \}}
\DoxyCodeLine{3707 }
\DoxyCodeLine{3708 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_FreeBitmap(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{3709 \{}
\DoxyCodeLine{3710    STBTT\_free(bitmap, userdata);}
\DoxyCodeLine{3711 \}}
\DoxyCodeLine{3712 }
\DoxyCodeLine{3713 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_GetGlyphBitmapSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff)}
\DoxyCodeLine{3714 \{}
\DoxyCodeLine{3715    \textcolor{keywordtype}{int} ix0,iy0,ix1,iy1;}
\DoxyCodeLine{3716    \mbox{\hyperlink{structstbtt____bitmap}{stbtt\_\_bitmap}} gbm;}
\DoxyCodeLine{3717    \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *vertices;}
\DoxyCodeLine{3718    \textcolor{keywordtype}{int} num\_verts = stbtt\_GetGlyphShape(info, glyph, \&vertices);}
\DoxyCodeLine{3719 }
\DoxyCodeLine{3720    \textcolor{keywordflow}{if} (scale\_x == 0) scale\_x = scale\_y;}
\DoxyCodeLine{3721    \textcolor{keywordflow}{if} (scale\_y == 0) \{}
\DoxyCodeLine{3722       \textcolor{keywordflow}{if} (scale\_x == 0) \{}
\DoxyCodeLine{3723          STBTT\_free(vertices, info-\/>userdata);}
\DoxyCodeLine{3724          \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{3725       \}}
\DoxyCodeLine{3726       scale\_y = scale\_x;}
\DoxyCodeLine{3727    \}}
\DoxyCodeLine{3728 }
\DoxyCodeLine{3729    stbtt\_GetGlyphBitmapBoxSubpixel(info, glyph, scale\_x, scale\_y, shift\_x, shift\_y, \&ix0,\&iy0,\&ix1,\&iy1);}
\DoxyCodeLine{3730 }
\DoxyCodeLine{3731    \textcolor{comment}{// now we get the size}}
\DoxyCodeLine{3732    gbm.w = (ix1 -\/ ix0);}
\DoxyCodeLine{3733    gbm.h = (iy1 -\/ iy0);}
\DoxyCodeLine{3734    gbm.pixels = NULL; \textcolor{comment}{// in case we error}}
\DoxyCodeLine{3735 }
\DoxyCodeLine{3736    \textcolor{keywordflow}{if} (width ) *width  = gbm.w;}
\DoxyCodeLine{3737    \textcolor{keywordflow}{if} (height) *height = gbm.h;}
\DoxyCodeLine{3738    \textcolor{keywordflow}{if} (xoff  ) *xoff   = ix0;}
\DoxyCodeLine{3739    \textcolor{keywordflow}{if} (yoff  ) *yoff   = iy0;}
\DoxyCodeLine{3740 }
\DoxyCodeLine{3741    \textcolor{keywordflow}{if} (gbm.w \&\& gbm.h) \{}
\DoxyCodeLine{3742       gbm.pixels = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) STBTT\_malloc(gbm.w * gbm.h, info-\/>userdata);}
\DoxyCodeLine{3743       \textcolor{keywordflow}{if} (gbm.pixels) \{}
\DoxyCodeLine{3744          gbm.stride = gbm.w;}
\DoxyCodeLine{3745 }
\DoxyCodeLine{3746          stbtt\_Rasterize(\&gbm, 0.35f, vertices, num\_verts, scale\_x, scale\_y, shift\_x, shift\_y, ix0, iy0, 1, info-\/>userdata);}
\DoxyCodeLine{3747       \}}
\DoxyCodeLine{3748    \}}
\DoxyCodeLine{3749    STBTT\_free(vertices, info-\/>userdata);}
\DoxyCodeLine{3750    \textcolor{keywordflow}{return} gbm.pixels;}
\DoxyCodeLine{3751 \}}
\DoxyCodeLine{3752 }
\DoxyCodeLine{3753 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_GetGlyphBitmap(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff)}
\DoxyCodeLine{3754 \{}
\DoxyCodeLine{3755    \textcolor{keywordflow}{return} stbtt\_GetGlyphBitmapSubpixel(info, scale\_x, scale\_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);}
\DoxyCodeLine{3756 \}}
\DoxyCodeLine{3757 }
\DoxyCodeLine{3758 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeGlyphBitmapSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} glyph)}
\DoxyCodeLine{3759 \{}
\DoxyCodeLine{3760    \textcolor{keywordtype}{int} ix0,iy0;}
\DoxyCodeLine{3761    \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *vertices;}
\DoxyCodeLine{3762    \textcolor{keywordtype}{int} num\_verts = stbtt\_GetGlyphShape(info, glyph, \&vertices);}
\DoxyCodeLine{3763    \mbox{\hyperlink{structstbtt____bitmap}{stbtt\_\_bitmap}} gbm;}
\DoxyCodeLine{3764 }
\DoxyCodeLine{3765    stbtt\_GetGlyphBitmapBoxSubpixel(info, glyph, scale\_x, scale\_y, shift\_x, shift\_y, \&ix0,\&iy0,0,0);}
\DoxyCodeLine{3766    gbm.pixels = output;}
\DoxyCodeLine{3767    gbm.w = out\_w;}
\DoxyCodeLine{3768    gbm.h = out\_h;}
\DoxyCodeLine{3769    gbm.stride = out\_stride;}
\DoxyCodeLine{3770 }
\DoxyCodeLine{3771    \textcolor{keywordflow}{if} (gbm.w \&\& gbm.h)}
\DoxyCodeLine{3772       stbtt\_Rasterize(\&gbm, 0.35f, vertices, num\_verts, scale\_x, scale\_y, shift\_x, shift\_y, ix0,iy0, 1, info-\/>userdata);}
\DoxyCodeLine{3773 }
\DoxyCodeLine{3774    STBTT\_free(vertices, info-\/>userdata);}
\DoxyCodeLine{3775 \}}
\DoxyCodeLine{3776 }
\DoxyCodeLine{3777 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeGlyphBitmap(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} glyph)}
\DoxyCodeLine{3778 \{}
\DoxyCodeLine{3779    stbtt\_MakeGlyphBitmapSubpixel(info, output, out\_w, out\_h, out\_stride, scale\_x, scale\_y, 0.0f,0.0f, glyph);}
\DoxyCodeLine{3780 \}}
\DoxyCodeLine{3781 }
\DoxyCodeLine{3782 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_GetCodepointBitmapSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff)}
\DoxyCodeLine{3783 \{}
\DoxyCodeLine{3784    \textcolor{keywordflow}{return} stbtt\_GetGlyphBitmapSubpixel(info, scale\_x, scale\_y,shift\_x,shift\_y, stbtt\_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);}
\DoxyCodeLine{3785 \}}
\DoxyCodeLine{3786 }
\DoxyCodeLine{3787 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeCodepointBitmapSubpixelPrefilter(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} oversample\_x, \textcolor{keywordtype}{int} oversample\_y, \textcolor{keywordtype}{float} *sub\_x, \textcolor{keywordtype}{float} *sub\_y, \textcolor{keywordtype}{int} codepoint)}
\DoxyCodeLine{3788 \{}
\DoxyCodeLine{3789    stbtt\_MakeGlyphBitmapSubpixelPrefilter(info, output, out\_w, out\_h, out\_stride, scale\_x, scale\_y, shift\_x, shift\_y, oversample\_x, oversample\_y, sub\_x, sub\_y, stbtt\_FindGlyphIndex(info,codepoint));}
\DoxyCodeLine{3790 \}}
\DoxyCodeLine{3791 }
\DoxyCodeLine{3792 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeCodepointBitmapSubpixel(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} codepoint)}
\DoxyCodeLine{3793 \{}
\DoxyCodeLine{3794    stbtt\_MakeGlyphBitmapSubpixel(info, output, out\_w, out\_h, out\_stride, scale\_x, scale\_y, shift\_x, shift\_y, stbtt\_FindGlyphIndex(info,codepoint));}
\DoxyCodeLine{3795 \}}
\DoxyCodeLine{3796 }
\DoxyCodeLine{3797 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *stbtt\_GetCodepointBitmap(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff)}
\DoxyCodeLine{3798 \{}
\DoxyCodeLine{3799    \textcolor{keywordflow}{return} stbtt\_GetCodepointBitmapSubpixel(info, scale\_x, scale\_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);}
\DoxyCodeLine{3800 \}}
\DoxyCodeLine{3801 }
\DoxyCodeLine{3802 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeCodepointBitmap(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{int} codepoint)}
\DoxyCodeLine{3803 \{}
\DoxyCodeLine{3804    stbtt\_MakeCodepointBitmapSubpixel(info, output, out\_w, out\_h, out\_stride, scale\_x, scale\_y, 0.0f,0.0f, codepoint);}
\DoxyCodeLine{3805 \}}
\DoxyCodeLine{3806 }
\DoxyCodeLine{3808 \textcolor{comment}{//}}
\DoxyCodeLine{3809 \textcolor{comment}{// bitmap baking}}
\DoxyCodeLine{3810 \textcolor{comment}{//}}
\DoxyCodeLine{3811 \textcolor{comment}{// This is SUPER-\/CRAPPY packing to keep source code small}}
\DoxyCodeLine{3812 }
\DoxyCodeLine{3813 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_BakeFontBitmap\_internal(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} offset,  \textcolor{comment}{// font location (use offset=0 for plain .ttf)}}
\DoxyCodeLine{3814                                 \textcolor{keywordtype}{float} pixel\_height,                     \textcolor{comment}{// height of font in pixels}}
\DoxyCodeLine{3815                                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph,  \textcolor{comment}{// bitmap to be filled in}}
\DoxyCodeLine{3816                                 \textcolor{keywordtype}{int} first\_char, \textcolor{keywordtype}{int} num\_chars,          \textcolor{comment}{// characters to bake}}
\DoxyCodeLine{3817                                 \mbox{\hyperlink{structstbtt__bakedchar}{stbtt\_bakedchar}} *chardata)}
\DoxyCodeLine{3818 \{}
\DoxyCodeLine{3819    \textcolor{keywordtype}{float} scale;}
\DoxyCodeLine{3820    \textcolor{keywordtype}{int} x,y,bottom\_y, i;}
\DoxyCodeLine{3821    \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} f;}
\DoxyCodeLine{3822    f.userdata = NULL;}
\DoxyCodeLine{3823    \textcolor{keywordflow}{if} (!stbtt\_InitFont(\&f, data, offset))}
\DoxyCodeLine{3824       \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{3825    STBTT\_memset(pixels, 0, pw*ph); \textcolor{comment}{// background of 0 around pixels}}
\DoxyCodeLine{3826    x=y=1;}
\DoxyCodeLine{3827    bottom\_y = 1;}
\DoxyCodeLine{3828 }
\DoxyCodeLine{3829    scale = stbtt\_ScaleForPixelHeight(\&f, pixel\_height);}
\DoxyCodeLine{3830 }
\DoxyCodeLine{3831    \textcolor{keywordflow}{for} (i=0; i < num\_chars; ++i) \{}
\DoxyCodeLine{3832       \textcolor{keywordtype}{int} advance, lsb, x0,y0,x1,y1,gw,gh;}
\DoxyCodeLine{3833       \textcolor{keywordtype}{int} g = stbtt\_FindGlyphIndex(\&f, first\_char + i);}
\DoxyCodeLine{3834       stbtt\_GetGlyphHMetrics(\&f, g, \&advance, \&lsb);}
\DoxyCodeLine{3835       stbtt\_GetGlyphBitmapBox(\&f, g, scale,scale, \&x0,\&y0,\&x1,\&y1);}
\DoxyCodeLine{3836       gw = x1-\/x0;}
\DoxyCodeLine{3837       gh = y1-\/y0;}
\DoxyCodeLine{3838       \textcolor{keywordflow}{if} (x + gw + 1 >= pw)}
\DoxyCodeLine{3839          y = bottom\_y, x = 1; \textcolor{comment}{// advance to next row}}
\DoxyCodeLine{3840       \textcolor{keywordflow}{if} (y + gh + 1 >= ph) \textcolor{comment}{// check if it fits vertically AFTER potentially moving to next row}}
\DoxyCodeLine{3841          \textcolor{keywordflow}{return} -\/i;}
\DoxyCodeLine{3842       STBTT\_assert(x+gw < pw);}
\DoxyCodeLine{3843       STBTT\_assert(y+gh < ph);}
\DoxyCodeLine{3844       stbtt\_MakeGlyphBitmap(\&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);}
\DoxyCodeLine{3845       chardata[i].x0 = (stbtt\_int16) x;}
\DoxyCodeLine{3846       chardata[i].y0 = (stbtt\_int16) y;}
\DoxyCodeLine{3847       chardata[i].x1 = (stbtt\_int16) (x + gw);}
\DoxyCodeLine{3848       chardata[i].y1 = (stbtt\_int16) (y + gh);}
\DoxyCodeLine{3849       chardata[i].xadvance = scale * advance;}
\DoxyCodeLine{3850       chardata[i].xoff     = (float) x0;}
\DoxyCodeLine{3851       chardata[i].yoff     = (float) y0;}
\DoxyCodeLine{3852       x = x + gw + 1;}
\DoxyCodeLine{3853       \textcolor{keywordflow}{if} (y+gh+1 > bottom\_y)}
\DoxyCodeLine{3854          bottom\_y = y+gh+1;}
\DoxyCodeLine{3855    \}}
\DoxyCodeLine{3856    \textcolor{keywordflow}{return} bottom\_y;}
\DoxyCodeLine{3857 \}}
\DoxyCodeLine{3858 }
\DoxyCodeLine{3859 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetBakedQuad(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__bakedchar}{stbtt\_bakedchar}} *chardata, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph, \textcolor{keywordtype}{int} char\_index, \textcolor{keywordtype}{float} *xpos, \textcolor{keywordtype}{float} *ypos, \mbox{\hyperlink{structstbtt__aligned__quad}{stbtt\_aligned\_quad}} *q, \textcolor{keywordtype}{int} opengl\_fillrule)}
\DoxyCodeLine{3860 \{}
\DoxyCodeLine{3861    \textcolor{keywordtype}{float} d3d\_bias = opengl\_fillrule ? 0 : -\/0.5f;}
\DoxyCodeLine{3862    \textcolor{keywordtype}{float} ipw = 1.0f / pw, iph = 1.0f / ph;}
\DoxyCodeLine{3863    \textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__bakedchar}{stbtt\_bakedchar}} *b = chardata + char\_index;}
\DoxyCodeLine{3864    \textcolor{keywordtype}{int} round\_x = STBTT\_ifloor((*xpos + b-\/>xoff) + 0.5f);}
\DoxyCodeLine{3865    \textcolor{keywordtype}{int} round\_y = STBTT\_ifloor((*ypos + b-\/>yoff) + 0.5f);}
\DoxyCodeLine{3866 }
\DoxyCodeLine{3867    q-\/>x0 = round\_x + d3d\_bias;}
\DoxyCodeLine{3868    q-\/>y0 = round\_y + d3d\_bias;}
\DoxyCodeLine{3869    q-\/>x1 = round\_x + b-\/>x1 -\/ b-\/>x0 + d3d\_bias;}
\DoxyCodeLine{3870    q-\/>y1 = round\_y + b-\/>y1 -\/ b-\/>y0 + d3d\_bias;}
\DoxyCodeLine{3871 }
\DoxyCodeLine{3872    q-\/>s0 = b-\/>x0 * ipw;}
\DoxyCodeLine{3873    q-\/>t0 = b-\/>y0 * iph;}
\DoxyCodeLine{3874    q-\/>s1 = b-\/>x1 * ipw;}
\DoxyCodeLine{3875    q-\/>t1 = b-\/>y1 * iph;}
\DoxyCodeLine{3876 }
\DoxyCodeLine{3877    *xpos += b-\/>xadvance;}
\DoxyCodeLine{3878 \}}
\DoxyCodeLine{3879 }
\DoxyCodeLine{3881 \textcolor{comment}{//}}
\DoxyCodeLine{3882 \textcolor{comment}{// rectangle packing replacement routines if you don't have stb\_rect\_pack.h}}
\DoxyCodeLine{3883 \textcolor{comment}{//}}
\DoxyCodeLine{3884 }
\DoxyCodeLine{3885 \textcolor{preprocessor}{\#ifndef STB\_RECT\_PACK\_VERSION}}
\DoxyCodeLine{3886 }
\DoxyCodeLine{3887 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} stbrp\_coord;}
\DoxyCodeLine{3888 }
\DoxyCodeLine{3890 \textcolor{comment}{//                                                                                //}}
\DoxyCodeLine{3891 \textcolor{comment}{//                                                                                //}}
\DoxyCodeLine{3892 \textcolor{comment}{// COMPILER WARNING ?!?!?                                                         //}}
\DoxyCodeLine{3893 \textcolor{comment}{//                                                                                //}}
\DoxyCodeLine{3894 \textcolor{comment}{//                                                                                //}}
\DoxyCodeLine{3895 \textcolor{comment}{// if you get a compile warning due to these symbols being defined more than      //}}
\DoxyCodeLine{3896 \textcolor{comment}{// once, move \#include "{}stb\_rect\_pack.h"{} before \#include "{}stb\_truetype.h"{}         //}}
\DoxyCodeLine{3897 \textcolor{comment}{//                                                                                //}}
\DoxyCodeLine{3899 \textcolor{comment}{}}
\DoxyCodeLine{3900 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{3901 \{}
\DoxyCodeLine{3902    \textcolor{keywordtype}{int} width,height;}
\DoxyCodeLine{3903    \textcolor{keywordtype}{int} x,y,bottom\_y;}
\DoxyCodeLine{3904 \} \mbox{\hyperlink{structstbrp__context}{stbrp\_context}};}
\DoxyCodeLine{3905 }
\DoxyCodeLine{3906 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{3907 \{}
\DoxyCodeLine{3908    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} x;}
\DoxyCodeLine{3909 \} \mbox{\hyperlink{structstbrp__node}{stbrp\_node}};}
\DoxyCodeLine{3910 }
\DoxyCodeLine{3911 \textcolor{keyword}{struct }\mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}}}
\DoxyCodeLine{3912 \{}
\DoxyCodeLine{3913    stbrp\_coord x,y;}
\DoxyCodeLine{3914    \textcolor{keywordtype}{int} id,w,h,was\_packed;}
\DoxyCodeLine{3915 \};}
\DoxyCodeLine{3916 }
\DoxyCodeLine{3917 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbrp\_init\_target(\mbox{\hyperlink{structstbrp__context}{stbrp\_context}} *con, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph, \mbox{\hyperlink{structstbrp__node}{stbrp\_node}} *nodes, \textcolor{keywordtype}{int} num\_nodes)}
\DoxyCodeLine{3918 \{}
\DoxyCodeLine{3919    con-\/>width  = pw;}
\DoxyCodeLine{3920    con-\/>height = ph;}
\DoxyCodeLine{3921    con-\/>x = 0;}
\DoxyCodeLine{3922    con-\/>y = 0;}
\DoxyCodeLine{3923    con-\/>bottom\_y = 0;}
\DoxyCodeLine{3924    STBTT\_\_NOTUSED(nodes);}
\DoxyCodeLine{3925    STBTT\_\_NOTUSED(num\_nodes);}
\DoxyCodeLine{3926 \}}
\DoxyCodeLine{3927 }
\DoxyCodeLine{3928 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbrp\_pack\_rects(\mbox{\hyperlink{structstbrp__context}{stbrp\_context}} *con, \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *rects, \textcolor{keywordtype}{int} num\_rects)}
\DoxyCodeLine{3929 \{}
\DoxyCodeLine{3930    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{3931    \textcolor{keywordflow}{for} (i=0; i < num\_rects; ++i) \{}
\DoxyCodeLine{3932       \textcolor{keywordflow}{if} (con-\/>x + rects[i].w > con-\/>width) \{}
\DoxyCodeLine{3933          con-\/>x = 0;}
\DoxyCodeLine{3934          con-\/>y = con-\/>bottom\_y;}
\DoxyCodeLine{3935       \}}
\DoxyCodeLine{3936       \textcolor{keywordflow}{if} (con-\/>y + rects[i].h > con-\/>height)}
\DoxyCodeLine{3937          \textcolor{keywordflow}{break};}
\DoxyCodeLine{3938       rects[i].x = con-\/>x;}
\DoxyCodeLine{3939       rects[i].y = con-\/>y;}
\DoxyCodeLine{3940       rects[i].was\_packed = 1;}
\DoxyCodeLine{3941       con-\/>x += rects[i].w;}
\DoxyCodeLine{3942       \textcolor{keywordflow}{if} (con-\/>y + rects[i].h > con-\/>bottom\_y)}
\DoxyCodeLine{3943          con-\/>bottom\_y = con-\/>y + rects[i].h;}
\DoxyCodeLine{3944    \}}
\DoxyCodeLine{3945    \textcolor{keywordflow}{for} (   ; i < num\_rects; ++i)}
\DoxyCodeLine{3946       rects[i].was\_packed = 0;}
\DoxyCodeLine{3947 \}}
\DoxyCodeLine{3948 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3949 }
\DoxyCodeLine{3951 \textcolor{comment}{//}}
\DoxyCodeLine{3952 \textcolor{comment}{// bitmap baking}}
\DoxyCodeLine{3953 \textcolor{comment}{//}}
\DoxyCodeLine{3954 \textcolor{comment}{// This is SUPER-\/AWESOME (tm Ryan Gordon) packing using stb\_rect\_pack.h. If}}
\DoxyCodeLine{3955 \textcolor{comment}{// stb\_rect\_pack.h isn't available, it uses the BakeFontBitmap strategy.}}
\DoxyCodeLine{3956 }
\DoxyCodeLine{3957 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_PackBegin(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph, \textcolor{keywordtype}{int} stride\_in\_bytes, \textcolor{keywordtype}{int} padding, \textcolor{keywordtype}{void} *alloc\_context)}
\DoxyCodeLine{3958 \{}
\DoxyCodeLine{3959    \mbox{\hyperlink{structstbrp__context}{stbrp\_context}} *context = (\mbox{\hyperlink{structstbrp__context}{stbrp\_context}} *) STBTT\_malloc(\textcolor{keyword}{sizeof}(*context)            ,alloc\_context);}
\DoxyCodeLine{3960    \textcolor{keywordtype}{int}            num\_nodes = pw -\/ padding;}
\DoxyCodeLine{3961    \mbox{\hyperlink{structstbrp__node}{stbrp\_node}}    *nodes   = (\mbox{\hyperlink{structstbrp__node}{stbrp\_node}}    *) STBTT\_malloc(\textcolor{keyword}{sizeof}(*nodes  ) * num\_nodes,alloc\_context);}
\DoxyCodeLine{3962 }
\DoxyCodeLine{3963    \textcolor{keywordflow}{if} (context == NULL || nodes == NULL) \{}
\DoxyCodeLine{3964       \textcolor{keywordflow}{if} (context != NULL) STBTT\_free(context, alloc\_context);}
\DoxyCodeLine{3965       \textcolor{keywordflow}{if} (nodes   != NULL) STBTT\_free(nodes  , alloc\_context);}
\DoxyCodeLine{3966       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3967    \}}
\DoxyCodeLine{3968 }
\DoxyCodeLine{3969    spc-\/>user\_allocator\_context = alloc\_context;}
\DoxyCodeLine{3970    spc-\/>width = pw;}
\DoxyCodeLine{3971    spc-\/>height = ph;}
\DoxyCodeLine{3972    spc-\/>pixels = pixels;}
\DoxyCodeLine{3973    spc-\/>pack\_info = context;}
\DoxyCodeLine{3974    spc-\/>nodes = nodes;}
\DoxyCodeLine{3975    spc-\/>padding = padding;}
\DoxyCodeLine{3976    spc-\/>stride\_in\_bytes = stride\_in\_bytes != 0 ? stride\_in\_bytes : pw;}
\DoxyCodeLine{3977    spc-\/>h\_oversample = 1;}
\DoxyCodeLine{3978    spc-\/>v\_oversample = 1;}
\DoxyCodeLine{3979    spc-\/>skip\_missing = 0;}
\DoxyCodeLine{3980 }
\DoxyCodeLine{3981    stbrp\_init\_target(context, pw-\/padding, ph-\/padding, nodes, num\_nodes);}
\DoxyCodeLine{3982 }
\DoxyCodeLine{3983    \textcolor{keywordflow}{if} (pixels)}
\DoxyCodeLine{3984       STBTT\_memset(pixels, 0, pw*ph); \textcolor{comment}{// background of 0 around pixels}}
\DoxyCodeLine{3985 }
\DoxyCodeLine{3986    \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{3987 \}}
\DoxyCodeLine{3988 }
\DoxyCodeLine{3989 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_PackEnd  (\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc)}
\DoxyCodeLine{3990 \{}
\DoxyCodeLine{3991    STBTT\_free(spc-\/>nodes    , spc-\/>user\_allocator\_context);}
\DoxyCodeLine{3992    STBTT\_free(spc-\/>pack\_info, spc-\/>user\_allocator\_context);}
\DoxyCodeLine{3993 \}}
\DoxyCodeLine{3994 }
\DoxyCodeLine{3995 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_PackSetOversampling(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h\_oversample, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} v\_oversample)}
\DoxyCodeLine{3996 \{}
\DoxyCodeLine{3997    STBTT\_assert(h\_oversample <= STBTT\_MAX\_OVERSAMPLE);}
\DoxyCodeLine{3998    STBTT\_assert(v\_oversample <= STBTT\_MAX\_OVERSAMPLE);}
\DoxyCodeLine{3999    \textcolor{keywordflow}{if} (h\_oversample <= STBTT\_MAX\_OVERSAMPLE)}
\DoxyCodeLine{4000       spc-\/>h\_oversample = h\_oversample;}
\DoxyCodeLine{4001    \textcolor{keywordflow}{if} (v\_oversample <= STBTT\_MAX\_OVERSAMPLE)}
\DoxyCodeLine{4002       spc-\/>v\_oversample = v\_oversample;}
\DoxyCodeLine{4003 \}}
\DoxyCodeLine{4004 }
\DoxyCodeLine{4005 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_PackSetSkipMissingCodepoints(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keywordtype}{int} skip)}
\DoxyCodeLine{4006 \{}
\DoxyCodeLine{4007    spc-\/>skip\_missing = skip;}
\DoxyCodeLine{4008 \}}
\DoxyCodeLine{4009 }
\DoxyCodeLine{4010 \textcolor{preprocessor}{\#define STBTT\_\_OVER\_MASK  (STBTT\_MAX\_OVERSAMPLE-\/1)}}
\DoxyCodeLine{4011 }
\DoxyCodeLine{4012 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_h\_prefilter(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels, \textcolor{keywordtype}{int} w, \textcolor{keywordtype}{int} h, \textcolor{keywordtype}{int} stride\_in\_bytes, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} kernel\_width)}
\DoxyCodeLine{4013 \{}
\DoxyCodeLine{4014    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buffer[STBTT\_MAX\_OVERSAMPLE];}
\DoxyCodeLine{4015    \textcolor{keywordtype}{int} safe\_w = w -\/ kernel\_width;}
\DoxyCodeLine{4016    \textcolor{keywordtype}{int} j;}
\DoxyCodeLine{4017    STBTT\_memset(buffer, 0, STBTT\_MAX\_OVERSAMPLE); \textcolor{comment}{// suppress bogus warning from VS2013 -\/analyze}}
\DoxyCodeLine{4018    \textcolor{keywordflow}{for} (j=0; j < h; ++j) \{}
\DoxyCodeLine{4019       \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{4020       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} total;}
\DoxyCodeLine{4021       STBTT\_memset(buffer, 0, kernel\_width);}
\DoxyCodeLine{4022 }
\DoxyCodeLine{4023       total = 0;}
\DoxyCodeLine{4024 }
\DoxyCodeLine{4025       \textcolor{comment}{// make kernel\_width a constant in common cases so compiler can optimize out the divide}}
\DoxyCodeLine{4026       \textcolor{keywordflow}{switch} (kernel\_width) \{}
\DoxyCodeLine{4027          \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{4028             \textcolor{keywordflow}{for} (i=0; i <= safe\_w; ++i) \{}
\DoxyCodeLine{4029                total += pixels[i] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4030                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i];}
\DoxyCodeLine{4031                pixels[i] = (\textcolor{keywordtype}{unsigned} char) (total / 2);}
\DoxyCodeLine{4032             \}}
\DoxyCodeLine{4033             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4034          \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{4035             \textcolor{keywordflow}{for} (i=0; i <= safe\_w; ++i) \{}
\DoxyCodeLine{4036                total += pixels[i] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4037                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i];}
\DoxyCodeLine{4038                pixels[i] = (\textcolor{keywordtype}{unsigned} char) (total / 3);}
\DoxyCodeLine{4039             \}}
\DoxyCodeLine{4040             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4041          \textcolor{keywordflow}{case} 4:}
\DoxyCodeLine{4042             \textcolor{keywordflow}{for} (i=0; i <= safe\_w; ++i) \{}
\DoxyCodeLine{4043                total += pixels[i] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4044                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i];}
\DoxyCodeLine{4045                pixels[i] = (\textcolor{keywordtype}{unsigned} char) (total / 4);}
\DoxyCodeLine{4046             \}}
\DoxyCodeLine{4047             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4048          \textcolor{keywordflow}{case} 5:}
\DoxyCodeLine{4049             \textcolor{keywordflow}{for} (i=0; i <= safe\_w; ++i) \{}
\DoxyCodeLine{4050                total += pixels[i] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4051                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i];}
\DoxyCodeLine{4052                pixels[i] = (\textcolor{keywordtype}{unsigned} char) (total / 5);}
\DoxyCodeLine{4053             \}}
\DoxyCodeLine{4054             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4055          \textcolor{keywordflow}{default}:}
\DoxyCodeLine{4056             \textcolor{keywordflow}{for} (i=0; i <= safe\_w; ++i) \{}
\DoxyCodeLine{4057                total += pixels[i] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4058                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i];}
\DoxyCodeLine{4059                pixels[i] = (\textcolor{keywordtype}{unsigned} char) (total / kernel\_width);}
\DoxyCodeLine{4060             \}}
\DoxyCodeLine{4061             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4062       \}}
\DoxyCodeLine{4063 }
\DoxyCodeLine{4064       \textcolor{keywordflow}{for} (; i < w; ++i) \{}
\DoxyCodeLine{4065          STBTT\_assert(pixels[i] == 0);}
\DoxyCodeLine{4066          total -\/= buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4067          pixels[i] = (\textcolor{keywordtype}{unsigned} char) (total / kernel\_width);}
\DoxyCodeLine{4068       \}}
\DoxyCodeLine{4069 }
\DoxyCodeLine{4070       pixels += stride\_in\_bytes;}
\DoxyCodeLine{4071    \}}
\DoxyCodeLine{4072 \}}
\DoxyCodeLine{4073 }
\DoxyCodeLine{4074 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stbtt\_\_v\_prefilter(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels, \textcolor{keywordtype}{int} w, \textcolor{keywordtype}{int} h, \textcolor{keywordtype}{int} stride\_in\_bytes, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} kernel\_width)}
\DoxyCodeLine{4075 \{}
\DoxyCodeLine{4076    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buffer[STBTT\_MAX\_OVERSAMPLE];}
\DoxyCodeLine{4077    \textcolor{keywordtype}{int} safe\_h = h -\/ kernel\_width;}
\DoxyCodeLine{4078    \textcolor{keywordtype}{int} j;}
\DoxyCodeLine{4079    STBTT\_memset(buffer, 0, STBTT\_MAX\_OVERSAMPLE); \textcolor{comment}{// suppress bogus warning from VS2013 -\/analyze}}
\DoxyCodeLine{4080    \textcolor{keywordflow}{for} (j=0; j < w; ++j) \{}
\DoxyCodeLine{4081       \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{4082       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} total;}
\DoxyCodeLine{4083       STBTT\_memset(buffer, 0, kernel\_width);}
\DoxyCodeLine{4084 }
\DoxyCodeLine{4085       total = 0;}
\DoxyCodeLine{4086 }
\DoxyCodeLine{4087       \textcolor{comment}{// make kernel\_width a constant in common cases so compiler can optimize out the divide}}
\DoxyCodeLine{4088       \textcolor{keywordflow}{switch} (kernel\_width) \{}
\DoxyCodeLine{4089          \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{4090             \textcolor{keywordflow}{for} (i=0; i <= safe\_h; ++i) \{}
\DoxyCodeLine{4091                total += pixels[i*stride\_in\_bytes] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4092                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i*stride\_in\_bytes];}
\DoxyCodeLine{4093                pixels[i*stride\_in\_bytes] = (\textcolor{keywordtype}{unsigned} char) (total / 2);}
\DoxyCodeLine{4094             \}}
\DoxyCodeLine{4095             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4096          \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{4097             \textcolor{keywordflow}{for} (i=0; i <= safe\_h; ++i) \{}
\DoxyCodeLine{4098                total += pixels[i*stride\_in\_bytes] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4099                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i*stride\_in\_bytes];}
\DoxyCodeLine{4100                pixels[i*stride\_in\_bytes] = (\textcolor{keywordtype}{unsigned} char) (total / 3);}
\DoxyCodeLine{4101             \}}
\DoxyCodeLine{4102             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4103          \textcolor{keywordflow}{case} 4:}
\DoxyCodeLine{4104             \textcolor{keywordflow}{for} (i=0; i <= safe\_h; ++i) \{}
\DoxyCodeLine{4105                total += pixels[i*stride\_in\_bytes] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4106                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i*stride\_in\_bytes];}
\DoxyCodeLine{4107                pixels[i*stride\_in\_bytes] = (\textcolor{keywordtype}{unsigned} char) (total / 4);}
\DoxyCodeLine{4108             \}}
\DoxyCodeLine{4109             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4110          \textcolor{keywordflow}{case} 5:}
\DoxyCodeLine{4111             \textcolor{keywordflow}{for} (i=0; i <= safe\_h; ++i) \{}
\DoxyCodeLine{4112                total += pixels[i*stride\_in\_bytes] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4113                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i*stride\_in\_bytes];}
\DoxyCodeLine{4114                pixels[i*stride\_in\_bytes] = (\textcolor{keywordtype}{unsigned} char) (total / 5);}
\DoxyCodeLine{4115             \}}
\DoxyCodeLine{4116             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4117          \textcolor{keywordflow}{default}:}
\DoxyCodeLine{4118             \textcolor{keywordflow}{for} (i=0; i <= safe\_h; ++i) \{}
\DoxyCodeLine{4119                total += pixels[i*stride\_in\_bytes] -\/ buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4120                buffer[(i+kernel\_width) \& STBTT\_\_OVER\_MASK] = pixels[i*stride\_in\_bytes];}
\DoxyCodeLine{4121                pixels[i*stride\_in\_bytes] = (\textcolor{keywordtype}{unsigned} char) (total / kernel\_width);}
\DoxyCodeLine{4122             \}}
\DoxyCodeLine{4123             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4124       \}}
\DoxyCodeLine{4125 }
\DoxyCodeLine{4126       \textcolor{keywordflow}{for} (; i < h; ++i) \{}
\DoxyCodeLine{4127          STBTT\_assert(pixels[i*stride\_in\_bytes] == 0);}
\DoxyCodeLine{4128          total -\/= buffer[i \& STBTT\_\_OVER\_MASK];}
\DoxyCodeLine{4129          pixels[i*stride\_in\_bytes] = (\textcolor{keywordtype}{unsigned} char) (total / kernel\_width);}
\DoxyCodeLine{4130       \}}
\DoxyCodeLine{4131 }
\DoxyCodeLine{4132       pixels += 1;}
\DoxyCodeLine{4133    \}}
\DoxyCodeLine{4134 \}}
\DoxyCodeLine{4135 }
\DoxyCodeLine{4136 \textcolor{keyword}{static} \textcolor{keywordtype}{float} stbtt\_\_oversample\_shift(\textcolor{keywordtype}{int} oversample)}
\DoxyCodeLine{4137 \{}
\DoxyCodeLine{4138    \textcolor{keywordflow}{if} (!oversample)}
\DoxyCodeLine{4139       \textcolor{keywordflow}{return} 0.0f;}
\DoxyCodeLine{4140 }
\DoxyCodeLine{4141    \textcolor{comment}{// The prefilter is a box filter of width "{}oversample"{},}}
\DoxyCodeLine{4142    \textcolor{comment}{// which shifts phase by (oversample -\/ 1)/2 pixels in}}
\DoxyCodeLine{4143    \textcolor{comment}{// oversampled space. We want to shift in the opposite}}
\DoxyCodeLine{4144    \textcolor{comment}{// direction to counter this.}}
\DoxyCodeLine{4145    \textcolor{keywordflow}{return} (\textcolor{keywordtype}{float})-\/(oversample -\/ 1) / (2.0f * (\textcolor{keywordtype}{float})oversample);}
\DoxyCodeLine{4146 \}}
\DoxyCodeLine{4147 }
\DoxyCodeLine{4148 \textcolor{comment}{// rects array must be big enough to accommodate all characters in the given ranges}}
\DoxyCodeLine{4149 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_PackFontRangesGatherRects(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \mbox{\hyperlink{structstbtt__pack__range}{stbtt\_pack\_range}} *ranges, \textcolor{keywordtype}{int} num\_ranges, \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *rects)}
\DoxyCodeLine{4150 \{}
\DoxyCodeLine{4151    \textcolor{keywordtype}{int} i,j,k;}
\DoxyCodeLine{4152    \textcolor{keywordtype}{int} missing\_glyph\_added = 0;}
\DoxyCodeLine{4153 }
\DoxyCodeLine{4154    k=0;}
\DoxyCodeLine{4155    \textcolor{keywordflow}{for} (i=0; i < num\_ranges; ++i) \{}
\DoxyCodeLine{4156       \textcolor{keywordtype}{float} fh = ranges[i].font\_size;}
\DoxyCodeLine{4157       \textcolor{keywordtype}{float} scale = fh > 0 ? stbtt\_ScaleForPixelHeight(info, fh) : stbtt\_ScaleForMappingEmToPixels(info, -\/fh);}
\DoxyCodeLine{4158       ranges[i].h\_oversample = (\textcolor{keywordtype}{unsigned} char) spc-\/>h\_oversample;}
\DoxyCodeLine{4159       ranges[i].v\_oversample = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}) spc-\/>v\_oversample;}
\DoxyCodeLine{4160       \textcolor{keywordflow}{for} (j=0; j < ranges[i].num\_chars; ++j) \{}
\DoxyCodeLine{4161          \textcolor{keywordtype}{int} x0,y0,x1,y1;}
\DoxyCodeLine{4162          \textcolor{keywordtype}{int} codepoint = ranges[i].array\_of\_unicode\_codepoints == NULL ? ranges[i].first\_unicode\_codepoint\_in\_range + j : ranges[i].array\_of\_unicode\_codepoints[j];}
\DoxyCodeLine{4163          \textcolor{keywordtype}{int} glyph = stbtt\_FindGlyphIndex(info, codepoint);}
\DoxyCodeLine{4164          \textcolor{keywordflow}{if} (glyph == 0 \&\& (spc-\/>skip\_missing || missing\_glyph\_added)) \{}
\DoxyCodeLine{4165             rects[k].w = rects[k].h = 0;}
\DoxyCodeLine{4166          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4167             stbtt\_GetGlyphBitmapBoxSubpixel(info,glyph,}
\DoxyCodeLine{4168                                             scale * spc-\/>h\_oversample,}
\DoxyCodeLine{4169                                             scale * spc-\/>v\_oversample,}
\DoxyCodeLine{4170                                             0,0,}
\DoxyCodeLine{4171                                             \&x0,\&y0,\&x1,\&y1);}
\DoxyCodeLine{4172             rects[k].w = (stbrp\_coord) (x1-\/x0 + spc-\/>padding + spc-\/>h\_oversample-\/1);}
\DoxyCodeLine{4173             rects[k].h = (stbrp\_coord) (y1-\/y0 + spc-\/>padding + spc-\/>v\_oversample-\/1);}
\DoxyCodeLine{4174             \textcolor{keywordflow}{if} (glyph == 0)}
\DoxyCodeLine{4175                missing\_glyph\_added = 1;}
\DoxyCodeLine{4176          \}}
\DoxyCodeLine{4177          ++k;}
\DoxyCodeLine{4178       \}}
\DoxyCodeLine{4179    \}}
\DoxyCodeLine{4180 }
\DoxyCodeLine{4181    \textcolor{keywordflow}{return} k;}
\DoxyCodeLine{4182 \}}
\DoxyCodeLine{4183 }
\DoxyCodeLine{4184 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_MakeGlyphBitmapSubpixelPrefilter(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *output, \textcolor{keywordtype}{int} out\_w, \textcolor{keywordtype}{int} out\_h, \textcolor{keywordtype}{int} out\_stride, \textcolor{keywordtype}{float} scale\_x, \textcolor{keywordtype}{float} scale\_y, \textcolor{keywordtype}{float} shift\_x, \textcolor{keywordtype}{float} shift\_y, \textcolor{keywordtype}{int} prefilter\_x, \textcolor{keywordtype}{int} prefilter\_y, \textcolor{keywordtype}{float} *sub\_x, \textcolor{keywordtype}{float} *sub\_y, \textcolor{keywordtype}{int} glyph)}
\DoxyCodeLine{4185 \{}
\DoxyCodeLine{4186    stbtt\_MakeGlyphBitmapSubpixel(info,}
\DoxyCodeLine{4187                                  output,}
\DoxyCodeLine{4188                                  out\_w -\/ (prefilter\_x -\/ 1),}
\DoxyCodeLine{4189                                  out\_h -\/ (prefilter\_y -\/ 1),}
\DoxyCodeLine{4190                                  out\_stride,}
\DoxyCodeLine{4191                                  scale\_x,}
\DoxyCodeLine{4192                                  scale\_y,}
\DoxyCodeLine{4193                                  shift\_x,}
\DoxyCodeLine{4194                                  shift\_y,}
\DoxyCodeLine{4195                                  glyph);}
\DoxyCodeLine{4196 }
\DoxyCodeLine{4197    \textcolor{keywordflow}{if} (prefilter\_x > 1)}
\DoxyCodeLine{4198       stbtt\_\_h\_prefilter(output, out\_w, out\_h, out\_stride, prefilter\_x);}
\DoxyCodeLine{4199 }
\DoxyCodeLine{4200    \textcolor{keywordflow}{if} (prefilter\_y > 1)}
\DoxyCodeLine{4201       stbtt\_\_v\_prefilter(output, out\_w, out\_h, out\_stride, prefilter\_y);}
\DoxyCodeLine{4202 }
\DoxyCodeLine{4203    *sub\_x = stbtt\_\_oversample\_shift(prefilter\_x);}
\DoxyCodeLine{4204    *sub\_y = stbtt\_\_oversample\_shift(prefilter\_y);}
\DoxyCodeLine{4205 \}}
\DoxyCodeLine{4206 }
\DoxyCodeLine{4207 \textcolor{comment}{// rects array must be big enough to accommodate all characters in the given ranges}}
\DoxyCodeLine{4208 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_PackFontRangesRenderIntoRects(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \mbox{\hyperlink{structstbtt__pack__range}{stbtt\_pack\_range}} *ranges, \textcolor{keywordtype}{int} num\_ranges, \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *rects)}
\DoxyCodeLine{4209 \{}
\DoxyCodeLine{4210    \textcolor{keywordtype}{int} i,j,k, missing\_glyph = -\/1, return\_value = 1;}
\DoxyCodeLine{4211 }
\DoxyCodeLine{4212    \textcolor{comment}{// save current values}}
\DoxyCodeLine{4213    \textcolor{keywordtype}{int} old\_h\_over = spc-\/>h\_oversample;}
\DoxyCodeLine{4214    \textcolor{keywordtype}{int} old\_v\_over = spc-\/>v\_oversample;}
\DoxyCodeLine{4215 }
\DoxyCodeLine{4216    k = 0;}
\DoxyCodeLine{4217    \textcolor{keywordflow}{for} (i=0; i < num\_ranges; ++i) \{}
\DoxyCodeLine{4218       \textcolor{keywordtype}{float} fh = ranges[i].font\_size;}
\DoxyCodeLine{4219       \textcolor{keywordtype}{float} scale = fh > 0 ? stbtt\_ScaleForPixelHeight(info, fh) : stbtt\_ScaleForMappingEmToPixels(info, -\/fh);}
\DoxyCodeLine{4220       \textcolor{keywordtype}{float} recip\_h,recip\_v,sub\_x,sub\_y;}
\DoxyCodeLine{4221       spc-\/>h\_oversample = ranges[i].h\_oversample;}
\DoxyCodeLine{4222       spc-\/>v\_oversample = ranges[i].v\_oversample;}
\DoxyCodeLine{4223       recip\_h = 1.0f / spc-\/>h\_oversample;}
\DoxyCodeLine{4224       recip\_v = 1.0f / spc-\/>v\_oversample;}
\DoxyCodeLine{4225       sub\_x = stbtt\_\_oversample\_shift(spc-\/>h\_oversample);}
\DoxyCodeLine{4226       sub\_y = stbtt\_\_oversample\_shift(spc-\/>v\_oversample);}
\DoxyCodeLine{4227       \textcolor{keywordflow}{for} (j=0; j < ranges[i].num\_chars; ++j) \{}
\DoxyCodeLine{4228          \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *r = \&rects[k];}
\DoxyCodeLine{4229          \textcolor{keywordflow}{if} (r-\/>was\_packed \&\& r-\/>w != 0 \&\& r-\/>h != 0) \{}
\DoxyCodeLine{4230             \mbox{\hyperlink{structstbtt__packedchar}{stbtt\_packedchar}} *bc = \&ranges[i].chardata\_for\_range[j];}
\DoxyCodeLine{4231             \textcolor{keywordtype}{int} advance, lsb, x0,y0,x1,y1;}
\DoxyCodeLine{4232             \textcolor{keywordtype}{int} codepoint = ranges[i].array\_of\_unicode\_codepoints == NULL ? ranges[i].first\_unicode\_codepoint\_in\_range + j : ranges[i].array\_of\_unicode\_codepoints[j];}
\DoxyCodeLine{4233             \textcolor{keywordtype}{int} glyph = stbtt\_FindGlyphIndex(info, codepoint);}
\DoxyCodeLine{4234             stbrp\_coord pad = (stbrp\_coord) spc-\/>padding;}
\DoxyCodeLine{4235 }
\DoxyCodeLine{4236             \textcolor{comment}{// pad on left and top}}
\DoxyCodeLine{4237             r-\/>x += pad;}
\DoxyCodeLine{4238             r-\/>y += pad;}
\DoxyCodeLine{4239             r-\/>w -\/= pad;}
\DoxyCodeLine{4240             r-\/>h -\/= pad;}
\DoxyCodeLine{4241             stbtt\_GetGlyphHMetrics(info, glyph, \&advance, \&lsb);}
\DoxyCodeLine{4242             stbtt\_GetGlyphBitmapBox(info, glyph,}
\DoxyCodeLine{4243                                     scale * spc-\/>h\_oversample,}
\DoxyCodeLine{4244                                     scale * spc-\/>v\_oversample,}
\DoxyCodeLine{4245                                     \&x0,\&y0,\&x1,\&y1);}
\DoxyCodeLine{4246             stbtt\_MakeGlyphBitmapSubpixel(info,}
\DoxyCodeLine{4247                                           spc-\/>pixels + r-\/>x + r-\/>y*spc-\/>stride\_in\_bytes,}
\DoxyCodeLine{4248                                           r-\/>w -\/ spc-\/>h\_oversample+1,}
\DoxyCodeLine{4249                                           r-\/>h -\/ spc-\/>v\_oversample+1,}
\DoxyCodeLine{4250                                           spc-\/>stride\_in\_bytes,}
\DoxyCodeLine{4251                                           scale * spc-\/>h\_oversample,}
\DoxyCodeLine{4252                                           scale * spc-\/>v\_oversample,}
\DoxyCodeLine{4253                                           0,0,}
\DoxyCodeLine{4254                                           glyph);}
\DoxyCodeLine{4255 }
\DoxyCodeLine{4256             \textcolor{keywordflow}{if} (spc-\/>h\_oversample > 1)}
\DoxyCodeLine{4257                stbtt\_\_h\_prefilter(spc-\/>pixels + r-\/>x + r-\/>y*spc-\/>stride\_in\_bytes,}
\DoxyCodeLine{4258                                   r-\/>w, r-\/>h, spc-\/>stride\_in\_bytes,}
\DoxyCodeLine{4259                                   spc-\/>h\_oversample);}
\DoxyCodeLine{4260 }
\DoxyCodeLine{4261             \textcolor{keywordflow}{if} (spc-\/>v\_oversample > 1)}
\DoxyCodeLine{4262                stbtt\_\_v\_prefilter(spc-\/>pixels + r-\/>x + r-\/>y*spc-\/>stride\_in\_bytes,}
\DoxyCodeLine{4263                                   r-\/>w, r-\/>h, spc-\/>stride\_in\_bytes,}
\DoxyCodeLine{4264                                   spc-\/>v\_oversample);}
\DoxyCodeLine{4265 }
\DoxyCodeLine{4266             bc-\/>x0       = (stbtt\_int16)  r-\/>x;}
\DoxyCodeLine{4267             bc-\/>y0       = (stbtt\_int16)  r-\/>y;}
\DoxyCodeLine{4268             bc-\/>x1       = (stbtt\_int16) (r-\/>x + r-\/>w);}
\DoxyCodeLine{4269             bc-\/>y1       = (stbtt\_int16) (r-\/>y + r-\/>h);}
\DoxyCodeLine{4270             bc-\/>xadvance =                scale * advance;}
\DoxyCodeLine{4271             bc-\/>xoff     =       (float)  x0 * recip\_h + sub\_x;}
\DoxyCodeLine{4272             bc-\/>yoff     =       (float)  y0 * recip\_v + sub\_y;}
\DoxyCodeLine{4273             bc-\/>xoff2    =                (x0 + r-\/>w) * recip\_h + sub\_x;}
\DoxyCodeLine{4274             bc-\/>yoff2    =                (y0 + r-\/>h) * recip\_v + sub\_y;}
\DoxyCodeLine{4275 }
\DoxyCodeLine{4276             \textcolor{keywordflow}{if} (glyph == 0)}
\DoxyCodeLine{4277                missing\_glyph = j;}
\DoxyCodeLine{4278          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (spc-\/>skip\_missing) \{}
\DoxyCodeLine{4279             return\_value = 0;}
\DoxyCodeLine{4280          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (r-\/>was\_packed \&\& r-\/>w == 0 \&\& r-\/>h == 0 \&\& missing\_glyph >= 0) \{}
\DoxyCodeLine{4281             ranges[i].chardata\_for\_range[j] = ranges[i].chardata\_for\_range[missing\_glyph];}
\DoxyCodeLine{4282          \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4283             return\_value = 0; \textcolor{comment}{// if any fail, report failure}}
\DoxyCodeLine{4284          \}}
\DoxyCodeLine{4285 }
\DoxyCodeLine{4286          ++k;}
\DoxyCodeLine{4287       \}}
\DoxyCodeLine{4288    \}}
\DoxyCodeLine{4289 }
\DoxyCodeLine{4290    \textcolor{comment}{// restore original values}}
\DoxyCodeLine{4291    spc-\/>h\_oversample = old\_h\_over;}
\DoxyCodeLine{4292    spc-\/>v\_oversample = old\_v\_over;}
\DoxyCodeLine{4293 }
\DoxyCodeLine{4294    \textcolor{keywordflow}{return} return\_value;}
\DoxyCodeLine{4295 \}}
\DoxyCodeLine{4296 }
\DoxyCodeLine{4297 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_PackFontRangesPackRects(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *rects, \textcolor{keywordtype}{int} num\_rects)}
\DoxyCodeLine{4298 \{}
\DoxyCodeLine{4299    stbrp\_pack\_rects((\mbox{\hyperlink{structstbrp__context}{stbrp\_context}} *) spc-\/>pack\_info, rects, num\_rects);}
\DoxyCodeLine{4300 \}}
\DoxyCodeLine{4301 }
\DoxyCodeLine{4302 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_PackFontRanges(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fontdata, \textcolor{keywordtype}{int} font\_index, \mbox{\hyperlink{structstbtt__pack__range}{stbtt\_pack\_range}} *ranges, \textcolor{keywordtype}{int} num\_ranges)}
\DoxyCodeLine{4303 \{}
\DoxyCodeLine{4304    \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} info;}
\DoxyCodeLine{4305    \textcolor{keywordtype}{int} i,j,n, return\_value = 1;}
\DoxyCodeLine{4306    \textcolor{comment}{//stbrp\_context *context = (stbrp\_context *) spc-\/>pack\_info;}}
\DoxyCodeLine{4307    \mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}}    *rects;}
\DoxyCodeLine{4308 }
\DoxyCodeLine{4309    \textcolor{comment}{// flag all characters as NOT packed}}
\DoxyCodeLine{4310    \textcolor{keywordflow}{for} (i=0; i < num\_ranges; ++i)}
\DoxyCodeLine{4311       \textcolor{keywordflow}{for} (j=0; j < ranges[i].num\_chars; ++j)}
\DoxyCodeLine{4312          ranges[i].chardata\_for\_range[j].x0 =}
\DoxyCodeLine{4313          ranges[i].chardata\_for\_range[j].y0 =}
\DoxyCodeLine{4314          ranges[i].chardata\_for\_range[j].x1 =}
\DoxyCodeLine{4315          ranges[i].chardata\_for\_range[j].y1 = 0;}
\DoxyCodeLine{4316 }
\DoxyCodeLine{4317    n = 0;}
\DoxyCodeLine{4318    \textcolor{keywordflow}{for} (i=0; i < num\_ranges; ++i)}
\DoxyCodeLine{4319       n += ranges[i].num\_chars;}
\DoxyCodeLine{4320 }
\DoxyCodeLine{4321    rects = (\mbox{\hyperlink{structstbrp__rect}{stbrp\_rect}} *) STBTT\_malloc(\textcolor{keyword}{sizeof}(*rects) * n, spc-\/>user\_allocator\_context);}
\DoxyCodeLine{4322    \textcolor{keywordflow}{if} (rects == NULL)}
\DoxyCodeLine{4323       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4324 }
\DoxyCodeLine{4325    info.userdata = spc-\/>user\_allocator\_context;}
\DoxyCodeLine{4326    stbtt\_InitFont(\&info, fontdata, stbtt\_GetFontOffsetForIndex(fontdata,font\_index));}
\DoxyCodeLine{4327 }
\DoxyCodeLine{4328    n = stbtt\_PackFontRangesGatherRects(spc, \&info, ranges, num\_ranges, rects);}
\DoxyCodeLine{4329 }
\DoxyCodeLine{4330    stbtt\_PackFontRangesPackRects(spc, rects, n);}
\DoxyCodeLine{4331 }
\DoxyCodeLine{4332    return\_value = stbtt\_PackFontRangesRenderIntoRects(spc, \&info, ranges, num\_ranges, rects);}
\DoxyCodeLine{4333 }
\DoxyCodeLine{4334    STBTT\_free(rects, spc-\/>user\_allocator\_context);}
\DoxyCodeLine{4335    \textcolor{keywordflow}{return} return\_value;}
\DoxyCodeLine{4336 \}}
\DoxyCodeLine{4337 }
\DoxyCodeLine{4338 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_PackFontRange(\mbox{\hyperlink{structstbtt__pack__context}{stbtt\_pack\_context}} *spc, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fontdata, \textcolor{keywordtype}{int} font\_index, \textcolor{keywordtype}{float} font\_size,}
\DoxyCodeLine{4339             \textcolor{keywordtype}{int} first\_unicode\_codepoint\_in\_range, \textcolor{keywordtype}{int} num\_chars\_in\_range, \mbox{\hyperlink{structstbtt__packedchar}{stbtt\_packedchar}} *chardata\_for\_range)}
\DoxyCodeLine{4340 \{}
\DoxyCodeLine{4341    \mbox{\hyperlink{structstbtt__pack__range}{stbtt\_pack\_range}} range;}
\DoxyCodeLine{4342    range.first\_unicode\_codepoint\_in\_range = first\_unicode\_codepoint\_in\_range;}
\DoxyCodeLine{4343    range.array\_of\_unicode\_codepoints = NULL;}
\DoxyCodeLine{4344    range.num\_chars                   = num\_chars\_in\_range;}
\DoxyCodeLine{4345    range.chardata\_for\_range          = chardata\_for\_range;}
\DoxyCodeLine{4346    range.font\_size                   = font\_size;}
\DoxyCodeLine{4347    \textcolor{keywordflow}{return} stbtt\_PackFontRanges(spc, fontdata, font\_index, \&range, 1);}
\DoxyCodeLine{4348 \}}
\DoxyCodeLine{4349 }
\DoxyCodeLine{4350 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetScaledFontVMetrics(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fontdata, \textcolor{keywordtype}{int} index, \textcolor{keywordtype}{float} size, \textcolor{keywordtype}{float} *ascent, \textcolor{keywordtype}{float} *descent, \textcolor{keywordtype}{float} *lineGap)}
\DoxyCodeLine{4351 \{}
\DoxyCodeLine{4352    \textcolor{keywordtype}{int} i\_ascent, i\_descent, i\_lineGap;}
\DoxyCodeLine{4353    \textcolor{keywordtype}{float} scale;}
\DoxyCodeLine{4354    \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} info;}
\DoxyCodeLine{4355    stbtt\_InitFont(\&info, fontdata, stbtt\_GetFontOffsetForIndex(fontdata, index));}
\DoxyCodeLine{4356    scale = size > 0 ? stbtt\_ScaleForPixelHeight(\&info, size) : stbtt\_ScaleForMappingEmToPixels(\&info, -\/size);}
\DoxyCodeLine{4357    stbtt\_GetFontVMetrics(\&info, \&i\_ascent, \&i\_descent, \&i\_lineGap);}
\DoxyCodeLine{4358    *ascent  = (float) i\_ascent  * scale;}
\DoxyCodeLine{4359    *descent = (float) i\_descent * scale;}
\DoxyCodeLine{4360    *lineGap = (float) i\_lineGap * scale;}
\DoxyCodeLine{4361 \}}
\DoxyCodeLine{4362 }
\DoxyCodeLine{4363 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_GetPackedQuad(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__packedchar}{stbtt\_packedchar}} *chardata, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph, \textcolor{keywordtype}{int} char\_index, \textcolor{keywordtype}{float} *xpos, \textcolor{keywordtype}{float} *ypos, \mbox{\hyperlink{structstbtt__aligned__quad}{stbtt\_aligned\_quad}} *q, \textcolor{keywordtype}{int} align\_to\_integer)}
\DoxyCodeLine{4364 \{}
\DoxyCodeLine{4365    \textcolor{keywordtype}{float} ipw = 1.0f / pw, iph = 1.0f / ph;}
\DoxyCodeLine{4366    \textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__packedchar}{stbtt\_packedchar}} *b = chardata + char\_index;}
\DoxyCodeLine{4367 }
\DoxyCodeLine{4368    \textcolor{keywordflow}{if} (align\_to\_integer) \{}
\DoxyCodeLine{4369       \textcolor{keywordtype}{float} x = (float) STBTT\_ifloor((*xpos + b-\/>xoff) + 0.5f);}
\DoxyCodeLine{4370       \textcolor{keywordtype}{float} y = (float) STBTT\_ifloor((*ypos + b-\/>yoff) + 0.5f);}
\DoxyCodeLine{4371       q-\/>x0 = x;}
\DoxyCodeLine{4372       q-\/>y0 = y;}
\DoxyCodeLine{4373       q-\/>x1 = x + b-\/>xoff2 -\/ b-\/>xoff;}
\DoxyCodeLine{4374       q-\/>y1 = y + b-\/>yoff2 -\/ b-\/>yoff;}
\DoxyCodeLine{4375    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4376       q-\/>x0 = *xpos + b-\/>xoff;}
\DoxyCodeLine{4377       q-\/>y0 = *ypos + b-\/>yoff;}
\DoxyCodeLine{4378       q-\/>x1 = *xpos + b-\/>xoff2;}
\DoxyCodeLine{4379       q-\/>y1 = *ypos + b-\/>yoff2;}
\DoxyCodeLine{4380    \}}
\DoxyCodeLine{4381 }
\DoxyCodeLine{4382    q-\/>s0 = b-\/>x0 * ipw;}
\DoxyCodeLine{4383    q-\/>t0 = b-\/>y0 * iph;}
\DoxyCodeLine{4384    q-\/>s1 = b-\/>x1 * ipw;}
\DoxyCodeLine{4385    q-\/>t1 = b-\/>y1 * iph;}
\DoxyCodeLine{4386 }
\DoxyCodeLine{4387    *xpos += b-\/>xadvance;}
\DoxyCodeLine{4388 \}}
\DoxyCodeLine{4389 }
\DoxyCodeLine{4391 \textcolor{comment}{//}}
\DoxyCodeLine{4392 \textcolor{comment}{// sdf computation}}
\DoxyCodeLine{4393 \textcolor{comment}{//}}
\DoxyCodeLine{4394 }
\DoxyCodeLine{4395 \textcolor{preprocessor}{\#define STBTT\_min(a,b)  ((a) < (b) ? (a) : (b))}}
\DoxyCodeLine{4396 \textcolor{preprocessor}{\#define STBTT\_max(a,b)  ((a) < (b) ? (b) : (a))}}
\DoxyCodeLine{4397 }
\DoxyCodeLine{4398 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_ray\_intersect\_bezier(\textcolor{keywordtype}{float} orig[2], \textcolor{keywordtype}{float} ray[2], \textcolor{keywordtype}{float} q0[2], \textcolor{keywordtype}{float} q1[2], \textcolor{keywordtype}{float} q2[2], \textcolor{keywordtype}{float} hits[2][2])}
\DoxyCodeLine{4399 \{}
\DoxyCodeLine{4400    \textcolor{keywordtype}{float} q0perp = q0[1]*ray[0] -\/ q0[0]*ray[1];}
\DoxyCodeLine{4401    \textcolor{keywordtype}{float} q1perp = q1[1]*ray[0] -\/ q1[0]*ray[1];}
\DoxyCodeLine{4402    \textcolor{keywordtype}{float} q2perp = q2[1]*ray[0] -\/ q2[0]*ray[1];}
\DoxyCodeLine{4403    \textcolor{keywordtype}{float} roperp = orig[1]*ray[0] -\/ orig[0]*ray[1];}
\DoxyCodeLine{4404 }
\DoxyCodeLine{4405    \textcolor{keywordtype}{float} a = q0perp -\/ 2*q1perp + q2perp;}
\DoxyCodeLine{4406    \textcolor{keywordtype}{float} b = q1perp -\/ q0perp;}
\DoxyCodeLine{4407    \textcolor{keywordtype}{float} c = q0perp -\/ roperp;}
\DoxyCodeLine{4408 }
\DoxyCodeLine{4409    \textcolor{keywordtype}{float} s0 = 0., s1 = 0.;}
\DoxyCodeLine{4410    \textcolor{keywordtype}{int} num\_s = 0;}
\DoxyCodeLine{4411 }
\DoxyCodeLine{4412    \textcolor{keywordflow}{if} (a != 0.0) \{}
\DoxyCodeLine{4413       \textcolor{keywordtype}{float} discr = b*b -\/ a*c;}
\DoxyCodeLine{4414       \textcolor{keywordflow}{if} (discr > 0.0) \{}
\DoxyCodeLine{4415          \textcolor{keywordtype}{float} rcpna = -\/1 / a;}
\DoxyCodeLine{4416          \textcolor{keywordtype}{float} d = (float) STBTT\_sqrt(discr);}
\DoxyCodeLine{4417          s0 = (b+d) * rcpna;}
\DoxyCodeLine{4418          s1 = (b-\/d) * rcpna;}
\DoxyCodeLine{4419          \textcolor{keywordflow}{if} (s0 >= 0.0 \&\& s0 <= 1.0)}
\DoxyCodeLine{4420             num\_s = 1;}
\DoxyCodeLine{4421          \textcolor{keywordflow}{if} (d > 0.0 \&\& s1 >= 0.0 \&\& s1 <= 1.0) \{}
\DoxyCodeLine{4422             \textcolor{keywordflow}{if} (num\_s == 0) s0 = s1;}
\DoxyCodeLine{4423             ++num\_s;}
\DoxyCodeLine{4424          \}}
\DoxyCodeLine{4425       \}}
\DoxyCodeLine{4426    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4427       \textcolor{comment}{// 2*b*s + c = 0}}
\DoxyCodeLine{4428       \textcolor{comment}{// s = -\/c / (2*b)}}
\DoxyCodeLine{4429       s0 = c / (-\/2 * b);}
\DoxyCodeLine{4430       \textcolor{keywordflow}{if} (s0 >= 0.0 \&\& s0 <= 1.0)}
\DoxyCodeLine{4431          num\_s = 1;}
\DoxyCodeLine{4432    \}}
\DoxyCodeLine{4433 }
\DoxyCodeLine{4434    \textcolor{keywordflow}{if} (num\_s == 0)}
\DoxyCodeLine{4435       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4436    \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4437       \textcolor{keywordtype}{float} rcp\_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);}
\DoxyCodeLine{4438       \textcolor{keywordtype}{float} rayn\_x = ray[0] * rcp\_len2, rayn\_y = ray[1] * rcp\_len2;}
\DoxyCodeLine{4439 }
\DoxyCodeLine{4440       \textcolor{keywordtype}{float} q0d =   q0[0]*rayn\_x +   q0[1]*rayn\_y;}
\DoxyCodeLine{4441       \textcolor{keywordtype}{float} q1d =   q1[0]*rayn\_x +   q1[1]*rayn\_y;}
\DoxyCodeLine{4442       \textcolor{keywordtype}{float} q2d =   q2[0]*rayn\_x +   q2[1]*rayn\_y;}
\DoxyCodeLine{4443       \textcolor{keywordtype}{float} rod = orig[0]*rayn\_x + orig[1]*rayn\_y;}
\DoxyCodeLine{4444 }
\DoxyCodeLine{4445       \textcolor{keywordtype}{float} q10d = q1d -\/ q0d;}
\DoxyCodeLine{4446       \textcolor{keywordtype}{float} q20d = q2d -\/ q0d;}
\DoxyCodeLine{4447       \textcolor{keywordtype}{float} q0rd = q0d -\/ rod;}
\DoxyCodeLine{4448 }
\DoxyCodeLine{4449       hits[0][0] = q0rd + s0*(2.0f -\/ 2.0f*s0)*q10d + s0*s0*q20d;}
\DoxyCodeLine{4450       hits[0][1] = a*s0+b;}
\DoxyCodeLine{4451 }
\DoxyCodeLine{4452       \textcolor{keywordflow}{if} (num\_s > 1) \{}
\DoxyCodeLine{4453          hits[1][0] = q0rd + s1*(2.0f -\/ 2.0f*s1)*q10d + s1*s1*q20d;}
\DoxyCodeLine{4454          hits[1][1] = a*s1+b;}
\DoxyCodeLine{4455          \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{4456       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4457          \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4458       \}}
\DoxyCodeLine{4459    \}}
\DoxyCodeLine{4460 \}}
\DoxyCodeLine{4461 }
\DoxyCodeLine{4462 \textcolor{keyword}{static} \textcolor{keywordtype}{int} equal(\textcolor{keywordtype}{float} *a, \textcolor{keywordtype}{float} *b)}
\DoxyCodeLine{4463 \{}
\DoxyCodeLine{4464    \textcolor{keywordflow}{return} (a[0] == b[0] \&\& a[1] == b[1]);}
\DoxyCodeLine{4465 \}}
\DoxyCodeLine{4466 }
\DoxyCodeLine{4467 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_compute\_crossings\_x(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{int} nverts, \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *verts)}
\DoxyCodeLine{4468 \{}
\DoxyCodeLine{4469    \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{4470    \textcolor{keywordtype}{float} orig[2], ray[2] = \{ 1, 0 \};}
\DoxyCodeLine{4471    \textcolor{keywordtype}{float} y\_frac;}
\DoxyCodeLine{4472    \textcolor{keywordtype}{int} winding = 0;}
\DoxyCodeLine{4473 }
\DoxyCodeLine{4474    \textcolor{comment}{// make sure y never passes through a vertex of the shape}}
\DoxyCodeLine{4475    y\_frac = (float) STBTT\_fmod(y, 1.0f);}
\DoxyCodeLine{4476    \textcolor{keywordflow}{if} (y\_frac < 0.01f)}
\DoxyCodeLine{4477       y += 0.01f;}
\DoxyCodeLine{4478    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (y\_frac > 0.99f)}
\DoxyCodeLine{4479       y -\/= 0.01f;}
\DoxyCodeLine{4480 }
\DoxyCodeLine{4481    orig[0] = x;}
\DoxyCodeLine{4482    orig[1] = y;}
\DoxyCodeLine{4483 }
\DoxyCodeLine{4484    \textcolor{comment}{// test a ray from (-\/infinity,y) to (x,y)}}
\DoxyCodeLine{4485    \textcolor{keywordflow}{for} (i=0; i < nverts; ++i) \{}
\DoxyCodeLine{4486       \textcolor{keywordflow}{if} (verts[i].type == STBTT\_vline) \{}
\DoxyCodeLine{4487          \textcolor{keywordtype}{int} x0 = (int) verts[i-\/1].x, y0 = (\textcolor{keywordtype}{int}) verts[i-\/1].y;}
\DoxyCodeLine{4488          \textcolor{keywordtype}{int} x1 = (int) verts[i  ].x, y1 = (\textcolor{keywordtype}{int}) verts[i  ].y;}
\DoxyCodeLine{4489          \textcolor{keywordflow}{if} (y > STBTT\_min(y0,y1) \&\& y < STBTT\_max(y0,y1) \&\& x > STBTT\_min(x0,x1)) \{}
\DoxyCodeLine{4490             \textcolor{keywordtype}{float} x\_inter = (y -\/ y0) / (y1 -\/ y0) * (x1-\/x0) + x0;}
\DoxyCodeLine{4491             \textcolor{keywordflow}{if} (x\_inter < x)}
\DoxyCodeLine{4492                winding += (y0 < y1) ? 1 : -\/1;}
\DoxyCodeLine{4493          \}}
\DoxyCodeLine{4494       \}}
\DoxyCodeLine{4495       \textcolor{keywordflow}{if} (verts[i].type == STBTT\_vcurve) \{}
\DoxyCodeLine{4496          \textcolor{keywordtype}{int} x0 = (int) verts[i-\/1].x , y0 = (\textcolor{keywordtype}{int}) verts[i-\/1].y ;}
\DoxyCodeLine{4497          \textcolor{keywordtype}{int} x1 = (int) verts[i  ].cx, y1 = (\textcolor{keywordtype}{int}) verts[i  ].cy;}
\DoxyCodeLine{4498          \textcolor{keywordtype}{int} x2 = (int) verts[i  ].x , y2 = (\textcolor{keywordtype}{int}) verts[i  ].y ;}
\DoxyCodeLine{4499          \textcolor{keywordtype}{int} ax = STBTT\_min(x0,STBTT\_min(x1,x2)), ay = STBTT\_min(y0,STBTT\_min(y1,y2));}
\DoxyCodeLine{4500          \textcolor{keywordtype}{int} by = STBTT\_max(y0,STBTT\_max(y1,y2));}
\DoxyCodeLine{4501          \textcolor{keywordflow}{if} (y > ay \&\& y < by \&\& x > ax) \{}
\DoxyCodeLine{4502             \textcolor{keywordtype}{float} q0[2],q1[2],q2[2];}
\DoxyCodeLine{4503             \textcolor{keywordtype}{float} hits[2][2];}
\DoxyCodeLine{4504             q0[0] = (float)x0;}
\DoxyCodeLine{4505             q0[1] = (float)y0;}
\DoxyCodeLine{4506             q1[0] = (float)x1;}
\DoxyCodeLine{4507             q1[1] = (float)y1;}
\DoxyCodeLine{4508             q2[0] = (float)x2;}
\DoxyCodeLine{4509             q2[1] = (float)y2;}
\DoxyCodeLine{4510             \textcolor{keywordflow}{if} (equal(q0,q1) || equal(q1,q2)) \{}
\DoxyCodeLine{4511                x0 = (int)verts[i-\/1].x;}
\DoxyCodeLine{4512                y0 = (int)verts[i-\/1].y;}
\DoxyCodeLine{4513                x1 = (int)verts[i  ].x;}
\DoxyCodeLine{4514                y1 = (int)verts[i  ].y;}
\DoxyCodeLine{4515                \textcolor{keywordflow}{if} (y > STBTT\_min(y0,y1) \&\& y < STBTT\_max(y0,y1) \&\& x > STBTT\_min(x0,x1)) \{}
\DoxyCodeLine{4516                   \textcolor{keywordtype}{float} x\_inter = (y -\/ y0) / (y1 -\/ y0) * (x1-\/x0) + x0;}
\DoxyCodeLine{4517                   \textcolor{keywordflow}{if} (x\_inter < x)}
\DoxyCodeLine{4518                      winding += (y0 < y1) ? 1 : -\/1;}
\DoxyCodeLine{4519                \}}
\DoxyCodeLine{4520             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4521                \textcolor{keywordtype}{int} num\_hits = stbtt\_\_ray\_intersect\_bezier(orig, ray, q0, q1, q2, hits);}
\DoxyCodeLine{4522                \textcolor{keywordflow}{if} (num\_hits >= 1)}
\DoxyCodeLine{4523                   \textcolor{keywordflow}{if} (hits[0][0] < 0)}
\DoxyCodeLine{4524                      winding += (hits[0][1] < 0 ? -\/1 : 1);}
\DoxyCodeLine{4525                \textcolor{keywordflow}{if} (num\_hits >= 2)}
\DoxyCodeLine{4526                   \textcolor{keywordflow}{if} (hits[1][0] < 0)}
\DoxyCodeLine{4527                      winding += (hits[1][1] < 0 ? -\/1 : 1);}
\DoxyCodeLine{4528             \}}
\DoxyCodeLine{4529          \}}
\DoxyCodeLine{4530       \}}
\DoxyCodeLine{4531    \}}
\DoxyCodeLine{4532    \textcolor{keywordflow}{return} winding;}
\DoxyCodeLine{4533 \}}
\DoxyCodeLine{4534 }
\DoxyCodeLine{4535 \textcolor{keyword}{static} \textcolor{keywordtype}{float} stbtt\_\_cuberoot( \textcolor{keywordtype}{float} x )}
\DoxyCodeLine{4536 \{}
\DoxyCodeLine{4537    \textcolor{keywordflow}{if} (x<0)}
\DoxyCodeLine{4538       \textcolor{keywordflow}{return} -\/(float) STBTT\_pow(-\/x,1.0f/3.0f);}
\DoxyCodeLine{4539    \textcolor{keywordflow}{else}}
\DoxyCodeLine{4540       \textcolor{keywordflow}{return}  (\textcolor{keywordtype}{float}) STBTT\_pow( x,1.0f/3.0f);}
\DoxyCodeLine{4541 \}}
\DoxyCodeLine{4542 }
\DoxyCodeLine{4543 \textcolor{comment}{// x\string^3 + a*x\string^2 + b*x + c = 0}}
\DoxyCodeLine{4544 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_solve\_cubic(\textcolor{keywordtype}{float} a, \textcolor{keywordtype}{float} b, \textcolor{keywordtype}{float} c, \textcolor{keywordtype}{float}* r)}
\DoxyCodeLine{4545 \{}
\DoxyCodeLine{4546    \textcolor{keywordtype}{float} s = -\/a / 3;}
\DoxyCodeLine{4547    \textcolor{keywordtype}{float} p = b -\/ a*a / 3;}
\DoxyCodeLine{4548    \textcolor{keywordtype}{float} q = a * (2*a*a -\/ 9*b) / 27 + c;}
\DoxyCodeLine{4549    \textcolor{keywordtype}{float} p3 = p*p*p;}
\DoxyCodeLine{4550    \textcolor{keywordtype}{float} d = q*q + 4*p3 / 27;}
\DoxyCodeLine{4551    \textcolor{keywordflow}{if} (d >= 0) \{}
\DoxyCodeLine{4552       \textcolor{keywordtype}{float} z = (float) STBTT\_sqrt(d);}
\DoxyCodeLine{4553       \textcolor{keywordtype}{float} u = (-\/q + z) / 2;}
\DoxyCodeLine{4554       \textcolor{keywordtype}{float} v = (-\/q -\/ z) / 2;}
\DoxyCodeLine{4555       u = stbtt\_\_cuberoot(u);}
\DoxyCodeLine{4556       v = stbtt\_\_cuberoot(v);}
\DoxyCodeLine{4557       r[0] = s + u + v;}
\DoxyCodeLine{4558       \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4559    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4560       \textcolor{keywordtype}{float} u = (float) STBTT\_sqrt(-\/p/3);}
\DoxyCodeLine{4561       \textcolor{keywordtype}{float} v = (float) STBTT\_acos(-\/STBTT\_sqrt(-\/27/p3) * q / 2) / 3; \textcolor{comment}{// p3 must be negative, since d is negative}}
\DoxyCodeLine{4562       \textcolor{keywordtype}{float} m = (float) STBTT\_cos(v);}
\DoxyCodeLine{4563       \textcolor{keywordtype}{float} n = (float) STBTT\_cos(v-\/3.141592/2)*1.732050808f;}
\DoxyCodeLine{4564       r[0] = s + u * 2 * m;}
\DoxyCodeLine{4565       r[1] = s -\/ u * (m + n);}
\DoxyCodeLine{4566       r[2] = s -\/ u * (m -\/ n);}
\DoxyCodeLine{4567 }
\DoxyCodeLine{4568       \textcolor{comment}{//STBTT\_assert( STBTT\_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?}}
\DoxyCodeLine{4569       \textcolor{comment}{//STBTT\_assert( STBTT\_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);}}
\DoxyCodeLine{4570       \textcolor{comment}{//STBTT\_assert( STBTT\_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);}}
\DoxyCodeLine{4571       \textcolor{keywordflow}{return} 3;}
\DoxyCodeLine{4572    \}}
\DoxyCodeLine{4573 \}}
\DoxyCodeLine{4574 }
\DoxyCodeLine{4575 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} * stbtt\_GetGlyphSDF(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale, \textcolor{keywordtype}{int} glyph, \textcolor{keywordtype}{int} padding, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} onedge\_value, \textcolor{keywordtype}{float} pixel\_dist\_scale, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff)}
\DoxyCodeLine{4576 \{}
\DoxyCodeLine{4577    \textcolor{keywordtype}{float} scale\_x = scale, scale\_y = scale;}
\DoxyCodeLine{4578    \textcolor{keywordtype}{int} ix0,iy0,ix1,iy1;}
\DoxyCodeLine{4579    \textcolor{keywordtype}{int} w,h;}
\DoxyCodeLine{4580    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data;}
\DoxyCodeLine{4581 }
\DoxyCodeLine{4582    \textcolor{keywordflow}{if} (scale == 0) \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{4583 }
\DoxyCodeLine{4584    stbtt\_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, \&ix0,\&iy0,\&ix1,\&iy1);}
\DoxyCodeLine{4585 }
\DoxyCodeLine{4586    \textcolor{comment}{// if empty, return NULL}}
\DoxyCodeLine{4587    \textcolor{keywordflow}{if} (ix0 == ix1 || iy0 == iy1)}
\DoxyCodeLine{4588       \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{4589 }
\DoxyCodeLine{4590    ix0 -\/= padding;}
\DoxyCodeLine{4591    iy0 -\/= padding;}
\DoxyCodeLine{4592    ix1 += padding;}
\DoxyCodeLine{4593    iy1 += padding;}
\DoxyCodeLine{4594 }
\DoxyCodeLine{4595    w = (ix1 -\/ ix0);}
\DoxyCodeLine{4596    h = (iy1 -\/ iy0);}
\DoxyCodeLine{4597 }
\DoxyCodeLine{4598    \textcolor{keywordflow}{if} (width ) *width  = w;}
\DoxyCodeLine{4599    \textcolor{keywordflow}{if} (height) *height = h;}
\DoxyCodeLine{4600    \textcolor{keywordflow}{if} (xoff  ) *xoff   = ix0;}
\DoxyCodeLine{4601    \textcolor{keywordflow}{if} (yoff  ) *yoff   = iy0;}
\DoxyCodeLine{4602 }
\DoxyCodeLine{4603    \textcolor{comment}{// invert for y-\/downwards bitmaps}}
\DoxyCodeLine{4604    scale\_y = -\/scale\_y;}
\DoxyCodeLine{4605 }
\DoxyCodeLine{4606    \{}
\DoxyCodeLine{4607       \textcolor{keywordtype}{int} x,y,i,j;}
\DoxyCodeLine{4608       \textcolor{keywordtype}{float} *precompute;}
\DoxyCodeLine{4609       \mbox{\hyperlink{structstbtt__vertex}{stbtt\_vertex}} *verts;}
\DoxyCodeLine{4610       \textcolor{keywordtype}{int} num\_verts = stbtt\_GetGlyphShape(info, glyph, \&verts);}
\DoxyCodeLine{4611       data = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) STBTT\_malloc(w * h, info-\/>userdata);}
\DoxyCodeLine{4612       precompute = (\textcolor{keywordtype}{float} *) STBTT\_malloc(num\_verts * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), info-\/>userdata);}
\DoxyCodeLine{4613 }
\DoxyCodeLine{4614       \textcolor{keywordflow}{for} (i=0,j=num\_verts-\/1; i < num\_verts; j=i++) \{}
\DoxyCodeLine{4615          \textcolor{keywordflow}{if} (verts[i].type == STBTT\_vline) \{}
\DoxyCodeLine{4616             \textcolor{keywordtype}{float} x0 = verts[i].x*scale\_x, y0 = verts[i].y*scale\_y;}
\DoxyCodeLine{4617             \textcolor{keywordtype}{float} x1 = verts[j].x*scale\_x, y1 = verts[j].y*scale\_y;}
\DoxyCodeLine{4618             \textcolor{keywordtype}{float} dist = (float) STBTT\_sqrt((x1-\/x0)*(x1-\/x0) + (y1-\/y0)*(y1-\/y0));}
\DoxyCodeLine{4619             precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;}
\DoxyCodeLine{4620          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (verts[i].type == STBTT\_vcurve) \{}
\DoxyCodeLine{4621             \textcolor{keywordtype}{float} x2 = verts[j].x *scale\_x, y2 = verts[j].y *scale\_y;}
\DoxyCodeLine{4622             \textcolor{keywordtype}{float} x1 = verts[i].cx*scale\_x, y1 = verts[i].cy*scale\_y;}
\DoxyCodeLine{4623             \textcolor{keywordtype}{float} x0 = verts[i].x *scale\_x, y0 = verts[i].y *scale\_y;}
\DoxyCodeLine{4624             \textcolor{keywordtype}{float} bx = x0 -\/ 2*x1 + x2, by = y0 -\/ 2*y1 + y2;}
\DoxyCodeLine{4625             \textcolor{keywordtype}{float} len2 = bx*bx + by*by;}
\DoxyCodeLine{4626             \textcolor{keywordflow}{if} (len2 != 0.0f)}
\DoxyCodeLine{4627                precompute[i] = 1.0f / (bx*bx + by*by);}
\DoxyCodeLine{4628             \textcolor{keywordflow}{else}}
\DoxyCodeLine{4629                precompute[i] = 0.0f;}
\DoxyCodeLine{4630          \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{4631             precompute[i] = 0.0f;}
\DoxyCodeLine{4632       \}}
\DoxyCodeLine{4633 }
\DoxyCodeLine{4634       \textcolor{keywordflow}{for} (y=iy0; y < iy1; ++y) \{}
\DoxyCodeLine{4635          \textcolor{keywordflow}{for} (x=ix0; x < ix1; ++x) \{}
\DoxyCodeLine{4636             \textcolor{keywordtype}{float} val;}
\DoxyCodeLine{4637             \textcolor{keywordtype}{float} min\_dist = 999999.0f;}
\DoxyCodeLine{4638             \textcolor{keywordtype}{float} sx = (float) x + 0.5f;}
\DoxyCodeLine{4639             \textcolor{keywordtype}{float} sy = (float) y + 0.5f;}
\DoxyCodeLine{4640             \textcolor{keywordtype}{float} x\_gspace = (sx / scale\_x);}
\DoxyCodeLine{4641             \textcolor{keywordtype}{float} y\_gspace = (sy / scale\_y);}
\DoxyCodeLine{4642 }
\DoxyCodeLine{4643             \textcolor{keywordtype}{int} winding = stbtt\_\_compute\_crossings\_x(x\_gspace, y\_gspace, num\_verts, verts); \textcolor{comment}{// @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-\/tesselated curves so a new path}}
\DoxyCodeLine{4644 }
\DoxyCodeLine{4645             \textcolor{keywordflow}{for} (i=0; i < num\_verts; ++i) \{}
\DoxyCodeLine{4646                \textcolor{keywordtype}{float} x0 = verts[i].x*scale\_x, y0 = verts[i].y*scale\_y;}
\DoxyCodeLine{4647 }
\DoxyCodeLine{4648                \textcolor{keywordflow}{if} (verts[i].type == STBTT\_vline \&\& precompute[i] != 0.0f) \{}
\DoxyCodeLine{4649                   \textcolor{keywordtype}{float} x1 = verts[i-\/1].x*scale\_x, y1 = verts[i-\/1].y*scale\_y;}
\DoxyCodeLine{4650 }
\DoxyCodeLine{4651                   \textcolor{keywordtype}{float} dist,dist2 = (x0-\/sx)*(x0-\/sx) + (y0-\/sy)*(y0-\/sy);}
\DoxyCodeLine{4652                   \textcolor{keywordflow}{if} (dist2 < min\_dist*min\_dist)}
\DoxyCodeLine{4653                      min\_dist = (float) STBTT\_sqrt(dist2);}
\DoxyCodeLine{4654 }
\DoxyCodeLine{4655                   \textcolor{comment}{// coarse culling against bbox}}
\DoxyCodeLine{4656                   \textcolor{comment}{//if (sx > STBTT\_min(x0,x1)-\/min\_dist \&\& sx < STBTT\_max(x0,x1)+min\_dist \&\&}}
\DoxyCodeLine{4657                   \textcolor{comment}{//    sy > STBTT\_min(y0,y1)-\/min\_dist \&\& sy < STBTT\_max(y0,y1)+min\_dist)}}
\DoxyCodeLine{4658                   dist = (float) STBTT\_fabs((x1-\/x0)*(y0-\/sy) -\/ (y1-\/y0)*(x0-\/sx)) * precompute[i];}
\DoxyCodeLine{4659                   STBTT\_assert(i != 0);}
\DoxyCodeLine{4660                   \textcolor{keywordflow}{if} (dist < min\_dist) \{}
\DoxyCodeLine{4661                      \textcolor{comment}{// check position along line}}
\DoxyCodeLine{4662                      \textcolor{comment}{// x' = x0 + t*(x1-\/x0), y' = y0 + t*(y1-\/y0)}}
\DoxyCodeLine{4663                      \textcolor{comment}{// minimize (x'-\/sx)*(x'-\/sx)+(y'-\/sy)*(y'-\/sy)}}
\DoxyCodeLine{4664                      \textcolor{keywordtype}{float} dx = x1-\/x0, dy = y1-\/y0;}
\DoxyCodeLine{4665                      \textcolor{keywordtype}{float} px = x0-\/sx, py = y0-\/sy;}
\DoxyCodeLine{4666                      \textcolor{comment}{// minimize (px+t*dx)\string^2 + (py+t*dy)\string^2 = px*px + 2*px*dx*t + t\string^2*dx*dx + py*py + 2*py*dy*t + t\string^2*dy*dy}}
\DoxyCodeLine{4667                      \textcolor{comment}{// derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve}}
\DoxyCodeLine{4668                      \textcolor{keywordtype}{float} t = -\/(px*dx + py*dy) / (dx*dx + dy*dy);}
\DoxyCodeLine{4669                      \textcolor{keywordflow}{if} (t >= 0.0f \&\& t <= 1.0f)}
\DoxyCodeLine{4670                         min\_dist = dist;}
\DoxyCodeLine{4671                   \}}
\DoxyCodeLine{4672                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (verts[i].type == STBTT\_vcurve) \{}
\DoxyCodeLine{4673                   \textcolor{keywordtype}{float} x2 = verts[i-\/1].x *scale\_x, y2 = verts[i-\/1].y *scale\_y;}
\DoxyCodeLine{4674                   \textcolor{keywordtype}{float} x1 = verts[i  ].cx*scale\_x, y1 = verts[i  ].cy*scale\_y;}
\DoxyCodeLine{4675                   \textcolor{keywordtype}{float} box\_x0 = STBTT\_min(STBTT\_min(x0,x1),x2);}
\DoxyCodeLine{4676                   \textcolor{keywordtype}{float} box\_y0 = STBTT\_min(STBTT\_min(y0,y1),y2);}
\DoxyCodeLine{4677                   \textcolor{keywordtype}{float} box\_x1 = STBTT\_max(STBTT\_max(x0,x1),x2);}
\DoxyCodeLine{4678                   \textcolor{keywordtype}{float} box\_y1 = STBTT\_max(STBTT\_max(y0,y1),y2);}
\DoxyCodeLine{4679                   \textcolor{comment}{// coarse culling against bbox to avoid computing cubic unnecessarily}}
\DoxyCodeLine{4680                   \textcolor{keywordflow}{if} (sx > box\_x0-\/min\_dist \&\& sx < box\_x1+min\_dist \&\& sy > box\_y0-\/min\_dist \&\& sy < box\_y1+min\_dist) \{}
\DoxyCodeLine{4681                      \textcolor{keywordtype}{int} num=0;}
\DoxyCodeLine{4682                      \textcolor{keywordtype}{float} ax = x1-\/x0, ay = y1-\/y0;}
\DoxyCodeLine{4683                      \textcolor{keywordtype}{float} bx = x0 -\/ 2*x1 + x2, by = y0 -\/ 2*y1 + y2;}
\DoxyCodeLine{4684                      \textcolor{keywordtype}{float} mx = x0 -\/ sx, my = y0 -\/ sy;}
\DoxyCodeLine{4685                      \textcolor{keywordtype}{float} res[3] = \{0.f,0.f,0.f\};}
\DoxyCodeLine{4686                      \textcolor{keywordtype}{float} px,py,t,it,dist2;}
\DoxyCodeLine{4687                      \textcolor{keywordtype}{float} a\_inv = precompute[i];}
\DoxyCodeLine{4688                      \textcolor{keywordflow}{if} (a\_inv == 0.0) \{ \textcolor{comment}{// if a\_inv is 0, it's 2nd degree so use quadratic formula}}
\DoxyCodeLine{4689                         \textcolor{keywordtype}{float} a = 3*(ax*bx + ay*by);}
\DoxyCodeLine{4690                         \textcolor{keywordtype}{float} b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);}
\DoxyCodeLine{4691                         \textcolor{keywordtype}{float} c = mx*ax+my*ay;}
\DoxyCodeLine{4692                         \textcolor{keywordflow}{if} (a == 0.0) \{ \textcolor{comment}{// if a is 0, it's linear}}
\DoxyCodeLine{4693                            \textcolor{keywordflow}{if} (b != 0.0) \{}
\DoxyCodeLine{4694                               res[num++] = -\/c/b;}
\DoxyCodeLine{4695                            \}}
\DoxyCodeLine{4696                         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4697                            \textcolor{keywordtype}{float} discriminant = b*b -\/ 4*a*c;}
\DoxyCodeLine{4698                            \textcolor{keywordflow}{if} (discriminant < 0)}
\DoxyCodeLine{4699                               num = 0;}
\DoxyCodeLine{4700                            \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4701                               \textcolor{keywordtype}{float} root = (float) STBTT\_sqrt(discriminant);}
\DoxyCodeLine{4702                               res[0] = (-\/b -\/ root)/(2*a);}
\DoxyCodeLine{4703                               res[1] = (-\/b + root)/(2*a);}
\DoxyCodeLine{4704                               num = 2; \textcolor{comment}{// don't bother distinguishing 1-\/solution case, as code below will still work}}
\DoxyCodeLine{4705                            \}}
\DoxyCodeLine{4706                         \}}
\DoxyCodeLine{4707                      \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4708                         \textcolor{keywordtype}{float} b = 3*(ax*bx + ay*by) * a\_inv; \textcolor{comment}{// could precompute this as it doesn't depend on sample point}}
\DoxyCodeLine{4709                         \textcolor{keywordtype}{float} c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a\_inv;}
\DoxyCodeLine{4710                         \textcolor{keywordtype}{float} d = (mx*ax+my*ay) * a\_inv;}
\DoxyCodeLine{4711                         num = stbtt\_\_solve\_cubic(b, c, d, res);}
\DoxyCodeLine{4712                      \}}
\DoxyCodeLine{4713                      dist2 = (x0-\/sx)*(x0-\/sx) + (y0-\/sy)*(y0-\/sy);}
\DoxyCodeLine{4714                      \textcolor{keywordflow}{if} (dist2 < min\_dist*min\_dist)}
\DoxyCodeLine{4715                         min\_dist = (float) STBTT\_sqrt(dist2);}
\DoxyCodeLine{4716 }
\DoxyCodeLine{4717                      \textcolor{keywordflow}{if} (num >= 1 \&\& res[0] >= 0.0f \&\& res[0] <= 1.0f) \{}
\DoxyCodeLine{4718                         t = res[0], it = 1.0f -\/ t;}
\DoxyCodeLine{4719                         px = it*it*x0 + 2*t*it*x1 + t*t*x2;}
\DoxyCodeLine{4720                         py = it*it*y0 + 2*t*it*y1 + t*t*y2;}
\DoxyCodeLine{4721                         dist2 = (px-\/sx)*(px-\/sx) + (py-\/sy)*(py-\/sy);}
\DoxyCodeLine{4722                         \textcolor{keywordflow}{if} (dist2 < min\_dist * min\_dist)}
\DoxyCodeLine{4723                            min\_dist = (float) STBTT\_sqrt(dist2);}
\DoxyCodeLine{4724                      \}}
\DoxyCodeLine{4725                      \textcolor{keywordflow}{if} (num >= 2 \&\& res[1] >= 0.0f \&\& res[1] <= 1.0f) \{}
\DoxyCodeLine{4726                         t = res[1], it = 1.0f -\/ t;}
\DoxyCodeLine{4727                         px = it*it*x0 + 2*t*it*x1 + t*t*x2;}
\DoxyCodeLine{4728                         py = it*it*y0 + 2*t*it*y1 + t*t*y2;}
\DoxyCodeLine{4729                         dist2 = (px-\/sx)*(px-\/sx) + (py-\/sy)*(py-\/sy);}
\DoxyCodeLine{4730                         \textcolor{keywordflow}{if} (dist2 < min\_dist * min\_dist)}
\DoxyCodeLine{4731                            min\_dist = (float) STBTT\_sqrt(dist2);}
\DoxyCodeLine{4732                      \}}
\DoxyCodeLine{4733                      \textcolor{keywordflow}{if} (num >= 3 \&\& res[2] >= 0.0f \&\& res[2] <= 1.0f) \{}
\DoxyCodeLine{4734                         t = res[2], it = 1.0f -\/ t;}
\DoxyCodeLine{4735                         px = it*it*x0 + 2*t*it*x1 + t*t*x2;}
\DoxyCodeLine{4736                         py = it*it*y0 + 2*t*it*y1 + t*t*y2;}
\DoxyCodeLine{4737                         dist2 = (px-\/sx)*(px-\/sx) + (py-\/sy)*(py-\/sy);}
\DoxyCodeLine{4738                         \textcolor{keywordflow}{if} (dist2 < min\_dist * min\_dist)}
\DoxyCodeLine{4739                            min\_dist = (float) STBTT\_sqrt(dist2);}
\DoxyCodeLine{4740                      \}}
\DoxyCodeLine{4741                   \}}
\DoxyCodeLine{4742                \}}
\DoxyCodeLine{4743             \}}
\DoxyCodeLine{4744             \textcolor{keywordflow}{if} (winding == 0)}
\DoxyCodeLine{4745                min\_dist = -\/min\_dist;  \textcolor{comment}{// if outside the shape, value is negative}}
\DoxyCodeLine{4746             val = onedge\_value + pixel\_dist\_scale * min\_dist;}
\DoxyCodeLine{4747             \textcolor{keywordflow}{if} (val < 0)}
\DoxyCodeLine{4748                val = 0;}
\DoxyCodeLine{4749             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (val > 255)}
\DoxyCodeLine{4750                val = 255;}
\DoxyCodeLine{4751             data[(y-\/iy0)*w+(x-\/ix0)] = (\textcolor{keywordtype}{unsigned} char) val;}
\DoxyCodeLine{4752          \}}
\DoxyCodeLine{4753       \}}
\DoxyCodeLine{4754       STBTT\_free(precompute, info-\/>userdata);}
\DoxyCodeLine{4755       STBTT\_free(verts, info-\/>userdata);}
\DoxyCodeLine{4756    \}}
\DoxyCodeLine{4757    \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{4758 \}}
\DoxyCodeLine{4759 }
\DoxyCodeLine{4760 STBTT\_DEF \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} * stbtt\_GetCodepointSDF(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keywordtype}{float} scale, \textcolor{keywordtype}{int} codepoint, \textcolor{keywordtype}{int} padding, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} onedge\_value, \textcolor{keywordtype}{float} pixel\_dist\_scale, \textcolor{keywordtype}{int} *width, \textcolor{keywordtype}{int} *height, \textcolor{keywordtype}{int} *xoff, \textcolor{keywordtype}{int} *yoff)}
\DoxyCodeLine{4761 \{}
\DoxyCodeLine{4762    \textcolor{keywordflow}{return} stbtt\_GetGlyphSDF(info, scale, stbtt\_FindGlyphIndex(info, codepoint), padding, onedge\_value, pixel\_dist\_scale, width, height, xoff, yoff);}
\DoxyCodeLine{4763 \}}
\DoxyCodeLine{4764 }
\DoxyCodeLine{4765 STBTT\_DEF \textcolor{keywordtype}{void} stbtt\_FreeSDF(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap, \textcolor{keywordtype}{void} *userdata)}
\DoxyCodeLine{4766 \{}
\DoxyCodeLine{4767    STBTT\_free(bitmap, userdata);}
\DoxyCodeLine{4768 \}}
\DoxyCodeLine{4769 }
\DoxyCodeLine{4771 \textcolor{comment}{//}}
\DoxyCodeLine{4772 \textcolor{comment}{// font name matching -\/-\/ recommended not to use this}}
\DoxyCodeLine{4773 \textcolor{comment}{//}}
\DoxyCodeLine{4774 }
\DoxyCodeLine{4775 \textcolor{comment}{// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string}}
\DoxyCodeLine{4776 \textcolor{keyword}{static} stbtt\_int32 stbtt\_\_CompareUTF8toUTF16\_bigendian\_prefix(stbtt\_uint8 *s1, stbtt\_int32 len1, stbtt\_uint8 *s2, stbtt\_int32 len2)}
\DoxyCodeLine{4777 \{}
\DoxyCodeLine{4778    stbtt\_int32 i=0;}
\DoxyCodeLine{4779 }
\DoxyCodeLine{4780    \textcolor{comment}{// convert utf16 to utf8 and compare the results while converting}}
\DoxyCodeLine{4781    \textcolor{keywordflow}{while} (len2) \{}
\DoxyCodeLine{4782       stbtt\_uint16 ch = s2[0]*256 + s2[1];}
\DoxyCodeLine{4783       \textcolor{keywordflow}{if} (ch < 0x80) \{}
\DoxyCodeLine{4784          \textcolor{keywordflow}{if} (i >= len1) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4785          \textcolor{keywordflow}{if} (s1[i++] != ch) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4786       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch < 0x800) \{}
\DoxyCodeLine{4787          \textcolor{keywordflow}{if} (i+1 >= len1) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4788          \textcolor{keywordflow}{if} (s1[i++] != 0xc0 + (ch >> 6)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4789          \textcolor{keywordflow}{if} (s1[i++] != 0x80 + (ch \& 0x3f)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4790       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch >= 0xd800 \&\& ch < 0xdc00) \{}
\DoxyCodeLine{4791          stbtt\_uint32 c;}
\DoxyCodeLine{4792          stbtt\_uint16 ch2 = s2[2]*256 + s2[3];}
\DoxyCodeLine{4793          \textcolor{keywordflow}{if} (i+3 >= len1) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4794          c = ((ch -\/ 0xd800) << 10) + (ch2 -\/ 0xdc00) + 0x10000;}
\DoxyCodeLine{4795          \textcolor{keywordflow}{if} (s1[i++] != 0xf0 + (c >> 18)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4796          \textcolor{keywordflow}{if} (s1[i++] != 0x80 + ((c >> 12) \& 0x3f)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4797          \textcolor{keywordflow}{if} (s1[i++] != 0x80 + ((c >>  6) \& 0x3f)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4798          \textcolor{keywordflow}{if} (s1[i++] != 0x80 + ((c      ) \& 0x3f)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4799          s2 += 2; \textcolor{comment}{// plus another 2 below}}
\DoxyCodeLine{4800          len2 -\/= 2;}
\DoxyCodeLine{4801       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch >= 0xdc00 \&\& ch < 0xe000) \{}
\DoxyCodeLine{4802          \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4803       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4804          \textcolor{keywordflow}{if} (i+2 >= len1) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4805          \textcolor{keywordflow}{if} (s1[i++] != 0xe0 + (ch >> 12)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4806          \textcolor{keywordflow}{if} (s1[i++] != 0x80 + ((ch >> 6) \& 0x3f)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4807          \textcolor{keywordflow}{if} (s1[i++] != 0x80 + ((ch     ) \& 0x3f)) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{4808       \}}
\DoxyCodeLine{4809       s2 += 2;}
\DoxyCodeLine{4810       len2 -\/= 2;}
\DoxyCodeLine{4811    \}}
\DoxyCodeLine{4812    \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{4813 \}}
\DoxyCodeLine{4814 }
\DoxyCodeLine{4815 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_CompareUTF8toUTF16\_bigendian\_internal(\textcolor{keywordtype}{char} *s1, \textcolor{keywordtype}{int} len1, \textcolor{keywordtype}{char} *s2, \textcolor{keywordtype}{int} len2)}
\DoxyCodeLine{4816 \{}
\DoxyCodeLine{4817    \textcolor{keywordflow}{return} len1 == stbtt\_\_CompareUTF8toUTF16\_bigendian\_prefix((stbtt\_uint8*) s1, len1, (stbtt\_uint8*) s2, len2);}
\DoxyCodeLine{4818 \}}
\DoxyCodeLine{4819 }
\DoxyCodeLine{4820 \textcolor{comment}{// returns results in whatever encoding you request... but note that 2-\/byte encodings}}
\DoxyCodeLine{4821 \textcolor{comment}{// will be BIG-\/ENDIAN... use stbtt\_CompareUTF8toUTF16\_bigendian() to compare}}
\DoxyCodeLine{4822 STBTT\_DEF \textcolor{keyword}{const} \textcolor{keywordtype}{char} *stbtt\_GetFontNameString(\textcolor{keyword}{const} \mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *font, \textcolor{keywordtype}{int} *length, \textcolor{keywordtype}{int} platformID, \textcolor{keywordtype}{int} encodingID, \textcolor{keywordtype}{int} languageID, \textcolor{keywordtype}{int} nameID)}
\DoxyCodeLine{4823 \{}
\DoxyCodeLine{4824    stbtt\_int32 i,count,stringOffset;}
\DoxyCodeLine{4825    stbtt\_uint8 *fc = font-\/>data;}
\DoxyCodeLine{4826    stbtt\_uint32 offset = font-\/>fontstart;}
\DoxyCodeLine{4827    stbtt\_uint32 nm = stbtt\_\_find\_table(fc, offset, \textcolor{stringliteral}{"{}name"{}});}
\DoxyCodeLine{4828    \textcolor{keywordflow}{if} (!nm) \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{4829 }
\DoxyCodeLine{4830    count = ttUSHORT(fc+nm+2);}
\DoxyCodeLine{4831    stringOffset = nm + ttUSHORT(fc+nm+4);}
\DoxyCodeLine{4832    \textcolor{keywordflow}{for} (i=0; i < count; ++i) \{}
\DoxyCodeLine{4833       stbtt\_uint32 loc = nm + 6 + 12 * i;}
\DoxyCodeLine{4834       \textcolor{keywordflow}{if} (platformID == ttUSHORT(fc+loc+0) \&\& encodingID == ttUSHORT(fc+loc+2)}
\DoxyCodeLine{4835           \&\& languageID == ttUSHORT(fc+loc+4) \&\& nameID == ttUSHORT(fc+loc+6)) \{}
\DoxyCodeLine{4836          *length = ttUSHORT(fc+loc+8);}
\DoxyCodeLine{4837          \textcolor{keywordflow}{return} (\textcolor{keyword}{const} \textcolor{keywordtype}{char} *) (fc+stringOffset+ttUSHORT(fc+loc+10));}
\DoxyCodeLine{4838       \}}
\DoxyCodeLine{4839    \}}
\DoxyCodeLine{4840    \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{4841 \}}
\DoxyCodeLine{4842 }
\DoxyCodeLine{4843 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_matchpair(stbtt\_uint8 *fc, stbtt\_uint32 nm, stbtt\_uint8 *name, stbtt\_int32 nlen, stbtt\_int32 target\_id, stbtt\_int32 next\_id)}
\DoxyCodeLine{4844 \{}
\DoxyCodeLine{4845    stbtt\_int32 i;}
\DoxyCodeLine{4846    stbtt\_int32 count = ttUSHORT(fc+nm+2);}
\DoxyCodeLine{4847    stbtt\_int32 stringOffset = nm + ttUSHORT(fc+nm+4);}
\DoxyCodeLine{4848 }
\DoxyCodeLine{4849    \textcolor{keywordflow}{for} (i=0; i < count; ++i) \{}
\DoxyCodeLine{4850       stbtt\_uint32 loc = nm + 6 + 12 * i;}
\DoxyCodeLine{4851       stbtt\_int32 \textcolor{keywordtype}{id} = ttUSHORT(fc+loc+6);}
\DoxyCodeLine{4852       \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} == target\_id) \{}
\DoxyCodeLine{4853          \textcolor{comment}{// find the encoding}}
\DoxyCodeLine{4854          stbtt\_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);}
\DoxyCodeLine{4855 }
\DoxyCodeLine{4856          \textcolor{comment}{// is this a Unicode encoding?}}
\DoxyCodeLine{4857          \textcolor{keywordflow}{if} (platform == 0 || (platform == 3 \&\& encoding == 1) || (platform == 3 \&\& encoding == 10)) \{}
\DoxyCodeLine{4858             stbtt\_int32 slen = ttUSHORT(fc+loc+8);}
\DoxyCodeLine{4859             stbtt\_int32 off = ttUSHORT(fc+loc+10);}
\DoxyCodeLine{4860 }
\DoxyCodeLine{4861             \textcolor{comment}{// check if there's a prefix match}}
\DoxyCodeLine{4862             stbtt\_int32 matchlen = stbtt\_\_CompareUTF8toUTF16\_bigendian\_prefix(name, nlen, fc+stringOffset+off,slen);}
\DoxyCodeLine{4863             \textcolor{keywordflow}{if} (matchlen >= 0) \{}
\DoxyCodeLine{4864                \textcolor{comment}{// check for target\_id+1 immediately following, with same encoding \& language}}
\DoxyCodeLine{4865                \textcolor{keywordflow}{if} (i+1 < count \&\& ttUSHORT(fc+loc+12+6) == next\_id \&\& ttUSHORT(fc+loc+12) == platform \&\& ttUSHORT(fc+loc+12+2) == encoding \&\& ttUSHORT(fc+loc+12+4) == language) \{}
\DoxyCodeLine{4866                   slen = ttUSHORT(fc+loc+12+8);}
\DoxyCodeLine{4867                   off = ttUSHORT(fc+loc+12+10);}
\DoxyCodeLine{4868                   \textcolor{keywordflow}{if} (slen == 0) \{}
\DoxyCodeLine{4869                      \textcolor{keywordflow}{if} (matchlen == nlen)}
\DoxyCodeLine{4870                         \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4871                   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (matchlen < nlen \&\& name[matchlen] == \textcolor{charliteral}{' '}) \{}
\DoxyCodeLine{4872                      ++matchlen;}
\DoxyCodeLine{4873                      \textcolor{keywordflow}{if} (stbtt\_CompareUTF8toUTF16\_bigendian\_internal((\textcolor{keywordtype}{char}*) (name+matchlen), nlen-\/matchlen, (\textcolor{keywordtype}{char}*)(fc+stringOffset+off),slen))}
\DoxyCodeLine{4874                         \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4875                   \}}
\DoxyCodeLine{4876                \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4877                   \textcolor{comment}{// if nothing immediately following}}
\DoxyCodeLine{4878                   \textcolor{keywordflow}{if} (matchlen == nlen)}
\DoxyCodeLine{4879                      \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4880                \}}
\DoxyCodeLine{4881             \}}
\DoxyCodeLine{4882          \}}
\DoxyCodeLine{4883 }
\DoxyCodeLine{4884          \textcolor{comment}{// @TODO handle other encodings}}
\DoxyCodeLine{4885       \}}
\DoxyCodeLine{4886    \}}
\DoxyCodeLine{4887    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4888 \}}
\DoxyCodeLine{4889 }
\DoxyCodeLine{4890 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_\_matches(stbtt\_uint8 *fc, stbtt\_uint32 offset, stbtt\_uint8 *name, stbtt\_int32 flags)}
\DoxyCodeLine{4891 \{}
\DoxyCodeLine{4892    stbtt\_int32 nlen = (stbtt\_int32) STBTT\_strlen((\textcolor{keywordtype}{char} *) name);}
\DoxyCodeLine{4893    stbtt\_uint32 nm,hd;}
\DoxyCodeLine{4894    \textcolor{keywordflow}{if} (!stbtt\_\_isfont(fc+offset)) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4895 }
\DoxyCodeLine{4896    \textcolor{comment}{// check italics/bold/underline flags in macStyle...}}
\DoxyCodeLine{4897    \textcolor{keywordflow}{if} (flags) \{}
\DoxyCodeLine{4898       hd = stbtt\_\_find\_table(fc, offset, \textcolor{stringliteral}{"{}head"{}});}
\DoxyCodeLine{4899       \textcolor{keywordflow}{if} ((ttUSHORT(fc+hd+44) \& 7) != (flags \& 7)) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4900    \}}
\DoxyCodeLine{4901 }
\DoxyCodeLine{4902    nm = stbtt\_\_find\_table(fc, offset, \textcolor{stringliteral}{"{}name"{}});}
\DoxyCodeLine{4903    \textcolor{keywordflow}{if} (!nm) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4904 }
\DoxyCodeLine{4905    \textcolor{keywordflow}{if} (flags) \{}
\DoxyCodeLine{4906       \textcolor{comment}{// if we checked the macStyle flags, then just check the family and ignore the subfamily}}
\DoxyCodeLine{4907       \textcolor{keywordflow}{if} (stbtt\_\_matchpair(fc, nm, name, nlen, 16, -\/1))  \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4908       \textcolor{keywordflow}{if} (stbtt\_\_matchpair(fc, nm, name, nlen,  1, -\/1))  \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4909       \textcolor{keywordflow}{if} (stbtt\_\_matchpair(fc, nm, name, nlen,  3, -\/1))  \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4910    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4911       \textcolor{keywordflow}{if} (stbtt\_\_matchpair(fc, nm, name, nlen, 16, 17))  \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4912       \textcolor{keywordflow}{if} (stbtt\_\_matchpair(fc, nm, name, nlen,  1,  2))  \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4913       \textcolor{keywordflow}{if} (stbtt\_\_matchpair(fc, nm, name, nlen,  3, -\/1))  \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{4914    \}}
\DoxyCodeLine{4915 }
\DoxyCodeLine{4916    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4917 \}}
\DoxyCodeLine{4918 }
\DoxyCodeLine{4919 \textcolor{keyword}{static} \textcolor{keywordtype}{int} stbtt\_FindMatchingFont\_internal(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *font\_collection, \textcolor{keywordtype}{char} *name\_utf8, stbtt\_int32 flags)}
\DoxyCodeLine{4920 \{}
\DoxyCodeLine{4921    stbtt\_int32 i;}
\DoxyCodeLine{4922    \textcolor{keywordflow}{for} (i=0;;++i) \{}
\DoxyCodeLine{4923       stbtt\_int32 off = stbtt\_GetFontOffsetForIndex(font\_collection, i);}
\DoxyCodeLine{4924       \textcolor{keywordflow}{if} (off < 0) \textcolor{keywordflow}{return} off;}
\DoxyCodeLine{4925       \textcolor{keywordflow}{if} (stbtt\_\_matches((stbtt\_uint8 *) font\_collection, off, (stbtt\_uint8*) name\_utf8, flags))}
\DoxyCodeLine{4926          \textcolor{keywordflow}{return} off;}
\DoxyCodeLine{4927    \}}
\DoxyCodeLine{4928 \}}
\DoxyCodeLine{4929 }
\DoxyCodeLine{4930 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{4931 \textcolor{preprocessor}{\#pragma GCC diagnostic push}}
\DoxyCodeLine{4932 \textcolor{preprocessor}{\#pragma GCC diagnostic ignored "{}-\/Wcast-\/qual"{}}}
\DoxyCodeLine{4933 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4934 }
\DoxyCodeLine{4935 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_BakeFontBitmap(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} offset,}
\DoxyCodeLine{4936                                 \textcolor{keywordtype}{float} pixel\_height, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pixels, \textcolor{keywordtype}{int} pw, \textcolor{keywordtype}{int} ph,}
\DoxyCodeLine{4937                                 \textcolor{keywordtype}{int} first\_char, \textcolor{keywordtype}{int} num\_chars, \mbox{\hyperlink{structstbtt__bakedchar}{stbtt\_bakedchar}} *chardata)}
\DoxyCodeLine{4938 \{}
\DoxyCodeLine{4939    \textcolor{keywordflow}{return} stbtt\_BakeFontBitmap\_internal((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) data, offset, pixel\_height, pixels, pw, ph, first\_char, num\_chars, chardata);}
\DoxyCodeLine{4940 \}}
\DoxyCodeLine{4941 }
\DoxyCodeLine{4942 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetFontOffsetForIndex(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} index)}
\DoxyCodeLine{4943 \{}
\DoxyCodeLine{4944    \textcolor{keywordflow}{return} stbtt\_GetFontOffsetForIndex\_internal((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) data, index);}
\DoxyCodeLine{4945 \}}
\DoxyCodeLine{4946 }
\DoxyCodeLine{4947 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_GetNumberOfFonts(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data)}
\DoxyCodeLine{4948 \{}
\DoxyCodeLine{4949    \textcolor{keywordflow}{return} stbtt\_GetNumberOfFonts\_internal((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) data);}
\DoxyCodeLine{4950 \}}
\DoxyCodeLine{4951 }
\DoxyCodeLine{4952 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_InitFont(\mbox{\hyperlink{structstbtt__fontinfo}{stbtt\_fontinfo}} *info, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{int} offset)}
\DoxyCodeLine{4953 \{}
\DoxyCodeLine{4954    \textcolor{keywordflow}{return} stbtt\_InitFont\_internal(info, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) data, offset);}
\DoxyCodeLine{4955 \}}
\DoxyCodeLine{4956 }
\DoxyCodeLine{4957 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_FindMatchingFont(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fontdata, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *name, \textcolor{keywordtype}{int} flags)}
\DoxyCodeLine{4958 \{}
\DoxyCodeLine{4959    \textcolor{keywordflow}{return} stbtt\_FindMatchingFont\_internal((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) fontdata, (\textcolor{keywordtype}{char} *) name, flags);}
\DoxyCodeLine{4960 \}}
\DoxyCodeLine{4961 }
\DoxyCodeLine{4962 STBTT\_DEF \textcolor{keywordtype}{int} stbtt\_CompareUTF8toUTF16\_bigendian(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s1, \textcolor{keywordtype}{int} len1, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s2, \textcolor{keywordtype}{int} len2)}
\DoxyCodeLine{4963 \{}
\DoxyCodeLine{4964    \textcolor{keywordflow}{return} stbtt\_CompareUTF8toUTF16\_bigendian\_internal((\textcolor{keywordtype}{char} *) s1, len1, (\textcolor{keywordtype}{char} *) s2, len2);}
\DoxyCodeLine{4965 \}}
\DoxyCodeLine{4966 }
\DoxyCodeLine{4967 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{4968 \textcolor{preprocessor}{\#pragma GCC diagnostic pop}}
\DoxyCodeLine{4969 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4970 }
\DoxyCodeLine{4971 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// STB\_TRUETYPE\_IMPLEMENTATION}}
\DoxyCodeLine{4972 }
\DoxyCodeLine{4973 }
\DoxyCodeLine{4974 \textcolor{comment}{// FULL VERSION HISTORY}}
\DoxyCodeLine{4975 \textcolor{comment}{//}}
\DoxyCodeLine{4976 \textcolor{comment}{//   1.25 (2021-\/07-\/11) many fixes}}
\DoxyCodeLine{4977 \textcolor{comment}{//   1.24 (2020-\/02-\/05) fix warning}}
\DoxyCodeLine{4978 \textcolor{comment}{//   1.23 (2020-\/02-\/02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)}}
\DoxyCodeLine{4979 \textcolor{comment}{//   1.22 (2019-\/08-\/11) minimize missing-\/glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined}}
\DoxyCodeLine{4980 \textcolor{comment}{//   1.21 (2019-\/02-\/25) fix warning}}
\DoxyCodeLine{4981 \textcolor{comment}{//   1.20 (2019-\/02-\/07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()}}
\DoxyCodeLine{4982 \textcolor{comment}{//   1.19 (2018-\/02-\/11) OpenType GPOS kerning (horizontal only), STBTT\_fmod}}
\DoxyCodeLine{4983 \textcolor{comment}{//   1.18 (2018-\/01-\/29) add missing function}}
\DoxyCodeLine{4984 \textcolor{comment}{//   1.17 (2017-\/07-\/23) make more arguments const; doc fix}}
\DoxyCodeLine{4985 \textcolor{comment}{//   1.16 (2017-\/07-\/12) SDF support}}
\DoxyCodeLine{4986 \textcolor{comment}{//   1.15 (2017-\/03-\/03) make more arguments const}}
\DoxyCodeLine{4987 \textcolor{comment}{//   1.14 (2017-\/01-\/16) num-\/fonts-\/in-\/TTC function}}
\DoxyCodeLine{4988 \textcolor{comment}{//   1.13 (2017-\/01-\/02) support OpenType fonts, certain Apple fonts}}
\DoxyCodeLine{4989 \textcolor{comment}{//   1.12 (2016-\/10-\/25) suppress warnings about casting away const with -\/Wcast-\/qual}}
\DoxyCodeLine{4990 \textcolor{comment}{//   1.11 (2016-\/04-\/02) fix unused-\/variable warning}}
\DoxyCodeLine{4991 \textcolor{comment}{//   1.10 (2016-\/04-\/02) allow user-\/defined fabs() replacement}}
\DoxyCodeLine{4992 \textcolor{comment}{//                     fix memory leak if fontsize=0.0}}
\DoxyCodeLine{4993 \textcolor{comment}{//                     fix warning from duplicate typedef}}
\DoxyCodeLine{4994 \textcolor{comment}{//   1.09 (2016-\/01-\/16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges}}
\DoxyCodeLine{4995 \textcolor{comment}{//   1.08 (2015-\/09-\/13) document stbtt\_Rasterize(); fixes for vertical \& horizontal edges}}
\DoxyCodeLine{4996 \textcolor{comment}{//   1.07 (2015-\/08-\/01) allow PackFontRanges to accept arrays of sparse codepoints;}}
\DoxyCodeLine{4997 \textcolor{comment}{//                     allow PackFontRanges to pack and render in separate phases;}}
\DoxyCodeLine{4998 \textcolor{comment}{//                     fix stbtt\_GetFontOFfsetForIndex (never worked for non-\/0 input?);}}
\DoxyCodeLine{4999 \textcolor{comment}{//                     fixed an assert() bug in the new rasterizer}}
\DoxyCodeLine{5000 \textcolor{comment}{//                     replace assert() with STBTT\_assert() in new rasterizer}}
\DoxyCodeLine{5001 \textcolor{comment}{//   1.06 (2015-\/07-\/14) performance improvements (\string~35\% faster on x86 and x64 on test machine)}}
\DoxyCodeLine{5002 \textcolor{comment}{//                     also more precise AA rasterizer, except if shapes overlap}}
\DoxyCodeLine{5003 \textcolor{comment}{//                     remove need for STBTT\_sort}}
\DoxyCodeLine{5004 \textcolor{comment}{//   1.05 (2015-\/04-\/15) fix misplaced definitions for STBTT\_STATIC}}
\DoxyCodeLine{5005 \textcolor{comment}{//   1.04 (2015-\/04-\/15) typo in example}}
\DoxyCodeLine{5006 \textcolor{comment}{//   1.03 (2015-\/04-\/12) STBTT\_STATIC, fix memory leak in new packing, various fixes}}
\DoxyCodeLine{5007 \textcolor{comment}{//   1.02 (2014-\/12-\/10) fix various warnings \& compile issues w/ stb\_rect\_pack, C++}}
\DoxyCodeLine{5008 \textcolor{comment}{//   1.01 (2014-\/12-\/08) fix subpixel position when oversampling to exactly match}}
\DoxyCodeLine{5009 \textcolor{comment}{//                        non-\/oversampled; STBTT\_POINT\_SIZE for packed case only}}
\DoxyCodeLine{5010 \textcolor{comment}{//   1.00 (2014-\/12-\/06) add new PackBegin etc. API, w/ support for oversampling}}
\DoxyCodeLine{5011 \textcolor{comment}{//   0.99 (2014-\/09-\/18) fix multiple bugs with subpixel rendering (ryg)}}
\DoxyCodeLine{5012 \textcolor{comment}{//   0.9  (2014-\/08-\/07) support certain mac/iOS fonts without an MS platformID}}
\DoxyCodeLine{5013 \textcolor{comment}{//   0.8b (2014-\/07-\/07) fix a warning}}
\DoxyCodeLine{5014 \textcolor{comment}{//   0.8  (2014-\/05-\/25) fix a few more warnings}}
\DoxyCodeLine{5015 \textcolor{comment}{//   0.7  (2013-\/09-\/25) bugfix: subpixel glyph bug fixed in 0.5 had come back}}
\DoxyCodeLine{5016 \textcolor{comment}{//   0.6c (2012-\/07-\/24) improve documentation}}
\DoxyCodeLine{5017 \textcolor{comment}{//   0.6b (2012-\/07-\/20) fix a few more warnings}}
\DoxyCodeLine{5018 \textcolor{comment}{//   0.6  (2012-\/07-\/17) fix warnings; added stbtt\_ScaleForMappingEmToPixels,}}
\DoxyCodeLine{5019 \textcolor{comment}{//                        stbtt\_GetFontBoundingBox, stbtt\_IsGlyphEmpty}}
\DoxyCodeLine{5020 \textcolor{comment}{//   0.5  (2011-\/12-\/09) bugfixes:}}
\DoxyCodeLine{5021 \textcolor{comment}{//                        subpixel glyph renderer computed wrong bounding box}}
\DoxyCodeLine{5022 \textcolor{comment}{//                        first vertex of shape can be off-\/curve (FreeSans)}}
\DoxyCodeLine{5023 \textcolor{comment}{//   0.4b (2011-\/12-\/03) fixed an error in the font baking example}}
\DoxyCodeLine{5024 \textcolor{comment}{//   0.4  (2011-\/12-\/01) kerning, subpixel rendering (tor)}}
\DoxyCodeLine{5025 \textcolor{comment}{//                    bugfixes for:}}
\DoxyCodeLine{5026 \textcolor{comment}{//                        codepoint-\/to-\/glyph conversion using table fmt=12}}
\DoxyCodeLine{5027 \textcolor{comment}{//                        codepoint-\/to-\/glyph conversion using table fmt=4}}
\DoxyCodeLine{5028 \textcolor{comment}{//                        stbtt\_GetBakedQuad with non-\/square texture (Zer)}}
\DoxyCodeLine{5029 \textcolor{comment}{//                    updated Hello World! sample to use kerning and subpixel}}
\DoxyCodeLine{5030 \textcolor{comment}{//                    fixed some warnings}}
\DoxyCodeLine{5031 \textcolor{comment}{//   0.3  (2009-\/06-\/24) cmap fmt=12, compound shapes (MM)}}
\DoxyCodeLine{5032 \textcolor{comment}{//                    userdata, malloc-\/from-\/userdata, non-\/zero fill (stb)}}
\DoxyCodeLine{5033 \textcolor{comment}{//   0.2  (2009-\/03-\/11) Fix unsigned/signed char warnings}}
\DoxyCodeLine{5034 \textcolor{comment}{//   0.1  (2009-\/03-\/09) First public release}}
\DoxyCodeLine{5035 \textcolor{comment}{//}}
\DoxyCodeLine{5036 }
\DoxyCodeLine{5037 \textcolor{comment}{/*}}
\DoxyCodeLine{5038 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5039 \textcolor{comment}{This software is available under 2 licenses -\/-\/ choose whichever you prefer.}}
\DoxyCodeLine{5040 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5041 \textcolor{comment}{ALTERNATIVE A -\/ MIT License}}
\DoxyCodeLine{5042 \textcolor{comment}{Copyright (c) 2017 Sean Barrett}}
\DoxyCodeLine{5043 \textcolor{comment}{Permission is hereby granted, free of charge, to any person obtaining a copy of}}
\DoxyCodeLine{5044 \textcolor{comment}{this software and associated documentation files (the "{}Software"{}), to deal in}}
\DoxyCodeLine{5045 \textcolor{comment}{the Software without restriction, including without limitation the rights to}}
\DoxyCodeLine{5046 \textcolor{comment}{use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies}}
\DoxyCodeLine{5047 \textcolor{comment}{of the Software, and to permit persons to whom the Software is furnished to do}}
\DoxyCodeLine{5048 \textcolor{comment}{so, subject to the following conditions:}}
\DoxyCodeLine{5049 \textcolor{comment}{The above copyright notice and this permission notice shall be included in all}}
\DoxyCodeLine{5050 \textcolor{comment}{copies or substantial portions of the Software.}}
\DoxyCodeLine{5051 \textcolor{comment}{THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{5052 \textcolor{comment}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}}
\DoxyCodeLine{5053 \textcolor{comment}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}}
\DoxyCodeLine{5054 \textcolor{comment}{AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}}
\DoxyCodeLine{5055 \textcolor{comment}{LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,}}
\DoxyCodeLine{5056 \textcolor{comment}{OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE}}
\DoxyCodeLine{5057 \textcolor{comment}{SOFTWARE.}}
\DoxyCodeLine{5058 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5059 \textcolor{comment}{ALTERNATIVE B -\/ Public Domain (www.unlicense.org)}}
\DoxyCodeLine{5060 \textcolor{comment}{This is free and unencumbered software released into the public domain.}}
\DoxyCodeLine{5061 \textcolor{comment}{Anyone is free to copy, modify, publish, use, compile, sell, or distribute this}}
\DoxyCodeLine{5062 \textcolor{comment}{software, either in source code form or as a compiled binary, for any purpose,}}
\DoxyCodeLine{5063 \textcolor{comment}{commercial or non-\/commercial, and by any means.}}
\DoxyCodeLine{5064 \textcolor{comment}{In jurisdictions that recognize copyright laws, the author or authors of this}}
\DoxyCodeLine{5065 \textcolor{comment}{software dedicate any and all copyright interest in the software to the public}}
\DoxyCodeLine{5066 \textcolor{comment}{domain. We make this dedication for the benefit of the public at large and to}}
\DoxyCodeLine{5067 \textcolor{comment}{the detriment of our heirs and successors. We intend this dedication to be an}}
\DoxyCodeLine{5068 \textcolor{comment}{overt act of relinquishment in perpetuity of all present and future rights to}}
\DoxyCodeLine{5069 \textcolor{comment}{this software under copyright law.}}
\DoxyCodeLine{5070 \textcolor{comment}{THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{5071 \textcolor{comment}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}}
\DoxyCodeLine{5072 \textcolor{comment}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}}
\DoxyCodeLine{5073 \textcolor{comment}{AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN}}
\DoxyCodeLine{5074 \textcolor{comment}{ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION}}
\DoxyCodeLine{5075 \textcolor{comment}{WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{5076 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5077 \textcolor{comment}{*/}}

\end{DoxyCode}
