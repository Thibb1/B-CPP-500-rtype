\hypertarget{msf__gif_8h_source}{}\doxysection{msf\+\_\+gif.\+h}
\label{msf__gif_8h_source}\index{build/\_deps/raylib-\/src/src/external/msf\_gif.h@{build/\_deps/raylib-\/src/src/external/msf\_gif.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{HOW TO USE:}}
\DoxyCodeLine{3 \textcolor{comment}{}}
\DoxyCodeLine{4 \textcolor{comment}{    In exactly one translation unit (.c or .cpp file), \#define MSF\_GIF\_IMPL before including the header, like so:}}
\DoxyCodeLine{5 \textcolor{comment}{}}
\DoxyCodeLine{6 \textcolor{comment}{    \#define MSF\_GIF\_IMPL}}
\DoxyCodeLine{7 \textcolor{comment}{    \#include "{}msf\_gif.h"{}}}
\DoxyCodeLine{8 \textcolor{comment}{}}
\DoxyCodeLine{9 \textcolor{comment}{    Everywhere else, just include the header like normal.}}
\DoxyCodeLine{10 \textcolor{comment}{}}
\DoxyCodeLine{11 \textcolor{comment}{}}
\DoxyCodeLine{12 \textcolor{comment}{USAGE EXAMPLE:}}
\DoxyCodeLine{13 \textcolor{comment}{}}
\DoxyCodeLine{14 \textcolor{comment}{    int width = 480, height = 320, centisecondsPerFrame = 5, bitDepth = 16;}}
\DoxyCodeLine{15 \textcolor{comment}{    MsfGifState gifState = \{\};}}
\DoxyCodeLine{16 \textcolor{comment}{    // msf\_gif\_bgra\_flag = true; //optionally, set this flag if your pixels are in BGRA format instead of RGBA}}
\DoxyCodeLine{17 \textcolor{comment}{    // msf\_gif\_alpha\_threshold = 128; //optionally, enable transparency (see function documentation below for details)}}
\DoxyCodeLine{18 \textcolor{comment}{    msf\_gif\_begin(\&gifState, width, height);}}
\DoxyCodeLine{19 \textcolor{comment}{    msf\_gif\_frame(\&gifState, ..., centisecondsPerFrame, bitDepth, width * 4); //frame 1}}
\DoxyCodeLine{20 \textcolor{comment}{    msf\_gif\_frame(\&gifState, ..., centisecondsPerFrame, bitDepth, width * 4); //frame 2}}
\DoxyCodeLine{21 \textcolor{comment}{    msf\_gif\_frame(\&gifState, ..., centisecondsPerFrame, bitDepth, width * 4); //frame 3, etc...}}
\DoxyCodeLine{22 \textcolor{comment}{    MsfGifResult result = msf\_gif\_end(\&gifState);}}
\DoxyCodeLine{23 \textcolor{comment}{    if (result.data) \{}}
\DoxyCodeLine{24 \textcolor{comment}{        FILE * fp = fopen("{}MyGif.gif"{}, "{}wb"{});}}
\DoxyCodeLine{25 \textcolor{comment}{        fwrite(result.data, result.dataSize, 1, fp);}}
\DoxyCodeLine{26 \textcolor{comment}{        fclose(fp);}}
\DoxyCodeLine{27 \textcolor{comment}{    \}}}
\DoxyCodeLine{28 \textcolor{comment}{    msf\_gif\_free(result);}}
\DoxyCodeLine{29 \textcolor{comment}{}}
\DoxyCodeLine{30 \textcolor{comment}{Detailed function documentation can be found in the header section below.}}
\DoxyCodeLine{31 \textcolor{comment}{}}
\DoxyCodeLine{32 \textcolor{comment}{}}
\DoxyCodeLine{33 \textcolor{comment}{ERROR HANDLING:}}
\DoxyCodeLine{34 \textcolor{comment}{}}
\DoxyCodeLine{35 \textcolor{comment}{    If memory allocation fails, the functions will signal the error via their return values.}}
\DoxyCodeLine{36 \textcolor{comment}{    If one function call fails, the library will free all of its allocations,}}
\DoxyCodeLine{37 \textcolor{comment}{    and all subsequent calls will safely no-\/op and return 0 until the next call to `msf\_gif\_begin()`.}}
\DoxyCodeLine{38 \textcolor{comment}{    Therefore, it's safe to check only the return value of `msf\_gif\_end()`.}}
\DoxyCodeLine{39 \textcolor{comment}{}}
\DoxyCodeLine{40 \textcolor{comment}{}}
\DoxyCodeLine{41 \textcolor{comment}{REPLACING MALLOC:}}
\DoxyCodeLine{42 \textcolor{comment}{}}
\DoxyCodeLine{43 \textcolor{comment}{    This library uses malloc+realloc+free internally for memory allocation.}}
\DoxyCodeLine{44 \textcolor{comment}{    To facilitate integration with custom memory allocators, these calls go through macros, which can be redefined.}}
\DoxyCodeLine{45 \textcolor{comment}{    The expected function signature equivalents of the macros are as follows:}}
\DoxyCodeLine{46 \textcolor{comment}{}}
\DoxyCodeLine{47 \textcolor{comment}{    void * MSF\_GIF\_MALLOC(void * context, size\_t newSize)}}
\DoxyCodeLine{48 \textcolor{comment}{    void * MSF\_GIF\_REALLOC(void * context, void * oldMemory, size\_t oldSize, size\_t newSize)}}
\DoxyCodeLine{49 \textcolor{comment}{    void MSF\_GIF\_FREE(void * context, void * oldMemory, size\_t oldSize)}}
\DoxyCodeLine{50 \textcolor{comment}{}}
\DoxyCodeLine{51 \textcolor{comment}{    If your allocator needs a context pointer, you can set the `customAllocatorContext` field of the MsfGifState struct}}
\DoxyCodeLine{52 \textcolor{comment}{    before calling msf\_gif\_begin(), and it will be passed to all subsequent allocator macro calls.}}
\DoxyCodeLine{53 \textcolor{comment}{}}
\DoxyCodeLine{54 \textcolor{comment}{    The maximum number of bytes the library will allocate to encode a single gif is bounded by the following formula:}}
\DoxyCodeLine{55 \textcolor{comment}{    `(2 * 1024 * 1024) + (width * height * 8) + ((1024 + width * height * 1.5) * 3 * frameCount)`}}
\DoxyCodeLine{56 \textcolor{comment}{    The peak heap memory usage in bytes, if using a general-\/purpose heap allocator, is bounded by the following formula:}}
\DoxyCodeLine{57 \textcolor{comment}{    `(2 * 1024 * 1024) + (width * height * 9.5) + 1024 + (16 * frameCount) + (2 * sizeOfResultingGif)}}
\DoxyCodeLine{58 \textcolor{comment}{}}
\DoxyCodeLine{59 \textcolor{comment}{}}
\DoxyCodeLine{60 \textcolor{comment}{See end of file for license information.}}
\DoxyCodeLine{61 \textcolor{comment}{*/}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63 \textcolor{comment}{//version 2.2}}
\DoxyCodeLine{64 }
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{preprocessor}{\#ifndef MSF\_GIF\_H}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\#define MSF\_GIF\_H}}
\DoxyCodeLine{71 }
\DoxyCodeLine{72 \textcolor{preprocessor}{\#include <stdint.h>}}
\DoxyCodeLine{73 \textcolor{preprocessor}{\#include <stddef.h>}}
\DoxyCodeLine{74 }
\DoxyCodeLine{75 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{}
\DoxyCodeLine{76     \textcolor{keywordtype}{void} * data;}
\DoxyCodeLine{77     \textcolor{keywordtype}{size\_t} dataSize;}
\DoxyCodeLine{78 }
\DoxyCodeLine{79     \textcolor{keywordtype}{size\_t} allocSize; \textcolor{comment}{//internal use}}
\DoxyCodeLine{80     \textcolor{keywordtype}{void} * contextPointer; \textcolor{comment}{//internal use}}
\DoxyCodeLine{81 \} \mbox{\hyperlink{structMsfGifResult}{MsfGifResult}};}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{ \textcolor{comment}{//internal use}}
\DoxyCodeLine{84     uint32\_t * pixels;}
\DoxyCodeLine{85     \textcolor{keywordtype}{int} depth, count, rbits, gbits, bbits;}
\DoxyCodeLine{86 \} \mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}};}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} \{}
\DoxyCodeLine{89     \textcolor{keyword}{struct }\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * next;}
\DoxyCodeLine{90     \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{91     uint8\_t data[1];}
\DoxyCodeLine{92 \} \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}};}
\DoxyCodeLine{93 }
\DoxyCodeLine{94 \textcolor{keyword}{typedef} size\_t (* MsfGifFileWriteFunc) (\textcolor{keyword}{const} \textcolor{keywordtype}{void} * buffer, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} count, \textcolor{keywordtype}{void} * stream);}
\DoxyCodeLine{95 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{}
\DoxyCodeLine{96     MsfGifFileWriteFunc fileWriteFunc;}
\DoxyCodeLine{97     \textcolor{keywordtype}{void} * fileWriteData;}
\DoxyCodeLine{98     \mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}} previousFrame;}
\DoxyCodeLine{99     \mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}} currentFrame;}
\DoxyCodeLine{100     int16\_t * lzwMem;}
\DoxyCodeLine{101     \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * listHead;}
\DoxyCodeLine{102     \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * listTail;}
\DoxyCodeLine{103     \textcolor{keywordtype}{int} width, height;}
\DoxyCodeLine{104     \textcolor{keywordtype}{void} * customAllocatorContext;}
\DoxyCodeLine{105     \textcolor{keywordtype}{int} framesSubmitted; \textcolor{comment}{//needed for transparency to work correctly (because we reach into the previous frame)}}
\DoxyCodeLine{106 \} \mbox{\hyperlink{structMsfGifState}{MsfGifState}};}
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{109 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{110 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_\_cplusplus}}
\DoxyCodeLine{111 }
\DoxyCodeLine{117 \textcolor{keywordtype}{int} msf\_gif\_begin(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, \textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height);}
\DoxyCodeLine{118 }
\DoxyCodeLine{136 \textcolor{keywordtype}{int} msf\_gif\_frame(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, uint8\_t * pixelData, \textcolor{keywordtype}{int} centiSecondsPerFame, \textcolor{keywordtype}{int} maxBitDepth, \textcolor{keywordtype}{int} pitchInBytes);}
\DoxyCodeLine{137 }
\DoxyCodeLine{142 \mbox{\hyperlink{structMsfGifResult}{MsfGifResult}} msf\_gif\_end(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle);}
\DoxyCodeLine{143 }
\DoxyCodeLine{147 \textcolor{keywordtype}{void} msf\_gif\_free(\mbox{\hyperlink{structMsfGifResult}{MsfGifResult}} result);}
\DoxyCodeLine{148 }
\DoxyCodeLine{149 \textcolor{comment}{//The gif format only supports 1-\/bit transparency, meaning a pixel will either be fully transparent or fully opaque.}}
\DoxyCodeLine{150 \textcolor{comment}{//Pixels with an alpha value less than the alpha threshold will be treated as transparent.}}
\DoxyCodeLine{151 \textcolor{comment}{//To enable exporting transparent gifs, set it to a value between 1 and 255 (inclusive) before calling msf\_gif\_frame().}}
\DoxyCodeLine{152 \textcolor{comment}{//Setting it to 0 causes the alpha channel to be ignored. Its initial value is 0.}}
\DoxyCodeLine{153 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} msf\_gif\_alpha\_threshold;}
\DoxyCodeLine{154 }
\DoxyCodeLine{155 \textcolor{comment}{//Set `msf\_gif\_bgra\_flag = true` before calling `msf\_gif\_frame()` if your pixels are in BGRA byte order instead of RBGA.}}
\DoxyCodeLine{156 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} msf\_gif\_bgra\_flag;}
\DoxyCodeLine{157 }
\DoxyCodeLine{158 }
\DoxyCodeLine{159 }
\DoxyCodeLine{160 \textcolor{comment}{//TO-\/FILE FUNCTIONS}}
\DoxyCodeLine{161 \textcolor{comment}{//These functions are equivalent to the ones above, but they write results to a file incrementally,}}
\DoxyCodeLine{162 \textcolor{comment}{//instead of building a buffer in memory. This can result in lower memory usage when saving large gifs,}}
\DoxyCodeLine{163 \textcolor{comment}{//because memory usage is bounded by only the size of a single frame, and is not dependent on the number of frames.}}
\DoxyCodeLine{164 \textcolor{comment}{//There is currently no reason to use these unless you are on a memory-\/constrained platform.}}
\DoxyCodeLine{165 \textcolor{comment}{//If in doubt about which API to use, for now you should use the normal (non-\/file) functions above.}}
\DoxyCodeLine{166 \textcolor{comment}{//The signature of MsfGifFileWriteFunc matches fwrite for convenience, so that you can use the C file API like so:}}
\DoxyCodeLine{167 \textcolor{comment}{//  FILE * fp = fopen("{}MyGif.gif"{}, "{}wb"{});}}
\DoxyCodeLine{168 \textcolor{comment}{//  msf\_gif\_begin\_to\_file(\&handle, width, height, (MsfGifFileWriteFunc) fwrite, (void *) fp);}}
\DoxyCodeLine{169 \textcolor{comment}{//  msf\_gif\_frame\_to\_file(...)}}
\DoxyCodeLine{170 \textcolor{comment}{//  msf\_gif\_end\_to\_file(\&handle);}}
\DoxyCodeLine{171 \textcolor{comment}{//  fclose(fp);}}
\DoxyCodeLine{172 \textcolor{comment}{//If you use a custom file write function, you must take care to return the same values that fwrite() would return.}}
\DoxyCodeLine{173 \textcolor{comment}{//Note that all three functions will potentially write to the file.}}
\DoxyCodeLine{174 \textcolor{keywordtype}{int} msf\_gif\_begin\_to\_file(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, \textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height, MsfGifFileWriteFunc func, \textcolor{keywordtype}{void} * filePointer);}
\DoxyCodeLine{175 \textcolor{keywordtype}{int} msf\_gif\_frame\_to\_file(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, uint8\_t * pixelData, \textcolor{keywordtype}{int} centiSecondsPerFame, \textcolor{keywordtype}{int} maxBitDepth, \textcolor{keywordtype}{int} pitchInBytes);}
\DoxyCodeLine{176 \textcolor{keywordtype}{int} msf\_gif\_end\_to\_file(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle); \textcolor{comment}{//returns 0 on error and non-\/zero on success}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{179 \}}
\DoxyCodeLine{180 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//\_\_cplusplus}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//MSF\_GIF\_H}}
\DoxyCodeLine{183 }
\DoxyCodeLine{187 }
\DoxyCodeLine{188 \textcolor{preprocessor}{\#ifdef MSF\_GIF\_IMPL}}
\DoxyCodeLine{189 \textcolor{preprocessor}{\#ifndef MSF\_GIF\_ALREADY\_IMPLEMENTED\_IN\_THIS\_TRANSLATION\_UNIT}}
\DoxyCodeLine{190 \textcolor{preprocessor}{\#define MSF\_GIF\_ALREADY\_IMPLEMENTED\_IN\_THIS\_TRANSLATION\_UNIT}}
\DoxyCodeLine{191 }
\DoxyCodeLine{192 \textcolor{comment}{//ensure the library user has either defined all of malloc/realloc/free, or none}}
\DoxyCodeLine{193 \textcolor{preprocessor}{\#if defined(MSF\_GIF\_MALLOC) \&\& defined(MSF\_GIF\_REALLOC) \&\& defined(MSF\_GIF\_FREE) }\textcolor{comment}{//ok}}
\DoxyCodeLine{194 \textcolor{preprocessor}{\#elif !defined(MSF\_GIF\_MALLOC) \&\& !defined(MSF\_GIF\_REALLOC) \&\& !defined(MSF\_GIF\_FREE) }\textcolor{comment}{//ok}}
\DoxyCodeLine{195 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{196 \textcolor{preprocessor}{\#error "{}You must either define all of MSF\_GIF\_MALLOC, MSF\_GIF\_REALLOC, and MSF\_GIF\_FREE, or define none of them"{}}}
\DoxyCodeLine{197 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{198 }
\DoxyCodeLine{199 \textcolor{comment}{//provide default allocator definitions that redirect to the standard global allocator}}
\DoxyCodeLine{200 \textcolor{preprocessor}{\#if !defined(MSF\_GIF\_MALLOC)}}
\DoxyCodeLine{201 \textcolor{preprocessor}{\#include <stdlib.h>} \textcolor{comment}{//malloc, etc.}}
\DoxyCodeLine{202 \textcolor{preprocessor}{\#define MSF\_GIF\_MALLOC(contextPointer, newSize) malloc(newSize)}}
\DoxyCodeLine{203 \textcolor{preprocessor}{\#define MSF\_GIF\_REALLOC(contextPointer, oldMemory, oldSize, newSize) realloc(oldMemory, newSize)}}
\DoxyCodeLine{204 \textcolor{preprocessor}{\#define MSF\_GIF\_FREE(contextPointer, oldMemory, oldSize) free(oldMemory)}}
\DoxyCodeLine{205 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{comment}{//instrumentation for capturing profiling traces (useless for the library user, but useful for the library author)}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\#ifdef MSF\_GIF\_ENABLE\_TRACING}}
\DoxyCodeLine{209 \textcolor{preprocessor}{\#define MsfTimeFunc TimeFunc}}
\DoxyCodeLine{210 \textcolor{preprocessor}{\#define MsfTimeLoop TimeLoop}}
\DoxyCodeLine{211 \textcolor{preprocessor}{\#define msf\_init\_profiling\_thread init\_profiling\_thread}}
\DoxyCodeLine{212 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{213 \textcolor{preprocessor}{\#define MsfTimeFunc}}
\DoxyCodeLine{214 \textcolor{preprocessor}{\#define MsfTimeLoop(name)}}
\DoxyCodeLine{215 \textcolor{preprocessor}{\#define msf\_init\_profiling\_thread()}}
\DoxyCodeLine{216 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//MSF\_GIF\_ENABLE\_TRACING}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218 \textcolor{preprocessor}{\#include <string.h>} \textcolor{comment}{//memcpy}}
\DoxyCodeLine{219 }
\DoxyCodeLine{220 \textcolor{comment}{//TODO: use compiler-\/specific notation to force-\/inline functions currently marked inline}}
\DoxyCodeLine{221 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) }\textcolor{comment}{//gcc, clang}}
\DoxyCodeLine{222 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} msf\_bit\_log(\textcolor{keywordtype}{int} i) \{ \textcolor{keywordflow}{return} 32 -\/ \_\_builtin\_clz(i); \}}
\DoxyCodeLine{223 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER) }\textcolor{comment}{//msvc}}
\DoxyCodeLine{224 \textcolor{preprocessor}{\#include <intrin.h>}}
\DoxyCodeLine{225 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} msf\_bit\_log(\textcolor{keywordtype}{int} i) \{ \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} idx; \_BitScanReverse(\&idx, i); \textcolor{keywordflow}{return} idx + 1; \}}
\DoxyCodeLine{226 \textcolor{preprocessor}{\#else }\textcolor{comment}{//fallback implementation for other compilers}}
\DoxyCodeLine{227 \textcolor{comment}{//from https://stackoverflow.com/a/31718095/3064745 -\/ thanks!}}
\DoxyCodeLine{228 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} msf\_bit\_log(\textcolor{keywordtype}{int} i) \{}
\DoxyCodeLine{229     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} MultiplyDeBruijnBitPosition[32] = \{}
\DoxyCodeLine{230         0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30,}
\DoxyCodeLine{231         8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31,}
\DoxyCodeLine{232     \};}
\DoxyCodeLine{233     i |= i >> 1;}
\DoxyCodeLine{234     i |= i >> 2;}
\DoxyCodeLine{235     i |= i >> 4;}
\DoxyCodeLine{236     i |= i >> 8;}
\DoxyCodeLine{237     i |= i >> 16;}
\DoxyCodeLine{238     \textcolor{keywordflow}{return} MultiplyDeBruijnBitPosition[(uint32\_t)(i * 0x07C4ACDDU) >> 27] + 1;}
\DoxyCodeLine{239 \}}
\DoxyCodeLine{240 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{241 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} msf\_imin(\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{ \textcolor{keywordflow}{return} a < b? a : b; \}}
\DoxyCodeLine{242 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} msf\_imax(\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{ \textcolor{keywordflow}{return} b < a? a : b; \}}
\DoxyCodeLine{243 }
\DoxyCodeLine{247 }
\DoxyCodeLine{248 \textcolor{preprocessor}{\#if (defined (\_\_SSE2\_\_) || defined (\_M\_X64) || \_M\_IX86\_FP == 2) \&\& !defined(MSF\_GIF\_NO\_SSE2)}}
\DoxyCodeLine{249 \textcolor{preprocessor}{\#include <emmintrin.h>}}
\DoxyCodeLine{250 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{251 }
\DoxyCodeLine{252 \textcolor{keywordtype}{int} msf\_gif\_alpha\_threshold = 0;}
\DoxyCodeLine{253 \textcolor{keywordtype}{int} msf\_gif\_bgra\_flag = 0;}
\DoxyCodeLine{254 }
\DoxyCodeLine{255 \textcolor{keyword}{static} \textcolor{keywordtype}{void} msf\_cook\_frame(\mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}} * frame, uint8\_t * raw, uint8\_t * used,}
\DoxyCodeLine{256                            \textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height, \textcolor{keywordtype}{int} pitch, \textcolor{keywordtype}{int} depth)}
\DoxyCodeLine{257 \{ MsfTimeFunc}
\DoxyCodeLine{258     \textcolor{comment}{//bit depth for each channel}}
\DoxyCodeLine{259     \textcolor{keyword}{const} \textcolor{keyword}{static} \textcolor{keywordtype}{int} rdepthsArray[17] = \{ 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5 \};}
\DoxyCodeLine{260     \textcolor{keyword}{const} \textcolor{keyword}{static} \textcolor{keywordtype}{int} gdepthsArray[17] = \{ 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6 \};}
\DoxyCodeLine{261     \textcolor{keyword}{const} \textcolor{keyword}{static} \textcolor{keywordtype}{int} bdepthsArray[17] = \{ 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5 \};}
\DoxyCodeLine{262     \textcolor{comment}{//this extra level of indirection looks unnecessary but we need to explicitly decay the arrays to pointers}}
\DoxyCodeLine{263     \textcolor{comment}{//in order to be able to swap them because of C's annoying not-\/quite-\/pointers, not-\/quite-\/value-\/types stack arrays.}}
\DoxyCodeLine{264     \textcolor{keyword}{const} \textcolor{keywordtype}{int} * rdepths = msf\_gif\_bgra\_flag? bdepthsArray : rdepthsArray;}
\DoxyCodeLine{265     \textcolor{keyword}{const} \textcolor{keywordtype}{int} * gdepths =                                   gdepthsArray;}
\DoxyCodeLine{266     \textcolor{keyword}{const} \textcolor{keywordtype}{int} * bdepths = msf\_gif\_bgra\_flag? rdepthsArray : bdepthsArray;}
\DoxyCodeLine{267 }
\DoxyCodeLine{268     \textcolor{keyword}{const} \textcolor{keyword}{static} \textcolor{keywordtype}{int} ditherKernel[16] = \{}
\DoxyCodeLine{269          0 << 12,  8 << 12,  2 << 12, 10 << 12,}
\DoxyCodeLine{270         12 << 12,  4 << 12, 14 << 12,  6 << 12,}
\DoxyCodeLine{271          3 << 12, 11 << 12,  1 << 12,  9 << 12,}
\DoxyCodeLine{272         15 << 12,  7 << 12, 13 << 12,  5 << 12,}
\DoxyCodeLine{273     \};}
\DoxyCodeLine{274 }
\DoxyCodeLine{275     uint32\_t * cooked = frame-\/>pixels;}
\DoxyCodeLine{276     \textcolor{keywordtype}{int} count = 0;}
\DoxyCodeLine{277     MsfTimeLoop(\textcolor{stringliteral}{"{}do"{}}) do \{}
\DoxyCodeLine{278         \textcolor{keywordtype}{int} rbits = rdepths[depth], gbits = gdepths[depth], bbits = bdepths[depth];}
\DoxyCodeLine{279         \textcolor{keywordtype}{int} paletteSize = (1 << (rbits + gbits + bbits)) + 1;}
\DoxyCodeLine{280         memset(used, 0, paletteSize * \textcolor{keyword}{sizeof}(uint8\_t));}
\DoxyCodeLine{281 }
\DoxyCodeLine{282         \textcolor{comment}{//TODO: document what this math does and why it's correct}}
\DoxyCodeLine{283         \textcolor{keywordtype}{int} rdiff = (1 << (8 -\/ rbits)) -\/ 1;}
\DoxyCodeLine{284         \textcolor{keywordtype}{int} gdiff = (1 << (8 -\/ gbits)) -\/ 1;}
\DoxyCodeLine{285         \textcolor{keywordtype}{int} bdiff = (1 << (8 -\/ bbits)) -\/ 1;}
\DoxyCodeLine{286         \textcolor{keywordtype}{short} rmul = (short) ((255.0f -\/ rdiff) / 255.0f * 257);}
\DoxyCodeLine{287         \textcolor{keywordtype}{short} gmul = (short) ((255.0f -\/ gdiff) / 255.0f * 257);}
\DoxyCodeLine{288         \textcolor{keywordtype}{short} bmul = (short) ((255.0f -\/ bdiff) / 255.0f * 257);}
\DoxyCodeLine{289 }
\DoxyCodeLine{290         \textcolor{keywordtype}{int} gmask = ((1 << gbits) -\/ 1) << rbits;}
\DoxyCodeLine{291         \textcolor{keywordtype}{int} bmask = ((1 << bbits) -\/ 1) << rbits << gbits;}
\DoxyCodeLine{292 }
\DoxyCodeLine{293         MsfTimeLoop(\textcolor{stringliteral}{"{}cook"{}}) for (\textcolor{keywordtype}{int} y = 0; y < height; ++y) \{}
\DoxyCodeLine{294             \textcolor{keywordtype}{int} x = 0;}
\DoxyCodeLine{295 }
\DoxyCodeLine{296 \textcolor{preprocessor}{            \#if (defined (\_\_SSE2\_\_) || defined (\_M\_X64) || \_M\_IX86\_FP == 2) \&\& !defined(MSF\_GIF\_NO\_SSE2)}}
\DoxyCodeLine{297                 \_\_m128i k = \_mm\_loadu\_si128((\_\_m128i *) \&ditherKernel[(y \& 3) * 4]);}
\DoxyCodeLine{298                 \_\_m128i k2 = \_mm\_or\_si128(\_mm\_srli\_epi32(k, rbits), \_mm\_slli\_epi32(\_mm\_srli\_epi32(k, bbits), 16));}
\DoxyCodeLine{299                 \textcolor{keywordflow}{for} (; x < width -\/ 3; x += 4) \{}
\DoxyCodeLine{300                     uint8\_t * pixels = \&raw[y * pitch + x * 4];}
\DoxyCodeLine{301                     \_\_m128i p = \_mm\_loadu\_si128((\_\_m128i *) pixels);}
\DoxyCodeLine{302 }
\DoxyCodeLine{303                     \_\_m128i rb = \_mm\_and\_si128(p, \_mm\_set1\_epi32(0x00FF00FF));}
\DoxyCodeLine{304                     \_\_m128i rb1 = \_mm\_mullo\_epi16(rb, \_mm\_set\_epi16(bmul, rmul, bmul, rmul, bmul, rmul, bmul, rmul));}
\DoxyCodeLine{305                     \_\_m128i rb2 = \_mm\_adds\_epu16(rb1, k2);}
\DoxyCodeLine{306                     \_\_m128i r3 = \_mm\_srli\_epi32(\_mm\_and\_si128(rb2, \_mm\_set1\_epi32(0x0000FFFF)), 16 -\/ rbits);}
\DoxyCodeLine{307                     \_\_m128i b3 = \_mm\_and\_si128(\_mm\_srli\_epi32(rb2, 32 -\/ rbits -\/ gbits -\/ bbits), \_mm\_set1\_epi32(bmask));}
\DoxyCodeLine{308 }
\DoxyCodeLine{309                     \_\_m128i g = \_mm\_and\_si128(\_mm\_srli\_epi32(p, 8), \_mm\_set1\_epi32(0x000000FF));}
\DoxyCodeLine{310                     \_\_m128i g1 = \_mm\_mullo\_epi16(g, \_mm\_set1\_epi32(gmul));}
\DoxyCodeLine{311                     \_\_m128i g2 = \_mm\_adds\_epu16(g1, \_mm\_srli\_epi32(k, gbits));}
\DoxyCodeLine{312                     \_\_m128i g3 = \_mm\_and\_si128(\_mm\_srli\_epi32(g2, 16 -\/ rbits -\/ gbits), \_mm\_set1\_epi32(gmask));}
\DoxyCodeLine{313 }
\DoxyCodeLine{314                     \_\_m128i out = \_mm\_or\_si128(\_mm\_or\_si128(r3, g3), b3);}
\DoxyCodeLine{315 }
\DoxyCodeLine{316                     \textcolor{comment}{//mask in transparency based on threshold}}
\DoxyCodeLine{317                     \textcolor{comment}{//NOTE: we can theoretically do a sub instead of srli by doing an unsigned compare via bias}}
\DoxyCodeLine{318                     \textcolor{comment}{//      to maybe save a TINY amount of throughput? but lol who cares maybe I'll do it later -\/m}}
\DoxyCodeLine{319                     \_\_m128i invAlphaMask = \_mm\_cmplt\_epi32(\_mm\_srli\_epi32(p, 24), \_mm\_set1\_epi32(msf\_gif\_alpha\_threshold));}
\DoxyCodeLine{320                     out = \_mm\_or\_si128(\_mm\_and\_si128(invAlphaMask, \_mm\_set1\_epi32(paletteSize -\/ 1)), \_mm\_andnot\_si128(invAlphaMask, out));}
\DoxyCodeLine{321 }
\DoxyCodeLine{322                     \textcolor{comment}{//TODO: does storing this as a \_\_m128i then reading it back as a uint32\_t violate strict aliasing?}}
\DoxyCodeLine{323                     uint32\_t * c = \&cooked[y * width + x];}
\DoxyCodeLine{324                     \_mm\_storeu\_si128((\_\_m128i *) c, out);}
\DoxyCodeLine{325                 \}}
\DoxyCodeLine{326 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328             \textcolor{comment}{//scalar cleanup loop}}
\DoxyCodeLine{329             \textcolor{keywordflow}{for} (; x < width; ++x) \{}
\DoxyCodeLine{330                 uint8\_t * p = \&raw[y * pitch + x * 4];}
\DoxyCodeLine{331 }
\DoxyCodeLine{332                 \textcolor{comment}{//transparent pixel if alpha is low}}
\DoxyCodeLine{333                 \textcolor{keywordflow}{if} (p[3] < msf\_gif\_alpha\_threshold) \{}
\DoxyCodeLine{334                     cooked[y * width + x] = paletteSize -\/ 1;}
\DoxyCodeLine{335                     \textcolor{keywordflow}{continue};}
\DoxyCodeLine{336                 \}}
\DoxyCodeLine{337 }
\DoxyCodeLine{338                 \textcolor{keywordtype}{int} dx = x \& 3, dy = y \& 3;}
\DoxyCodeLine{339                 \textcolor{keywordtype}{int} k = ditherKernel[dy * 4 + dx];}
\DoxyCodeLine{340                 cooked[y * width + x] =}
\DoxyCodeLine{341                     (msf\_imin(65535, p[2] * bmul + (k >> bbits)) >> (16 -\/ rbits -\/ gbits -\/ bbits) \& bmask) |}
\DoxyCodeLine{342                     (msf\_imin(65535, p[1] * gmul + (k >> gbits)) >> (16 -\/ rbits -\/ gbits        ) \& gmask) |}
\DoxyCodeLine{343                      msf\_imin(65535, p[0] * rmul + (k >> rbits)) >> (16 -\/ rbits                );}
\DoxyCodeLine{344             \}}
\DoxyCodeLine{345         \}}
\DoxyCodeLine{346 }
\DoxyCodeLine{347         count = 0;}
\DoxyCodeLine{348         MsfTimeLoop(\textcolor{stringliteral}{"{}mark"{}}) for (\textcolor{keywordtype}{int} i = 0; i < width * height; ++i) \{}
\DoxyCodeLine{349             used[cooked[i]] = 1;}
\DoxyCodeLine{350         \}}
\DoxyCodeLine{351 }
\DoxyCodeLine{352         \textcolor{comment}{//count used colors, transparent is ignored}}
\DoxyCodeLine{353         MsfTimeLoop(\textcolor{stringliteral}{"{}count"{}}) for (\textcolor{keywordtype}{int} j = 0; j < paletteSize -\/ 1; ++j) \{}
\DoxyCodeLine{354             count += used[j];}
\DoxyCodeLine{355         \}}
\DoxyCodeLine{356     \} \textcolor{keywordflow}{while} (count >= 256 \&\& -\/-\/depth);}
\DoxyCodeLine{357 }
\DoxyCodeLine{358     \mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}} ret = \{ cooked, depth, count, rdepths[depth], gdepths[depth], bdepths[depth] \};}
\DoxyCodeLine{359     *frame = ret;}
\DoxyCodeLine{360 \}}
\DoxyCodeLine{361 }
\DoxyCodeLine{365 }
\DoxyCodeLine{366 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} msf\_put\_code(uint8\_t * * writeHead, uint32\_t * blockBits, \textcolor{keywordtype}{int} len, uint32\_t code) \{}
\DoxyCodeLine{367     \textcolor{comment}{//insert new code into block buffer}}
\DoxyCodeLine{368     \textcolor{keywordtype}{int} idx = *blockBits / 8;}
\DoxyCodeLine{369     \textcolor{keywordtype}{int} bit = *blockBits \% 8;}
\DoxyCodeLine{370     (*writeHead)[idx + 0] |= code <<       bit ;}
\DoxyCodeLine{371     (*writeHead)[idx + 1] |= code >> ( 8 -\/ bit);}
\DoxyCodeLine{372     (*writeHead)[idx + 2] |= code >> (16 -\/ bit);}
\DoxyCodeLine{373     *blockBits += len;}
\DoxyCodeLine{374 }
\DoxyCodeLine{375     \textcolor{comment}{//prep the next block buffer if the current one is full}}
\DoxyCodeLine{376     \textcolor{keywordflow}{if} (*blockBits >= 256 * 8) \{}
\DoxyCodeLine{377         *blockBits -\/= 255 * 8;}
\DoxyCodeLine{378         (*writeHead) += 256;}
\DoxyCodeLine{379         (*writeHead)[2] = (*writeHead)[1];}
\DoxyCodeLine{380         (*writeHead)[1] = (*writeHead)[0];}
\DoxyCodeLine{381         (*writeHead)[0] = 255;}
\DoxyCodeLine{382         memset((*writeHead) + 4, 0, 256);}
\DoxyCodeLine{383     \}}
\DoxyCodeLine{384 \}}
\DoxyCodeLine{385 }
\DoxyCodeLine{386 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{}
\DoxyCodeLine{387     int16\_t * data;}
\DoxyCodeLine{388     \textcolor{keywordtype}{int} len;}
\DoxyCodeLine{389     \textcolor{keywordtype}{int} stride;}
\DoxyCodeLine{390 \} MsfStridedList;}
\DoxyCodeLine{391 }
\DoxyCodeLine{392 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} msf\_lzw\_reset(MsfStridedList * lzw, \textcolor{keywordtype}{int} tableSize, \textcolor{keywordtype}{int} stride) \{ MsfTimeFunc}
\DoxyCodeLine{393     memset(lzw-\/>data, 0xFF, 4096 * stride * \textcolor{keyword}{sizeof}(int16\_t));}
\DoxyCodeLine{394     lzw-\/>len = tableSize + 2;}
\DoxyCodeLine{395     lzw-\/>stride = stride;}
\DoxyCodeLine{396 \}}
\DoxyCodeLine{397 }
\DoxyCodeLine{398 \textcolor{keyword}{static} \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * msf\_compress\_frame(\textcolor{keywordtype}{void} * allocContext, \textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height, \textcolor{keywordtype}{int} centiSeconds,}
\DoxyCodeLine{399                                          \mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}} frame, \mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, uint8\_t * used, int16\_t * lzwMem)}
\DoxyCodeLine{400 \{ MsfTimeFunc}
\DoxyCodeLine{401     \textcolor{comment}{//NOTE: we reserve enough memory for theoretical the worst case upfront because it's a reasonable amount,}}
\DoxyCodeLine{402     \textcolor{comment}{//      and prevents us from ever having to check size or realloc during compression}}
\DoxyCodeLine{403     \textcolor{keywordtype}{int} maxBufSize = offsetof(\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}}, data) + 32 + 256 * 3 + width * height * 3 / 2; \textcolor{comment}{//headers + color table + data}}
\DoxyCodeLine{404     \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * buffer = (\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} *) MSF\_GIF\_MALLOC(allocContext, maxBufSize);}
\DoxyCodeLine{405     \textcolor{keywordflow}{if} (!buffer) \{ \textcolor{keywordflow}{return} NULL; \}}
\DoxyCodeLine{406     uint8\_t * writeHead = buffer-\/>data;}
\DoxyCodeLine{407     MsfStridedList lzw = \{ lzwMem \};}
\DoxyCodeLine{408 }
\DoxyCodeLine{409     \textcolor{comment}{//allocate tlb}}
\DoxyCodeLine{410     \textcolor{keywordtype}{int} totalBits = frame.rbits + frame.gbits + frame.bbits;}
\DoxyCodeLine{411     \textcolor{keywordtype}{int} tlbSize = (1 << totalBits) + 1;}
\DoxyCodeLine{412     uint8\_t tlb[(1 << 16) + 1]; \textcolor{comment}{//only 64k, so stack allocating is fine}}
\DoxyCodeLine{413 }
\DoxyCodeLine{414     \textcolor{comment}{//generate palette}}
\DoxyCodeLine{415     \textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{ uint8\_t r, g, b; \} Color3;}
\DoxyCodeLine{416     Color3 table[256] = \{ \{0\} \};}
\DoxyCodeLine{417     \textcolor{keywordtype}{int} tableIdx = 1; \textcolor{comment}{//we start counting at 1 because 0 is the transparent color}}
\DoxyCodeLine{418     \textcolor{comment}{//transparent is always last in the table}}
\DoxyCodeLine{419     tlb[tlbSize-\/1] = 0;}
\DoxyCodeLine{420     MsfTimeLoop(\textcolor{stringliteral}{"{}table"{}}) for (\textcolor{keywordtype}{int} i = 0; i < tlbSize-\/1; ++i) \{}
\DoxyCodeLine{421         \textcolor{keywordflow}{if} (used[i]) \{}
\DoxyCodeLine{422             tlb[i] = tableIdx;}
\DoxyCodeLine{423             \textcolor{keywordtype}{int} rmask = (1 << frame.rbits) -\/ 1;}
\DoxyCodeLine{424             \textcolor{keywordtype}{int} gmask = (1 << frame.gbits) -\/ 1;}
\DoxyCodeLine{425             \textcolor{comment}{//isolate components}}
\DoxyCodeLine{426             \textcolor{keywordtype}{int} r = i \& rmask;}
\DoxyCodeLine{427             \textcolor{keywordtype}{int} g = i >> frame.rbits \& gmask;}
\DoxyCodeLine{428             \textcolor{keywordtype}{int} b = i >> (frame.rbits + frame.gbits);}
\DoxyCodeLine{429             \textcolor{comment}{//shift into highest bits}}
\DoxyCodeLine{430             r <<= 8 -\/ frame.rbits;}
\DoxyCodeLine{431             g <<= 8 -\/ frame.gbits;}
\DoxyCodeLine{432             b <<= 8 -\/ frame.bbits;}
\DoxyCodeLine{433             table[tableIdx].r = r | r >> frame.rbits | r >> (frame.rbits * 2) | r >> (frame.rbits * 3);}
\DoxyCodeLine{434             table[tableIdx].g = g | g >> frame.gbits | g >> (frame.gbits * 2) | g >> (frame.gbits * 3);}
\DoxyCodeLine{435             table[tableIdx].b = b | b >> frame.bbits | b >> (frame.bbits * 2) | b >> (frame.bbits * 3);}
\DoxyCodeLine{436             \textcolor{keywordflow}{if} (msf\_gif\_bgra\_flag) \{}
\DoxyCodeLine{437                 uint8\_t temp = table[tableIdx].r;}
\DoxyCodeLine{438                 table[tableIdx].r = table[tableIdx].b;}
\DoxyCodeLine{439                 table[tableIdx].b = temp;}
\DoxyCodeLine{440             \}}
\DoxyCodeLine{441             ++tableIdx;}
\DoxyCodeLine{442         \}}
\DoxyCodeLine{443     \}}
\DoxyCodeLine{444     \textcolor{keywordtype}{int} hasTransparentPixels = used[tlbSize-\/1];}
\DoxyCodeLine{445 }
\DoxyCodeLine{446     \textcolor{comment}{//SPEC: "{}Because of some algorithmic constraints however, black \& white images which have one color bit}}
\DoxyCodeLine{447     \textcolor{comment}{//       must be indicated as having a code size of 2."{}}}
\DoxyCodeLine{448     \textcolor{keywordtype}{int} tableBits = msf\_imax(2, msf\_bit\_log(tableIdx -\/ 1));}
\DoxyCodeLine{449     \textcolor{keywordtype}{int} tableSize = 1 << tableBits;}
\DoxyCodeLine{450     \textcolor{comment}{//NOTE: we don't just compare `depth` field here because it will be wrong for the first frame and we will segfault}}
\DoxyCodeLine{451     \mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}} previous = handle-\/>previousFrame;}
\DoxyCodeLine{452     \textcolor{keywordtype}{int} hasSamePal = frame.rbits == previous.rbits \&\& frame.gbits == previous.gbits \&\& frame.bbits == previous.bbits;}
\DoxyCodeLine{453     \textcolor{keywordtype}{int} framesCompatible = hasSamePal \&\& !hasTransparentPixels;}
\DoxyCodeLine{454 }
\DoxyCodeLine{455     \textcolor{comment}{//NOTE: because \_\_attribute\_\_((\_\_packed\_\_)) is annoyingly compiler-\/specific, we do this unreadable weirdness}}
\DoxyCodeLine{456     \textcolor{keywordtype}{char} headerBytes[19] = \textcolor{stringliteral}{"{}\(\backslash\)x21\(\backslash\)xF9\(\backslash\)x04\(\backslash\)x05\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0"{}} \textcolor{stringliteral}{"{}\(\backslash\)x2C\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)x80"{}};}
\DoxyCodeLine{457     \textcolor{comment}{//NOTE: we need to check the frame number because if we reach into the buffer prior to the first frame,}}
\DoxyCodeLine{458     \textcolor{comment}{//      we'll just clobber the file header instead, which is a bug}}
\DoxyCodeLine{459     \textcolor{keywordflow}{if} (hasTransparentPixels \&\& handle-\/>framesSubmitted > 0) \{}
\DoxyCodeLine{460         handle-\/>listTail-\/>data[3] = 0x09; \textcolor{comment}{//set the previous frame's disposal to background, so transparency is possible}}
\DoxyCodeLine{461     \}}
\DoxyCodeLine{462     memcpy(\&headerBytes[4], \&centiSeconds, 2);}
\DoxyCodeLine{463     memcpy(\&headerBytes[13], \&width, 2);}
\DoxyCodeLine{464     memcpy(\&headerBytes[15], \&height, 2);}
\DoxyCodeLine{465     headerBytes[17] |= tableBits -\/ 1;}
\DoxyCodeLine{466     memcpy(writeHead, headerBytes, 18);}
\DoxyCodeLine{467     writeHead += 18;}
\DoxyCodeLine{468 }
\DoxyCodeLine{469     \textcolor{comment}{//local color table}}
\DoxyCodeLine{470     memcpy(writeHead, table, tableSize * \textcolor{keyword}{sizeof}(Color3));}
\DoxyCodeLine{471     writeHead += tableSize * \textcolor{keyword}{sizeof}(Color3);}
\DoxyCodeLine{472     *writeHead++ = tableBits;}
\DoxyCodeLine{473 }
\DoxyCodeLine{474     \textcolor{comment}{//prep block}}
\DoxyCodeLine{475     memset(writeHead, 0, 260);}
\DoxyCodeLine{476     writeHead[0] = 255;}
\DoxyCodeLine{477     uint32\_t blockBits = 8; \textcolor{comment}{//relative to block.head}}
\DoxyCodeLine{478 }
\DoxyCodeLine{479     \textcolor{comment}{//SPEC: "{}Encoders should output a Clear code as the first code of each image data stream."{}}}
\DoxyCodeLine{480     msf\_lzw\_reset(\&lzw, tableSize, tableIdx);}
\DoxyCodeLine{481     msf\_put\_code(\&writeHead, \&blockBits, msf\_bit\_log(lzw.len -\/ 1), tableSize);}
\DoxyCodeLine{482 }
\DoxyCodeLine{483     \textcolor{keywordtype}{int} lastCode = framesCompatible \&\& frame.pixels[0] == previous.pixels[0]? 0 : tlb[frame.pixels[0]];}
\DoxyCodeLine{484     MsfTimeLoop(\textcolor{stringliteral}{"{}compress"{}}) for (\textcolor{keywordtype}{int} i = 1; i < width * height; ++i) \{}
\DoxyCodeLine{485         \textcolor{comment}{//PERF: branching vs. branchless version of this line is observed to have no discernable impact on speed}}
\DoxyCodeLine{486         \textcolor{keywordtype}{int} color = framesCompatible \&\& frame.pixels[i] == previous.pixels[i]? 0 : tlb[frame.pixels[i]];}
\DoxyCodeLine{487         \textcolor{keywordtype}{int} code = (\&lzw.data[lastCode * lzw.stride])[color];}
\DoxyCodeLine{488         \textcolor{keywordflow}{if} (code < 0) \{}
\DoxyCodeLine{489             \textcolor{comment}{//write to code stream}}
\DoxyCodeLine{490             \textcolor{keywordtype}{int} codeBits = msf\_bit\_log(lzw.len -\/ 1);}
\DoxyCodeLine{491             msf\_put\_code(\&writeHead, \&blockBits, codeBits, lastCode);}
\DoxyCodeLine{492 }
\DoxyCodeLine{493             \textcolor{keywordflow}{if} (lzw.len > 4095) \{}
\DoxyCodeLine{494                 \textcolor{comment}{//reset buffer code table}}
\DoxyCodeLine{495                 msf\_put\_code(\&writeHead, \&blockBits, codeBits, tableSize);}
\DoxyCodeLine{496                 msf\_lzw\_reset(\&lzw, tableSize, tableIdx);}
\DoxyCodeLine{497             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{498                 (\&lzw.data[lastCode * lzw.stride])[color] = lzw.len;}
\DoxyCodeLine{499                 ++lzw.len;}
\DoxyCodeLine{500             \}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502             lastCode = color;}
\DoxyCodeLine{503         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{504             lastCode = code;}
\DoxyCodeLine{505         \}}
\DoxyCodeLine{506     \}}
\DoxyCodeLine{507 }
\DoxyCodeLine{508     \textcolor{comment}{//write code for leftover index buffer contents, then the end code}}
\DoxyCodeLine{509     msf\_put\_code(\&writeHead, \&blockBits, msf\_imin(12, msf\_bit\_log(lzw.len -\/ 1)), lastCode);}
\DoxyCodeLine{510     msf\_put\_code(\&writeHead, \&blockBits, msf\_imin(12, msf\_bit\_log(lzw.len)), tableSize + 1);}
\DoxyCodeLine{511 }
\DoxyCodeLine{512     \textcolor{comment}{//flush remaining data}}
\DoxyCodeLine{513     \textcolor{keywordflow}{if} (blockBits > 8) \{}
\DoxyCodeLine{514         \textcolor{keywordtype}{int} bytes = (blockBits + 7) / 8; \textcolor{comment}{//round up}}
\DoxyCodeLine{515         writeHead[0] = bytes -\/ 1;}
\DoxyCodeLine{516         writeHead += bytes;}
\DoxyCodeLine{517     \}}
\DoxyCodeLine{518     *writeHead++ = 0; \textcolor{comment}{//terminating block}}
\DoxyCodeLine{519 }
\DoxyCodeLine{520     \textcolor{comment}{//fill in buffer header and shrink buffer to fit data}}
\DoxyCodeLine{521     buffer-\/>next = NULL;}
\DoxyCodeLine{522     buffer-\/>size = writeHead -\/ buffer-\/>data;}
\DoxyCodeLine{523     \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * moved =}
\DoxyCodeLine{524         (\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} *) MSF\_GIF\_REALLOC(allocContext, buffer, maxBufSize, offsetof(\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}}, data) + buffer-\/>size);}
\DoxyCodeLine{525     \textcolor{keywordflow}{if} (!moved) \{ MSF\_GIF\_FREE(allocContext, buffer, maxBufSize); \textcolor{keywordflow}{return} NULL; \}}
\DoxyCodeLine{526     \textcolor{keywordflow}{return} moved;}
\DoxyCodeLine{527 \}}
\DoxyCodeLine{528 }
\DoxyCodeLine{532 }
\DoxyCodeLine{533 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} lzwAllocSize = 4096 * 256 * \textcolor{keyword}{sizeof}(int16\_t);}
\DoxyCodeLine{534 }
\DoxyCodeLine{535 \textcolor{comment}{//NOTE: by C standard library conventions, freeing NULL should be a no-\/op,}}
\DoxyCodeLine{536 \textcolor{comment}{//      but just in case the user's custom free doesn't follow that rule, we do null checks on our end as well.}}
\DoxyCodeLine{537 \textcolor{keyword}{static} \textcolor{keywordtype}{void} msf\_free\_gif\_state(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle) \{}
\DoxyCodeLine{538     \textcolor{keywordflow}{if} (handle-\/>previousFrame.pixels) MSF\_GIF\_FREE(handle-\/>customAllocatorContext, handle-\/>previousFrame.pixels,}
\DoxyCodeLine{539                                                    handle-\/>width * handle-\/>height * \textcolor{keyword}{sizeof}(uint32\_t));}
\DoxyCodeLine{540     \textcolor{keywordflow}{if} (handle-\/>currentFrame.pixels)  MSF\_GIF\_FREE(handle-\/>customAllocatorContext, handle-\/>currentFrame.pixels,}
\DoxyCodeLine{541                                                    handle-\/>width * handle-\/>height * \textcolor{keyword}{sizeof}(uint32\_t));}
\DoxyCodeLine{542     \textcolor{keywordflow}{if} (handle-\/>lzwMem) MSF\_GIF\_FREE(handle-\/>customAllocatorContext, handle-\/>lzwMem, lzwAllocSize);}
\DoxyCodeLine{543     \textcolor{keywordflow}{for} (\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * node = handle-\/>listHead; node;) \{}
\DoxyCodeLine{544         \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * next = node-\/>next; \textcolor{comment}{//NOTE: we have to copy the `next` pointer BEFORE freeing the node holding it}}
\DoxyCodeLine{545         MSF\_GIF\_FREE(handle-\/>customAllocatorContext, node, offsetof(\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}}, data) + node-\/>size);}
\DoxyCodeLine{546         node = next;}
\DoxyCodeLine{547     \}}
\DoxyCodeLine{548     handle-\/>listHead = NULL; \textcolor{comment}{//this implicitly marks the handle as invalid until the next msf\_gif\_begin() call}}
\DoxyCodeLine{549 \}}
\DoxyCodeLine{550 }
\DoxyCodeLine{551 \textcolor{keywordtype}{int} msf\_gif\_begin(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, \textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height) \{ MsfTimeFunc}
\DoxyCodeLine{552     \textcolor{comment}{//NOTE: we cannot stomp the entire struct to zero because we must preserve `customAllocatorContext`.}}
\DoxyCodeLine{553     \mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}} empty = \{0\}; \textcolor{comment}{//god I hate MSVC...}}
\DoxyCodeLine{554     handle-\/>previousFrame = empty;}
\DoxyCodeLine{555     handle-\/>currentFrame = empty;}
\DoxyCodeLine{556     handle-\/>width = width;}
\DoxyCodeLine{557     handle-\/>height = height;}
\DoxyCodeLine{558     handle-\/>framesSubmitted = 0;}
\DoxyCodeLine{559 }
\DoxyCodeLine{560     \textcolor{comment}{//allocate memory for LZW buffer}}
\DoxyCodeLine{561     \textcolor{comment}{//NOTE: Unfortunately we can't just use stack memory for the LZW table because it's 2MB,}}
\DoxyCodeLine{562     \textcolor{comment}{//      which is more stack space than most operating systems give by default,}}
\DoxyCodeLine{563     \textcolor{comment}{//      and we can't realistically expect users to be willing to override that just to use our library,}}
\DoxyCodeLine{564     \textcolor{comment}{//      so we have to allocate this on the heap.}}
\DoxyCodeLine{565     handle-\/>lzwMem = (int16\_t *) MSF\_GIF\_MALLOC(handle-\/>customAllocatorContext, lzwAllocSize);}
\DoxyCodeLine{566     handle-\/>previousFrame.pixels =}
\DoxyCodeLine{567         (uint32\_t *) MSF\_GIF\_MALLOC(handle-\/>customAllocatorContext, handle-\/>width * handle-\/>height * \textcolor{keyword}{sizeof}(uint32\_t));}
\DoxyCodeLine{568     handle-\/>currentFrame.pixels =}
\DoxyCodeLine{569         (uint32\_t *) MSF\_GIF\_MALLOC(handle-\/>customAllocatorContext, handle-\/>width * handle-\/>height * \textcolor{keyword}{sizeof}(uint32\_t));}
\DoxyCodeLine{570 }
\DoxyCodeLine{571     \textcolor{comment}{//setup header buffer header (lol)}}
\DoxyCodeLine{572     handle-\/>listHead = (\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} *) MSF\_GIF\_MALLOC(handle-\/>customAllocatorContext, offsetof(\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}}, data) + 32);}
\DoxyCodeLine{573     \textcolor{keywordflow}{if} (!handle-\/>listHead || !handle-\/>lzwMem || !handle-\/>previousFrame.pixels || !handle-\/>currentFrame.pixels) \{}
\DoxyCodeLine{574         msf\_free\_gif\_state(handle);}
\DoxyCodeLine{575         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{576     \}}
\DoxyCodeLine{577     handle-\/>listTail = handle-\/>listHead;}
\DoxyCodeLine{578     handle-\/>listHead-\/>next = NULL;}
\DoxyCodeLine{579     handle-\/>listHead-\/>size = 32;}
\DoxyCodeLine{580 }
\DoxyCodeLine{581     \textcolor{comment}{//NOTE: because \_\_attribute\_\_((\_\_packed\_\_)) is annoyingly compiler-\/specific, we do this unreadable weirdness}}
\DoxyCodeLine{582     \textcolor{keywordtype}{char} headerBytes[33] = \textcolor{stringliteral}{"{}GIF89a\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)x70\(\backslash\)0\(\backslash\)0"{}} \textcolor{stringliteral}{"{}\(\backslash\)x21\(\backslash\)xFF\(\backslash\)x0BNETSCAPE2.0\(\backslash\)x03\(\backslash\)x01\(\backslash\)0\(\backslash\)0\(\backslash\)0"{}};}
\DoxyCodeLine{583     memcpy(\&headerBytes[6], \&width, 2);}
\DoxyCodeLine{584     memcpy(\&headerBytes[8], \&height, 2);}
\DoxyCodeLine{585     memcpy(handle-\/>listHead-\/>data, headerBytes, 32);}
\DoxyCodeLine{586     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{587 \}}
\DoxyCodeLine{588 }
\DoxyCodeLine{589 \textcolor{keywordtype}{int} msf\_gif\_frame(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, uint8\_t * pixelData, \textcolor{keywordtype}{int} centiSecondsPerFame, \textcolor{keywordtype}{int} maxBitDepth, \textcolor{keywordtype}{int} pitchInBytes)}
\DoxyCodeLine{590 \{ MsfTimeFunc}
\DoxyCodeLine{591     \textcolor{keywordflow}{if} (!handle-\/>listHead) \{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{592 }
\DoxyCodeLine{593     maxBitDepth = msf\_imax(1, msf\_imin(16, maxBitDepth));}
\DoxyCodeLine{594     \textcolor{keywordflow}{if} (pitchInBytes == 0) pitchInBytes = handle-\/>width * 4;}
\DoxyCodeLine{595     \textcolor{keywordflow}{if} (pitchInBytes < 0) pixelData -\/= pitchInBytes * (handle-\/>height -\/ 1);}
\DoxyCodeLine{596 }
\DoxyCodeLine{597     uint8\_t used[(1 << 16) + 1]; \textcolor{comment}{//only 64k, so stack allocating is fine}}
\DoxyCodeLine{598     msf\_cook\_frame(\&handle-\/>currentFrame, pixelData, used, handle-\/>width, handle-\/>height, pitchInBytes,}
\DoxyCodeLine{599         msf\_imin(maxBitDepth, handle-\/>previousFrame.depth + 160 / msf\_imax(1, handle-\/>previousFrame.count)));}
\DoxyCodeLine{600 }
\DoxyCodeLine{601     \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * buffer = msf\_compress\_frame(handle-\/>customAllocatorContext, handle-\/>width, handle-\/>height,}
\DoxyCodeLine{602         centiSecondsPerFame, handle-\/>currentFrame, handle, used, handle-\/>lzwMem);}
\DoxyCodeLine{603     \textcolor{keywordflow}{if} (!buffer) \{ msf\_free\_gif\_state(handle); \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{604     handle-\/>listTail-\/>next = buffer;}
\DoxyCodeLine{605     handle-\/>listTail = buffer;}
\DoxyCodeLine{606 }
\DoxyCodeLine{607     \textcolor{comment}{//swap current and previous frames}}
\DoxyCodeLine{608     \mbox{\hyperlink{structMsfCookedFrame}{MsfCookedFrame}} tmp = handle-\/>previousFrame;}
\DoxyCodeLine{609     handle-\/>previousFrame = handle-\/>currentFrame;}
\DoxyCodeLine{610     handle-\/>currentFrame = tmp;}
\DoxyCodeLine{611 }
\DoxyCodeLine{612     handle-\/>framesSubmitted += 1;}
\DoxyCodeLine{613     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{614 \}}
\DoxyCodeLine{615 }
\DoxyCodeLine{616 \mbox{\hyperlink{structMsfGifResult}{MsfGifResult}} msf\_gif\_end(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle) \{ MsfTimeFunc}
\DoxyCodeLine{617     \textcolor{keywordflow}{if} (!handle-\/>listHead) \{ \mbox{\hyperlink{structMsfGifResult}{MsfGifResult}} empty = \{0\}; \textcolor{keywordflow}{return} empty; \}}
\DoxyCodeLine{618 }
\DoxyCodeLine{619     \textcolor{comment}{//first pass: determine total size}}
\DoxyCodeLine{620     \textcolor{keywordtype}{size\_t} total = 1; \textcolor{comment}{//1 byte for trailing marker}}
\DoxyCodeLine{621     \textcolor{keywordflow}{for} (\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * node = handle-\/>listHead; node; node = node-\/>next) \{ total += node-\/>size; \}}
\DoxyCodeLine{622 }
\DoxyCodeLine{623     \textcolor{comment}{//second pass: write data}}
\DoxyCodeLine{624     uint8\_t * buffer = (uint8\_t *) MSF\_GIF\_MALLOC(handle-\/>customAllocatorContext, total);}
\DoxyCodeLine{625     \textcolor{keywordflow}{if} (buffer) \{}
\DoxyCodeLine{626         uint8\_t * writeHead = buffer;}
\DoxyCodeLine{627         \textcolor{keywordflow}{for} (\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * node = handle-\/>listHead; node; node = node-\/>next) \{}
\DoxyCodeLine{628             memcpy(writeHead, node-\/>data, node-\/>size);}
\DoxyCodeLine{629             writeHead += node-\/>size;}
\DoxyCodeLine{630         \}}
\DoxyCodeLine{631         *writeHead++ = 0x3B;}
\DoxyCodeLine{632     \}}
\DoxyCodeLine{633 }
\DoxyCodeLine{634     \textcolor{comment}{//third pass: free buffers}}
\DoxyCodeLine{635     msf\_free\_gif\_state(handle);}
\DoxyCodeLine{636 }
\DoxyCodeLine{637     \mbox{\hyperlink{structMsfGifResult}{MsfGifResult}} ret = \{ buffer, total, total, handle-\/>customAllocatorContext \};}
\DoxyCodeLine{638     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{639 \}}
\DoxyCodeLine{640 }
\DoxyCodeLine{641 \textcolor{keywordtype}{void} msf\_gif\_free(\mbox{\hyperlink{structMsfGifResult}{MsfGifResult}} result) \{ MsfTimeFunc}
\DoxyCodeLine{642     \textcolor{keywordflow}{if} (result.data) \{ MSF\_GIF\_FREE(result.contextPointer, result.data, result.allocSize); \}}
\DoxyCodeLine{643 \}}
\DoxyCodeLine{644 }
\DoxyCodeLine{648 }
\DoxyCodeLine{649 \textcolor{keywordtype}{int} msf\_gif\_begin\_to\_file(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, \textcolor{keywordtype}{int} width, \textcolor{keywordtype}{int} height, MsfGifFileWriteFunc func, \textcolor{keywordtype}{void} * filePointer) \{}
\DoxyCodeLine{650     handle-\/>fileWriteFunc = func;}
\DoxyCodeLine{651     handle-\/>fileWriteData = filePointer;}
\DoxyCodeLine{652     \textcolor{keywordflow}{return} msf\_gif\_begin(handle, width, height);}
\DoxyCodeLine{653 \}}
\DoxyCodeLine{654 }
\DoxyCodeLine{655 \textcolor{keywordtype}{int} msf\_gif\_frame\_to\_file(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle, uint8\_t * pixelData, \textcolor{keywordtype}{int} centiSecondsPerFame, \textcolor{keywordtype}{int} maxBitDepth, \textcolor{keywordtype}{int} pitchInBytes) \{}
\DoxyCodeLine{656     \textcolor{keywordflow}{if} (!msf\_gif\_frame(handle, pixelData, centiSecondsPerFame, maxBitDepth, pitchInBytes)) \{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{657 }
\DoxyCodeLine{658     \textcolor{comment}{//NOTE: this is a somewhat hacky implementation which is not perfectly efficient, but it's good enough for now}}
\DoxyCodeLine{659     \mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}} * head = handle-\/>listHead;}
\DoxyCodeLine{660     \textcolor{keywordflow}{if} (!handle-\/>fileWriteFunc(head-\/>data, head-\/>size, 1, handle-\/>fileWriteData)) \{ msf\_free\_gif\_state(handle); \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{661     handle-\/>listHead = head-\/>next;}
\DoxyCodeLine{662     MSF\_GIF\_FREE(handle-\/>customAllocatorContext, head, offsetof(\mbox{\hyperlink{structMsfGifBuffer}{MsfGifBuffer}}, data) + head-\/>size);}
\DoxyCodeLine{663     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{664 \}}
\DoxyCodeLine{665 }
\DoxyCodeLine{666 \textcolor{keywordtype}{int} msf\_gif\_end\_to\_file(\mbox{\hyperlink{structMsfGifState}{MsfGifState}} * handle) \{}
\DoxyCodeLine{667     \textcolor{comment}{//NOTE: this is a somewhat hacky implementation which is not perfectly efficient, but it's good enough for now}}
\DoxyCodeLine{668     \mbox{\hyperlink{structMsfGifResult}{MsfGifResult}} result = msf\_gif\_end(handle);}
\DoxyCodeLine{669     \textcolor{keywordtype}{int} ret = (int) handle-\/>fileWriteFunc(result.data, result.dataSize, 1, handle-\/>fileWriteData);}
\DoxyCodeLine{670     msf\_gif\_free(result);}
\DoxyCodeLine{671     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{672 \}}
\DoxyCodeLine{673 }
\DoxyCodeLine{674 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//MSF\_GIF\_ALREADY\_IMPLEMENTED\_IN\_THIS\_TRANSLATION\_UNIT}}
\DoxyCodeLine{675 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//MSF\_GIF\_IMPL}}
\DoxyCodeLine{676 }
\DoxyCodeLine{677 \textcolor{comment}{/*}}
\DoxyCodeLine{678 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{679 \textcolor{comment}{This software is available under 2 licenses -\/-\/ choose whichever you prefer.}}
\DoxyCodeLine{680 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{681 \textcolor{comment}{ALTERNATIVE A -\/ MIT License}}
\DoxyCodeLine{682 \textcolor{comment}{Copyright (c) 2021 Miles Fogle}}
\DoxyCodeLine{683 \textcolor{comment}{Permission is hereby granted, free of charge, to any person obtaining a copy of}}
\DoxyCodeLine{684 \textcolor{comment}{this software and associated documentation files (the "{}Software"{}), to deal in}}
\DoxyCodeLine{685 \textcolor{comment}{the Software without restriction, including without limitation the rights to}}
\DoxyCodeLine{686 \textcolor{comment}{use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies}}
\DoxyCodeLine{687 \textcolor{comment}{of the Software, and to permit persons to whom the Software is furnished to do}}
\DoxyCodeLine{688 \textcolor{comment}{so, subject to the following conditions:}}
\DoxyCodeLine{689 \textcolor{comment}{The above copyright notice and this permission notice shall be included in all}}
\DoxyCodeLine{690 \textcolor{comment}{copies or substantial portions of the Software.}}
\DoxyCodeLine{691 \textcolor{comment}{THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{692 \textcolor{comment}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}}
\DoxyCodeLine{693 \textcolor{comment}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}}
\DoxyCodeLine{694 \textcolor{comment}{AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}}
\DoxyCodeLine{695 \textcolor{comment}{LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,}}
\DoxyCodeLine{696 \textcolor{comment}{OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE}}
\DoxyCodeLine{697 \textcolor{comment}{SOFTWARE.}}
\DoxyCodeLine{698 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{699 \textcolor{comment}{ALTERNATIVE B -\/ Public Domain (www.unlicense.org)}}
\DoxyCodeLine{700 \textcolor{comment}{This is free and unencumbered software released into the public domain.}}
\DoxyCodeLine{701 \textcolor{comment}{Anyone is free to copy, modify, publish, use, compile, sell, or distribute this}}
\DoxyCodeLine{702 \textcolor{comment}{software, either in source code form or as a compiled binary, for any purpose,}}
\DoxyCodeLine{703 \textcolor{comment}{commercial or non-\/commercial, and by any means.}}
\DoxyCodeLine{704 \textcolor{comment}{In jurisdictions that recognize copyright laws, the author or authors of this}}
\DoxyCodeLine{705 \textcolor{comment}{software dedicate any and all copyright interest in the software to the public}}
\DoxyCodeLine{706 \textcolor{comment}{domain. We make this dedication for the benefit of the public at large and to}}
\DoxyCodeLine{707 \textcolor{comment}{the detriment of our heirs and successors. We intend this dedication to be an}}
\DoxyCodeLine{708 \textcolor{comment}{overt act of relinquishment in perpetuity of all present and future rights to}}
\DoxyCodeLine{709 \textcolor{comment}{this software under copyright law.}}
\DoxyCodeLine{710 \textcolor{comment}{THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{711 \textcolor{comment}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}}
\DoxyCodeLine{712 \textcolor{comment}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}}
\DoxyCodeLine{713 \textcolor{comment}{AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN}}
\DoxyCodeLine{714 \textcolor{comment}{ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION}}
\DoxyCodeLine{715 \textcolor{comment}{WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{716 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{717 \textcolor{comment}{*/}}

\end{DoxyCode}
