\hypertarget{dr__wav_8h_source}{}\doxysection{dr\+\_\+wav.\+h}
\label{dr__wav_8h_source}\index{build/\_deps/raylib-\/src/src/external/dr\_wav.h@{build/\_deps/raylib-\/src/src/external/dr\_wav.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{WAV audio loader and writer. Choice of public domain or MIT-\/0. See license statements at the end of this file.}}
\DoxyCodeLine{3 \textcolor{comment}{dr\_wav -\/ v0.13.4 -\/ 2021-\/12-\/08}}
\DoxyCodeLine{4 \textcolor{comment}{}}
\DoxyCodeLine{5 \textcolor{comment}{David Reid -\/ mackron@gmail.com}}
\DoxyCodeLine{6 \textcolor{comment}{}}
\DoxyCodeLine{7 \textcolor{comment}{GitHub: https://github.com/mackron/dr\_libs}}
\DoxyCodeLine{8 \textcolor{comment}{*/}}
\DoxyCodeLine{9 }
\DoxyCodeLine{10 \textcolor{comment}{/*}}
\DoxyCodeLine{11 \textcolor{comment}{Introduction}}
\DoxyCodeLine{12 \textcolor{comment}{============}}
\DoxyCodeLine{13 \textcolor{comment}{This is a single file library. To use it, do something like the following in one .c file.}}
\DoxyCodeLine{14 \textcolor{comment}{}}
\DoxyCodeLine{15 \textcolor{comment}{    ```c}}
\DoxyCodeLine{16 \textcolor{comment}{    \#define DR\_WAV\_IMPLEMENTATION}}
\DoxyCodeLine{17 \textcolor{comment}{    \#include "{}dr\_wav.h"{}}}
\DoxyCodeLine{18 \textcolor{comment}{    ```}}
\DoxyCodeLine{19 \textcolor{comment}{}}
\DoxyCodeLine{20 \textcolor{comment}{You can then \#include this file in other parts of the program as you would with any other header file. Do something like the following to read audio data:}}
\DoxyCodeLine{21 \textcolor{comment}{}}
\DoxyCodeLine{22 \textcolor{comment}{    ```c}}
\DoxyCodeLine{23 \textcolor{comment}{    drwav wav;}}
\DoxyCodeLine{24 \textcolor{comment}{    if (!drwav\_init\_file(\&wav, "{}my\_song.wav"{}, NULL)) \{}}
\DoxyCodeLine{25 \textcolor{comment}{        // Error opening WAV file.}}
\DoxyCodeLine{26 \textcolor{comment}{    \}}}
\DoxyCodeLine{27 \textcolor{comment}{}}
\DoxyCodeLine{28 \textcolor{comment}{    drwav\_int32* pDecodedInterleavedPCMFrames = malloc(wav.totalPCMFrameCount * wav.channels * sizeof(drwav\_int32));}}
\DoxyCodeLine{29 \textcolor{comment}{    size\_t numberOfSamplesActuallyDecoded = drwav\_read\_pcm\_frames\_s32(\&wav, wav.totalPCMFrameCount, pDecodedInterleavedPCMFrames);}}
\DoxyCodeLine{30 \textcolor{comment}{}}
\DoxyCodeLine{31 \textcolor{comment}{    ...}}
\DoxyCodeLine{32 \textcolor{comment}{}}
\DoxyCodeLine{33 \textcolor{comment}{    drwav\_uninit(\&wav);}}
\DoxyCodeLine{34 \textcolor{comment}{    ```}}
\DoxyCodeLine{35 \textcolor{comment}{}}
\DoxyCodeLine{36 \textcolor{comment}{If you just want to quickly open and read the audio data in a single operation you can do something like this:}}
\DoxyCodeLine{37 \textcolor{comment}{}}
\DoxyCodeLine{38 \textcolor{comment}{    ```c}}
\DoxyCodeLine{39 \textcolor{comment}{    unsigned int channels;}}
\DoxyCodeLine{40 \textcolor{comment}{    unsigned int sampleRate;}}
\DoxyCodeLine{41 \textcolor{comment}{    drwav\_uint64 totalPCMFrameCount;}}
\DoxyCodeLine{42 \textcolor{comment}{    float* pSampleData = drwav\_open\_file\_and\_read\_pcm\_frames\_f32("{}my\_song.wav"{}, \&channels, \&sampleRate, \&totalPCMFrameCount, NULL);}}
\DoxyCodeLine{43 \textcolor{comment}{    if (pSampleData == NULL) \{}}
\DoxyCodeLine{44 \textcolor{comment}{        // Error opening and reading WAV file.}}
\DoxyCodeLine{45 \textcolor{comment}{    \}}}
\DoxyCodeLine{46 \textcolor{comment}{}}
\DoxyCodeLine{47 \textcolor{comment}{    ...}}
\DoxyCodeLine{48 \textcolor{comment}{}}
\DoxyCodeLine{49 \textcolor{comment}{    drwav\_free(pSampleData, NULL);}}
\DoxyCodeLine{50 \textcolor{comment}{    ```}}
\DoxyCodeLine{51 \textcolor{comment}{}}
\DoxyCodeLine{52 \textcolor{comment}{The examples above use versions of the API that convert the audio data to a consistent format (32-\/bit signed PCM, in this case), but you can still output the}}
\DoxyCodeLine{53 \textcolor{comment}{audio data in its internal format (see notes below for supported formats):}}
\DoxyCodeLine{54 \textcolor{comment}{}}
\DoxyCodeLine{55 \textcolor{comment}{    ```c}}
\DoxyCodeLine{56 \textcolor{comment}{    size\_t framesRead = drwav\_read\_pcm\_frames(\&wav, wav.totalPCMFrameCount, pDecodedInterleavedPCMFrames);}}
\DoxyCodeLine{57 \textcolor{comment}{    ```}}
\DoxyCodeLine{58 \textcolor{comment}{}}
\DoxyCodeLine{59 \textcolor{comment}{You can also read the raw bytes of audio data, which could be useful if dr\_wav does not have native support for a particular data format:}}
\DoxyCodeLine{60 \textcolor{comment}{}}
\DoxyCodeLine{61 \textcolor{comment}{    ```c}}
\DoxyCodeLine{62 \textcolor{comment}{    size\_t bytesRead = drwav\_read\_raw(\&wav, bytesToRead, pRawDataBuffer);}}
\DoxyCodeLine{63 \textcolor{comment}{    ```}}
\DoxyCodeLine{64 \textcolor{comment}{}}
\DoxyCodeLine{65 \textcolor{comment}{dr\_wav can also be used to output WAV files. This does not currently support compressed formats. To use this, look at `drwav\_init\_write()`,}}
\DoxyCodeLine{66 \textcolor{comment}{`drwav\_init\_file\_write()`, etc. Use `drwav\_write\_pcm\_frames()` to write samples, or `drwav\_write\_raw()` to write raw data in the "{}data"{} chunk.}}
\DoxyCodeLine{67 \textcolor{comment}{}}
\DoxyCodeLine{68 \textcolor{comment}{    ```c}}
\DoxyCodeLine{69 \textcolor{comment}{    drwav\_data\_format format;}}
\DoxyCodeLine{70 \textcolor{comment}{    format.container = drwav\_container\_riff;     // <-\/-\/ drwav\_container\_riff = normal WAV files, drwav\_container\_w64 = Sony Wave64.}}
\DoxyCodeLine{71 \textcolor{comment}{    format.format = DR\_WAVE\_FORMAT\_PCM;          // <-\/-\/ Any of the DR\_WAVE\_FORMAT\_* codes.}}
\DoxyCodeLine{72 \textcolor{comment}{    format.channels = 2;}}
\DoxyCodeLine{73 \textcolor{comment}{    format.sampleRate = 44100;}}
\DoxyCodeLine{74 \textcolor{comment}{    format.bitsPerSample = 16;}}
\DoxyCodeLine{75 \textcolor{comment}{    drwav\_init\_file\_write(\&wav, "{}data/recording.wav"{}, \&format, NULL);}}
\DoxyCodeLine{76 \textcolor{comment}{}}
\DoxyCodeLine{77 \textcolor{comment}{    ...}}
\DoxyCodeLine{78 \textcolor{comment}{}}
\DoxyCodeLine{79 \textcolor{comment}{    drwav\_uint64 framesWritten = drwav\_write\_pcm\_frames(pWav, frameCount, pSamples);}}
\DoxyCodeLine{80 \textcolor{comment}{    ```}}
\DoxyCodeLine{81 \textcolor{comment}{}}
\DoxyCodeLine{82 \textcolor{comment}{dr\_wav has seamless support the Sony Wave64 format. The decoder will automatically detect it and it should Just Work without any manual intervention.}}
\DoxyCodeLine{83 \textcolor{comment}{}}
\DoxyCodeLine{84 \textcolor{comment}{}}
\DoxyCodeLine{85 \textcolor{comment}{Build Options}}
\DoxyCodeLine{86 \textcolor{comment}{=============}}
\DoxyCodeLine{87 \textcolor{comment}{\#define these options before including this file.}}
\DoxyCodeLine{88 \textcolor{comment}{}}
\DoxyCodeLine{89 \textcolor{comment}{\#define DR\_WAV\_NO\_CONVERSION\_API}}
\DoxyCodeLine{90 \textcolor{comment}{  Disables conversion APIs such as `drwav\_read\_pcm\_frames\_f32()` and `drwav\_s16\_to\_f32()`.}}
\DoxyCodeLine{91 \textcolor{comment}{}}
\DoxyCodeLine{92 \textcolor{comment}{\#define DR\_WAV\_NO\_STDIO}}
\DoxyCodeLine{93 \textcolor{comment}{  Disables APIs that initialize a decoder from a file such as `drwav\_init\_file()`, `drwav\_init\_file\_write()`, etc.}}
\DoxyCodeLine{94 \textcolor{comment}{}}
\DoxyCodeLine{95 \textcolor{comment}{}}
\DoxyCodeLine{96 \textcolor{comment}{}}
\DoxyCodeLine{97 \textcolor{comment}{Notes}}
\DoxyCodeLine{98 \textcolor{comment}{=====}}
\DoxyCodeLine{99 \textcolor{comment}{-\/ Samples are always interleaved.}}
\DoxyCodeLine{100 \textcolor{comment}{-\/ The default read function does not do any data conversion. Use `drwav\_read\_pcm\_frames\_f32()`, `drwav\_read\_pcm\_frames\_s32()` and `drwav\_read\_pcm\_frames\_s16()`}}
\DoxyCodeLine{101 \textcolor{comment}{  to read and convert audio data to 32-\/bit floating point, signed 32-\/bit integer and signed 16-\/bit integer samples respectively. Tested and supported internal}}
\DoxyCodeLine{102 \textcolor{comment}{  formats include the following:}}
\DoxyCodeLine{103 \textcolor{comment}{  -\/ Unsigned 8-\/bit PCM}}
\DoxyCodeLine{104 \textcolor{comment}{  -\/ Signed 12-\/bit PCM}}
\DoxyCodeLine{105 \textcolor{comment}{  -\/ Signed 16-\/bit PCM}}
\DoxyCodeLine{106 \textcolor{comment}{  -\/ Signed 24-\/bit PCM}}
\DoxyCodeLine{107 \textcolor{comment}{  -\/ Signed 32-\/bit PCM}}
\DoxyCodeLine{108 \textcolor{comment}{  -\/ IEEE 32-\/bit floating point}}
\DoxyCodeLine{109 \textcolor{comment}{  -\/ IEEE 64-\/bit floating point}}
\DoxyCodeLine{110 \textcolor{comment}{  -\/ A-\/law and u-\/law}}
\DoxyCodeLine{111 \textcolor{comment}{  -\/ Microsoft ADPCM}}
\DoxyCodeLine{112 \textcolor{comment}{  -\/ IMA ADPCM (DVI, format code 0x11)}}
\DoxyCodeLine{113 \textcolor{comment}{-\/ dr\_wav will try to read the WAV file as best it can, even if it's not strictly conformant to the WAV format.}}
\DoxyCodeLine{114 \textcolor{comment}{*/}}
\DoxyCodeLine{115 }
\DoxyCodeLine{116 \textcolor{preprocessor}{\#ifndef dr\_wav\_h}}
\DoxyCodeLine{117 \textcolor{preprocessor}{\#define dr\_wav\_h}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{120 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \{}
\DoxyCodeLine{121 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123 \textcolor{preprocessor}{\#define DRWAV\_STRINGIFY(x)      \#x}}
\DoxyCodeLine{124 \textcolor{preprocessor}{\#define DRWAV\_XSTRINGIFY(x)     DRWAV\_STRINGIFY(x)}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{preprocessor}{\#define DRWAV\_VERSION\_MAJOR     0}}
\DoxyCodeLine{127 \textcolor{preprocessor}{\#define DRWAV\_VERSION\_MINOR     13}}
\DoxyCodeLine{128 \textcolor{preprocessor}{\#define DRWAV\_VERSION\_REVISION  4}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#define DRWAV\_VERSION\_STRING    DRWAV\_XSTRINGIFY(DRWAV\_VERSION\_MAJOR) "{}."{}} DRWAV\_XSTRINGIFY(DRWAV\_VERSION\_MINOR) "{}."{} DRWAV\_XSTRINGIFY(DRWAV\_VERSION\_REVISION)}
\DoxyCodeLine{130 }
\DoxyCodeLine{131 \textcolor{preprocessor}{\#include <stddef.h>} \textcolor{comment}{/* For size\_t. */}}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{comment}{/* Sized types. */}}
\DoxyCodeLine{134 \textcolor{keyword}{typedef}   \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}           drwav\_int8;}
\DoxyCodeLine{135 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}           drwav\_uint8;}
\DoxyCodeLine{136 \textcolor{keyword}{typedef}   \textcolor{keywordtype}{signed} \textcolor{keywordtype}{short}          drwav\_int16;}
\DoxyCodeLine{137 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}          drwav\_uint16;}
\DoxyCodeLine{138 \textcolor{keyword}{typedef}   \textcolor{keywordtype}{signed} \textcolor{keywordtype}{int}            drwav\_int32;}
\DoxyCodeLine{139 \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}            drwav\_uint32;}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#if defined(\_MSC\_VER) \&\& !defined(\_\_clang\_\_)}}
\DoxyCodeLine{141     \textcolor{keyword}{typedef}   \textcolor{keywordtype}{signed} \_\_int64    drwav\_int64;}
\DoxyCodeLine{142     \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \_\_int64    drwav\_uint64;}
\DoxyCodeLine{143 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{144 \textcolor{preprocessor}{    \#if defined(\_\_clang\_\_) || (defined(\_\_GNUC\_\_) \&\& (\_\_GNUC\_\_ > 4 || (\_\_GNUC\_\_ == 4 \&\& \_\_GNUC\_MINOR\_\_ >= 6)))}}
\DoxyCodeLine{145 \textcolor{preprocessor}{        \#pragma GCC diagnostic push}}
\DoxyCodeLine{146 \textcolor{preprocessor}{        \#pragma GCC diagnostic ignored "{}-\/Wlong-\/long"{}}}
\DoxyCodeLine{147 \textcolor{preprocessor}{        \#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{148 \textcolor{preprocessor}{            \#pragma GCC diagnostic ignored "{}-\/Wc++11-\/long-\/long"{}}}
\DoxyCodeLine{149 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{150 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{151     \textcolor{keyword}{typedef}   \textcolor{keywordtype}{signed} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}  drwav\_int64;}
\DoxyCodeLine{152     \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}  drwav\_uint64;}
\DoxyCodeLine{153 \textcolor{preprocessor}{    \#if defined(\_\_clang\_\_) || (defined(\_\_GNUC\_\_) \&\& (\_\_GNUC\_\_ > 4 || (\_\_GNUC\_\_ == 4 \&\& \_\_GNUC\_MINOR\_\_ >= 6)))}}
\DoxyCodeLine{154 \textcolor{preprocessor}{        \#pragma GCC diagnostic pop}}
\DoxyCodeLine{155 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{156 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{157 \textcolor{preprocessor}{\#if defined(\_\_LP64\_\_) || defined(\_WIN64) || (defined(\_\_x86\_64\_\_) \&\& !defined(\_\_ILP32\_\_)) || defined(\_M\_X64) || defined(\_\_ia64) || defined (\_M\_IA64) || defined(\_\_aarch64\_\_) || defined(\_M\_ARM64) || defined(\_\_powerpc64\_\_)}}
\DoxyCodeLine{158     \textcolor{keyword}{typedef} drwav\_uint64        drwav\_uintptr;}
\DoxyCodeLine{159 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{160     \textcolor{keyword}{typedef} drwav\_uint32        drwav\_uintptr;}
\DoxyCodeLine{161 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{162 \textcolor{keyword}{typedef} drwav\_uint8             drwav\_bool8;}
\DoxyCodeLine{163 \textcolor{keyword}{typedef} drwav\_uint32            drwav\_bool32;}
\DoxyCodeLine{164 \textcolor{preprocessor}{\#define DRWAV\_TRUE              1}}
\DoxyCodeLine{165 \textcolor{preprocessor}{\#define DRWAV\_FALSE             0}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \textcolor{preprocessor}{\#if !defined(DRWAV\_API)}}
\DoxyCodeLine{168 \textcolor{preprocessor}{    \#if defined(DRWAV\_DLL)}}
\DoxyCodeLine{169 \textcolor{preprocessor}{        \#if defined(\_WIN32)}}
\DoxyCodeLine{170 \textcolor{preprocessor}{            \#define DRWAV\_DLL\_IMPORT  \_\_declspec(dllimport)}}
\DoxyCodeLine{171 \textcolor{preprocessor}{            \#define DRWAV\_DLL\_EXPORT  \_\_declspec(dllexport)}}
\DoxyCodeLine{172 \textcolor{preprocessor}{            \#define DRWAV\_DLL\_PRIVATE static}}
\DoxyCodeLine{173 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{174 \textcolor{preprocessor}{            \#if defined(\_\_GNUC\_\_) \&\& \_\_GNUC\_\_ >= 4}}
\DoxyCodeLine{175 \textcolor{preprocessor}{                \#define DRWAV\_DLL\_IMPORT  \_\_attribute\_\_((visibility("{}default"{}})))}
\DoxyCodeLine{176 \textcolor{preprocessor}{                \#define DRWAV\_DLL\_EXPORT  \_\_attribute\_\_((visibility("{}default"{}})))}
\DoxyCodeLine{177 \textcolor{preprocessor}{                \#define DRWAV\_DLL\_PRIVATE \_\_attribute\_\_((visibility("{}hidden"{}})))}
\DoxyCodeLine{178 \textcolor{preprocessor}{            \#else}}
\DoxyCodeLine{179 \textcolor{preprocessor}{                \#define DRWAV\_DLL\_IMPORT}}
\DoxyCodeLine{180 \textcolor{preprocessor}{                \#define DRWAV\_DLL\_EXPORT}}
\DoxyCodeLine{181 \textcolor{preprocessor}{                \#define DRWAV\_DLL\_PRIVATE static}}
\DoxyCodeLine{182 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{183 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 \textcolor{preprocessor}{        \#if defined(DR\_WAV\_IMPLEMENTATION) || defined(DRWAV\_IMPLEMENTATION)}}
\DoxyCodeLine{186 \textcolor{preprocessor}{            \#define DRWAV\_API  DRWAV\_DLL\_EXPORT}}
\DoxyCodeLine{187 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{188 \textcolor{preprocessor}{            \#define DRWAV\_API  DRWAV\_DLL\_IMPORT}}
\DoxyCodeLine{189 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{190 \textcolor{preprocessor}{        \#define DRWAV\_PRIVATE DRWAV\_DLL\_PRIVATE}}
\DoxyCodeLine{191 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{192 \textcolor{preprocessor}{        \#define DRWAV\_API extern}}
\DoxyCodeLine{193 \textcolor{preprocessor}{        \#define DRWAV\_PRIVATE static}}
\DoxyCodeLine{194 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{195 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 \textcolor{keyword}{typedef} drwav\_int32 drwav\_result;}
\DoxyCodeLine{198 \textcolor{preprocessor}{\#define DRWAV\_SUCCESS                        0}}
\DoxyCodeLine{199 \textcolor{preprocessor}{\#define DRWAV\_ERROR                         -\/1   }\textcolor{comment}{/* A generic error. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{200 \textcolor{preprocessor}{\#define DRWAV\_INVALID\_ARGS                  -\/2}}
\DoxyCodeLine{201 \textcolor{preprocessor}{\#define DRWAV\_INVALID\_OPERATION             -\/3}}
\DoxyCodeLine{202 \textcolor{preprocessor}{\#define DRWAV\_OUT\_OF\_MEMORY                 -\/4}}
\DoxyCodeLine{203 \textcolor{preprocessor}{\#define DRWAV\_OUT\_OF\_RANGE                  -\/5}}
\DoxyCodeLine{204 \textcolor{preprocessor}{\#define DRWAV\_ACCESS\_DENIED                 -\/6}}
\DoxyCodeLine{205 \textcolor{preprocessor}{\#define DRWAV\_DOES\_NOT\_EXIST                -\/7}}
\DoxyCodeLine{206 \textcolor{preprocessor}{\#define DRWAV\_ALREADY\_EXISTS                -\/8}}
\DoxyCodeLine{207 \textcolor{preprocessor}{\#define DRWAV\_TOO\_MANY\_OPEN\_FILES           -\/9}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\#define DRWAV\_INVALID\_FILE                  -\/10}}
\DoxyCodeLine{209 \textcolor{preprocessor}{\#define DRWAV\_TOO\_BIG                       -\/11}}
\DoxyCodeLine{210 \textcolor{preprocessor}{\#define DRWAV\_PATH\_TOO\_LONG                 -\/12}}
\DoxyCodeLine{211 \textcolor{preprocessor}{\#define DRWAV\_NAME\_TOO\_LONG                 -\/13}}
\DoxyCodeLine{212 \textcolor{preprocessor}{\#define DRWAV\_NOT\_DIRECTORY                 -\/14}}
\DoxyCodeLine{213 \textcolor{preprocessor}{\#define DRWAV\_IS\_DIRECTORY                  -\/15}}
\DoxyCodeLine{214 \textcolor{preprocessor}{\#define DRWAV\_DIRECTORY\_NOT\_EMPTY           -\/16}}
\DoxyCodeLine{215 \textcolor{preprocessor}{\#define DRWAV\_END\_OF\_FILE                   -\/17}}
\DoxyCodeLine{216 \textcolor{preprocessor}{\#define DRWAV\_NO\_SPACE                      -\/18}}
\DoxyCodeLine{217 \textcolor{preprocessor}{\#define DRWAV\_BUSY                          -\/19}}
\DoxyCodeLine{218 \textcolor{preprocessor}{\#define DRWAV\_IO\_ERROR                      -\/20}}
\DoxyCodeLine{219 \textcolor{preprocessor}{\#define DRWAV\_INTERRUPT                     -\/21}}
\DoxyCodeLine{220 \textcolor{preprocessor}{\#define DRWAV\_UNAVAILABLE                   -\/22}}
\DoxyCodeLine{221 \textcolor{preprocessor}{\#define DRWAV\_ALREADY\_IN\_USE                -\/23}}
\DoxyCodeLine{222 \textcolor{preprocessor}{\#define DRWAV\_BAD\_ADDRESS                   -\/24}}
\DoxyCodeLine{223 \textcolor{preprocessor}{\#define DRWAV\_BAD\_SEEK                      -\/25}}
\DoxyCodeLine{224 \textcolor{preprocessor}{\#define DRWAV\_BAD\_PIPE                      -\/26}}
\DoxyCodeLine{225 \textcolor{preprocessor}{\#define DRWAV\_DEADLOCK                      -\/27}}
\DoxyCodeLine{226 \textcolor{preprocessor}{\#define DRWAV\_TOO\_MANY\_LINKS                -\/28}}
\DoxyCodeLine{227 \textcolor{preprocessor}{\#define DRWAV\_NOT\_IMPLEMENTED               -\/29}}
\DoxyCodeLine{228 \textcolor{preprocessor}{\#define DRWAV\_NO\_MESSAGE                    -\/30}}
\DoxyCodeLine{229 \textcolor{preprocessor}{\#define DRWAV\_BAD\_MESSAGE                   -\/31}}
\DoxyCodeLine{230 \textcolor{preprocessor}{\#define DRWAV\_NO\_DATA\_AVAILABLE             -\/32}}
\DoxyCodeLine{231 \textcolor{preprocessor}{\#define DRWAV\_INVALID\_DATA                  -\/33}}
\DoxyCodeLine{232 \textcolor{preprocessor}{\#define DRWAV\_TIMEOUT                       -\/34}}
\DoxyCodeLine{233 \textcolor{preprocessor}{\#define DRWAV\_NO\_NETWORK                    -\/35}}
\DoxyCodeLine{234 \textcolor{preprocessor}{\#define DRWAV\_NOT\_UNIQUE                    -\/36}}
\DoxyCodeLine{235 \textcolor{preprocessor}{\#define DRWAV\_NOT\_SOCKET                    -\/37}}
\DoxyCodeLine{236 \textcolor{preprocessor}{\#define DRWAV\_NO\_ADDRESS                    -\/38}}
\DoxyCodeLine{237 \textcolor{preprocessor}{\#define DRWAV\_BAD\_PROTOCOL                  -\/39}}
\DoxyCodeLine{238 \textcolor{preprocessor}{\#define DRWAV\_PROTOCOL\_UNAVAILABLE          -\/40}}
\DoxyCodeLine{239 \textcolor{preprocessor}{\#define DRWAV\_PROTOCOL\_NOT\_SUPPORTED        -\/41}}
\DoxyCodeLine{240 \textcolor{preprocessor}{\#define DRWAV\_PROTOCOL\_FAMILY\_NOT\_SUPPORTED -\/42}}
\DoxyCodeLine{241 \textcolor{preprocessor}{\#define DRWAV\_ADDRESS\_FAMILY\_NOT\_SUPPORTED  -\/43}}
\DoxyCodeLine{242 \textcolor{preprocessor}{\#define DRWAV\_SOCKET\_NOT\_SUPPORTED          -\/44}}
\DoxyCodeLine{243 \textcolor{preprocessor}{\#define DRWAV\_CONNECTION\_RESET              -\/45}}
\DoxyCodeLine{244 \textcolor{preprocessor}{\#define DRWAV\_ALREADY\_CONNECTED             -\/46}}
\DoxyCodeLine{245 \textcolor{preprocessor}{\#define DRWAV\_NOT\_CONNECTED                 -\/47}}
\DoxyCodeLine{246 \textcolor{preprocessor}{\#define DRWAV\_CONNECTION\_REFUSED            -\/48}}
\DoxyCodeLine{247 \textcolor{preprocessor}{\#define DRWAV\_NO\_HOST                       -\/49}}
\DoxyCodeLine{248 \textcolor{preprocessor}{\#define DRWAV\_IN\_PROGRESS                   -\/50}}
\DoxyCodeLine{249 \textcolor{preprocessor}{\#define DRWAV\_CANCELLED                     -\/51}}
\DoxyCodeLine{250 \textcolor{preprocessor}{\#define DRWAV\_MEMORY\_ALREADY\_MAPPED         -\/52}}
\DoxyCodeLine{251 \textcolor{preprocessor}{\#define DRWAV\_AT\_END                        -\/53}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253 \textcolor{comment}{/* Common data formats. */}}
\DoxyCodeLine{254 \textcolor{preprocessor}{\#define DR\_WAVE\_FORMAT\_PCM          0x1}}
\DoxyCodeLine{255 \textcolor{preprocessor}{\#define DR\_WAVE\_FORMAT\_ADPCM        0x2}}
\DoxyCodeLine{256 \textcolor{preprocessor}{\#define DR\_WAVE\_FORMAT\_IEEE\_FLOAT   0x3}}
\DoxyCodeLine{257 \textcolor{preprocessor}{\#define DR\_WAVE\_FORMAT\_ALAW         0x6}}
\DoxyCodeLine{258 \textcolor{preprocessor}{\#define DR\_WAVE\_FORMAT\_MULAW        0x7}}
\DoxyCodeLine{259 \textcolor{preprocessor}{\#define DR\_WAVE\_FORMAT\_DVI\_ADPCM    0x11}}
\DoxyCodeLine{260 \textcolor{preprocessor}{\#define DR\_WAVE\_FORMAT\_EXTENSIBLE   0xFFFE}}
\DoxyCodeLine{261 }
\DoxyCodeLine{262 \textcolor{comment}{/* Flags to pass into drwav\_init\_ex(), etc. */}}
\DoxyCodeLine{263 \textcolor{preprocessor}{\#define DRWAV\_SEQUENTIAL            0x00000001}}
\DoxyCodeLine{264 }
\DoxyCodeLine{265 DRWAV\_API \textcolor{keywordtype}{void} drwav\_version(drwav\_uint32* pMajor, drwav\_uint32* pMinor, drwav\_uint32* pRevision);}
\DoxyCodeLine{266 DRWAV\_API \textcolor{keyword}{const} \textcolor{keywordtype}{char}* drwav\_version\_string(\textcolor{keywordtype}{void});}
\DoxyCodeLine{267 }
\DoxyCodeLine{268 \textcolor{keyword}{typedef} \textcolor{keyword}{enum}}
\DoxyCodeLine{269 \{}
\DoxyCodeLine{270     drwav\_seek\_origin\_start,}
\DoxyCodeLine{271     drwav\_seek\_origin\_current}
\DoxyCodeLine{272 \} drwav\_seek\_origin;}
\DoxyCodeLine{273 }
\DoxyCodeLine{274 \textcolor{keyword}{typedef} \textcolor{keyword}{enum}}
\DoxyCodeLine{275 \{}
\DoxyCodeLine{276     drwav\_container\_riff,}
\DoxyCodeLine{277     drwav\_container\_w64,}
\DoxyCodeLine{278     drwav\_container\_rf64}
\DoxyCodeLine{279 \} drwav\_container;}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{282 \{}
\DoxyCodeLine{283     \textcolor{keyword}{union}}
\DoxyCodeLine{284     \{}
\DoxyCodeLine{285         drwav\_uint8 fourcc[4];}
\DoxyCodeLine{286         drwav\_uint8 guid[16];}
\DoxyCodeLine{287     \} id;}
\DoxyCodeLine{288 }
\DoxyCodeLine{289     \textcolor{comment}{/* The size in bytes of the chunk. */}}
\DoxyCodeLine{290     drwav\_uint64 sizeInBytes;}
\DoxyCodeLine{291 }
\DoxyCodeLine{292     \textcolor{comment}{/*}}
\DoxyCodeLine{293 \textcolor{comment}{    RIFF = 2 byte alignment.}}
\DoxyCodeLine{294 \textcolor{comment}{    W64  = 8 byte alignment.}}
\DoxyCodeLine{295 \textcolor{comment}{    */}}
\DoxyCodeLine{296     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} paddingSize;}
\DoxyCodeLine{297 \} \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}};}
\DoxyCodeLine{298 }
\DoxyCodeLine{299 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{300 \{}
\DoxyCodeLine{301     \textcolor{comment}{/*}}
\DoxyCodeLine{302 \textcolor{comment}{    The format tag exactly as specified in the wave file's "{}fmt"{} chunk. This can be used by applications}}
\DoxyCodeLine{303 \textcolor{comment}{    that require support for data formats not natively supported by dr\_wav.}}
\DoxyCodeLine{304 \textcolor{comment}{    */}}
\DoxyCodeLine{305     drwav\_uint16 formatTag;}
\DoxyCodeLine{306 }
\DoxyCodeLine{307     \textcolor{comment}{/* The number of channels making up the audio data. When this is set to 1 it is mono, 2 is stereo, etc. */}}
\DoxyCodeLine{308     drwav\_uint16 channels;}
\DoxyCodeLine{309 }
\DoxyCodeLine{310     \textcolor{comment}{/* The sample rate. Usually set to something like 44100. */}}
\DoxyCodeLine{311     drwav\_uint32 sampleRate;}
\DoxyCodeLine{312 }
\DoxyCodeLine{313     \textcolor{comment}{/* Average bytes per second. You probably don't need this, but it's left here for informational purposes. */}}
\DoxyCodeLine{314     drwav\_uint32 avgBytesPerSec;}
\DoxyCodeLine{315 }
\DoxyCodeLine{316     \textcolor{comment}{/* Block align. This is equal to the number of channels * bytes per sample. */}}
\DoxyCodeLine{317     drwav\_uint16 blockAlign;}
\DoxyCodeLine{318 }
\DoxyCodeLine{319     \textcolor{comment}{/* Bits per sample. */}}
\DoxyCodeLine{320     drwav\_uint16 bitsPerSample;}
\DoxyCodeLine{321 }
\DoxyCodeLine{322     \textcolor{comment}{/* The size of the extended data. Only used internally for validation, but left here for informational purposes. */}}
\DoxyCodeLine{323     drwav\_uint16 extendedSize;}
\DoxyCodeLine{324 }
\DoxyCodeLine{325     \textcolor{comment}{/*}}
\DoxyCodeLine{326 \textcolor{comment}{    The number of valid bits per sample. When <formatTag> is equal to WAVE\_FORMAT\_EXTENSIBLE, <bitsPerSample>}}
\DoxyCodeLine{327 \textcolor{comment}{    is always rounded up to the nearest multiple of 8. This variable contains information about exactly how}}
\DoxyCodeLine{328 \textcolor{comment}{    many bits are valid per sample. Mainly used for informational purposes.}}
\DoxyCodeLine{329 \textcolor{comment}{    */}}
\DoxyCodeLine{330     drwav\_uint16 validBitsPerSample;}
\DoxyCodeLine{331 }
\DoxyCodeLine{332     \textcolor{comment}{/* The channel mask. Not used at the moment. */}}
\DoxyCodeLine{333     drwav\_uint32 channelMask;}
\DoxyCodeLine{334 }
\DoxyCodeLine{335     \textcolor{comment}{/* The sub-\/format, exactly as specified by the wave file. */}}
\DoxyCodeLine{336     drwav\_uint8 subFormat[16];}
\DoxyCodeLine{337 \} \mbox{\hyperlink{structdrwav__fmt}{drwav\_fmt}};}
\DoxyCodeLine{338 }
\DoxyCodeLine{339 DRWAV\_API drwav\_uint16 drwav\_fmt\_get\_format(\textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__fmt}{drwav\_fmt}}* pFMT);}
\DoxyCodeLine{340 }
\DoxyCodeLine{341 }
\DoxyCodeLine{342 \textcolor{comment}{/*}}
\DoxyCodeLine{343 \textcolor{comment}{Callback for when data is read. Return value is the number of bytes actually read.}}
\DoxyCodeLine{344 \textcolor{comment}{}}
\DoxyCodeLine{345 \textcolor{comment}{pUserData   [in]  The user data that was passed to drwav\_init() and family.}}
\DoxyCodeLine{346 \textcolor{comment}{pBufferOut  [out] The output buffer.}}
\DoxyCodeLine{347 \textcolor{comment}{bytesToRead [in]  The number of bytes to read.}}
\DoxyCodeLine{348 \textcolor{comment}{}}
\DoxyCodeLine{349 \textcolor{comment}{Returns the number of bytes actually read.}}
\DoxyCodeLine{350 \textcolor{comment}{}}
\DoxyCodeLine{351 \textcolor{comment}{A return value of less than bytesToRead indicates the end of the stream. Do \_not\_ return from this callback until}}
\DoxyCodeLine{352 \textcolor{comment}{either the entire bytesToRead is filled or you have reached the end of the stream.}}
\DoxyCodeLine{353 \textcolor{comment}{*/}}
\DoxyCodeLine{354 \textcolor{keyword}{typedef} size\_t (* drwav\_read\_proc)(\textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{void}* pBufferOut, \textcolor{keywordtype}{size\_t} bytesToRead);}
\DoxyCodeLine{355 }
\DoxyCodeLine{356 \textcolor{comment}{/*}}
\DoxyCodeLine{357 \textcolor{comment}{Callback for when data is written. Returns value is the number of bytes actually written.}}
\DoxyCodeLine{358 \textcolor{comment}{}}
\DoxyCodeLine{359 \textcolor{comment}{pUserData    [in]  The user data that was passed to drwav\_init\_write() and family.}}
\DoxyCodeLine{360 \textcolor{comment}{pData        [out] A pointer to the data to write.}}
\DoxyCodeLine{361 \textcolor{comment}{bytesToWrite [in]  The number of bytes to write.}}
\DoxyCodeLine{362 \textcolor{comment}{}}
\DoxyCodeLine{363 \textcolor{comment}{Returns the number of bytes actually written.}}
\DoxyCodeLine{364 \textcolor{comment}{}}
\DoxyCodeLine{365 \textcolor{comment}{If the return value differs from bytesToWrite, it indicates an error.}}
\DoxyCodeLine{366 \textcolor{comment}{*/}}
\DoxyCodeLine{367 \textcolor{keyword}{typedef} size\_t (* drwav\_write\_proc)(\textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData, \textcolor{keywordtype}{size\_t} bytesToWrite);}
\DoxyCodeLine{368 }
\DoxyCodeLine{369 \textcolor{comment}{/*}}
\DoxyCodeLine{370 \textcolor{comment}{Callback for when data needs to be seeked.}}
\DoxyCodeLine{371 \textcolor{comment}{}}
\DoxyCodeLine{372 \textcolor{comment}{pUserData [in] The user data that was passed to drwav\_init() and family.}}
\DoxyCodeLine{373 \textcolor{comment}{offset    [in] The number of bytes to move, relative to the origin. Will never be negative.}}
\DoxyCodeLine{374 \textcolor{comment}{origin    [in] The origin of the seek -\/ the current position or the start of the stream.}}
\DoxyCodeLine{375 \textcolor{comment}{}}
\DoxyCodeLine{376 \textcolor{comment}{Returns whether or not the seek was successful.}}
\DoxyCodeLine{377 \textcolor{comment}{}}
\DoxyCodeLine{378 \textcolor{comment}{Whether or not it is relative to the beginning or current position is determined by the "{}origin"{} parameter which will be either drwav\_seek\_origin\_start or}}
\DoxyCodeLine{379 \textcolor{comment}{drwav\_seek\_origin\_current.}}
\DoxyCodeLine{380 \textcolor{comment}{*/}}
\DoxyCodeLine{381 \textcolor{keyword}{typedef} drwav\_bool32 (* drwav\_seek\_proc)(\textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{int} offset, drwav\_seek\_origin origin);}
\DoxyCodeLine{382 }
\DoxyCodeLine{383 \textcolor{comment}{/*}}
\DoxyCodeLine{384 \textcolor{comment}{Callback for when drwav\_init\_ex() finds a chunk.}}
\DoxyCodeLine{385 \textcolor{comment}{}}
\DoxyCodeLine{386 \textcolor{comment}{pChunkUserData    [in] The user data that was passed to the pChunkUserData parameter of drwav\_init\_ex() and family.}}
\DoxyCodeLine{387 \textcolor{comment}{onRead            [in] A pointer to the function to call when reading.}}
\DoxyCodeLine{388 \textcolor{comment}{onSeek            [in] A pointer to the function to call when seeking.}}
\DoxyCodeLine{389 \textcolor{comment}{pReadSeekUserData [in] The user data that was passed to the pReadSeekUserData parameter of drwav\_init\_ex() and family.}}
\DoxyCodeLine{390 \textcolor{comment}{pChunkHeader      [in] A pointer to an object containing basic header information about the chunk. Use this to identify the chunk.}}
\DoxyCodeLine{391 \textcolor{comment}{container         [in] Whether or not the WAV file is a RIFF or Wave64 container. If you're unsure of the difference, assume RIFF.}}
\DoxyCodeLine{392 \textcolor{comment}{pFMT              [in] A pointer to the object containing the contents of the "{}fmt"{} chunk.}}
\DoxyCodeLine{393 \textcolor{comment}{}}
\DoxyCodeLine{394 \textcolor{comment}{Returns the number of bytes read + seeked.}}
\DoxyCodeLine{395 \textcolor{comment}{}}
\DoxyCodeLine{396 \textcolor{comment}{To read data from the chunk, call onRead(), passing in pReadSeekUserData as the first parameter. Do the same for seeking with onSeek(). The return value must}}
\DoxyCodeLine{397 \textcolor{comment}{be the total number of bytes you have read \_plus\_ seeked.}}
\DoxyCodeLine{398 \textcolor{comment}{}}
\DoxyCodeLine{399 \textcolor{comment}{Use the `container` argument to discriminate the fields in `pChunkHeader-\/>id`. If the container is `drwav\_container\_riff` or `drwav\_container\_rf64` you should}}
\DoxyCodeLine{400 \textcolor{comment}{use `id.fourcc`, otherwise you should use `id.guid`.}}
\DoxyCodeLine{401 \textcolor{comment}{}}
\DoxyCodeLine{402 \textcolor{comment}{The `pFMT` parameter can be used to determine the data format of the wave file. Use `drwav\_fmt\_get\_format()` to get the sample format, which will be one of the}}
\DoxyCodeLine{403 \textcolor{comment}{`DR\_WAVE\_FORMAT\_*` identifiers.}}
\DoxyCodeLine{404 \textcolor{comment}{}}
\DoxyCodeLine{405 \textcolor{comment}{The read pointer will be sitting on the first byte after the chunk's header. You must not attempt to read beyond the boundary of the chunk.}}
\DoxyCodeLine{406 \textcolor{comment}{*/}}
\DoxyCodeLine{407 \textcolor{keyword}{typedef} drwav\_uint64 (* drwav\_chunk\_proc)(\textcolor{keywordtype}{void}* pChunkUserData, drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pReadSeekUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}}* pChunkHeader, drwav\_container container, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__fmt}{drwav\_fmt}}* pFMT);}
\DoxyCodeLine{408 }
\DoxyCodeLine{409 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{410 \{}
\DoxyCodeLine{411     \textcolor{keywordtype}{void}* pUserData;}
\DoxyCodeLine{412     \textcolor{keywordtype}{void}* (* onMalloc)(\textcolor{keywordtype}{size\_t} sz, \textcolor{keywordtype}{void}* pUserData);}
\DoxyCodeLine{413     \textcolor{keywordtype}{void}* (* onRealloc)(\textcolor{keywordtype}{void}* p, \textcolor{keywordtype}{size\_t} sz, \textcolor{keywordtype}{void}* pUserData);}
\DoxyCodeLine{414     void  (* onFree)(\textcolor{keywordtype}{void}* p, \textcolor{keywordtype}{void}* pUserData);}
\DoxyCodeLine{415 \} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}};}
\DoxyCodeLine{416 }
\DoxyCodeLine{417 \textcolor{comment}{/* Structure for internal use. Only used for loaders opened with drwav\_init\_memory(). */}}
\DoxyCodeLine{418 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{419 \{}
\DoxyCodeLine{420     \textcolor{keyword}{const} drwav\_uint8* data;}
\DoxyCodeLine{421     \textcolor{keywordtype}{size\_t} dataSize;}
\DoxyCodeLine{422     \textcolor{keywordtype}{size\_t} currentReadPos;}
\DoxyCodeLine{423 \} \mbox{\hyperlink{structdrwav____memory__stream}{drwav\_\_memory\_stream}};}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{comment}{/* Structure for internal use. Only used for writers opened with drwav\_init\_memory\_write(). */}}
\DoxyCodeLine{426 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{427 \{}
\DoxyCodeLine{428     \textcolor{keywordtype}{void}** ppData;}
\DoxyCodeLine{429     \textcolor{keywordtype}{size\_t}* pDataSize;}
\DoxyCodeLine{430     \textcolor{keywordtype}{size\_t} dataSize;}
\DoxyCodeLine{431     \textcolor{keywordtype}{size\_t} dataCapacity;}
\DoxyCodeLine{432     \textcolor{keywordtype}{size\_t} currentWritePos;}
\DoxyCodeLine{433 \} \mbox{\hyperlink{structdrwav____memory__stream__write}{drwav\_\_memory\_stream\_write}};}
\DoxyCodeLine{434 }
\DoxyCodeLine{435 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{436 \{}
\DoxyCodeLine{437     drwav\_container container;  \textcolor{comment}{/* RIFF, W64. */}}
\DoxyCodeLine{438     drwav\_uint32 format;        \textcolor{comment}{/* DR\_WAVE\_FORMAT\_* */}}
\DoxyCodeLine{439     drwav\_uint32 channels;}
\DoxyCodeLine{440     drwav\_uint32 sampleRate;}
\DoxyCodeLine{441     drwav\_uint32 bitsPerSample;}
\DoxyCodeLine{442 \} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}};}
\DoxyCodeLine{443 }
\DoxyCodeLine{444 \textcolor{keyword}{typedef} \textcolor{keyword}{enum}}
\DoxyCodeLine{445 \{}
\DoxyCodeLine{446     drwav\_metadata\_type\_none                        = 0,}
\DoxyCodeLine{447 }
\DoxyCodeLine{448     \textcolor{comment}{/*}}
\DoxyCodeLine{449 \textcolor{comment}{    Unknown simply means a chunk that drwav does not handle specifically. You can still ask to}}
\DoxyCodeLine{450 \textcolor{comment}{    receive these chunks as metadata objects. It is then up to you to interpret the chunk's data.}}
\DoxyCodeLine{451 \textcolor{comment}{    You can also write unknown metadata to a wav file. Be careful writing unknown chunks if you}}
\DoxyCodeLine{452 \textcolor{comment}{    have also edited the audio data. The unknown chunks could represent offsets/sizes that no}}
\DoxyCodeLine{453 \textcolor{comment}{    longer correctly correspond to the audio data.}}
\DoxyCodeLine{454 \textcolor{comment}{    */}}
\DoxyCodeLine{455     drwav\_metadata\_type\_unknown                     = 1 << 0,}
\DoxyCodeLine{456 }
\DoxyCodeLine{457     \textcolor{comment}{/* Only 1 of each of these metadata items are allowed in a wav file. */}}
\DoxyCodeLine{458     drwav\_metadata\_type\_smpl                        = 1 << 1,}
\DoxyCodeLine{459     drwav\_metadata\_type\_inst                        = 1 << 2,}
\DoxyCodeLine{460     drwav\_metadata\_type\_cue                         = 1 << 3,}
\DoxyCodeLine{461     drwav\_metadata\_type\_acid                        = 1 << 4,}
\DoxyCodeLine{462     drwav\_metadata\_type\_bext                        = 1 << 5,}
\DoxyCodeLine{463 }
\DoxyCodeLine{464     \textcolor{comment}{/*}}
\DoxyCodeLine{465 \textcolor{comment}{    Wav files often have a LIST chunk. This is a chunk that contains a set of subchunks. For this}}
\DoxyCodeLine{466 \textcolor{comment}{    higher-\/level metadata API, we don't make a distinction between a regular chunk and a LIST}}
\DoxyCodeLine{467 \textcolor{comment}{    subchunk. Instead, they are all just 'metadata' items.}}
\DoxyCodeLine{468 \textcolor{comment}{}}
\DoxyCodeLine{469 \textcolor{comment}{    There can be multiple of these metadata items in a wav file.}}
\DoxyCodeLine{470 \textcolor{comment}{    */}}
\DoxyCodeLine{471     drwav\_metadata\_type\_list\_label                  = 1 << 6,}
\DoxyCodeLine{472     drwav\_metadata\_type\_list\_note                   = 1 << 7,}
\DoxyCodeLine{473     drwav\_metadata\_type\_list\_labelled\_cue\_region    = 1 << 8,}
\DoxyCodeLine{474 }
\DoxyCodeLine{475     drwav\_metadata\_type\_list\_info\_software          = 1 << 9,}
\DoxyCodeLine{476     drwav\_metadata\_type\_list\_info\_copyright         = 1 << 10,}
\DoxyCodeLine{477     drwav\_metadata\_type\_list\_info\_title             = 1 << 11,}
\DoxyCodeLine{478     drwav\_metadata\_type\_list\_info\_artist            = 1 << 12,}
\DoxyCodeLine{479     drwav\_metadata\_type\_list\_info\_comment           = 1 << 13,}
\DoxyCodeLine{480     drwav\_metadata\_type\_list\_info\_date              = 1 << 14,}
\DoxyCodeLine{481     drwav\_metadata\_type\_list\_info\_genre             = 1 << 15,}
\DoxyCodeLine{482     drwav\_metadata\_type\_list\_info\_album             = 1 << 16,}
\DoxyCodeLine{483     drwav\_metadata\_type\_list\_info\_tracknumber       = 1 << 17,}
\DoxyCodeLine{484 }
\DoxyCodeLine{485     \textcolor{comment}{/* Other type constants for convenience. */}}
\DoxyCodeLine{486     drwav\_metadata\_type\_list\_all\_info\_strings       = drwav\_metadata\_type\_list\_info\_software}
\DoxyCodeLine{487                                                     | drwav\_metadata\_type\_list\_info\_copyright}
\DoxyCodeLine{488                                                     | drwav\_metadata\_type\_list\_info\_title}
\DoxyCodeLine{489                                                     | drwav\_metadata\_type\_list\_info\_artist}
\DoxyCodeLine{490                                                     | drwav\_metadata\_type\_list\_info\_comment}
\DoxyCodeLine{491                                                     | drwav\_metadata\_type\_list\_info\_date}
\DoxyCodeLine{492                                                     | drwav\_metadata\_type\_list\_info\_genre}
\DoxyCodeLine{493                                                     | drwav\_metadata\_type\_list\_info\_album}
\DoxyCodeLine{494                                                     | drwav\_metadata\_type\_list\_info\_tracknumber,}
\DoxyCodeLine{495 }
\DoxyCodeLine{496     drwav\_metadata\_type\_list\_all\_adtl               = drwav\_metadata\_type\_list\_label}
\DoxyCodeLine{497                                                     | drwav\_metadata\_type\_list\_note}
\DoxyCodeLine{498                                                     | drwav\_metadata\_type\_list\_labelled\_cue\_region,}
\DoxyCodeLine{499 }
\DoxyCodeLine{500     drwav\_metadata\_type\_all                         = -\/2,   \textcolor{comment}{/*0xFFFFFFFF \& \string~drwav\_metadata\_type\_unknown,*/}}
\DoxyCodeLine{501     drwav\_metadata\_type\_all\_including\_unknown       = -\/1    \textcolor{comment}{/*0xFFFFFFFF,*/}}
\DoxyCodeLine{502 \} drwav\_metadata\_type;}
\DoxyCodeLine{503 }
\DoxyCodeLine{504 \textcolor{comment}{/*}}
\DoxyCodeLine{505 \textcolor{comment}{Sampler Metadata}}
\DoxyCodeLine{506 \textcolor{comment}{}}
\DoxyCodeLine{507 \textcolor{comment}{The sampler chunk contains information about how a sound should be played in the context of a whole}}
\DoxyCodeLine{508 \textcolor{comment}{audio production, and when used in a sampler. See https://en.wikipedia.org/wiki/Sample-\/based\_synthesis.}}
\DoxyCodeLine{509 \textcolor{comment}{*/}}
\DoxyCodeLine{510 \textcolor{keyword}{typedef} \textcolor{keyword}{enum}}
\DoxyCodeLine{511 \{}
\DoxyCodeLine{512     drwav\_smpl\_loop\_type\_forward  = 0,}
\DoxyCodeLine{513     drwav\_smpl\_loop\_type\_pingpong = 1,}
\DoxyCodeLine{514     drwav\_smpl\_loop\_type\_backward = 2}
\DoxyCodeLine{515 \} drwav\_smpl\_loop\_type;}
\DoxyCodeLine{516 }
\DoxyCodeLine{517 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{518 \{}
\DoxyCodeLine{519     \textcolor{comment}{/* The ID of the associated cue point, see drwav\_cue and drwav\_cue\_point. As with all cue point IDs, this can correspond to a label chunk to give this loop a name, see drwav\_list\_label\_or\_note. */}}
\DoxyCodeLine{520     drwav\_uint32 cuePointId;}
\DoxyCodeLine{521 }
\DoxyCodeLine{522     \textcolor{comment}{/* See drwav\_smpl\_loop\_type. */}}
\DoxyCodeLine{523     drwav\_uint32 type;}
\DoxyCodeLine{524 }
\DoxyCodeLine{525     \textcolor{comment}{/* The byte offset of the first sample to be played in the loop. */}}
\DoxyCodeLine{526     drwav\_uint32 firstSampleByteOffset;}
\DoxyCodeLine{527 }
\DoxyCodeLine{528     \textcolor{comment}{/* The byte offset into the audio data of the last sample to be played in the loop. */}}
\DoxyCodeLine{529     drwav\_uint32 lastSampleByteOffset;}
\DoxyCodeLine{530 }
\DoxyCodeLine{531     \textcolor{comment}{/* A value to represent that playback should occur at a point between samples. This value ranges from 0 to UINT32\_MAX. Where a value of 0 means no fraction, and a value of (UINT32\_MAX / 2) would mean half a sample. */}}
\DoxyCodeLine{532     drwav\_uint32 sampleFraction;}
\DoxyCodeLine{533 }
\DoxyCodeLine{534     \textcolor{comment}{/* Number of times to play the loop. 0 means loop infinitely. */}}
\DoxyCodeLine{535     drwav\_uint32 playCount;}
\DoxyCodeLine{536 \} \mbox{\hyperlink{structdrwav__smpl__loop}{drwav\_smpl\_loop}};}
\DoxyCodeLine{537 }
\DoxyCodeLine{538 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{539 \{}
\DoxyCodeLine{540     \textcolor{comment}{/* IDs for a particular MIDI manufacturer. 0 if not used. */}}
\DoxyCodeLine{541     drwav\_uint32 manufacturerId;}
\DoxyCodeLine{542     drwav\_uint32 productId;}
\DoxyCodeLine{543 }
\DoxyCodeLine{544     \textcolor{comment}{/* The period of 1 sample in nanoseconds. */}}
\DoxyCodeLine{545     drwav\_uint32 samplePeriodNanoseconds;}
\DoxyCodeLine{546 }
\DoxyCodeLine{547     \textcolor{comment}{/* The MIDI root note of this file. 0 to 127. */}}
\DoxyCodeLine{548     drwav\_uint32 midiUnityNote;}
\DoxyCodeLine{549 }
\DoxyCodeLine{550     \textcolor{comment}{/* The fraction of a semitone up from the given MIDI note. This is a value from 0 to UINT32\_MAX, where 0 means no change and (UINT32\_MAX / 2) is half a semitone (AKA 50 cents). */}}
\DoxyCodeLine{551     drwav\_uint32 midiPitchFraction;}
\DoxyCodeLine{552 }
\DoxyCodeLine{553     \textcolor{comment}{/* Data relating to SMPTE standards which are used for syncing audio and video. 0 if not used. */}}
\DoxyCodeLine{554     drwav\_uint32 smpteFormat;}
\DoxyCodeLine{555     drwav\_uint32 smpteOffset;}
\DoxyCodeLine{556 }
\DoxyCodeLine{557     \textcolor{comment}{/* drwav\_smpl\_loop loops. */}}
\DoxyCodeLine{558     drwav\_uint32 sampleLoopCount;}
\DoxyCodeLine{559 }
\DoxyCodeLine{560     \textcolor{comment}{/* Optional sampler-\/specific data. */}}
\DoxyCodeLine{561     drwav\_uint32 samplerSpecificDataSizeInBytes;}
\DoxyCodeLine{562 }
\DoxyCodeLine{563     \mbox{\hyperlink{structdrwav__smpl__loop}{drwav\_smpl\_loop}}* pLoops;}
\DoxyCodeLine{564     drwav\_uint8* pSamplerSpecificData;}
\DoxyCodeLine{565 \} \mbox{\hyperlink{structdrwav__smpl}{drwav\_smpl}};}
\DoxyCodeLine{566 }
\DoxyCodeLine{567 \textcolor{comment}{/*}}
\DoxyCodeLine{568 \textcolor{comment}{Instrument Metadata}}
\DoxyCodeLine{569 \textcolor{comment}{}}
\DoxyCodeLine{570 \textcolor{comment}{The inst metadata contains data about how a sound should be played as part of an instrument. This}}
\DoxyCodeLine{571 \textcolor{comment}{commonly read by samplers. See https://en.wikipedia.org/wiki/Sample-\/based\_synthesis.}}
\DoxyCodeLine{572 \textcolor{comment}{*/}}
\DoxyCodeLine{573 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{574 \{}
\DoxyCodeLine{575     drwav\_int8 midiUnityNote;   \textcolor{comment}{/* The root note of the audio as a MIDI note number. 0 to 127. */}}
\DoxyCodeLine{576     drwav\_int8 fineTuneCents;   \textcolor{comment}{/* -\/50 to +50 */}}
\DoxyCodeLine{577     drwav\_int8 gainDecibels;    \textcolor{comment}{/* -\/64 to +64 */}}
\DoxyCodeLine{578     drwav\_int8 lowNote;         \textcolor{comment}{/* 0 to 127 */}}
\DoxyCodeLine{579     drwav\_int8 highNote;        \textcolor{comment}{/* 0 to 127 */}}
\DoxyCodeLine{580     drwav\_int8 lowVelocity;     \textcolor{comment}{/* 1 to 127 */}}
\DoxyCodeLine{581     drwav\_int8 highVelocity;    \textcolor{comment}{/* 1 to 127 */}}
\DoxyCodeLine{582 \} \mbox{\hyperlink{structdrwav__inst}{drwav\_inst}};}
\DoxyCodeLine{583 }
\DoxyCodeLine{584 \textcolor{comment}{/*}}
\DoxyCodeLine{585 \textcolor{comment}{Cue Metadata}}
\DoxyCodeLine{586 \textcolor{comment}{}}
\DoxyCodeLine{587 \textcolor{comment}{Cue points are markers at specific points in the audio. They often come with an associated piece of}}
\DoxyCodeLine{588 \textcolor{comment}{drwav\_list\_label\_or\_note metadata which contains the text for the marker.}}
\DoxyCodeLine{589 \textcolor{comment}{*/}}
\DoxyCodeLine{590 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{591 \{}
\DoxyCodeLine{592     \textcolor{comment}{/* Unique identification value. */}}
\DoxyCodeLine{593     drwav\_uint32 id;}
\DoxyCodeLine{594 }
\DoxyCodeLine{595     \textcolor{comment}{/* Set to 0. This is only relevant if there is a 'playlist' chunk -\/ which is not supported by dr\_wav. */}}
\DoxyCodeLine{596     drwav\_uint32 playOrderPosition;}
\DoxyCodeLine{597 }
\DoxyCodeLine{598     \textcolor{comment}{/* Should always be "{}data"{}. This represents the fourcc value of the chunk that this cue point corresponds to. dr\_wav only supports a single data chunk so this should always be "{}data"{}. */}}
\DoxyCodeLine{599     drwav\_uint8 dataChunkId[4];}
\DoxyCodeLine{600 }
\DoxyCodeLine{601     \textcolor{comment}{/* Set to 0. This is only relevant if there is a wave list chunk. dr\_wav, like lots of readers/writers, do not support this. */}}
\DoxyCodeLine{602     drwav\_uint32 chunkStart;}
\DoxyCodeLine{603 }
\DoxyCodeLine{604     \textcolor{comment}{/* Set to 0 for uncompressed formats. Else the last byte in compressed wave data where decompression can begin to find the value of the corresponding sample value. */}}
\DoxyCodeLine{605     drwav\_uint32 blockStart;}
\DoxyCodeLine{606 }
\DoxyCodeLine{607     \textcolor{comment}{/* For uncompressed formats this is the byte offset of the cue point into the audio data. For compressed formats this is relative to the block specified with blockStart. */}}
\DoxyCodeLine{608     drwav\_uint32 sampleByteOffset;}
\DoxyCodeLine{609 \} \mbox{\hyperlink{structdrwav__cue__point}{drwav\_cue\_point}};}
\DoxyCodeLine{610 }
\DoxyCodeLine{611 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{612 \{}
\DoxyCodeLine{613     drwav\_uint32 cuePointCount;}
\DoxyCodeLine{614     \mbox{\hyperlink{structdrwav__cue__point}{drwav\_cue\_point}} *pCuePoints;}
\DoxyCodeLine{615 \} \mbox{\hyperlink{structdrwav__cue}{drwav\_cue}};}
\DoxyCodeLine{616 }
\DoxyCodeLine{617 \textcolor{comment}{/*}}
\DoxyCodeLine{618 \textcolor{comment}{Acid Metadata}}
\DoxyCodeLine{619 \textcolor{comment}{}}
\DoxyCodeLine{620 \textcolor{comment}{This chunk contains some information about the time signature and the tempo of the audio.}}
\DoxyCodeLine{621 \textcolor{comment}{*/}}
\DoxyCodeLine{622 \textcolor{keyword}{typedef} \textcolor{keyword}{enum}}
\DoxyCodeLine{623 \{}
\DoxyCodeLine{624     drwav\_acid\_flag\_one\_shot      = 1,  \textcolor{comment}{/* If this is not set, then it is a loop instead of a one-\/shot. */}}
\DoxyCodeLine{625     drwav\_acid\_flag\_root\_note\_set = 2,}
\DoxyCodeLine{626     drwav\_acid\_flag\_stretch       = 4,}
\DoxyCodeLine{627     drwav\_acid\_flag\_disk\_based    = 8,}
\DoxyCodeLine{628     drwav\_acid\_flag\_acidizer      = 16  \textcolor{comment}{/* Not sure what this means. */}}
\DoxyCodeLine{629 \} drwav\_acid\_flag;}
\DoxyCodeLine{630 }
\DoxyCodeLine{631 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{632 \{}
\DoxyCodeLine{633     \textcolor{comment}{/* A bit-\/field, see drwav\_acid\_flag. */}}
\DoxyCodeLine{634     drwav\_uint32 flags;}
\DoxyCodeLine{635 }
\DoxyCodeLine{636     \textcolor{comment}{/* Valid if flags contains drwav\_acid\_flag\_root\_note\_set. It represents the MIDI root note the file -\/ a value from 0 to 127. */}}
\DoxyCodeLine{637     drwav\_uint16 midiUnityNote;}
\DoxyCodeLine{638 }
\DoxyCodeLine{639     \textcolor{comment}{/* Reserved values that should probably be ignored. reserved1 seems to often be 128 and reserved2 is 0. */}}
\DoxyCodeLine{640     drwav\_uint16 reserved1;}
\DoxyCodeLine{641     \textcolor{keywordtype}{float} reserved2;}
\DoxyCodeLine{642 }
\DoxyCodeLine{643     \textcolor{comment}{/* Number of beats. */}}
\DoxyCodeLine{644     drwav\_uint32 numBeats;}
\DoxyCodeLine{645 }
\DoxyCodeLine{646     \textcolor{comment}{/* The time signature of the audio. */}}
\DoxyCodeLine{647     drwav\_uint16 meterDenominator;}
\DoxyCodeLine{648     drwav\_uint16 meterNumerator;}
\DoxyCodeLine{649 }
\DoxyCodeLine{650     \textcolor{comment}{/* Beats per minute of the track. Setting a value of 0 suggests that there is no tempo. */}}
\DoxyCodeLine{651     \textcolor{keywordtype}{float} tempo;}
\DoxyCodeLine{652 \} \mbox{\hyperlink{structdrwav__acid}{drwav\_acid}};}
\DoxyCodeLine{653 }
\DoxyCodeLine{654 \textcolor{comment}{/*}}
\DoxyCodeLine{655 \textcolor{comment}{Cue Label or Note metadata}}
\DoxyCodeLine{656 \textcolor{comment}{}}
\DoxyCodeLine{657 \textcolor{comment}{These are 2 different types of metadata, but they have the exact same format. Labels tend to be the}}
\DoxyCodeLine{658 \textcolor{comment}{more common and represent a short name for a cue point. Notes might be used to represent a longer}}
\DoxyCodeLine{659 \textcolor{comment}{comment.}}
\DoxyCodeLine{660 \textcolor{comment}{*/}}
\DoxyCodeLine{661 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{662 \{}
\DoxyCodeLine{663     \textcolor{comment}{/* The ID of a cue point that this label or note corresponds to. */}}
\DoxyCodeLine{664     drwav\_uint32 cuePointId;}
\DoxyCodeLine{665 }
\DoxyCodeLine{666     \textcolor{comment}{/* Size of the string not including any null terminator. */}}
\DoxyCodeLine{667     drwav\_uint32 stringLength;}
\DoxyCodeLine{668 }
\DoxyCodeLine{669     \textcolor{comment}{/* The string. The *init\_with\_metadata functions null terminate this for convenience. */}}
\DoxyCodeLine{670     \textcolor{keywordtype}{char}* pString;}
\DoxyCodeLine{671 \} \mbox{\hyperlink{structdrwav__list__label__or__note}{drwav\_list\_label\_or\_note}};}
\DoxyCodeLine{672 }
\DoxyCodeLine{673 \textcolor{comment}{/*}}
\DoxyCodeLine{674 \textcolor{comment}{BEXT metadata, also known as Broadcast Wave Format (BWF)}}
\DoxyCodeLine{675 \textcolor{comment}{}}
\DoxyCodeLine{676 \textcolor{comment}{This metadata adds some extra description to an audio file. You must check the version field to}}
\DoxyCodeLine{677 \textcolor{comment}{determine if the UMID or the loudness fields are valid.}}
\DoxyCodeLine{678 \textcolor{comment}{*/}}
\DoxyCodeLine{679 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{680 \{}
\DoxyCodeLine{681     \textcolor{comment}{/*}}
\DoxyCodeLine{682 \textcolor{comment}{    These top 3 fields, and the umid field are actually defined in the standard as a statically}}
\DoxyCodeLine{683 \textcolor{comment}{    sized buffers. In order to reduce the size of this struct (and therefore the union in the}}
\DoxyCodeLine{684 \textcolor{comment}{    metadata struct), we instead store these as pointers.}}
\DoxyCodeLine{685 \textcolor{comment}{    */}}
\DoxyCodeLine{686     \textcolor{keywordtype}{char}* pDescription;                 \textcolor{comment}{/* Can be NULL or a null-\/terminated string, must be <= 256 characters. */}}
\DoxyCodeLine{687     \textcolor{keywordtype}{char}* pOriginatorName;              \textcolor{comment}{/* Can be NULL or a null-\/terminated string, must be <= 32 characters. */}}
\DoxyCodeLine{688     \textcolor{keywordtype}{char}* pOriginatorReference;         \textcolor{comment}{/* Can be NULL or a null-\/terminated string, must be <= 32 characters. */}}
\DoxyCodeLine{689     \textcolor{keywordtype}{char}  pOriginationDate[10];         \textcolor{comment}{/* ASCII "{}yyyy:mm:dd"{}. */}}
\DoxyCodeLine{690     \textcolor{keywordtype}{char}  pOriginationTime[8];          \textcolor{comment}{/* ASCII "{}hh:mm:ss"{}. */}}
\DoxyCodeLine{691     drwav\_uint64 timeReference;         \textcolor{comment}{/* First sample count since midnight. */}}
\DoxyCodeLine{692     drwav\_uint16 version;               \textcolor{comment}{/* Version of the BWF, check this to see if the fields below are valid. */}}
\DoxyCodeLine{693 }
\DoxyCodeLine{694     \textcolor{comment}{/*}}
\DoxyCodeLine{695 \textcolor{comment}{    Unrestricted ASCII characters containing a collection of strings terminated by CR/LF. Each}}
\DoxyCodeLine{696 \textcolor{comment}{    string shall contain a description of a coding process applied to the audio data.}}
\DoxyCodeLine{697 \textcolor{comment}{    */}}
\DoxyCodeLine{698     \textcolor{keywordtype}{char}* pCodingHistory;}
\DoxyCodeLine{699     drwav\_uint32 codingHistorySize;}
\DoxyCodeLine{700 }
\DoxyCodeLine{701     \textcolor{comment}{/* Fields below this point are only valid if the version is 1 or above. */}}
\DoxyCodeLine{702     drwav\_uint8* pUMID;                  \textcolor{comment}{/* Exactly 64 bytes of SMPTE UMID */}}
\DoxyCodeLine{703 }
\DoxyCodeLine{704     \textcolor{comment}{/* Fields below this point are only valid if the version is 2 or above. */}}
\DoxyCodeLine{705     drwav\_uint16 loudnessValue;         \textcolor{comment}{/* Integrated Loudness Value of the file in LUFS (multiplied by 100). */}}
\DoxyCodeLine{706     drwav\_uint16 loudnessRange;         \textcolor{comment}{/* Loudness Range of the file in LU (multiplied by 100). */}}
\DoxyCodeLine{707     drwav\_uint16 maxTruePeakLevel;      \textcolor{comment}{/* Maximum True Peak Level of the file expressed as dBTP (multiplied by 100). */}}
\DoxyCodeLine{708     drwav\_uint16 maxMomentaryLoudness;  \textcolor{comment}{/* Highest value of the Momentary Loudness Level of the file in LUFS (multiplied by 100). */}}
\DoxyCodeLine{709     drwav\_uint16 maxShortTermLoudness;  \textcolor{comment}{/* Highest value of the Short-\/Term Loudness Level of the file in LUFS (multiplied by 100). */}}
\DoxyCodeLine{710 \} \mbox{\hyperlink{structdrwav__bext}{drwav\_bext}};}
\DoxyCodeLine{711 }
\DoxyCodeLine{712 \textcolor{comment}{/*}}
\DoxyCodeLine{713 \textcolor{comment}{Info Text Metadata}}
\DoxyCodeLine{714 \textcolor{comment}{}}
\DoxyCodeLine{715 \textcolor{comment}{There a many different types of information text that can be saved in this format. This is where}}
\DoxyCodeLine{716 \textcolor{comment}{things like the album name, the artists, the year it was produced, etc are saved. See}}
\DoxyCodeLine{717 \textcolor{comment}{drwav\_metadata\_type for the full list of types that dr\_wav supports.}}
\DoxyCodeLine{718 \textcolor{comment}{*/}}
\DoxyCodeLine{719 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{720 \{}
\DoxyCodeLine{721     \textcolor{comment}{/* Size of the string not including any null terminator. */}}
\DoxyCodeLine{722     drwav\_uint32 stringLength;}
\DoxyCodeLine{723 }
\DoxyCodeLine{724     \textcolor{comment}{/* The string. The *init\_with\_metadata functions null terminate this for convenience. */}}
\DoxyCodeLine{725     \textcolor{keywordtype}{char}* pString;}
\DoxyCodeLine{726 \} \mbox{\hyperlink{structdrwav__list__info__text}{drwav\_list\_info\_text}};}
\DoxyCodeLine{727 }
\DoxyCodeLine{728 \textcolor{comment}{/*}}
\DoxyCodeLine{729 \textcolor{comment}{Labelled Cue Region Metadata}}
\DoxyCodeLine{730 \textcolor{comment}{}}
\DoxyCodeLine{731 \textcolor{comment}{The labelled cue region metadata is used to associate some region of audio with text. The region}}
\DoxyCodeLine{732 \textcolor{comment}{starts at a cue point, and extends for the given number of samples.}}
\DoxyCodeLine{733 \textcolor{comment}{*/}}
\DoxyCodeLine{734 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{735 \{}
\DoxyCodeLine{736     \textcolor{comment}{/* The ID of a cue point that this object corresponds to. */}}
\DoxyCodeLine{737     drwav\_uint32 cuePointId;}
\DoxyCodeLine{738 }
\DoxyCodeLine{739     \textcolor{comment}{/* The number of samples from the cue point forwards that should be considered this region */}}
\DoxyCodeLine{740     drwav\_uint32 sampleLength;}
\DoxyCodeLine{741 }
\DoxyCodeLine{742     \textcolor{comment}{/* Four characters used to say what the purpose of this region is. */}}
\DoxyCodeLine{743     drwav\_uint8 purposeId[4];}
\DoxyCodeLine{744 }
\DoxyCodeLine{745     \textcolor{comment}{/* Unsure of the exact meanings of these. It appears to be acceptable to set them all to 0. */}}
\DoxyCodeLine{746     drwav\_uint16 country;}
\DoxyCodeLine{747     drwav\_uint16 language;}
\DoxyCodeLine{748     drwav\_uint16 dialect;}
\DoxyCodeLine{749     drwav\_uint16 codePage;}
\DoxyCodeLine{750 }
\DoxyCodeLine{751     \textcolor{comment}{/* Size of the string not including any null terminator. */}}
\DoxyCodeLine{752     drwav\_uint32 stringLength;}
\DoxyCodeLine{753 }
\DoxyCodeLine{754     \textcolor{comment}{/* The string. The *init\_with\_metadata functions null terminate this for convenience. */}}
\DoxyCodeLine{755     \textcolor{keywordtype}{char}* pString;}
\DoxyCodeLine{756 \} \mbox{\hyperlink{structdrwav__list__labelled__cue__region}{drwav\_list\_labelled\_cue\_region}};}
\DoxyCodeLine{757 }
\DoxyCodeLine{758 \textcolor{comment}{/*}}
\DoxyCodeLine{759 \textcolor{comment}{Unknown Metadata}}
\DoxyCodeLine{760 \textcolor{comment}{}}
\DoxyCodeLine{761 \textcolor{comment}{This chunk just represents a type of chunk that dr\_wav does not understand.}}
\DoxyCodeLine{762 \textcolor{comment}{}}
\DoxyCodeLine{763 \textcolor{comment}{Unknown metadata has a location attached to it. This is because wav files can have a LIST chunk}}
\DoxyCodeLine{764 \textcolor{comment}{that contains subchunks. These LIST chunks can be one of two types. An adtl list, or an INFO}}
\DoxyCodeLine{765 \textcolor{comment}{list. This enum is used to specify the location of a chunk that dr\_wav currently doesn't support.}}
\DoxyCodeLine{766 \textcolor{comment}{*/}}
\DoxyCodeLine{767 \textcolor{keyword}{typedef} \textcolor{keyword}{enum}}
\DoxyCodeLine{768 \{}
\DoxyCodeLine{769     drwav\_metadata\_location\_invalid,}
\DoxyCodeLine{770     drwav\_metadata\_location\_top\_level,}
\DoxyCodeLine{771     drwav\_metadata\_location\_inside\_info\_list,}
\DoxyCodeLine{772     drwav\_metadata\_location\_inside\_adtl\_list}
\DoxyCodeLine{773 \} drwav\_metadata\_location;}
\DoxyCodeLine{774 }
\DoxyCodeLine{775 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{776 \{}
\DoxyCodeLine{777     drwav\_uint8 \textcolor{keywordtype}{id}[4];}
\DoxyCodeLine{778     drwav\_metadata\_location chunkLocation;}
\DoxyCodeLine{779     drwav\_uint32 dataSizeInBytes;}
\DoxyCodeLine{780     drwav\_uint8* pData;}
\DoxyCodeLine{781 \} \mbox{\hyperlink{structdrwav__unknown__metadata}{drwav\_unknown\_metadata}};}
\DoxyCodeLine{782 }
\DoxyCodeLine{783 \textcolor{comment}{/*}}
\DoxyCodeLine{784 \textcolor{comment}{Metadata is saved as a union of all the supported types.}}
\DoxyCodeLine{785 \textcolor{comment}{*/}}
\DoxyCodeLine{786 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{787 \{}
\DoxyCodeLine{788     \textcolor{comment}{/* Determines which item in the union is valid. */}}
\DoxyCodeLine{789     drwav\_metadata\_type type;}
\DoxyCodeLine{790 }
\DoxyCodeLine{791     \textcolor{keyword}{union}}
\DoxyCodeLine{792     \{}
\DoxyCodeLine{793         \mbox{\hyperlink{structdrwav__cue}{drwav\_cue}} cue;}
\DoxyCodeLine{794         \mbox{\hyperlink{structdrwav__smpl}{drwav\_smpl}} smpl;}
\DoxyCodeLine{795         \mbox{\hyperlink{structdrwav__acid}{drwav\_acid}} acid;}
\DoxyCodeLine{796         \mbox{\hyperlink{structdrwav__inst}{drwav\_inst}} inst;}
\DoxyCodeLine{797         \mbox{\hyperlink{structdrwav__bext}{drwav\_bext}} bext;}
\DoxyCodeLine{798         \mbox{\hyperlink{structdrwav__list__label__or__note}{drwav\_list\_label\_or\_note}} labelOrNote;   \textcolor{comment}{/* List label or list note. */}}
\DoxyCodeLine{799         \mbox{\hyperlink{structdrwav__list__labelled__cue__region}{drwav\_list\_labelled\_cue\_region}} labelledCueRegion;}
\DoxyCodeLine{800         \mbox{\hyperlink{structdrwav__list__info__text}{drwav\_list\_info\_text}} infoText;          \textcolor{comment}{/* Any of the list info types. */}}
\DoxyCodeLine{801         \mbox{\hyperlink{structdrwav__unknown__metadata}{drwav\_unknown\_metadata}} unknown;}
\DoxyCodeLine{802     \} data;}
\DoxyCodeLine{803 \} \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}};}
\DoxyCodeLine{804 }
\DoxyCodeLine{805 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{806 \{}
\DoxyCodeLine{807     \textcolor{comment}{/* A pointer to the function to call when more data is needed. */}}
\DoxyCodeLine{808     drwav\_read\_proc onRead;}
\DoxyCodeLine{809 }
\DoxyCodeLine{810     \textcolor{comment}{/* A pointer to the function to call when data needs to be written. Only used when the drwav object is opened in write mode. */}}
\DoxyCodeLine{811     drwav\_write\_proc onWrite;}
\DoxyCodeLine{812 }
\DoxyCodeLine{813     \textcolor{comment}{/* A pointer to the function to call when the wav file needs to be seeked. */}}
\DoxyCodeLine{814     drwav\_seek\_proc onSeek;}
\DoxyCodeLine{815 }
\DoxyCodeLine{816     \textcolor{comment}{/* The user data to pass to callbacks. */}}
\DoxyCodeLine{817     \textcolor{keywordtype}{void}* pUserData;}
\DoxyCodeLine{818 }
\DoxyCodeLine{819     \textcolor{comment}{/* Allocation callbacks. */}}
\DoxyCodeLine{820     \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}} allocationCallbacks;}
\DoxyCodeLine{821 }
\DoxyCodeLine{822 }
\DoxyCodeLine{823     \textcolor{comment}{/* Whether or not the WAV file is formatted as a standard RIFF file or W64. */}}
\DoxyCodeLine{824     drwav\_container container;}
\DoxyCodeLine{825 }
\DoxyCodeLine{826 }
\DoxyCodeLine{827     \textcolor{comment}{/* Structure containing format information exactly as specified by the wav file. */}}
\DoxyCodeLine{828     \mbox{\hyperlink{structdrwav__fmt}{drwav\_fmt}} fmt;}
\DoxyCodeLine{829 }
\DoxyCodeLine{830     \textcolor{comment}{/* The sample rate. Will be set to something like 44100. */}}
\DoxyCodeLine{831     drwav\_uint32 sampleRate;}
\DoxyCodeLine{832 }
\DoxyCodeLine{833     \textcolor{comment}{/* The number of channels. This will be set to 1 for monaural streams, 2 for stereo, etc. */}}
\DoxyCodeLine{834     drwav\_uint16 channels;}
\DoxyCodeLine{835 }
\DoxyCodeLine{836     \textcolor{comment}{/* The bits per sample. Will be set to something like 16, 24, etc. */}}
\DoxyCodeLine{837     drwav\_uint16 bitsPerSample;}
\DoxyCodeLine{838 }
\DoxyCodeLine{839     \textcolor{comment}{/* Equal to fmt.formatTag, or the value specified by fmt.subFormat if fmt.formatTag is equal to 65534 (WAVE\_FORMAT\_EXTENSIBLE). */}}
\DoxyCodeLine{840     drwav\_uint16 translatedFormatTag;}
\DoxyCodeLine{841 }
\DoxyCodeLine{842     \textcolor{comment}{/* The total number of PCM frames making up the audio data. */}}
\DoxyCodeLine{843     drwav\_uint64 totalPCMFrameCount;}
\DoxyCodeLine{844 }
\DoxyCodeLine{845 }
\DoxyCodeLine{846     \textcolor{comment}{/* The size in bytes of the data chunk. */}}
\DoxyCodeLine{847     drwav\_uint64 dataChunkDataSize;}
\DoxyCodeLine{848 }
\DoxyCodeLine{849     \textcolor{comment}{/* The position in the stream of the first data byte of the data chunk. This is used for seeking. */}}
\DoxyCodeLine{850     drwav\_uint64 dataChunkDataPos;}
\DoxyCodeLine{851 }
\DoxyCodeLine{852     \textcolor{comment}{/* The number of bytes remaining in the data chunk. */}}
\DoxyCodeLine{853     drwav\_uint64 bytesRemaining;}
\DoxyCodeLine{854 }
\DoxyCodeLine{855     \textcolor{comment}{/* The current read position in PCM frames. */}}
\DoxyCodeLine{856     drwav\_uint64 readCursorInPCMFrames;}
\DoxyCodeLine{857 }
\DoxyCodeLine{858 }
\DoxyCodeLine{859     \textcolor{comment}{/*}}
\DoxyCodeLine{860 \textcolor{comment}{    Only used in sequential write mode. Keeps track of the desired size of the "{}data"{} chunk at the point of initialization time. Always}}
\DoxyCodeLine{861 \textcolor{comment}{    set to 0 for non-\/sequential writes and when the drwav object is opened in read mode. Used for validation.}}
\DoxyCodeLine{862 \textcolor{comment}{    */}}
\DoxyCodeLine{863     drwav\_uint64 dataChunkDataSizeTargetWrite;}
\DoxyCodeLine{864 }
\DoxyCodeLine{865     \textcolor{comment}{/* Keeps track of whether or not the wav writer was initialized in sequential mode. */}}
\DoxyCodeLine{866     drwav\_bool32 isSequentialWrite;}
\DoxyCodeLine{867 }
\DoxyCodeLine{868 }
\DoxyCodeLine{869     \textcolor{comment}{/* A bit-\/field of drwav\_metadata\_type values, only bits set in this variable are parsed and saved */}}
\DoxyCodeLine{870     drwav\_metadata\_type allowedMetadataTypes;}
\DoxyCodeLine{871 }
\DoxyCodeLine{872     \textcolor{comment}{/* A array of metadata. This is valid after the *init\_with\_metadata call returns. It will be valid until drwav\_uninit() is called. You can take ownership of this data with drwav\_take\_ownership\_of\_metadata(). */}}
\DoxyCodeLine{873     \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata;}
\DoxyCodeLine{874     drwav\_uint32 metadataCount;}
\DoxyCodeLine{875 }
\DoxyCodeLine{876 }
\DoxyCodeLine{877     \textcolor{comment}{/* A hack to avoid a DRWAV\_MALLOC() when opening a decoder with drwav\_init\_memory(). */}}
\DoxyCodeLine{878     \mbox{\hyperlink{structdrwav____memory__stream}{drwav\_\_memory\_stream}} memoryStream;}
\DoxyCodeLine{879     \mbox{\hyperlink{structdrwav____memory__stream__write}{drwav\_\_memory\_stream\_write}} memoryStreamWrite;}
\DoxyCodeLine{880 }
\DoxyCodeLine{881 }
\DoxyCodeLine{882     \textcolor{comment}{/* Microsoft ADPCM specific data. */}}
\DoxyCodeLine{883     \textcolor{keyword}{struct}}
\DoxyCodeLine{884     \{}
\DoxyCodeLine{885         drwav\_uint32 bytesRemainingInBlock;}
\DoxyCodeLine{886         drwav\_uint16 predictor[2];}
\DoxyCodeLine{887         drwav\_int32  delta[2];}
\DoxyCodeLine{888         drwav\_int32  cachedFrames[4];  \textcolor{comment}{/* Samples are stored in this cache during decoding. */}}
\DoxyCodeLine{889         drwav\_uint32 cachedFrameCount;}
\DoxyCodeLine{890         drwav\_int32  prevFrames[2][2]; \textcolor{comment}{/* The previous 2 samples for each channel (2 channels at most). */}}
\DoxyCodeLine{891     \} msadpcm;}
\DoxyCodeLine{892 }
\DoxyCodeLine{893     \textcolor{comment}{/* IMA ADPCM specific data. */}}
\DoxyCodeLine{894     \textcolor{keyword}{struct}}
\DoxyCodeLine{895     \{}
\DoxyCodeLine{896         drwav\_uint32 bytesRemainingInBlock;}
\DoxyCodeLine{897         drwav\_int32  predictor[2];}
\DoxyCodeLine{898         drwav\_int32  stepIndex[2];}
\DoxyCodeLine{899         drwav\_int32  cachedFrames[16]; \textcolor{comment}{/* Samples are stored in this cache during decoding. */}}
\DoxyCodeLine{900         drwav\_uint32 cachedFrameCount;}
\DoxyCodeLine{901     \} ima;}
\DoxyCodeLine{902 \} \mbox{\hyperlink{structdrwav}{drwav}};}
\DoxyCodeLine{903 }
\DoxyCodeLine{904 }
\DoxyCodeLine{905 \textcolor{comment}{/*}}
\DoxyCodeLine{906 \textcolor{comment}{Initializes a pre-\/allocated drwav object for reading.}}
\DoxyCodeLine{907 \textcolor{comment}{}}
\DoxyCodeLine{908 \textcolor{comment}{pWav                         [out]          A pointer to the drwav object being initialized.}}
\DoxyCodeLine{909 \textcolor{comment}{onRead                       [in]           The function to call when data needs to be read from the client.}}
\DoxyCodeLine{910 \textcolor{comment}{onSeek                       [in]           The function to call when the read position of the client data needs to move.}}
\DoxyCodeLine{911 \textcolor{comment}{onChunk                      [in, optional] The function to call when a chunk is enumerated at initialized time.}}
\DoxyCodeLine{912 \textcolor{comment}{pUserData, pReadSeekUserData [in, optional] A pointer to application defined data that will be passed to onRead and onSeek.}}
\DoxyCodeLine{913 \textcolor{comment}{pChunkUserData               [in, optional] A pointer to application defined data that will be passed to onChunk.}}
\DoxyCodeLine{914 \textcolor{comment}{flags                        [in, optional] A set of flags for controlling how things are loaded.}}
\DoxyCodeLine{915 \textcolor{comment}{}}
\DoxyCodeLine{916 \textcolor{comment}{Returns true if successful; false otherwise.}}
\DoxyCodeLine{917 \textcolor{comment}{}}
\DoxyCodeLine{918 \textcolor{comment}{Close the loader with drwav\_uninit().}}
\DoxyCodeLine{919 \textcolor{comment}{}}
\DoxyCodeLine{920 \textcolor{comment}{This is the lowest level function for initializing a WAV file. You can also use drwav\_init\_file() and drwav\_init\_memory()}}
\DoxyCodeLine{921 \textcolor{comment}{to open the stream from a file or from a block of memory respectively.}}
\DoxyCodeLine{922 \textcolor{comment}{}}
\DoxyCodeLine{923 \textcolor{comment}{Possible values for flags:}}
\DoxyCodeLine{924 \textcolor{comment}{  DRWAV\_SEQUENTIAL: Never perform a backwards seek while loading. This disables the chunk callback and will cause this function}}
\DoxyCodeLine{925 \textcolor{comment}{                    to return as soon as the data chunk is found. Any chunks after the data chunk will be ignored.}}
\DoxyCodeLine{926 \textcolor{comment}{}}
\DoxyCodeLine{927 \textcolor{comment}{drwav\_init() is equivalent to "{}drwav\_init\_ex(pWav, onRead, onSeek, NULL, pUserData, NULL, 0);"{}.}}
\DoxyCodeLine{928 \textcolor{comment}{}}
\DoxyCodeLine{929 \textcolor{comment}{The onChunk callback is not called for the WAVE or FMT chunks. The contents of the FMT chunk can be read from pWav-\/>fmt}}
\DoxyCodeLine{930 \textcolor{comment}{after the function returns.}}
\DoxyCodeLine{931 \textcolor{comment}{}}
\DoxyCodeLine{932 \textcolor{comment}{See also: drwav\_init\_file(), drwav\_init\_memory(), drwav\_uninit()}}
\DoxyCodeLine{933 \textcolor{comment}{*/}}
\DoxyCodeLine{934 DRWAV\_API drwav\_bool32 drwav\_init(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{935 DRWAV\_API drwav\_bool32 drwav\_init\_ex(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pReadSeekUserData, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{936 DRWAV\_API drwav\_bool32 drwav\_init\_with\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{937 }
\DoxyCodeLine{938 \textcolor{comment}{/*}}
\DoxyCodeLine{939 \textcolor{comment}{Initializes a pre-\/allocated drwav object for writing.}}
\DoxyCodeLine{940 \textcolor{comment}{}}
\DoxyCodeLine{941 \textcolor{comment}{onWrite               [in]           The function to call when data needs to be written.}}
\DoxyCodeLine{942 \textcolor{comment}{onSeek                [in]           The function to call when the write position needs to move.}}
\DoxyCodeLine{943 \textcolor{comment}{pUserData             [in, optional] A pointer to application defined data that will be passed to onWrite and onSeek.}}
\DoxyCodeLine{944 \textcolor{comment}{metadata, numMetadata [in, optional] An array of metadata objects that should be written to the file. The array is not edited. You are responsible for this metadata memory and it must maintain valid until drwav\_uninit() is called.}}
\DoxyCodeLine{945 \textcolor{comment}{}}
\DoxyCodeLine{946 \textcolor{comment}{Returns true if successful; false otherwise.}}
\DoxyCodeLine{947 \textcolor{comment}{}}
\DoxyCodeLine{948 \textcolor{comment}{Close the writer with drwav\_uninit().}}
\DoxyCodeLine{949 \textcolor{comment}{}}
\DoxyCodeLine{950 \textcolor{comment}{This is the lowest level function for initializing a WAV file. You can also use drwav\_init\_file\_write() and drwav\_init\_memory\_write()}}
\DoxyCodeLine{951 \textcolor{comment}{to open the stream from a file or from a block of memory respectively.}}
\DoxyCodeLine{952 \textcolor{comment}{}}
\DoxyCodeLine{953 \textcolor{comment}{If the total sample count is known, you can use drwav\_init\_write\_sequential(). This avoids the need for dr\_wav to perform}}
\DoxyCodeLine{954 \textcolor{comment}{a post-\/processing step for storing the total sample count and the size of the data chunk which requires a backwards seek.}}
\DoxyCodeLine{955 \textcolor{comment}{}}
\DoxyCodeLine{956 \textcolor{comment}{See also: drwav\_init\_file\_write(), drwav\_init\_memory\_write(), drwav\_uninit()}}
\DoxyCodeLine{957 \textcolor{comment}{*/}}
\DoxyCodeLine{958 DRWAV\_API drwav\_bool32 drwav\_init\_write(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_write\_proc onWrite, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{959 DRWAV\_API drwav\_bool32 drwav\_init\_write\_sequential(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, drwav\_write\_proc onWrite, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{960 DRWAV\_API drwav\_bool32 drwav\_init\_write\_sequential\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalPCMFrameCount, drwav\_write\_proc onWrite, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{961 DRWAV\_API drwav\_bool32 drwav\_init\_write\_with\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_write\_proc onWrite, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata, drwav\_uint32 metadataCount);}
\DoxyCodeLine{962 }
\DoxyCodeLine{963 \textcolor{comment}{/*}}
\DoxyCodeLine{964 \textcolor{comment}{Utility function to determine the target size of the entire data to be written (including all headers and chunks).}}
\DoxyCodeLine{965 \textcolor{comment}{}}
\DoxyCodeLine{966 \textcolor{comment}{Returns the target size in bytes.}}
\DoxyCodeLine{967 \textcolor{comment}{}}
\DoxyCodeLine{968 \textcolor{comment}{The metadata argument can be NULL meaning no metadata exists.}}
\DoxyCodeLine{969 \textcolor{comment}{}}
\DoxyCodeLine{970 \textcolor{comment}{Useful if the application needs to know the size to allocate.}}
\DoxyCodeLine{971 \textcolor{comment}{}}
\DoxyCodeLine{972 \textcolor{comment}{Only writing to the RIFF chunk and one data chunk is currently supported.}}
\DoxyCodeLine{973 \textcolor{comment}{}}
\DoxyCodeLine{974 \textcolor{comment}{See also: drwav\_init\_write(), drwav\_init\_file\_write(), drwav\_init\_memory\_write()}}
\DoxyCodeLine{975 \textcolor{comment}{*/}}
\DoxyCodeLine{976 DRWAV\_API drwav\_uint64 drwav\_target\_write\_size\_bytes(\textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalFrameCount, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata, drwav\_uint32 metadataCount);}
\DoxyCodeLine{977 }
\DoxyCodeLine{978 \textcolor{comment}{/*}}
\DoxyCodeLine{979 \textcolor{comment}{Take ownership of the metadata objects that were allocated via one of the init\_with\_metadata() function calls. The init\_with\_metdata functions perform a single heap allocation for this metadata.}}
\DoxyCodeLine{980 \textcolor{comment}{}}
\DoxyCodeLine{981 \textcolor{comment}{Useful if you want the data to persist beyond the lifetime of the drwav object.}}
\DoxyCodeLine{982 \textcolor{comment}{}}
\DoxyCodeLine{983 \textcolor{comment}{You must free the data returned from this function using drwav\_free().}}
\DoxyCodeLine{984 \textcolor{comment}{*/}}
\DoxyCodeLine{985 DRWAV\_API \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* drwav\_take\_ownership\_of\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav);}
\DoxyCodeLine{986 }
\DoxyCodeLine{987 \textcolor{comment}{/*}}
\DoxyCodeLine{988 \textcolor{comment}{Uninitializes the given drwav object.}}
\DoxyCodeLine{989 \textcolor{comment}{}}
\DoxyCodeLine{990 \textcolor{comment}{Use this only for objects initialized with drwav\_init*() functions (drwav\_init(), drwav\_init\_ex(), drwav\_init\_write(), drwav\_init\_write\_sequential()).}}
\DoxyCodeLine{991 \textcolor{comment}{*/}}
\DoxyCodeLine{992 DRWAV\_API drwav\_result drwav\_uninit(\mbox{\hyperlink{structdrwav}{drwav}}* pWav);}
\DoxyCodeLine{993 }
\DoxyCodeLine{994 }
\DoxyCodeLine{995 \textcolor{comment}{/*}}
\DoxyCodeLine{996 \textcolor{comment}{Reads raw audio data.}}
\DoxyCodeLine{997 \textcolor{comment}{}}
\DoxyCodeLine{998 \textcolor{comment}{This is the lowest level function for reading audio data. It simply reads the given number of}}
\DoxyCodeLine{999 \textcolor{comment}{bytes of the raw internal sample data.}}
\DoxyCodeLine{1000 \textcolor{comment}{}}
\DoxyCodeLine{1001 \textcolor{comment}{Consider using drwav\_read\_pcm\_frames\_s16(), drwav\_read\_pcm\_frames\_s32() or drwav\_read\_pcm\_frames\_f32() for}}
\DoxyCodeLine{1002 \textcolor{comment}{reading sample data in a consistent format.}}
\DoxyCodeLine{1003 \textcolor{comment}{}}
\DoxyCodeLine{1004 \textcolor{comment}{pBufferOut can be NULL in which case a seek will be performed.}}
\DoxyCodeLine{1005 \textcolor{comment}{}}
\DoxyCodeLine{1006 \textcolor{comment}{Returns the number of bytes actually read.}}
\DoxyCodeLine{1007 \textcolor{comment}{*/}}
\DoxyCodeLine{1008 DRWAV\_API \textcolor{keywordtype}{size\_t} drwav\_read\_raw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{size\_t} bytesToRead, \textcolor{keywordtype}{void}* pBufferOut);}
\DoxyCodeLine{1009 }
\DoxyCodeLine{1010 \textcolor{comment}{/*}}
\DoxyCodeLine{1011 \textcolor{comment}{Reads up to the specified number of PCM frames from the WAV file.}}
\DoxyCodeLine{1012 \textcolor{comment}{}}
\DoxyCodeLine{1013 \textcolor{comment}{The output data will be in the file's internal format, converted to native-\/endian byte order. Use}}
\DoxyCodeLine{1014 \textcolor{comment}{drwav\_read\_pcm\_frames\_s16/f32/s32() to read data in a specific format.}}
\DoxyCodeLine{1015 \textcolor{comment}{}}
\DoxyCodeLine{1016 \textcolor{comment}{If the return value is less than <framesToRead> it means the end of the file has been reached or}}
\DoxyCodeLine{1017 \textcolor{comment}{you have requested more PCM frames than can possibly fit in the output buffer.}}
\DoxyCodeLine{1018 \textcolor{comment}{}}
\DoxyCodeLine{1019 \textcolor{comment}{This function will only work when sample data is of a fixed size and uncompressed. If you are}}
\DoxyCodeLine{1020 \textcolor{comment}{using a compressed format consider using drwav\_read\_raw() or drwav\_read\_pcm\_frames\_s16/s32/f32().}}
\DoxyCodeLine{1021 \textcolor{comment}{}}
\DoxyCodeLine{1022 \textcolor{comment}{pBufferOut can be NULL in which case a seek will be performed.}}
\DoxyCodeLine{1023 \textcolor{comment}{*/}}
\DoxyCodeLine{1024 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{void}* pBufferOut);}
\DoxyCodeLine{1025 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{void}* pBufferOut);}
\DoxyCodeLine{1026 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{void}* pBufferOut);}
\DoxyCodeLine{1027 }
\DoxyCodeLine{1028 \textcolor{comment}{/*}}
\DoxyCodeLine{1029 \textcolor{comment}{Seeks to the given PCM frame.}}
\DoxyCodeLine{1030 \textcolor{comment}{}}
\DoxyCodeLine{1031 \textcolor{comment}{Returns true if successful; false otherwise.}}
\DoxyCodeLine{1032 \textcolor{comment}{*/}}
\DoxyCodeLine{1033 DRWAV\_API drwav\_bool32 drwav\_seek\_to\_pcm\_frame(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 targetFrameIndex);}
\DoxyCodeLine{1034 }
\DoxyCodeLine{1035 \textcolor{comment}{/*}}
\DoxyCodeLine{1036 \textcolor{comment}{Retrieves the current read position in pcm frames.}}
\DoxyCodeLine{1037 \textcolor{comment}{*/}}
\DoxyCodeLine{1038 DRWAV\_API drwav\_result drwav\_get\_cursor\_in\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64* pCursor);}
\DoxyCodeLine{1039 }
\DoxyCodeLine{1040 \textcolor{comment}{/*}}
\DoxyCodeLine{1041 \textcolor{comment}{Retrieves the length of the file.}}
\DoxyCodeLine{1042 \textcolor{comment}{*/}}
\DoxyCodeLine{1043 DRWAV\_API drwav\_result drwav\_get\_length\_in\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64* pLength);}
\DoxyCodeLine{1044 }
\DoxyCodeLine{1045 }
\DoxyCodeLine{1046 \textcolor{comment}{/*}}
\DoxyCodeLine{1047 \textcolor{comment}{Writes raw audio data.}}
\DoxyCodeLine{1048 \textcolor{comment}{}}
\DoxyCodeLine{1049 \textcolor{comment}{Returns the number of bytes actually written. If this differs from bytesToWrite, it indicates an error.}}
\DoxyCodeLine{1050 \textcolor{comment}{*/}}
\DoxyCodeLine{1051 DRWAV\_API \textcolor{keywordtype}{size\_t} drwav\_write\_raw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{size\_t} bytesToWrite, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData);}
\DoxyCodeLine{1052 }
\DoxyCodeLine{1053 \textcolor{comment}{/*}}
\DoxyCodeLine{1054 \textcolor{comment}{Writes PCM frames.}}
\DoxyCodeLine{1055 \textcolor{comment}{}}
\DoxyCodeLine{1056 \textcolor{comment}{Returns the number of PCM frames written.}}
\DoxyCodeLine{1057 \textcolor{comment}{}}
\DoxyCodeLine{1058 \textcolor{comment}{Input samples need to be in native-\/endian byte order. On big-\/endian architectures the input data will be converted to}}
\DoxyCodeLine{1059 \textcolor{comment}{little-\/endian. Use drwav\_write\_raw() to write raw audio data without performing any conversion.}}
\DoxyCodeLine{1060 \textcolor{comment}{*/}}
\DoxyCodeLine{1061 DRWAV\_API drwav\_uint64 drwav\_write\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToWrite, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData);}
\DoxyCodeLine{1062 DRWAV\_API drwav\_uint64 drwav\_write\_pcm\_frames\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToWrite, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData);}
\DoxyCodeLine{1063 DRWAV\_API drwav\_uint64 drwav\_write\_pcm\_frames\_be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToWrite, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData);}
\DoxyCodeLine{1064 }
\DoxyCodeLine{1065 \textcolor{comment}{/* Conversion Utilities */}}
\DoxyCodeLine{1066 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_CONVERSION\_API}}
\DoxyCodeLine{1067 }
\DoxyCodeLine{1068 \textcolor{comment}{/*}}
\DoxyCodeLine{1069 \textcolor{comment}{Reads a chunk of audio data and converts it to signed 16-\/bit PCM samples.}}
\DoxyCodeLine{1070 \textcolor{comment}{}}
\DoxyCodeLine{1071 \textcolor{comment}{pBufferOut can be NULL in which case a seek will be performed.}}
\DoxyCodeLine{1072 \textcolor{comment}{}}
\DoxyCodeLine{1073 \textcolor{comment}{Returns the number of PCM frames actually read.}}
\DoxyCodeLine{1074 \textcolor{comment}{}}
\DoxyCodeLine{1075 \textcolor{comment}{If the return value is less than <framesToRead> it means the end of the file has been reached.}}
\DoxyCodeLine{1076 \textcolor{comment}{*/}}
\DoxyCodeLine{1077 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s16(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut);}
\DoxyCodeLine{1078 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s16le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut);}
\DoxyCodeLine{1079 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s16be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut);}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081 \textcolor{comment}{/* Low-\/level function for converting unsigned 8-\/bit PCM samples to signed 16-\/bit PCM samples. */}}
\DoxyCodeLine{1082 DRWAV\_API \textcolor{keywordtype}{void} drwav\_u8\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084 \textcolor{comment}{/* Low-\/level function for converting signed 24-\/bit PCM samples to signed 16-\/bit PCM samples. */}}
\DoxyCodeLine{1085 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s24\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1086 }
\DoxyCodeLine{1087 \textcolor{comment}{/* Low-\/level function for converting signed 32-\/bit PCM samples to signed 16-\/bit PCM samples. */}}
\DoxyCodeLine{1088 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s32\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_int32* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1089 }
\DoxyCodeLine{1090 \textcolor{comment}{/* Low-\/level function for converting IEEE 32-\/bit floating point samples to signed 16-\/bit PCM samples. */}}
\DoxyCodeLine{1091 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f32\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{float}* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1092 }
\DoxyCodeLine{1093 \textcolor{comment}{/* Low-\/level function for converting IEEE 64-\/bit floating point samples to signed 16-\/bit PCM samples. */}}
\DoxyCodeLine{1094 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f64\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{double}* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1095 }
\DoxyCodeLine{1096 \textcolor{comment}{/* Low-\/level function for converting A-\/law samples to signed 16-\/bit PCM samples. */}}
\DoxyCodeLine{1097 DRWAV\_API \textcolor{keywordtype}{void} drwav\_alaw\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1098 }
\DoxyCodeLine{1099 \textcolor{comment}{/* Low-\/level function for converting u-\/law samples to signed 16-\/bit PCM samples. */}}
\DoxyCodeLine{1100 DRWAV\_API \textcolor{keywordtype}{void} drwav\_mulaw\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1101 }
\DoxyCodeLine{1102 }
\DoxyCodeLine{1103 \textcolor{comment}{/*}}
\DoxyCodeLine{1104 \textcolor{comment}{Reads a chunk of audio data and converts it to IEEE 32-\/bit floating point samples.}}
\DoxyCodeLine{1105 \textcolor{comment}{}}
\DoxyCodeLine{1106 \textcolor{comment}{pBufferOut can be NULL in which case a seek will be performed.}}
\DoxyCodeLine{1107 \textcolor{comment}{}}
\DoxyCodeLine{1108 \textcolor{comment}{Returns the number of PCM frames actually read.}}
\DoxyCodeLine{1109 \textcolor{comment}{}}
\DoxyCodeLine{1110 \textcolor{comment}{If the return value is less than <framesToRead> it means the end of the file has been reached.}}
\DoxyCodeLine{1111 \textcolor{comment}{*/}}
\DoxyCodeLine{1112 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_f32(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut);}
\DoxyCodeLine{1113 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_f32le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut);}
\DoxyCodeLine{1114 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_f32be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut);}
\DoxyCodeLine{1115 }
\DoxyCodeLine{1116 \textcolor{comment}{/* Low-\/level function for converting unsigned 8-\/bit PCM samples to IEEE 32-\/bit floating point samples. */}}
\DoxyCodeLine{1117 DRWAV\_API \textcolor{keywordtype}{void} drwav\_u8\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1118 }
\DoxyCodeLine{1119 \textcolor{comment}{/* Low-\/level function for converting signed 16-\/bit PCM samples to IEEE 32-\/bit floating point samples. */}}
\DoxyCodeLine{1120 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s16\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_int16* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1121 }
\DoxyCodeLine{1122 \textcolor{comment}{/* Low-\/level function for converting signed 24-\/bit PCM samples to IEEE 32-\/bit floating point samples. */}}
\DoxyCodeLine{1123 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s24\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125 \textcolor{comment}{/* Low-\/level function for converting signed 32-\/bit PCM samples to IEEE 32-\/bit floating point samples. */}}
\DoxyCodeLine{1126 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s32\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_int32* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1127 }
\DoxyCodeLine{1128 \textcolor{comment}{/* Low-\/level function for converting IEEE 64-\/bit floating point samples to IEEE 32-\/bit floating point samples. */}}
\DoxyCodeLine{1129 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f64\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{double}* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1130 }
\DoxyCodeLine{1131 \textcolor{comment}{/* Low-\/level function for converting A-\/law samples to IEEE 32-\/bit floating point samples. */}}
\DoxyCodeLine{1132 DRWAV\_API \textcolor{keywordtype}{void} drwav\_alaw\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1133 }
\DoxyCodeLine{1134 \textcolor{comment}{/* Low-\/level function for converting u-\/law samples to IEEE 32-\/bit floating point samples. */}}
\DoxyCodeLine{1135 DRWAV\_API \textcolor{keywordtype}{void} drwav\_mulaw\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1136 }
\DoxyCodeLine{1137 }
\DoxyCodeLine{1138 \textcolor{comment}{/*}}
\DoxyCodeLine{1139 \textcolor{comment}{Reads a chunk of audio data and converts it to signed 32-\/bit PCM samples.}}
\DoxyCodeLine{1140 \textcolor{comment}{}}
\DoxyCodeLine{1141 \textcolor{comment}{pBufferOut can be NULL in which case a seek will be performed.}}
\DoxyCodeLine{1142 \textcolor{comment}{}}
\DoxyCodeLine{1143 \textcolor{comment}{Returns the number of PCM frames actually read.}}
\DoxyCodeLine{1144 \textcolor{comment}{}}
\DoxyCodeLine{1145 \textcolor{comment}{If the return value is less than <framesToRead> it means the end of the file has been reached.}}
\DoxyCodeLine{1146 \textcolor{comment}{*/}}
\DoxyCodeLine{1147 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s32(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut);}
\DoxyCodeLine{1148 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s32le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut);}
\DoxyCodeLine{1149 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s32be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut);}
\DoxyCodeLine{1150 }
\DoxyCodeLine{1151 \textcolor{comment}{/* Low-\/level function for converting unsigned 8-\/bit PCM samples to signed 32-\/bit PCM samples. */}}
\DoxyCodeLine{1152 DRWAV\_API \textcolor{keywordtype}{void} drwav\_u8\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1153 }
\DoxyCodeLine{1154 \textcolor{comment}{/* Low-\/level function for converting signed 16-\/bit PCM samples to signed 32-\/bit PCM samples. */}}
\DoxyCodeLine{1155 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s16\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_int16* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1156 }
\DoxyCodeLine{1157 \textcolor{comment}{/* Low-\/level function for converting signed 24-\/bit PCM samples to signed 32-\/bit PCM samples. */}}
\DoxyCodeLine{1158 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s24\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1159 }
\DoxyCodeLine{1160 \textcolor{comment}{/* Low-\/level function for converting IEEE 32-\/bit floating point samples to signed 32-\/bit PCM samples. */}}
\DoxyCodeLine{1161 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f32\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{float}* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1162 }
\DoxyCodeLine{1163 \textcolor{comment}{/* Low-\/level function for converting IEEE 64-\/bit floating point samples to signed 32-\/bit PCM samples. */}}
\DoxyCodeLine{1164 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f64\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{double}* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1165 }
\DoxyCodeLine{1166 \textcolor{comment}{/* Low-\/level function for converting A-\/law samples to signed 32-\/bit PCM samples. */}}
\DoxyCodeLine{1167 DRWAV\_API \textcolor{keywordtype}{void} drwav\_alaw\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1168 }
\DoxyCodeLine{1169 \textcolor{comment}{/* Low-\/level function for converting u-\/law samples to signed 32-\/bit PCM samples. */}}
\DoxyCodeLine{1170 DRWAV\_API \textcolor{keywordtype}{void} drwav\_mulaw\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount);}
\DoxyCodeLine{1171 }
\DoxyCodeLine{1172 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{/* DR\_WAV\_NO\_CONVERSION\_API */}\textcolor{preprocessor}{}}
\DoxyCodeLine{1173 }
\DoxyCodeLine{1174 }
\DoxyCodeLine{1175 \textcolor{comment}{/* High-\/Level Convenience Helpers */}}
\DoxyCodeLine{1176 }
\DoxyCodeLine{1177 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_STDIO}}
\DoxyCodeLine{1178 \textcolor{comment}{/*}}
\DoxyCodeLine{1179 \textcolor{comment}{Helper for initializing a wave file for reading using stdio.}}
\DoxyCodeLine{1180 \textcolor{comment}{}}
\DoxyCodeLine{1181 \textcolor{comment}{This holds the internal FILE object until drwav\_uninit() is called. Keep this in mind if you're caching drwav}}
\DoxyCodeLine{1182 \textcolor{comment}{objects because the operating system may restrict the number of file handles an application can have open at}}
\DoxyCodeLine{1183 \textcolor{comment}{any given time.}}
\DoxyCodeLine{1184 \textcolor{comment}{*/}}
\DoxyCodeLine{1185 DRWAV\_API drwav\_bool32 drwav\_init\_file(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1186 DRWAV\_API drwav\_bool32 drwav\_init\_file\_ex(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1187 DRWAV\_API drwav\_bool32 drwav\_init\_file\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1188 DRWAV\_API drwav\_bool32 drwav\_init\_file\_ex\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1189 DRWAV\_API drwav\_bool32 drwav\_init\_file\_with\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1190 DRWAV\_API drwav\_bool32 drwav\_init\_file\_with\_metadata\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1191 }
\DoxyCodeLine{1192 }
\DoxyCodeLine{1193 \textcolor{comment}{/*}}
\DoxyCodeLine{1194 \textcolor{comment}{Helper for initializing a wave file for writing using stdio.}}
\DoxyCodeLine{1195 \textcolor{comment}{}}
\DoxyCodeLine{1196 \textcolor{comment}{This holds the internal FILE object until drwav\_uninit() is called. Keep this in mind if you're caching drwav}}
\DoxyCodeLine{1197 \textcolor{comment}{objects because the operating system may restrict the number of file handles an application can have open at}}
\DoxyCodeLine{1198 \textcolor{comment}{any given time.}}
\DoxyCodeLine{1199 \textcolor{comment}{*/}}
\DoxyCodeLine{1200 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1201 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_sequential(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1202 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_sequential\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalPCMFrameCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1203 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1204 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_sequential\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1205 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_sequential\_pcm\_frames\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalPCMFrameCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1206 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{/* DR\_WAV\_NO\_STDIO */}\textcolor{preprocessor}{}}
\DoxyCodeLine{1207 }
\DoxyCodeLine{1208 \textcolor{comment}{/*}}
\DoxyCodeLine{1209 \textcolor{comment}{Helper for initializing a loader from a pre-\/allocated memory buffer.}}
\DoxyCodeLine{1210 \textcolor{comment}{}}
\DoxyCodeLine{1211 \textcolor{comment}{This does not create a copy of the data. It is up to the application to ensure the buffer remains valid for}}
\DoxyCodeLine{1212 \textcolor{comment}{the lifetime of the drwav object.}}
\DoxyCodeLine{1213 \textcolor{comment}{}}
\DoxyCodeLine{1214 \textcolor{comment}{The buffer should contain the contents of the entire wave file, not just the sample data.}}
\DoxyCodeLine{1215 \textcolor{comment}{*/}}
\DoxyCodeLine{1216 DRWAV\_API drwav\_bool32 drwav\_init\_memory(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1217 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_ex(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1218 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_with\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220 \textcolor{comment}{/*}}
\DoxyCodeLine{1221 \textcolor{comment}{Helper for initializing a writer which outputs data to a memory buffer.}}
\DoxyCodeLine{1222 \textcolor{comment}{}}
\DoxyCodeLine{1223 \textcolor{comment}{dr\_wav will manage the memory allocations, however it is up to the caller to free the data with drwav\_free().}}
\DoxyCodeLine{1224 \textcolor{comment}{}}
\DoxyCodeLine{1225 \textcolor{comment}{The buffer will remain allocated even after drwav\_uninit() is called. The buffer should not be considered valid}}
\DoxyCodeLine{1226 \textcolor{comment}{until after drwav\_uninit() has been called.}}
\DoxyCodeLine{1227 \textcolor{comment}{*/}}
\DoxyCodeLine{1228 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_write(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{void}** ppData, \textcolor{keywordtype}{size\_t}* pDataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1229 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_write\_sequential(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{void}** ppData, \textcolor{keywordtype}{size\_t}* pDataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1230 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_write\_sequential\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{void}** ppData, \textcolor{keywordtype}{size\_t}* pDataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalPCMFrameCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1231 }
\DoxyCodeLine{1232 }
\DoxyCodeLine{1233 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_CONVERSION\_API}}
\DoxyCodeLine{1234 \textcolor{comment}{/*}}
\DoxyCodeLine{1235 \textcolor{comment}{Opens and reads an entire wav file in a single operation.}}
\DoxyCodeLine{1236 \textcolor{comment}{}}
\DoxyCodeLine{1237 \textcolor{comment}{The return value is a heap-\/allocated buffer containing the audio data. Use drwav\_free() to free the buffer.}}
\DoxyCodeLine{1238 \textcolor{comment}{*/}}
\DoxyCodeLine{1239 DRWAV\_API drwav\_int16* drwav\_open\_and\_read\_pcm\_frames\_s16(drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1240 DRWAV\_API \textcolor{keywordtype}{float}* drwav\_open\_and\_read\_pcm\_frames\_f32(drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1241 DRWAV\_API drwav\_int32* drwav\_open\_and\_read\_pcm\_frames\_s32(drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1242 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_STDIO}}
\DoxyCodeLine{1243 \textcolor{comment}{/*}}
\DoxyCodeLine{1244 \textcolor{comment}{Opens and decodes an entire wav file in a single operation.}}
\DoxyCodeLine{1245 \textcolor{comment}{}}
\DoxyCodeLine{1246 \textcolor{comment}{The return value is a heap-\/allocated buffer containing the audio data. Use drwav\_free() to free the buffer.}}
\DoxyCodeLine{1247 \textcolor{comment}{*/}}
\DoxyCodeLine{1248 DRWAV\_API drwav\_int16* drwav\_open\_file\_and\_read\_pcm\_frames\_s16(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1249 DRWAV\_API \textcolor{keywordtype}{float}* drwav\_open\_file\_and\_read\_pcm\_frames\_f32(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1250 DRWAV\_API drwav\_int32* drwav\_open\_file\_and\_read\_pcm\_frames\_s32(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1251 DRWAV\_API drwav\_int16* drwav\_open\_file\_and\_read\_pcm\_frames\_s16\_w(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1252 DRWAV\_API \textcolor{keywordtype}{float}* drwav\_open\_file\_and\_read\_pcm\_frames\_f32\_w(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1253 DRWAV\_API drwav\_int32* drwav\_open\_file\_and\_read\_pcm\_frames\_s32\_w(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1254 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1255 \textcolor{comment}{/*}}
\DoxyCodeLine{1256 \textcolor{comment}{Opens and decodes an entire wav file from a block of memory in a single operation.}}
\DoxyCodeLine{1257 \textcolor{comment}{}}
\DoxyCodeLine{1258 \textcolor{comment}{The return value is a heap-\/allocated buffer containing the audio data. Use drwav\_free() to free the buffer.}}
\DoxyCodeLine{1259 \textcolor{comment}{*/}}
\DoxyCodeLine{1260 DRWAV\_API drwav\_int16* drwav\_open\_memory\_and\_read\_pcm\_frames\_s16(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1261 DRWAV\_API \textcolor{keywordtype}{float}* drwav\_open\_memory\_and\_read\_pcm\_frames\_f32(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1262 DRWAV\_API drwav\_int32* drwav\_open\_memory\_and\_read\_pcm\_frames\_s32(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1263 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1264 }
\DoxyCodeLine{1265 \textcolor{comment}{/* Frees data that was allocated internally by dr\_wav. */}}
\DoxyCodeLine{1266 DRWAV\_API \textcolor{keywordtype}{void} drwav\_free(\textcolor{keywordtype}{void}* p, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks);}
\DoxyCodeLine{1267 }
\DoxyCodeLine{1268 \textcolor{comment}{/* Converts bytes from a wav stream to a sized type of native endian. */}}
\DoxyCodeLine{1269 DRWAV\_API drwav\_uint16 drwav\_bytes\_to\_u16(\textcolor{keyword}{const} drwav\_uint8* data);}
\DoxyCodeLine{1270 DRWAV\_API drwav\_int16 drwav\_bytes\_to\_s16(\textcolor{keyword}{const} drwav\_uint8* data);}
\DoxyCodeLine{1271 DRWAV\_API drwav\_uint32 drwav\_bytes\_to\_u32(\textcolor{keyword}{const} drwav\_uint8* data);}
\DoxyCodeLine{1272 DRWAV\_API drwav\_int32 drwav\_bytes\_to\_s32(\textcolor{keyword}{const} drwav\_uint8* data);}
\DoxyCodeLine{1273 DRWAV\_API drwav\_uint64 drwav\_bytes\_to\_u64(\textcolor{keyword}{const} drwav\_uint8* data);}
\DoxyCodeLine{1274 DRWAV\_API drwav\_int64 drwav\_bytes\_to\_s64(\textcolor{keyword}{const} drwav\_uint8* data);}
\DoxyCodeLine{1275 DRWAV\_API \textcolor{keywordtype}{float} drwav\_bytes\_to\_f32(\textcolor{keyword}{const} drwav\_uint8* data);}
\DoxyCodeLine{1276 }
\DoxyCodeLine{1277 \textcolor{comment}{/* Compares a GUID for the purpose of checking the type of a Wave64 chunk. */}}
\DoxyCodeLine{1278 DRWAV\_API drwav\_bool32 drwav\_guid\_equal(\textcolor{keyword}{const} drwav\_uint8 a[16], \textcolor{keyword}{const} drwav\_uint8 b[16]);}
\DoxyCodeLine{1279 }
\DoxyCodeLine{1280 \textcolor{comment}{/* Compares a four-\/character-\/code for the purpose of checking the type of a RIFF chunk. */}}
\DoxyCodeLine{1281 DRWAV\_API drwav\_bool32 drwav\_fourcc\_equal(\textcolor{keyword}{const} drwav\_uint8* a, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* b);}
\DoxyCodeLine{1282 }
\DoxyCodeLine{1283 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{1284 \}}
\DoxyCodeLine{1285 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1286 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{/* dr\_wav\_h */}\textcolor{preprocessor}{}}
\DoxyCodeLine{1287 }
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289 \textcolor{comment}{/************************************************************************************************************************************************************}}
\DoxyCodeLine{1290 \textcolor{comment}{ ************************************************************************************************************************************************************}}
\DoxyCodeLine{1291 \textcolor{comment}{}}
\DoxyCodeLine{1292 \textcolor{comment}{ IMPLEMENTATION}}
\DoxyCodeLine{1293 \textcolor{comment}{}}
\DoxyCodeLine{1294 \textcolor{comment}{ ************************************************************************************************************************************************************}}
\DoxyCodeLine{1295 \textcolor{comment}{ ************************************************************************************************************************************************************/}}
\DoxyCodeLine{1296 \textcolor{preprocessor}{\#if defined(DR\_WAV\_IMPLEMENTATION) || defined(DRWAV\_IMPLEMENTATION)}}
\DoxyCodeLine{1297 \textcolor{preprocessor}{\#ifndef dr\_wav\_c}}
\DoxyCodeLine{1298 \textcolor{preprocessor}{\#define dr\_wav\_c}}
\DoxyCodeLine{1299 }
\DoxyCodeLine{1300 \textcolor{preprocessor}{\#include <stdlib.h>}}
\DoxyCodeLine{1301 \textcolor{preprocessor}{\#include <string.h>} \textcolor{comment}{/* For memcpy(), memset() */}}
\DoxyCodeLine{1302 \textcolor{preprocessor}{\#include <limits.h>} \textcolor{comment}{/* For INT\_MAX */}}
\DoxyCodeLine{1303 }
\DoxyCodeLine{1304 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_STDIO}}
\DoxyCodeLine{1305 \textcolor{preprocessor}{\#include <stdio.h>}}
\DoxyCodeLine{1306 \textcolor{preprocessor}{\#include <wchar.h>}}
\DoxyCodeLine{1307 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1308 }
\DoxyCodeLine{1309 \textcolor{comment}{/* Standard library stuff. */}}
\DoxyCodeLine{1310 \textcolor{preprocessor}{\#ifndef DRWAV\_ASSERT}}
\DoxyCodeLine{1311 \textcolor{preprocessor}{\#include <assert.h>}}
\DoxyCodeLine{1312 \textcolor{preprocessor}{\#define DRWAV\_ASSERT(expression)           assert(expression)}}
\DoxyCodeLine{1313 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1314 \textcolor{preprocessor}{\#ifndef DRWAV\_MALLOC}}
\DoxyCodeLine{1315 \textcolor{preprocessor}{\#define DRWAV\_MALLOC(sz)                   malloc((sz))}}
\DoxyCodeLine{1316 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1317 \textcolor{preprocessor}{\#ifndef DRWAV\_REALLOC}}
\DoxyCodeLine{1318 \textcolor{preprocessor}{\#define DRWAV\_REALLOC(p, sz)               realloc((p), (sz))}}
\DoxyCodeLine{1319 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1320 \textcolor{preprocessor}{\#ifndef DRWAV\_FREE}}
\DoxyCodeLine{1321 \textcolor{preprocessor}{\#define DRWAV\_FREE(p)                      free((p))}}
\DoxyCodeLine{1322 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1323 \textcolor{preprocessor}{\#ifndef DRWAV\_COPY\_MEMORY}}
\DoxyCodeLine{1324 \textcolor{preprocessor}{\#define DRWAV\_COPY\_MEMORY(dst, src, sz)    memcpy((dst), (src), (sz))}}
\DoxyCodeLine{1325 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1326 \textcolor{preprocessor}{\#ifndef DRWAV\_ZERO\_MEMORY}}
\DoxyCodeLine{1327 \textcolor{preprocessor}{\#define DRWAV\_ZERO\_MEMORY(p, sz)           memset((p), 0, (sz))}}
\DoxyCodeLine{1328 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1329 \textcolor{preprocessor}{\#ifndef DRWAV\_ZERO\_OBJECT}}
\DoxyCodeLine{1330 \textcolor{preprocessor}{\#define DRWAV\_ZERO\_OBJECT(p)               DRWAV\_ZERO\_MEMORY((p), sizeof(*p))}}
\DoxyCodeLine{1331 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1332 }
\DoxyCodeLine{1333 \textcolor{preprocessor}{\#define drwav\_countof(x)                   (sizeof(x) / sizeof(x[0]))}}
\DoxyCodeLine{1334 \textcolor{preprocessor}{\#define drwav\_align(x, a)                  ((((x) + (a) -\/ 1) / (a)) * (a))}}
\DoxyCodeLine{1335 \textcolor{preprocessor}{\#define drwav\_min(a, b)                    (((a) < (b)) ? (a) : (b))}}
\DoxyCodeLine{1336 \textcolor{preprocessor}{\#define drwav\_max(a, b)                    (((a) > (b)) ? (a) : (b))}}
\DoxyCodeLine{1337 \textcolor{preprocessor}{\#define drwav\_clamp(x, lo, hi)             (drwav\_max((lo), drwav\_min((hi), (x))))}}
\DoxyCodeLine{1338 \textcolor{preprocessor}{\#define drwav\_offset\_ptr(p, offset)        (((drwav\_uint8*)(p)) + (offset))}}
\DoxyCodeLine{1339 }
\DoxyCodeLine{1340 \textcolor{preprocessor}{\#define DRWAV\_MAX\_SIMD\_VECTOR\_SIZE         64  }\textcolor{comment}{/* 64 for AVX-\/512 in the future. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{1341 }
\DoxyCodeLine{1342 \textcolor{comment}{/* CPU architecture. */}}
\DoxyCodeLine{1343 \textcolor{preprocessor}{\#if defined(\_\_x86\_64\_\_) || defined(\_M\_X64)}}
\DoxyCodeLine{1344 \textcolor{preprocessor}{    \#define DRWAV\_X64}}
\DoxyCodeLine{1345 \textcolor{preprocessor}{\#elif defined(\_\_i386) || defined(\_M\_IX86)}}
\DoxyCodeLine{1346 \textcolor{preprocessor}{    \#define DRWAV\_X86}}
\DoxyCodeLine{1347 \textcolor{preprocessor}{\#elif defined(\_\_arm\_\_) || defined(\_M\_ARM)}}
\DoxyCodeLine{1348 \textcolor{preprocessor}{    \#define DRWAV\_ARM}}
\DoxyCodeLine{1349 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1350 }
\DoxyCodeLine{1351 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{1352 \textcolor{preprocessor}{    \#define DRWAV\_INLINE \_\_forceinline}}
\DoxyCodeLine{1353 \textcolor{preprocessor}{\#elif defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{1354     \textcolor{comment}{/*}}
\DoxyCodeLine{1355 \textcolor{comment}{    I've had a bug report where GCC is emitting warnings about functions possibly not being inlineable. This warning happens when}}
\DoxyCodeLine{1356 \textcolor{comment}{    the \_\_attribute\_\_((always\_inline)) attribute is defined without an "{}inline"{} statement. I think therefore there must be some}}
\DoxyCodeLine{1357 \textcolor{comment}{    case where "{}\_\_inline\_\_"{} is not always defined, thus the compiler emitting these warnings. When using -\/std=c89 or -\/ansi on the}}
\DoxyCodeLine{1358 \textcolor{comment}{    command line, we cannot use the "{}inline"{} keyword and instead need to use "{}\_\_inline\_\_"{}. In an attempt to work around this issue}}
\DoxyCodeLine{1359 \textcolor{comment}{    I am using "{}\_\_inline\_\_"{} only when we're compiling in strict ANSI mode.}}
\DoxyCodeLine{1360 \textcolor{comment}{    */}}
\DoxyCodeLine{1361 \textcolor{preprocessor}{    \#if defined(\_\_STRICT\_ANSI\_\_)}}
\DoxyCodeLine{1362 \textcolor{preprocessor}{        \#define DRWAV\_INLINE \_\_inline\_\_ \_\_attribute\_\_((always\_inline))}}
\DoxyCodeLine{1363 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1364 \textcolor{preprocessor}{        \#define DRWAV\_INLINE inline \_\_attribute\_\_((always\_inline))}}
\DoxyCodeLine{1365 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1366 \textcolor{preprocessor}{\#elif defined(\_\_WATCOMC\_\_)}}
\DoxyCodeLine{1367 \textcolor{preprocessor}{    \#define DRWAV\_INLINE \_\_inline}}
\DoxyCodeLine{1368 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1369 \textcolor{preprocessor}{    \#define DRWAV\_INLINE}}
\DoxyCodeLine{1370 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1371 }
\DoxyCodeLine{1372 \textcolor{preprocessor}{\#if defined(SIZE\_MAX)}}
\DoxyCodeLine{1373 \textcolor{preprocessor}{    \#define DRWAV\_SIZE\_MAX  SIZE\_MAX}}
\DoxyCodeLine{1374 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1375 \textcolor{preprocessor}{    \#if defined(\_WIN64) || defined(\_LP64) || defined(\_\_LP64\_\_)}}
\DoxyCodeLine{1376 \textcolor{preprocessor}{        \#define DRWAV\_SIZE\_MAX  ((drwav\_uint64)0xFFFFFFFFFFFFFFFF)}}
\DoxyCodeLine{1377 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1378 \textcolor{preprocessor}{        \#define DRWAV\_SIZE\_MAX  0xFFFFFFFF}}
\DoxyCodeLine{1379 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1380 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1381 }
\DoxyCodeLine{1382 \textcolor{preprocessor}{\#if defined(\_MSC\_VER) \&\& \_MSC\_VER >= 1400}}
\DoxyCodeLine{1383 \textcolor{preprocessor}{    \#define DRWAV\_HAS\_BYTESWAP16\_INTRINSIC}}
\DoxyCodeLine{1384 \textcolor{preprocessor}{    \#define DRWAV\_HAS\_BYTESWAP32\_INTRINSIC}}
\DoxyCodeLine{1385 \textcolor{preprocessor}{    \#define DRWAV\_HAS\_BYTESWAP64\_INTRINSIC}}
\DoxyCodeLine{1386 \textcolor{preprocessor}{\#elif defined(\_\_clang\_\_)}}
\DoxyCodeLine{1387 \textcolor{preprocessor}{    \#if defined(\_\_has\_builtin)}}
\DoxyCodeLine{1388 \textcolor{preprocessor}{        \#if \_\_has\_builtin(\_\_builtin\_bswap16)}}
\DoxyCodeLine{1389 \textcolor{preprocessor}{            \#define DRWAV\_HAS\_BYTESWAP16\_INTRINSIC}}
\DoxyCodeLine{1390 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{1391 \textcolor{preprocessor}{        \#if \_\_has\_builtin(\_\_builtin\_bswap32)}}
\DoxyCodeLine{1392 \textcolor{preprocessor}{            \#define DRWAV\_HAS\_BYTESWAP32\_INTRINSIC}}
\DoxyCodeLine{1393 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{1394 \textcolor{preprocessor}{        \#if \_\_has\_builtin(\_\_builtin\_bswap64)}}
\DoxyCodeLine{1395 \textcolor{preprocessor}{            \#define DRWAV\_HAS\_BYTESWAP64\_INTRINSIC}}
\DoxyCodeLine{1396 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{1397 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1398 \textcolor{preprocessor}{\#elif defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{1399 \textcolor{preprocessor}{    \#if ((\_\_GNUC\_\_ > 4) || (\_\_GNUC\_\_ == 4 \&\& \_\_GNUC\_MINOR\_\_ >= 3))}}
\DoxyCodeLine{1400 \textcolor{preprocessor}{        \#define DRWAV\_HAS\_BYTESWAP32\_INTRINSIC}}
\DoxyCodeLine{1401 \textcolor{preprocessor}{        \#define DRWAV\_HAS\_BYTESWAP64\_INTRINSIC}}
\DoxyCodeLine{1402 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1403 \textcolor{preprocessor}{    \#if ((\_\_GNUC\_\_ > 4) || (\_\_GNUC\_\_ == 4 \&\& \_\_GNUC\_MINOR\_\_ >= 8))}}
\DoxyCodeLine{1404 \textcolor{preprocessor}{        \#define DRWAV\_HAS\_BYTESWAP16\_INTRINSIC}}
\DoxyCodeLine{1405 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1406 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1407 }
\DoxyCodeLine{1408 DRWAV\_API \textcolor{keywordtype}{void} drwav\_version(drwav\_uint32* pMajor, drwav\_uint32* pMinor, drwav\_uint32* pRevision)}
\DoxyCodeLine{1409 \{}
\DoxyCodeLine{1410     \textcolor{keywordflow}{if} (pMajor) \{}
\DoxyCodeLine{1411         *pMajor = DRWAV\_VERSION\_MAJOR;}
\DoxyCodeLine{1412     \}}
\DoxyCodeLine{1413 }
\DoxyCodeLine{1414     \textcolor{keywordflow}{if} (pMinor) \{}
\DoxyCodeLine{1415         *pMinor = DRWAV\_VERSION\_MINOR;}
\DoxyCodeLine{1416     \}}
\DoxyCodeLine{1417 }
\DoxyCodeLine{1418     \textcolor{keywordflow}{if} (pRevision) \{}
\DoxyCodeLine{1419         *pRevision = DRWAV\_VERSION\_REVISION;}
\DoxyCodeLine{1420     \}}
\DoxyCodeLine{1421 \}}
\DoxyCodeLine{1422 }
\DoxyCodeLine{1423 DRWAV\_API \textcolor{keyword}{const} \textcolor{keywordtype}{char}* drwav\_version\_string(\textcolor{keywordtype}{void})}
\DoxyCodeLine{1424 \{}
\DoxyCodeLine{1425     \textcolor{keywordflow}{return} DRWAV\_VERSION\_STRING;}
\DoxyCodeLine{1426 \}}
\DoxyCodeLine{1427 }
\DoxyCodeLine{1428 \textcolor{comment}{/*}}
\DoxyCodeLine{1429 \textcolor{comment}{These limits are used for basic validation when initializing the decoder. If you exceed these limits, first of all: what on Earth are}}
\DoxyCodeLine{1430 \textcolor{comment}{you doing?! (Let me know, I'd be curious!) Second, you can adjust these by \#define-\/ing them before the dr\_wav implementation.}}
\DoxyCodeLine{1431 \textcolor{comment}{*/}}
\DoxyCodeLine{1432 \textcolor{preprocessor}{\#ifndef DRWAV\_MAX\_SAMPLE\_RATE}}
\DoxyCodeLine{1433 \textcolor{preprocessor}{\#define DRWAV\_MAX\_SAMPLE\_RATE       384000}}
\DoxyCodeLine{1434 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1435 \textcolor{preprocessor}{\#ifndef DRWAV\_MAX\_CHANNELS}}
\DoxyCodeLine{1436 \textcolor{preprocessor}{\#define DRWAV\_MAX\_CHANNELS          256}}
\DoxyCodeLine{1437 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1438 \textcolor{preprocessor}{\#ifndef DRWAV\_MAX\_BITS\_PER\_SAMPLE}}
\DoxyCodeLine{1439 \textcolor{preprocessor}{\#define DRWAV\_MAX\_BITS\_PER\_SAMPLE   64}}
\DoxyCodeLine{1440 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1441 }
\DoxyCodeLine{1442 \textcolor{keyword}{static} \textcolor{keyword}{const} drwav\_uint8 drwavGUID\_W64\_RIFF[16] = \{0x72,0x69,0x66,0x66, 0x2E,0x91, 0xCF,0x11, 0xA5,0xD6, 0x28,0xDB,0x04,0xC1,0x00,0x00\};    \textcolor{comment}{/* 66666972-\/912E-\/11CF-\/A5D6-\/28DB04C10000 */}}
\DoxyCodeLine{1443 \textcolor{keyword}{static} \textcolor{keyword}{const} drwav\_uint8 drwavGUID\_W64\_WAVE[16] = \{0x77,0x61,0x76,0x65, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A\};    \textcolor{comment}{/* 65766177-\/ACF3-\/11D3-\/8CD1-\/00C04F8EDB8A */}}
\DoxyCodeLine{1444 \textcolor{comment}{/*static const drwav\_uint8 drwavGUID\_W64\_JUNK[16] = \{0x6A,0x75,0x6E,0x6B, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A\};*/}    \textcolor{comment}{/* 6B6E756A-\/ACF3-\/11D3-\/8CD1-\/00C04F8EDB8A */}}
\DoxyCodeLine{1445 \textcolor{keyword}{static} \textcolor{keyword}{const} drwav\_uint8 drwavGUID\_W64\_FMT [16] = \{0x66,0x6D,0x74,0x20, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A\};    \textcolor{comment}{/* 20746D66-\/ACF3-\/11D3-\/8CD1-\/00C04F8EDB8A */}}
\DoxyCodeLine{1446 \textcolor{keyword}{static} \textcolor{keyword}{const} drwav\_uint8 drwavGUID\_W64\_FACT[16] = \{0x66,0x61,0x63,0x74, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A\};    \textcolor{comment}{/* 74636166-\/ACF3-\/11D3-\/8CD1-\/00C04F8EDB8A */}}
\DoxyCodeLine{1447 \textcolor{keyword}{static} \textcolor{keyword}{const} drwav\_uint8 drwavGUID\_W64\_DATA[16] = \{0x64,0x61,0x74,0x61, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A\};    \textcolor{comment}{/* 61746164-\/ACF3-\/11D3-\/8CD1-\/00C04F8EDB8A */}}
\DoxyCodeLine{1448 \textcolor{comment}{/*static const drwav\_uint8 drwavGUID\_W64\_SMPL[16] = \{0x73,0x6D,0x70,0x6C, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A\};*/}    \textcolor{comment}{/* 6C706D73-\/ACF3-\/11D3-\/8CD1-\/00C04F8EDB8A */}}
\DoxyCodeLine{1449 }
\DoxyCodeLine{1450 }
\DoxyCodeLine{1451 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{int} drwav\_\_is\_little\_endian(\textcolor{keywordtype}{void})}
\DoxyCodeLine{1452 \{}
\DoxyCodeLine{1453 \textcolor{preprocessor}{\#if defined(DRWAV\_X86) || defined(DRWAV\_X64)}}
\DoxyCodeLine{1454     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{1455 \textcolor{preprocessor}{\#elif defined(\_\_BYTE\_ORDER) \&\& defined(\_\_LITTLE\_ENDIAN) \&\& \_\_BYTE\_ORDER == \_\_LITTLE\_ENDIAN}}
\DoxyCodeLine{1456     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{1457 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1458     \textcolor{keywordtype}{int} n = 1;}
\DoxyCodeLine{1459     \textcolor{keywordflow}{return} (*(\textcolor{keywordtype}{char}*)\&n) == 1;}
\DoxyCodeLine{1460 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1461 \}}
\DoxyCodeLine{1462 }
\DoxyCodeLine{1463 }
\DoxyCodeLine{1464 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_bytes\_to\_guid(\textcolor{keyword}{const} drwav\_uint8* data, drwav\_uint8* guid)}
\DoxyCodeLine{1465 \{}
\DoxyCodeLine{1466     \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{1467     \textcolor{keywordflow}{for} (i = 0; i < 16; ++i) \{}
\DoxyCodeLine{1468         guid[i] = data[i];}
\DoxyCodeLine{1469     \}}
\DoxyCodeLine{1470 \}}
\DoxyCodeLine{1471 }
\DoxyCodeLine{1472 }
\DoxyCodeLine{1473 \textcolor{keyword}{static} DRWAV\_INLINE drwav\_uint16 drwav\_\_bswap16(drwav\_uint16 n)}
\DoxyCodeLine{1474 \{}
\DoxyCodeLine{1475 \textcolor{preprocessor}{\#ifdef DRWAV\_HAS\_BYTESWAP16\_INTRINSIC}}
\DoxyCodeLine{1476 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{1477         \textcolor{keywordflow}{return} \_byteswap\_ushort(n);}
\DoxyCodeLine{1478 \textcolor{preprocessor}{    \#elif defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{1479         \textcolor{keywordflow}{return} \_\_builtin\_bswap16(n);}
\DoxyCodeLine{1480 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1481 \textcolor{preprocessor}{        \#error "{}This compiler does not support the byte swap intrinsic."{}}}
\DoxyCodeLine{1482 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1483 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1484     \textcolor{keywordflow}{return} ((n \& 0xFF00) >> 8) |}
\DoxyCodeLine{1485            ((n \& 0x00FF) << 8);}
\DoxyCodeLine{1486 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1487 \}}
\DoxyCodeLine{1488 }
\DoxyCodeLine{1489 \textcolor{keyword}{static} DRWAV\_INLINE drwav\_uint32 drwav\_\_bswap32(drwav\_uint32 n)}
\DoxyCodeLine{1490 \{}
\DoxyCodeLine{1491 \textcolor{preprocessor}{\#ifdef DRWAV\_HAS\_BYTESWAP32\_INTRINSIC}}
\DoxyCodeLine{1492 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{1493         \textcolor{keywordflow}{return} \_byteswap\_ulong(n);}
\DoxyCodeLine{1494 \textcolor{preprocessor}{    \#elif defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{1495 \textcolor{preprocessor}{        \#if defined(DRWAV\_ARM) \&\& (defined(\_\_ARM\_ARCH) \&\& \_\_ARM\_ARCH >= 6) \&\& !defined(DRWAV\_64BIT)   }\textcolor{comment}{/* <-\/-\/ 64-\/bit inline assembly has not been tested, so disabling for now. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{1496             \textcolor{comment}{/* Inline assembly optimized implementation for ARM. In my testing, GCC does not generate optimized code with \_\_builtin\_bswap32(). */}}
\DoxyCodeLine{1497             drwav\_uint32 r;}
\DoxyCodeLine{1498             \_\_asm\_\_ \_\_volatile\_\_ (}
\DoxyCodeLine{1499             \#\textcolor{keywordflow}{if} defined(DRWAV\_64BIT)}
\DoxyCodeLine{1500                 \textcolor{stringliteral}{"{}rev \%w[out], \%w[in]"{}} : [out]\textcolor{stringliteral}{"{}=r"{}}(r) : [in]\textcolor{stringliteral}{"{}r"{}}(n)   \textcolor{comment}{/* <-\/-\/ This is untested. If someone in the community could test this, that would be appreciated! */}}
\DoxyCodeLine{1501             \#\textcolor{keywordflow}{else}}
\DoxyCodeLine{1502                 \textcolor{stringliteral}{"{}rev \%[out], \%[in]"{}} : [out]\textcolor{stringliteral}{"{}=r"{}}(r) : [in]\textcolor{stringliteral}{"{}r"{}}(n)}
\DoxyCodeLine{1503             \#endif}
\DoxyCodeLine{1504             );}
\DoxyCodeLine{1505             \textcolor{keywordflow}{return} r;}
\DoxyCodeLine{1506 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{1507             \textcolor{keywordflow}{return} \_\_builtin\_bswap32(n);}
\DoxyCodeLine{1508 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{1509 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1510 \textcolor{preprocessor}{        \#error "{}This compiler does not support the byte swap intrinsic."{}}}
\DoxyCodeLine{1511 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1512 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1513     \textcolor{keywordflow}{return} ((n \& 0xFF000000) >> 24) |}
\DoxyCodeLine{1514            ((n \& 0x00FF0000) >>  8) |}
\DoxyCodeLine{1515            ((n \& 0x0000FF00) <<  8) |}
\DoxyCodeLine{1516            ((n \& 0x000000FF) << 24);}
\DoxyCodeLine{1517 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1518 \}}
\DoxyCodeLine{1519 }
\DoxyCodeLine{1520 \textcolor{keyword}{static} DRWAV\_INLINE drwav\_uint64 drwav\_\_bswap64(drwav\_uint64 n)}
\DoxyCodeLine{1521 \{}
\DoxyCodeLine{1522 \textcolor{preprocessor}{\#ifdef DRWAV\_HAS\_BYTESWAP64\_INTRINSIC}}
\DoxyCodeLine{1523 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{1524         \textcolor{keywordflow}{return} \_byteswap\_uint64(n);}
\DoxyCodeLine{1525 \textcolor{preprocessor}{    \#elif defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{1526         \textcolor{keywordflow}{return} \_\_builtin\_bswap64(n);}
\DoxyCodeLine{1527 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1528 \textcolor{preprocessor}{        \#error "{}This compiler does not support the byte swap intrinsic."{}}}
\DoxyCodeLine{1529 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1530 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1531     \textcolor{comment}{/* Weird "{}<< 32"{} bitshift is required for C89 because it doesn't support 64-\/bit constants. Should be optimized out by a good compiler. */}}
\DoxyCodeLine{1532     \textcolor{keywordflow}{return} ((n \& ((drwav\_uint64)0xFF000000 << 32)) >> 56) |}
\DoxyCodeLine{1533            ((n \& ((drwav\_uint64)0x00FF0000 << 32)) >> 40) |}
\DoxyCodeLine{1534            ((n \& ((drwav\_uint64)0x0000FF00 << 32)) >> 24) |}
\DoxyCodeLine{1535            ((n \& ((drwav\_uint64)0x000000FF << 32)) >>  8) |}
\DoxyCodeLine{1536            ((n \& ((drwav\_uint64)0xFF000000      )) <<  8) |}
\DoxyCodeLine{1537            ((n \& ((drwav\_uint64)0x00FF0000      )) << 24) |}
\DoxyCodeLine{1538            ((n \& ((drwav\_uint64)0x0000FF00      )) << 40) |}
\DoxyCodeLine{1539            ((n \& ((drwav\_uint64)0x000000FF      )) << 56);}
\DoxyCodeLine{1540 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1541 \}}
\DoxyCodeLine{1542 }
\DoxyCodeLine{1543 }
\DoxyCodeLine{1544 \textcolor{keyword}{static} DRWAV\_INLINE drwav\_int16 drwav\_\_bswap\_s16(drwav\_int16 n)}
\DoxyCodeLine{1545 \{}
\DoxyCodeLine{1546     \textcolor{keywordflow}{return} (drwav\_int16)drwav\_\_bswap16((drwav\_uint16)n);}
\DoxyCodeLine{1547 \}}
\DoxyCodeLine{1548 }
\DoxyCodeLine{1549 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_samples\_s16(drwav\_int16* pSamples, drwav\_uint64 sampleCount)}
\DoxyCodeLine{1550 \{}
\DoxyCodeLine{1551     drwav\_uint64 iSample;}
\DoxyCodeLine{1552     \textcolor{keywordflow}{for} (iSample = 0; iSample < sampleCount; iSample += 1) \{}
\DoxyCodeLine{1553         pSamples[iSample] = drwav\_\_bswap\_s16(pSamples[iSample]);}
\DoxyCodeLine{1554     \}}
\DoxyCodeLine{1555 \}}
\DoxyCodeLine{1556 }
\DoxyCodeLine{1557 }
\DoxyCodeLine{1558 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_s24(drwav\_uint8* p)}
\DoxyCodeLine{1559 \{}
\DoxyCodeLine{1560     drwav\_uint8 t;}
\DoxyCodeLine{1561     t = p[0];}
\DoxyCodeLine{1562     p[0] = p[2];}
\DoxyCodeLine{1563     p[2] = t;}
\DoxyCodeLine{1564 \}}
\DoxyCodeLine{1565 }
\DoxyCodeLine{1566 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_samples\_s24(drwav\_uint8* pSamples, drwav\_uint64 sampleCount)}
\DoxyCodeLine{1567 \{}
\DoxyCodeLine{1568     drwav\_uint64 iSample;}
\DoxyCodeLine{1569     \textcolor{keywordflow}{for} (iSample = 0; iSample < sampleCount; iSample += 1) \{}
\DoxyCodeLine{1570         drwav\_uint8* pSample = pSamples + (iSample*3);}
\DoxyCodeLine{1571         drwav\_\_bswap\_s24(pSample);}
\DoxyCodeLine{1572     \}}
\DoxyCodeLine{1573 \}}
\DoxyCodeLine{1574 }
\DoxyCodeLine{1575 }
\DoxyCodeLine{1576 \textcolor{keyword}{static} DRWAV\_INLINE drwav\_int32 drwav\_\_bswap\_s32(drwav\_int32 n)}
\DoxyCodeLine{1577 \{}
\DoxyCodeLine{1578     \textcolor{keywordflow}{return} (drwav\_int32)drwav\_\_bswap32((drwav\_uint32)n);}
\DoxyCodeLine{1579 \}}
\DoxyCodeLine{1580 }
\DoxyCodeLine{1581 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_samples\_s32(drwav\_int32* pSamples, drwav\_uint64 sampleCount)}
\DoxyCodeLine{1582 \{}
\DoxyCodeLine{1583     drwav\_uint64 iSample;}
\DoxyCodeLine{1584     \textcolor{keywordflow}{for} (iSample = 0; iSample < sampleCount; iSample += 1) \{}
\DoxyCodeLine{1585         pSamples[iSample] = drwav\_\_bswap\_s32(pSamples[iSample]);}
\DoxyCodeLine{1586     \}}
\DoxyCodeLine{1587 \}}
\DoxyCodeLine{1588 }
\DoxyCodeLine{1589 }
\DoxyCodeLine{1590 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{float} drwav\_\_bswap\_f32(\textcolor{keywordtype}{float} n)}
\DoxyCodeLine{1591 \{}
\DoxyCodeLine{1592     \textcolor{keyword}{union }\{}
\DoxyCodeLine{1593         drwav\_uint32 i;}
\DoxyCodeLine{1594         \textcolor{keywordtype}{float} f;}
\DoxyCodeLine{1595     \} x;}
\DoxyCodeLine{1596     x.f = n;}
\DoxyCodeLine{1597     x.i = drwav\_\_bswap32(x.i);}
\DoxyCodeLine{1598 }
\DoxyCodeLine{1599     \textcolor{keywordflow}{return} x.f;}
\DoxyCodeLine{1600 \}}
\DoxyCodeLine{1601 }
\DoxyCodeLine{1602 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_samples\_f32(\textcolor{keywordtype}{float}* pSamples, drwav\_uint64 sampleCount)}
\DoxyCodeLine{1603 \{}
\DoxyCodeLine{1604     drwav\_uint64 iSample;}
\DoxyCodeLine{1605     \textcolor{keywordflow}{for} (iSample = 0; iSample < sampleCount; iSample += 1) \{}
\DoxyCodeLine{1606         pSamples[iSample] = drwav\_\_bswap\_f32(pSamples[iSample]);}
\DoxyCodeLine{1607     \}}
\DoxyCodeLine{1608 \}}
\DoxyCodeLine{1609 }
\DoxyCodeLine{1610 }
\DoxyCodeLine{1611 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{double} drwav\_\_bswap\_f64(\textcolor{keywordtype}{double} n)}
\DoxyCodeLine{1612 \{}
\DoxyCodeLine{1613     \textcolor{keyword}{union }\{}
\DoxyCodeLine{1614         drwav\_uint64 i;}
\DoxyCodeLine{1615         \textcolor{keywordtype}{double} f;}
\DoxyCodeLine{1616     \} x;}
\DoxyCodeLine{1617     x.f = n;}
\DoxyCodeLine{1618     x.i = drwav\_\_bswap64(x.i);}
\DoxyCodeLine{1619 }
\DoxyCodeLine{1620     \textcolor{keywordflow}{return} x.f;}
\DoxyCodeLine{1621 \}}
\DoxyCodeLine{1622 }
\DoxyCodeLine{1623 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_samples\_f64(\textcolor{keywordtype}{double}* pSamples, drwav\_uint64 sampleCount)}
\DoxyCodeLine{1624 \{}
\DoxyCodeLine{1625     drwav\_uint64 iSample;}
\DoxyCodeLine{1626     \textcolor{keywordflow}{for} (iSample = 0; iSample < sampleCount; iSample += 1) \{}
\DoxyCodeLine{1627         pSamples[iSample] = drwav\_\_bswap\_f64(pSamples[iSample]);}
\DoxyCodeLine{1628     \}}
\DoxyCodeLine{1629 \}}
\DoxyCodeLine{1630 }
\DoxyCodeLine{1631 }
\DoxyCodeLine{1632 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_samples\_pcm(\textcolor{keywordtype}{void}* pSamples, drwav\_uint64 sampleCount, drwav\_uint32 bytesPerSample)}
\DoxyCodeLine{1633 \{}
\DoxyCodeLine{1634     \textcolor{comment}{/* Assumes integer PCM. Floating point PCM is done in drwav\_\_bswap\_samples\_ieee(). */}}
\DoxyCodeLine{1635     \textcolor{keywordflow}{switch} (bytesPerSample)}
\DoxyCodeLine{1636     \{}
\DoxyCodeLine{1637         \textcolor{keywordflow}{case} 1: \textcolor{comment}{/* u8 */}}
\DoxyCodeLine{1638         \{}
\DoxyCodeLine{1639             \textcolor{comment}{/* no-\/op. */}}
\DoxyCodeLine{1640         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1641         \textcolor{keywordflow}{case} 2: \textcolor{comment}{/* s16, s12 (loosely packed) */}}
\DoxyCodeLine{1642         \{}
\DoxyCodeLine{1643             drwav\_\_bswap\_samples\_s16((drwav\_int16*)pSamples, sampleCount);}
\DoxyCodeLine{1644         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1645         \textcolor{keywordflow}{case} 3: \textcolor{comment}{/* s24 */}}
\DoxyCodeLine{1646         \{}
\DoxyCodeLine{1647             drwav\_\_bswap\_samples\_s24((drwav\_uint8*)pSamples, sampleCount);}
\DoxyCodeLine{1648         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1649         \textcolor{keywordflow}{case} 4: \textcolor{comment}{/* s32 */}}
\DoxyCodeLine{1650         \{}
\DoxyCodeLine{1651             drwav\_\_bswap\_samples\_s32((drwav\_int32*)pSamples, sampleCount);}
\DoxyCodeLine{1652         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1653         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1654         \{}
\DoxyCodeLine{1655             \textcolor{comment}{/* Unsupported format. */}}
\DoxyCodeLine{1656             DRWAV\_ASSERT(DRWAV\_FALSE);}
\DoxyCodeLine{1657         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1658     \}}
\DoxyCodeLine{1659 \}}
\DoxyCodeLine{1660 }
\DoxyCodeLine{1661 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_samples\_ieee(\textcolor{keywordtype}{void}* pSamples, drwav\_uint64 sampleCount, drwav\_uint32 bytesPerSample)}
\DoxyCodeLine{1662 \{}
\DoxyCodeLine{1663     \textcolor{keywordflow}{switch} (bytesPerSample)}
\DoxyCodeLine{1664     \{}
\DoxyCodeLine{1665 \textcolor{preprocessor}{    \#if 0   }\textcolor{comment}{/* Contributions welcome for f16 support. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{1666         \textcolor{keywordflow}{case} 2: \textcolor{comment}{/* f16 */}}
\DoxyCodeLine{1667         \{}
\DoxyCodeLine{1668             drwav\_\_bswap\_samples\_f16((drwav\_float16*)pSamples, sampleCount);}
\DoxyCodeLine{1669         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1670 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1671         \textcolor{keywordflow}{case} 4: \textcolor{comment}{/* f32 */}}
\DoxyCodeLine{1672         \{}
\DoxyCodeLine{1673             drwav\_\_bswap\_samples\_f32((\textcolor{keywordtype}{float}*)pSamples, sampleCount);}
\DoxyCodeLine{1674         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1675         \textcolor{keywordflow}{case} 8: \textcolor{comment}{/* f64 */}}
\DoxyCodeLine{1676         \{}
\DoxyCodeLine{1677             drwav\_\_bswap\_samples\_f64((\textcolor{keywordtype}{double}*)pSamples, sampleCount);}
\DoxyCodeLine{1678         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1679         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1680         \{}
\DoxyCodeLine{1681             \textcolor{comment}{/* Unsupported format. */}}
\DoxyCodeLine{1682             DRWAV\_ASSERT(DRWAV\_FALSE);}
\DoxyCodeLine{1683         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1684     \}}
\DoxyCodeLine{1685 \}}
\DoxyCodeLine{1686 }
\DoxyCodeLine{1687 \textcolor{keyword}{static} DRWAV\_INLINE \textcolor{keywordtype}{void} drwav\_\_bswap\_samples(\textcolor{keywordtype}{void}* pSamples, drwav\_uint64 sampleCount, drwav\_uint32 bytesPerSample, drwav\_uint16 format)}
\DoxyCodeLine{1688 \{}
\DoxyCodeLine{1689     \textcolor{keywordflow}{switch} (format)}
\DoxyCodeLine{1690     \{}
\DoxyCodeLine{1691         \textcolor{keywordflow}{case} DR\_WAVE\_FORMAT\_PCM:}
\DoxyCodeLine{1692         \{}
\DoxyCodeLine{1693             drwav\_\_bswap\_samples\_pcm(pSamples, sampleCount, bytesPerSample);}
\DoxyCodeLine{1694         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1695 }
\DoxyCodeLine{1696         \textcolor{keywordflow}{case} DR\_WAVE\_FORMAT\_IEEE\_FLOAT:}
\DoxyCodeLine{1697         \{}
\DoxyCodeLine{1698             drwav\_\_bswap\_samples\_ieee(pSamples, sampleCount, bytesPerSample);}
\DoxyCodeLine{1699         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1700 }
\DoxyCodeLine{1701         \textcolor{keywordflow}{case} DR\_WAVE\_FORMAT\_ALAW:}
\DoxyCodeLine{1702         \textcolor{keywordflow}{case} DR\_WAVE\_FORMAT\_MULAW:}
\DoxyCodeLine{1703         \{}
\DoxyCodeLine{1704             drwav\_\_bswap\_samples\_s16((drwav\_int16*)pSamples, sampleCount);}
\DoxyCodeLine{1705         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1706 }
\DoxyCodeLine{1707         \textcolor{keywordflow}{case} DR\_WAVE\_FORMAT\_ADPCM:}
\DoxyCodeLine{1708         \textcolor{keywordflow}{case} DR\_WAVE\_FORMAT\_DVI\_ADPCM:}
\DoxyCodeLine{1709         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1710         \{}
\DoxyCodeLine{1711             \textcolor{comment}{/* Unsupported format. */}}
\DoxyCodeLine{1712             DRWAV\_ASSERT(DRWAV\_FALSE);}
\DoxyCodeLine{1713         \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{1714     \}}
\DoxyCodeLine{1715 \}}
\DoxyCodeLine{1716 }
\DoxyCodeLine{1717 }
\DoxyCodeLine{1718 DRWAV\_PRIVATE \textcolor{keywordtype}{void}* drwav\_\_malloc\_default(\textcolor{keywordtype}{size\_t} sz, \textcolor{keywordtype}{void}* pUserData)}
\DoxyCodeLine{1719 \{}
\DoxyCodeLine{1720     (void)pUserData;}
\DoxyCodeLine{1721     \textcolor{keywordflow}{return} DRWAV\_MALLOC(sz);}
\DoxyCodeLine{1722 \}}
\DoxyCodeLine{1723 }
\DoxyCodeLine{1724 DRWAV\_PRIVATE \textcolor{keywordtype}{void}* drwav\_\_realloc\_default(\textcolor{keywordtype}{void}* p, \textcolor{keywordtype}{size\_t} sz, \textcolor{keywordtype}{void}* pUserData)}
\DoxyCodeLine{1725 \{}
\DoxyCodeLine{1726     (void)pUserData;}
\DoxyCodeLine{1727     \textcolor{keywordflow}{return} DRWAV\_REALLOC(p, sz);}
\DoxyCodeLine{1728 \}}
\DoxyCodeLine{1729 }
\DoxyCodeLine{1730 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_free\_default(\textcolor{keywordtype}{void}* p, \textcolor{keywordtype}{void}* pUserData)}
\DoxyCodeLine{1731 \{}
\DoxyCodeLine{1732     (void)pUserData;}
\DoxyCodeLine{1733     DRWAV\_FREE(p);}
\DoxyCodeLine{1734 \}}
\DoxyCodeLine{1735 }
\DoxyCodeLine{1736 }
\DoxyCodeLine{1737 DRWAV\_PRIVATE \textcolor{keywordtype}{void}* drwav\_\_malloc\_from\_callbacks(\textcolor{keywordtype}{size\_t} sz, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{1738 \{}
\DoxyCodeLine{1739     \textcolor{keywordflow}{if} (pAllocationCallbacks == NULL) \{}
\DoxyCodeLine{1740         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{1741     \}}
\DoxyCodeLine{1742 }
\DoxyCodeLine{1743     \textcolor{keywordflow}{if} (pAllocationCallbacks-\/>onMalloc != NULL) \{}
\DoxyCodeLine{1744         \textcolor{keywordflow}{return} pAllocationCallbacks-\/>onMalloc(sz, pAllocationCallbacks-\/>pUserData);}
\DoxyCodeLine{1745     \}}
\DoxyCodeLine{1746 }
\DoxyCodeLine{1747     \textcolor{comment}{/* Try using realloc(). */}}
\DoxyCodeLine{1748     \textcolor{keywordflow}{if} (pAllocationCallbacks-\/>onRealloc != NULL) \{}
\DoxyCodeLine{1749         \textcolor{keywordflow}{return} pAllocationCallbacks-\/>onRealloc(NULL, sz, pAllocationCallbacks-\/>pUserData);}
\DoxyCodeLine{1750     \}}
\DoxyCodeLine{1751 }
\DoxyCodeLine{1752     \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{1753 \}}
\DoxyCodeLine{1754 }
\DoxyCodeLine{1755 DRWAV\_PRIVATE \textcolor{keywordtype}{void}* drwav\_\_realloc\_from\_callbacks(\textcolor{keywordtype}{void}* p, \textcolor{keywordtype}{size\_t} szNew, \textcolor{keywordtype}{size\_t} szOld, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{1756 \{}
\DoxyCodeLine{1757     \textcolor{keywordflow}{if} (pAllocationCallbacks == NULL) \{}
\DoxyCodeLine{1758         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{1759     \}}
\DoxyCodeLine{1760 }
\DoxyCodeLine{1761     \textcolor{keywordflow}{if} (pAllocationCallbacks-\/>onRealloc != NULL) \{}
\DoxyCodeLine{1762         \textcolor{keywordflow}{return} pAllocationCallbacks-\/>onRealloc(p, szNew, pAllocationCallbacks-\/>pUserData);}
\DoxyCodeLine{1763     \}}
\DoxyCodeLine{1764 }
\DoxyCodeLine{1765     \textcolor{comment}{/* Try emulating realloc() in terms of malloc()/free(). */}}
\DoxyCodeLine{1766     \textcolor{keywordflow}{if} (pAllocationCallbacks-\/>onMalloc != NULL \&\& pAllocationCallbacks-\/>onFree != NULL) \{}
\DoxyCodeLine{1767         \textcolor{keywordtype}{void}* p2;}
\DoxyCodeLine{1768 }
\DoxyCodeLine{1769         p2 = pAllocationCallbacks-\/>onMalloc(szNew, pAllocationCallbacks-\/>pUserData);}
\DoxyCodeLine{1770         \textcolor{keywordflow}{if} (p2 == NULL) \{}
\DoxyCodeLine{1771             \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{1772         \}}
\DoxyCodeLine{1773 }
\DoxyCodeLine{1774         \textcolor{keywordflow}{if} (p != NULL) \{}
\DoxyCodeLine{1775             DRWAV\_COPY\_MEMORY(p2, p, szOld);}
\DoxyCodeLine{1776             pAllocationCallbacks-\/>onFree(p, pAllocationCallbacks-\/>pUserData);}
\DoxyCodeLine{1777         \}}
\DoxyCodeLine{1778 }
\DoxyCodeLine{1779         \textcolor{keywordflow}{return} p2;}
\DoxyCodeLine{1780     \}}
\DoxyCodeLine{1781 }
\DoxyCodeLine{1782     \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{1783 \}}
\DoxyCodeLine{1784 }
\DoxyCodeLine{1785 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_free\_from\_callbacks(\textcolor{keywordtype}{void}* p, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{1786 \{}
\DoxyCodeLine{1787     \textcolor{keywordflow}{if} (p == NULL || pAllocationCallbacks == NULL) \{}
\DoxyCodeLine{1788         \textcolor{keywordflow}{return};}
\DoxyCodeLine{1789     \}}
\DoxyCodeLine{1790 }
\DoxyCodeLine{1791     \textcolor{keywordflow}{if} (pAllocationCallbacks-\/>onFree != NULL) \{}
\DoxyCodeLine{1792         pAllocationCallbacks-\/>onFree(p, pAllocationCallbacks-\/>pUserData);}
\DoxyCodeLine{1793     \}}
\DoxyCodeLine{1794 \}}
\DoxyCodeLine{1795 }
\DoxyCodeLine{1796 }
\DoxyCodeLine{1797 DRWAV\_PRIVATE \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}} drwav\_copy\_allocation\_callbacks\_or\_defaults(\textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{1798 \{}
\DoxyCodeLine{1799     \textcolor{keywordflow}{if} (pAllocationCallbacks != NULL) \{}
\DoxyCodeLine{1800         \textcolor{comment}{/* Copy. */}}
\DoxyCodeLine{1801         \textcolor{keywordflow}{return} *pAllocationCallbacks;}
\DoxyCodeLine{1802     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1803         \textcolor{comment}{/* Defaults. */}}
\DoxyCodeLine{1804         \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}} allocationCallbacks;}
\DoxyCodeLine{1805         allocationCallbacks.pUserData = NULL;}
\DoxyCodeLine{1806         allocationCallbacks.onMalloc  = drwav\_\_malloc\_default;}
\DoxyCodeLine{1807         allocationCallbacks.onRealloc = drwav\_\_realloc\_default;}
\DoxyCodeLine{1808         allocationCallbacks.onFree    = drwav\_\_free\_default;}
\DoxyCodeLine{1809         \textcolor{keywordflow}{return} allocationCallbacks;}
\DoxyCodeLine{1810     \}}
\DoxyCodeLine{1811 \}}
\DoxyCodeLine{1812 }
\DoxyCodeLine{1813 }
\DoxyCodeLine{1814 \textcolor{keyword}{static} DRWAV\_INLINE drwav\_bool32 drwav\_\_is\_compressed\_format\_tag(drwav\_uint16 formatTag)}
\DoxyCodeLine{1815 \{}
\DoxyCodeLine{1816     \textcolor{keywordflow}{return}}
\DoxyCodeLine{1817         formatTag == DR\_WAVE\_FORMAT\_ADPCM ||}
\DoxyCodeLine{1818         formatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM;}
\DoxyCodeLine{1819 \}}
\DoxyCodeLine{1820 }
\DoxyCodeLine{1821 DRWAV\_PRIVATE \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} drwav\_\_chunk\_padding\_size\_riff(drwav\_uint64 chunkSize)}
\DoxyCodeLine{1822 \{}
\DoxyCodeLine{1823     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})(chunkSize \% 2);}
\DoxyCodeLine{1824 \}}
\DoxyCodeLine{1825 }
\DoxyCodeLine{1826 DRWAV\_PRIVATE \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} drwav\_\_chunk\_padding\_size\_w64(drwav\_uint64 chunkSize)}
\DoxyCodeLine{1827 \{}
\DoxyCodeLine{1828     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})(chunkSize \% 8);}
\DoxyCodeLine{1829 \}}
\DoxyCodeLine{1830 }
\DoxyCodeLine{1831 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s16\_\_msadpcm(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 samplesToRead, drwav\_int16* pBufferOut);}
\DoxyCodeLine{1832 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s16\_\_ima(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 samplesToRead, drwav\_int16* pBufferOut);}
\DoxyCodeLine{1833 DRWAV\_PRIVATE drwav\_bool32 drwav\_init\_write\_\_internal(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount);}
\DoxyCodeLine{1834 }
\DoxyCodeLine{1835 DRWAV\_PRIVATE drwav\_result drwav\_\_read\_chunk\_header(drwav\_read\_proc onRead, \textcolor{keywordtype}{void}* pUserData, drwav\_container container, drwav\_uint64* pRunningBytesReadOut, \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}}* pHeaderOut)}
\DoxyCodeLine{1836 \{}
\DoxyCodeLine{1837     \textcolor{keywordflow}{if} (container == drwav\_container\_riff || container == drwav\_container\_rf64) \{}
\DoxyCodeLine{1838         drwav\_uint8 sizeInBytes[4];}
\DoxyCodeLine{1839 }
\DoxyCodeLine{1840         \textcolor{keywordflow}{if} (onRead(pUserData, pHeaderOut-\/>id.fourcc, 4) != 4) \{}
\DoxyCodeLine{1841             \textcolor{keywordflow}{return} DRWAV\_AT\_END;}
\DoxyCodeLine{1842         \}}
\DoxyCodeLine{1843 }
\DoxyCodeLine{1844         \textcolor{keywordflow}{if} (onRead(pUserData, sizeInBytes, 4) != 4) \{}
\DoxyCodeLine{1845             \textcolor{keywordflow}{return} DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{1846         \}}
\DoxyCodeLine{1847 }
\DoxyCodeLine{1848         pHeaderOut-\/>sizeInBytes = drwav\_bytes\_to\_u32(sizeInBytes);}
\DoxyCodeLine{1849         pHeaderOut-\/>paddingSize = drwav\_\_chunk\_padding\_size\_riff(pHeaderOut-\/>sizeInBytes);}
\DoxyCodeLine{1850         *pRunningBytesReadOut += 8;}
\DoxyCodeLine{1851     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1852         drwav\_uint8 sizeInBytes[8];}
\DoxyCodeLine{1853 }
\DoxyCodeLine{1854         \textcolor{keywordflow}{if} (onRead(pUserData, pHeaderOut-\/>id.guid, 16) != 16) \{}
\DoxyCodeLine{1855             \textcolor{keywordflow}{return} DRWAV\_AT\_END;}
\DoxyCodeLine{1856         \}}
\DoxyCodeLine{1857 }
\DoxyCodeLine{1858         \textcolor{keywordflow}{if} (onRead(pUserData, sizeInBytes, 8) != 8) \{}
\DoxyCodeLine{1859             \textcolor{keywordflow}{return} DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{1860         \}}
\DoxyCodeLine{1861 }
\DoxyCodeLine{1862         pHeaderOut-\/>sizeInBytes = drwav\_bytes\_to\_u64(sizeInBytes) -\/ 24;    \textcolor{comment}{/* <-\/-\/ Subtract 24 because w64 includes the size of the header. */}}
\DoxyCodeLine{1863         pHeaderOut-\/>paddingSize = drwav\_\_chunk\_padding\_size\_w64(pHeaderOut-\/>sizeInBytes);}
\DoxyCodeLine{1864         *pRunningBytesReadOut += 24;}
\DoxyCodeLine{1865     \}}
\DoxyCodeLine{1866 }
\DoxyCodeLine{1867     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{1868 \}}
\DoxyCodeLine{1869 }
\DoxyCodeLine{1870 DRWAV\_PRIVATE drwav\_bool32 drwav\_\_seek\_forward(drwav\_seek\_proc onSeek, drwav\_uint64 offset, \textcolor{keywordtype}{void}* pUserData)}
\DoxyCodeLine{1871 \{}
\DoxyCodeLine{1872     drwav\_uint64 bytesRemainingToSeek = offset;}
\DoxyCodeLine{1873     \textcolor{keywordflow}{while} (bytesRemainingToSeek > 0) \{}
\DoxyCodeLine{1874         \textcolor{keywordflow}{if} (bytesRemainingToSeek > 0x7FFFFFFF) \{}
\DoxyCodeLine{1875             \textcolor{keywordflow}{if} (!onSeek(pUserData, 0x7FFFFFFF, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{1876                 \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1877             \}}
\DoxyCodeLine{1878             bytesRemainingToSeek -\/= 0x7FFFFFFF;}
\DoxyCodeLine{1879         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1880             \textcolor{keywordflow}{if} (!onSeek(pUserData, (\textcolor{keywordtype}{int})bytesRemainingToSeek, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{1881                 \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1882             \}}
\DoxyCodeLine{1883             bytesRemainingToSeek = 0;}
\DoxyCodeLine{1884         \}}
\DoxyCodeLine{1885     \}}
\DoxyCodeLine{1886 }
\DoxyCodeLine{1887     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{1888 \}}
\DoxyCodeLine{1889 }
\DoxyCodeLine{1890 DRWAV\_PRIVATE drwav\_bool32 drwav\_\_seek\_from\_start(drwav\_seek\_proc onSeek, drwav\_uint64 offset, \textcolor{keywordtype}{void}* pUserData)}
\DoxyCodeLine{1891 \{}
\DoxyCodeLine{1892     \textcolor{keywordflow}{if} (offset <= 0x7FFFFFFF) \{}
\DoxyCodeLine{1893         \textcolor{keywordflow}{return} onSeek(pUserData, (\textcolor{keywordtype}{int})offset, drwav\_seek\_origin\_start);}
\DoxyCodeLine{1894     \}}
\DoxyCodeLine{1895 }
\DoxyCodeLine{1896     \textcolor{comment}{/* Larger than 32-\/bit seek. */}}
\DoxyCodeLine{1897     \textcolor{keywordflow}{if} (!onSeek(pUserData, 0x7FFFFFFF, drwav\_seek\_origin\_start)) \{}
\DoxyCodeLine{1898         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1899     \}}
\DoxyCodeLine{1900     offset -\/= 0x7FFFFFFF;}
\DoxyCodeLine{1901 }
\DoxyCodeLine{1902     \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{1903         \textcolor{keywordflow}{if} (offset <= 0x7FFFFFFF) \{}
\DoxyCodeLine{1904             \textcolor{keywordflow}{return} onSeek(pUserData, (\textcolor{keywordtype}{int})offset, drwav\_seek\_origin\_current);}
\DoxyCodeLine{1905         \}}
\DoxyCodeLine{1906 }
\DoxyCodeLine{1907         \textcolor{keywordflow}{if} (!onSeek(pUserData, 0x7FFFFFFF, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{1908             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1909         \}}
\DoxyCodeLine{1910         offset -\/= 0x7FFFFFFF;}
\DoxyCodeLine{1911     \}}
\DoxyCodeLine{1912 }
\DoxyCodeLine{1913     \textcolor{comment}{/* Should never get here. */}}
\DoxyCodeLine{1914     \textcolor{comment}{/*return DRWAV\_TRUE; */}}
\DoxyCodeLine{1915 \}}
\DoxyCodeLine{1916 }
\DoxyCodeLine{1917 }
\DoxyCodeLine{1918 DRWAV\_PRIVATE drwav\_bool32 drwav\_\_read\_fmt(drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, drwav\_container container, drwav\_uint64* pRunningBytesReadOut, \mbox{\hyperlink{structdrwav__fmt}{drwav\_fmt}}* fmtOut)}
\DoxyCodeLine{1919 \{}
\DoxyCodeLine{1920     \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}} header;}
\DoxyCodeLine{1921     drwav\_uint8 fmt[16];}
\DoxyCodeLine{1922 }
\DoxyCodeLine{1923     \textcolor{keywordflow}{if} (drwav\_\_read\_chunk\_header(onRead, pUserData, container, pRunningBytesReadOut, \&header) != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{1924         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1925     \}}
\DoxyCodeLine{1926 }
\DoxyCodeLine{1927 }
\DoxyCodeLine{1928     \textcolor{comment}{/* Skip non-\/fmt chunks. */}}
\DoxyCodeLine{1929     \textcolor{keywordflow}{while} (((container == drwav\_container\_riff || container == drwav\_container\_rf64) \&\& !drwav\_fourcc\_equal(header.id.fourcc, \textcolor{stringliteral}{"{}fmt "{}})) || (container == drwav\_container\_w64 \&\& !drwav\_guid\_equal(header.id.guid, drwavGUID\_W64\_FMT))) \{}
\DoxyCodeLine{1930         \textcolor{keywordflow}{if} (!drwav\_\_seek\_forward(onSeek, header.sizeInBytes + header.paddingSize, pUserData)) \{}
\DoxyCodeLine{1931             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1932         \}}
\DoxyCodeLine{1933         *pRunningBytesReadOut += header.sizeInBytes + header.paddingSize;}
\DoxyCodeLine{1934 }
\DoxyCodeLine{1935         \textcolor{comment}{/* Try the next header. */}}
\DoxyCodeLine{1936         \textcolor{keywordflow}{if} (drwav\_\_read\_chunk\_header(onRead, pUserData, container, pRunningBytesReadOut, \&header) != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{1937             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1938         \}}
\DoxyCodeLine{1939     \}}
\DoxyCodeLine{1940 }
\DoxyCodeLine{1941 }
\DoxyCodeLine{1942     \textcolor{comment}{/* Validation. */}}
\DoxyCodeLine{1943     \textcolor{keywordflow}{if} (container == drwav\_container\_riff || container == drwav\_container\_rf64) \{}
\DoxyCodeLine{1944         \textcolor{keywordflow}{if} (!drwav\_fourcc\_equal(header.id.fourcc, \textcolor{stringliteral}{"{}fmt "{}})) \{}
\DoxyCodeLine{1945             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1946         \}}
\DoxyCodeLine{1947     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1948         \textcolor{keywordflow}{if} (!drwav\_guid\_equal(header.id.guid, drwavGUID\_W64\_FMT)) \{}
\DoxyCodeLine{1949             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1950         \}}
\DoxyCodeLine{1951     \}}
\DoxyCodeLine{1952 }
\DoxyCodeLine{1953 }
\DoxyCodeLine{1954     \textcolor{keywordflow}{if} (onRead(pUserData, fmt, \textcolor{keyword}{sizeof}(fmt)) != \textcolor{keyword}{sizeof}(fmt)) \{}
\DoxyCodeLine{1955         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1956     \}}
\DoxyCodeLine{1957     *pRunningBytesReadOut += \textcolor{keyword}{sizeof}(fmt);}
\DoxyCodeLine{1958 }
\DoxyCodeLine{1959     fmtOut-\/>formatTag      = drwav\_bytes\_to\_u16(fmt + 0);}
\DoxyCodeLine{1960     fmtOut-\/>channels       = drwav\_bytes\_to\_u16(fmt + 2);}
\DoxyCodeLine{1961     fmtOut-\/>sampleRate     = drwav\_bytes\_to\_u32(fmt + 4);}
\DoxyCodeLine{1962     fmtOut-\/>avgBytesPerSec = drwav\_bytes\_to\_u32(fmt + 8);}
\DoxyCodeLine{1963     fmtOut-\/>blockAlign     = drwav\_bytes\_to\_u16(fmt + 12);}
\DoxyCodeLine{1964     fmtOut-\/>bitsPerSample  = drwav\_bytes\_to\_u16(fmt + 14);}
\DoxyCodeLine{1965 }
\DoxyCodeLine{1966     fmtOut-\/>extendedSize       = 0;}
\DoxyCodeLine{1967     fmtOut-\/>validBitsPerSample = 0;}
\DoxyCodeLine{1968     fmtOut-\/>channelMask        = 0;}
\DoxyCodeLine{1969     memset(fmtOut-\/>subFormat, 0, \textcolor{keyword}{sizeof}(fmtOut-\/>subFormat));}
\DoxyCodeLine{1970 }
\DoxyCodeLine{1971     \textcolor{keywordflow}{if} (header.sizeInBytes > 16) \{}
\DoxyCodeLine{1972         drwav\_uint8 fmt\_cbSize[2];}
\DoxyCodeLine{1973         \textcolor{keywordtype}{int} bytesReadSoFar = 0;}
\DoxyCodeLine{1974 }
\DoxyCodeLine{1975         \textcolor{keywordflow}{if} (onRead(pUserData, fmt\_cbSize, \textcolor{keyword}{sizeof}(fmt\_cbSize)) != \textcolor{keyword}{sizeof}(fmt\_cbSize)) \{}
\DoxyCodeLine{1976             \textcolor{keywordflow}{return} DRWAV\_FALSE;    \textcolor{comment}{/* Expecting more data. */}}
\DoxyCodeLine{1977         \}}
\DoxyCodeLine{1978         *pRunningBytesReadOut += \textcolor{keyword}{sizeof}(fmt\_cbSize);}
\DoxyCodeLine{1979 }
\DoxyCodeLine{1980         bytesReadSoFar = 18;}
\DoxyCodeLine{1981 }
\DoxyCodeLine{1982         fmtOut-\/>extendedSize = drwav\_bytes\_to\_u16(fmt\_cbSize);}
\DoxyCodeLine{1983         \textcolor{keywordflow}{if} (fmtOut-\/>extendedSize > 0) \{}
\DoxyCodeLine{1984             \textcolor{comment}{/* Simple validation. */}}
\DoxyCodeLine{1985             \textcolor{keywordflow}{if} (fmtOut-\/>formatTag == DR\_WAVE\_FORMAT\_EXTENSIBLE) \{}
\DoxyCodeLine{1986                 \textcolor{keywordflow}{if} (fmtOut-\/>extendedSize != 22) \{}
\DoxyCodeLine{1987                     \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{1988                 \}}
\DoxyCodeLine{1989             \}}
\DoxyCodeLine{1990 }
\DoxyCodeLine{1991             \textcolor{keywordflow}{if} (fmtOut-\/>formatTag == DR\_WAVE\_FORMAT\_EXTENSIBLE) \{}
\DoxyCodeLine{1992                 drwav\_uint8 fmtext[22];}
\DoxyCodeLine{1993                 \textcolor{keywordflow}{if} (onRead(pUserData, fmtext, fmtOut-\/>extendedSize) != fmtOut-\/>extendedSize) \{}
\DoxyCodeLine{1994                     \textcolor{keywordflow}{return} DRWAV\_FALSE;    \textcolor{comment}{/* Expecting more data. */}}
\DoxyCodeLine{1995                 \}}
\DoxyCodeLine{1996 }
\DoxyCodeLine{1997                 fmtOut-\/>validBitsPerSample = drwav\_bytes\_to\_u16(fmtext + 0);}
\DoxyCodeLine{1998                 fmtOut-\/>channelMask        = drwav\_bytes\_to\_u32(fmtext + 2);}
\DoxyCodeLine{1999                 drwav\_bytes\_to\_guid(fmtext + 6, fmtOut-\/>subFormat);}
\DoxyCodeLine{2000             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2001                 \textcolor{keywordflow}{if} (!onSeek(pUserData, fmtOut-\/>extendedSize, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{2002                     \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{2003                 \}}
\DoxyCodeLine{2004             \}}
\DoxyCodeLine{2005             *pRunningBytesReadOut += fmtOut-\/>extendedSize;}
\DoxyCodeLine{2006 }
\DoxyCodeLine{2007             bytesReadSoFar += fmtOut-\/>extendedSize;}
\DoxyCodeLine{2008         \}}
\DoxyCodeLine{2009 }
\DoxyCodeLine{2010         \textcolor{comment}{/* Seek past any leftover bytes. For w64 the leftover will be defined based on the chunk size. */}}
\DoxyCodeLine{2011         \textcolor{keywordflow}{if} (!onSeek(pUserData, (\textcolor{keywordtype}{int})(header.sizeInBytes -\/ bytesReadSoFar), drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{2012             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{2013         \}}
\DoxyCodeLine{2014         *pRunningBytesReadOut += (header.sizeInBytes -\/ bytesReadSoFar);}
\DoxyCodeLine{2015     \}}
\DoxyCodeLine{2016 }
\DoxyCodeLine{2017     \textcolor{keywordflow}{if} (header.paddingSize > 0) \{}
\DoxyCodeLine{2018         \textcolor{keywordflow}{if} (!onSeek(pUserData, header.paddingSize, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{2019             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{2020         \}}
\DoxyCodeLine{2021         *pRunningBytesReadOut += header.paddingSize;}
\DoxyCodeLine{2022     \}}
\DoxyCodeLine{2023 }
\DoxyCodeLine{2024     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{2025 \}}
\DoxyCodeLine{2026 }
\DoxyCodeLine{2027 }
\DoxyCodeLine{2028 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_on\_read(drwav\_read\_proc onRead, \textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{void}* pBufferOut, \textcolor{keywordtype}{size\_t} bytesToRead, drwav\_uint64* pCursor)}
\DoxyCodeLine{2029 \{}
\DoxyCodeLine{2030     \textcolor{keywordtype}{size\_t} bytesRead;}
\DoxyCodeLine{2031 }
\DoxyCodeLine{2032     DRWAV\_ASSERT(onRead != NULL);}
\DoxyCodeLine{2033     DRWAV\_ASSERT(pCursor != NULL);}
\DoxyCodeLine{2034 }
\DoxyCodeLine{2035     bytesRead = onRead(pUserData, pBufferOut, bytesToRead);}
\DoxyCodeLine{2036     *pCursor += bytesRead;}
\DoxyCodeLine{2037     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2038 \}}
\DoxyCodeLine{2039 }
\DoxyCodeLine{2040 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{2041 DRWAV\_PRIVATE drwav\_bool32 drwav\_\_on\_seek(drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{int} offset, drwav\_seek\_origin origin, drwav\_uint64* pCursor)}
\DoxyCodeLine{2042 \{}
\DoxyCodeLine{2043     DRWAV\_ASSERT(onSeek != NULL);}
\DoxyCodeLine{2044     DRWAV\_ASSERT(pCursor != NULL);}
\DoxyCodeLine{2045 }
\DoxyCodeLine{2046     \textcolor{keywordflow}{if} (!onSeek(pUserData, offset, origin)) \{}
\DoxyCodeLine{2047         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{2048     \}}
\DoxyCodeLine{2049 }
\DoxyCodeLine{2050     \textcolor{keywordflow}{if} (origin == drwav\_seek\_origin\_start) \{}
\DoxyCodeLine{2051         *pCursor = offset;}
\DoxyCodeLine{2052     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2053         *pCursor += offset;}
\DoxyCodeLine{2054     \}}
\DoxyCodeLine{2055 }
\DoxyCodeLine{2056     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{2057 \}}
\DoxyCodeLine{2058 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2059 }
\DoxyCodeLine{2060 }
\DoxyCodeLine{2061 \textcolor{preprocessor}{\#define DRWAV\_SMPL\_BYTES                    36}}
\DoxyCodeLine{2062 \textcolor{preprocessor}{\#define DRWAV\_SMPL\_LOOP\_BYTES               24}}
\DoxyCodeLine{2063 \textcolor{preprocessor}{\#define DRWAV\_INST\_BYTES                    7}}
\DoxyCodeLine{2064 \textcolor{preprocessor}{\#define DRWAV\_ACID\_BYTES                    24}}
\DoxyCodeLine{2065 \textcolor{preprocessor}{\#define DRWAV\_CUE\_BYTES                     4}}
\DoxyCodeLine{2066 \textcolor{preprocessor}{\#define DRWAV\_BEXT\_BYTES                    602}}
\DoxyCodeLine{2067 \textcolor{preprocessor}{\#define DRWAV\_BEXT\_DESCRIPTION\_BYTES        256}}
\DoxyCodeLine{2068 \textcolor{preprocessor}{\#define DRWAV\_BEXT\_ORIGINATOR\_NAME\_BYTES    32}}
\DoxyCodeLine{2069 \textcolor{preprocessor}{\#define DRWAV\_BEXT\_ORIGINATOR\_REF\_BYTES     32}}
\DoxyCodeLine{2070 \textcolor{preprocessor}{\#define DRWAV\_BEXT\_RESERVED\_BYTES           180}}
\DoxyCodeLine{2071 \textcolor{preprocessor}{\#define DRWAV\_BEXT\_UMID\_BYTES               64}}
\DoxyCodeLine{2072 \textcolor{preprocessor}{\#define DRWAV\_CUE\_POINT\_BYTES               24}}
\DoxyCodeLine{2073 \textcolor{preprocessor}{\#define DRWAV\_LIST\_LABEL\_OR\_NOTE\_BYTES      4}}
\DoxyCodeLine{2074 \textcolor{preprocessor}{\#define DRWAV\_LIST\_LABELLED\_TEXT\_BYTES      20}}
\DoxyCodeLine{2075 }
\DoxyCodeLine{2076 \textcolor{preprocessor}{\#define DRWAV\_METADATA\_ALIGNMENT            8}}
\DoxyCodeLine{2077 }
\DoxyCodeLine{2078 \textcolor{keyword}{typedef} \textcolor{keyword}{enum}}
\DoxyCodeLine{2079 \{}
\DoxyCodeLine{2080     drwav\_\_metadata\_parser\_stage\_count,}
\DoxyCodeLine{2081     drwav\_\_metadata\_parser\_stage\_read}
\DoxyCodeLine{2082 \} drwav\_\_metadata\_parser\_stage;}
\DoxyCodeLine{2083 }
\DoxyCodeLine{2084 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{2085 \{}
\DoxyCodeLine{2086     drwav\_read\_proc onRead;}
\DoxyCodeLine{2087     drwav\_seek\_proc onSeek;}
\DoxyCodeLine{2088     \textcolor{keywordtype}{void} *pReadSeekUserData;}
\DoxyCodeLine{2089     drwav\_\_metadata\_parser\_stage stage;}
\DoxyCodeLine{2090     \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}} *pMetadata;}
\DoxyCodeLine{2091     drwav\_uint32 metadataCount;}
\DoxyCodeLine{2092     drwav\_uint8 *pData;}
\DoxyCodeLine{2093     drwav\_uint8 *pDataCursor;}
\DoxyCodeLine{2094     drwav\_uint64 metadataCursor;}
\DoxyCodeLine{2095     drwav\_uint64 extraCapacity;}
\DoxyCodeLine{2096 \} drwav\_\_metadata\_parser;}
\DoxyCodeLine{2097 }
\DoxyCodeLine{2098 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_metadata\_memory\_capacity(drwav\_\_metadata\_parser* pParser)}
\DoxyCodeLine{2099 \{}
\DoxyCodeLine{2100     drwav\_uint64 cap = \textcolor{keyword}{sizeof}(\mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}) * (drwav\_uint64)pParser-\/>metadataCount + pParser-\/>extraCapacity;}
\DoxyCodeLine{2101     \textcolor{keywordflow}{if} (cap > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{2102         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Too big. */}}
\DoxyCodeLine{2103     \}}
\DoxyCodeLine{2104 }
\DoxyCodeLine{2105     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{size\_t})cap; \textcolor{comment}{/* Safe cast thanks to the check above. */}}
\DoxyCodeLine{2106 \}}
\DoxyCodeLine{2107 }
\DoxyCodeLine{2108 DRWAV\_PRIVATE drwav\_uint8* drwav\_\_metadata\_get\_memory(drwav\_\_metadata\_parser* pParser, \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} align)}
\DoxyCodeLine{2109 \{}
\DoxyCodeLine{2110     drwav\_uint8* pResult;}
\DoxyCodeLine{2111 }
\DoxyCodeLine{2112     \textcolor{keywordflow}{if} (align) \{}
\DoxyCodeLine{2113         drwav\_uintptr modulo = (drwav\_uintptr)pParser-\/>pDataCursor \% align;}
\DoxyCodeLine{2114         if (modulo != 0) \{}
\DoxyCodeLine{2115             pParser-\/>pDataCursor += align -\/ modulo;}
\DoxyCodeLine{2116         \}}
\DoxyCodeLine{2117     \}}
\DoxyCodeLine{2118     }
\DoxyCodeLine{2119     pResult = pParser-\/>pDataCursor;}
\DoxyCodeLine{2120 }
\DoxyCodeLine{2121     \textcolor{comment}{/*}}
\DoxyCodeLine{2122 \textcolor{comment}{    Getting to the point where this function is called means there should always be memory}}
\DoxyCodeLine{2123 \textcolor{comment}{    available. Out of memory checks should have been done at an earlier stage.}}
\DoxyCodeLine{2124 \textcolor{comment}{    */}}
\DoxyCodeLine{2125     DRWAV\_ASSERT((pResult + size) <= (pParser-\/>pData + drwav\_\_metadata\_memory\_capacity(pParser)));}
\DoxyCodeLine{2126 }
\DoxyCodeLine{2127     pParser-\/>pDataCursor += size;}
\DoxyCodeLine{2128     \textcolor{keywordflow}{return} pResult;}
\DoxyCodeLine{2129 \}}
\DoxyCodeLine{2130 }
\DoxyCodeLine{2131 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(drwav\_\_metadata\_parser* pParser, \textcolor{keywordtype}{size\_t} bytes, \textcolor{keywordtype}{size\_t} align)}
\DoxyCodeLine{2132 \{}
\DoxyCodeLine{2133     \textcolor{keywordtype}{size\_t} extra = bytes + (align ? (align -\/ 1) : 0);}
\DoxyCodeLine{2134     pParser-\/>extraCapacity += extra;}
\DoxyCodeLine{2135 \}}
\DoxyCodeLine{2136 }
\DoxyCodeLine{2137 DRWAV\_PRIVATE drwav\_result drwav\_\_metadata\_alloc(drwav\_\_metadata\_parser* pParser, \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{2138 \{}
\DoxyCodeLine{2139     \textcolor{keywordflow}{if} (pParser-\/>extraCapacity != 0 || pParser-\/>metadataCount != 0) \{}
\DoxyCodeLine{2140         free(pParser-\/>pData);}
\DoxyCodeLine{2141 }
\DoxyCodeLine{2142         pParser-\/>pData = (drwav\_uint8*)pAllocationCallbacks-\/>onMalloc(drwav\_\_metadata\_memory\_capacity(pParser), pAllocationCallbacks-\/>pUserData);}
\DoxyCodeLine{2143         pParser-\/>pDataCursor = pParser-\/>pData;}
\DoxyCodeLine{2144 }
\DoxyCodeLine{2145         \textcolor{keywordflow}{if} (pParser-\/>pData == NULL) \{}
\DoxyCodeLine{2146             \textcolor{keywordflow}{return} DRWAV\_OUT\_OF\_MEMORY;}
\DoxyCodeLine{2147         \}}
\DoxyCodeLine{2148 }
\DoxyCodeLine{2149         \textcolor{comment}{/*}}
\DoxyCodeLine{2150 \textcolor{comment}{        We don't need to worry about specifying an alignment here because malloc always returns something}}
\DoxyCodeLine{2151 \textcolor{comment}{        of suitable alignment. This also means than pParser-\/>pMetadata is all that we need to store in order}}
\DoxyCodeLine{2152 \textcolor{comment}{        for us to free when we are done.}}
\DoxyCodeLine{2153 \textcolor{comment}{        */}}
\DoxyCodeLine{2154         pParser-\/>pMetadata = (\mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}*)drwav\_\_metadata\_get\_memory(pParser, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}) * pParser-\/>metadataCount, 1);}
\DoxyCodeLine{2155         pParser-\/>metadataCursor = 0;}
\DoxyCodeLine{2156     \}}
\DoxyCodeLine{2157 }
\DoxyCodeLine{2158     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{2159 \}}
\DoxyCodeLine{2160 }
\DoxyCodeLine{2161 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_metadata\_parser\_read(drwav\_\_metadata\_parser* pParser, \textcolor{keywordtype}{void}* pBufferOut, \textcolor{keywordtype}{size\_t} bytesToRead, drwav\_uint64* pCursor)}
\DoxyCodeLine{2162 \{}
\DoxyCodeLine{2163     \textcolor{keywordflow}{if} (pCursor != NULL) \{}
\DoxyCodeLine{2164         \textcolor{keywordflow}{return} drwav\_\_on\_read(pParser-\/>onRead, pParser-\/>pReadSeekUserData, pBufferOut, bytesToRead, pCursor);}
\DoxyCodeLine{2165     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2166         \textcolor{keywordflow}{return} pParser-\/>onRead(pParser-\/>pReadSeekUserData, pBufferOut, bytesToRead);}
\DoxyCodeLine{2167     \}}
\DoxyCodeLine{2168 \}}
\DoxyCodeLine{2169 }
\DoxyCodeLine{2170 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_read\_smpl\_to\_metadata\_obj(drwav\_\_metadata\_parser* pParser, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}}* pChunkHeader, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata)}
\DoxyCodeLine{2171 \{}
\DoxyCodeLine{2172     drwav\_uint8 smplHeaderData[DRWAV\_SMPL\_BYTES];}
\DoxyCodeLine{2173     drwav\_uint64 totalBytesRead = 0;}
\DoxyCodeLine{2174     \textcolor{keywordtype}{size\_t} bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, smplHeaderData, \textcolor{keyword}{sizeof}(smplHeaderData), \&totalBytesRead);}
\DoxyCodeLine{2175 }
\DoxyCodeLine{2176     DRWAV\_ASSERT(pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_read);}
\DoxyCodeLine{2177     DRWAV\_ASSERT(pChunkHeader != NULL);}
\DoxyCodeLine{2178 }
\DoxyCodeLine{2179     \textcolor{keywordflow}{if} (bytesJustRead == \textcolor{keyword}{sizeof}(smplHeaderData)) \{}
\DoxyCodeLine{2180         drwav\_uint32 iSampleLoop;}
\DoxyCodeLine{2181 }
\DoxyCodeLine{2182         pMetadata-\/>type                                     = drwav\_metadata\_type\_smpl;}
\DoxyCodeLine{2183         pMetadata-\/>data.smpl.manufacturerId                 = drwav\_bytes\_to\_u32(smplHeaderData + 0);}
\DoxyCodeLine{2184         pMetadata-\/>data.smpl.productId                      = drwav\_bytes\_to\_u32(smplHeaderData + 4);}
\DoxyCodeLine{2185         pMetadata-\/>data.smpl.samplePeriodNanoseconds        = drwav\_bytes\_to\_u32(smplHeaderData + 8);}
\DoxyCodeLine{2186         pMetadata-\/>data.smpl.midiUnityNote                  = drwav\_bytes\_to\_u32(smplHeaderData + 12);}
\DoxyCodeLine{2187         pMetadata-\/>data.smpl.midiPitchFraction              = drwav\_bytes\_to\_u32(smplHeaderData + 16);}
\DoxyCodeLine{2188         pMetadata-\/>data.smpl.smpteFormat                    = drwav\_bytes\_to\_u32(smplHeaderData + 20);}
\DoxyCodeLine{2189         pMetadata-\/>data.smpl.smpteOffset                    = drwav\_bytes\_to\_u32(smplHeaderData + 24);}
\DoxyCodeLine{2190         pMetadata-\/>data.smpl.sampleLoopCount                = drwav\_bytes\_to\_u32(smplHeaderData + 28);}
\DoxyCodeLine{2191         pMetadata-\/>data.smpl.samplerSpecificDataSizeInBytes = drwav\_bytes\_to\_u32(smplHeaderData + 32);}
\DoxyCodeLine{2192 }
\DoxyCodeLine{2193         \textcolor{comment}{/*}}
\DoxyCodeLine{2194 \textcolor{comment}{        The loop count needs to be validated against the size of the chunk for safety so we don't}}
\DoxyCodeLine{2195 \textcolor{comment}{        attempt to read over the boundary of the chunk.}}
\DoxyCodeLine{2196 \textcolor{comment}{        */}}
\DoxyCodeLine{2197         \textcolor{keywordflow}{if} (pMetadata-\/>data.smpl.sampleLoopCount == (pChunkHeader-\/>sizeInBytes -\/ DRWAV\_SMPL\_BYTES) / DRWAV\_SMPL\_LOOP\_BYTES) \{}
\DoxyCodeLine{2198             pMetadata-\/>data.smpl.pLoops = (\mbox{\hyperlink{structdrwav__smpl__loop}{drwav\_smpl\_loop}}*)drwav\_\_metadata\_get\_memory(pParser, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{structdrwav__smpl__loop}{drwav\_smpl\_loop}}) * pMetadata-\/>data.smpl.sampleLoopCount, DRWAV\_METADATA\_ALIGNMENT);}
\DoxyCodeLine{2199 }
\DoxyCodeLine{2200             \textcolor{keywordflow}{for} (iSampleLoop = 0; iSampleLoop < pMetadata-\/>data.smpl.sampleLoopCount; ++iSampleLoop) \{}
\DoxyCodeLine{2201                 drwav\_uint8 smplLoopData[DRWAV\_SMPL\_LOOP\_BYTES];}
\DoxyCodeLine{2202                 bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, smplLoopData, \textcolor{keyword}{sizeof}(smplLoopData), \&totalBytesRead);}
\DoxyCodeLine{2203 }
\DoxyCodeLine{2204                 \textcolor{keywordflow}{if} (bytesJustRead == \textcolor{keyword}{sizeof}(smplLoopData)) \{}
\DoxyCodeLine{2205                     pMetadata-\/>data.smpl.pLoops[iSampleLoop].cuePointId            = drwav\_bytes\_to\_u32(smplLoopData + 0);}
\DoxyCodeLine{2206                     pMetadata-\/>data.smpl.pLoops[iSampleLoop].type                  = drwav\_bytes\_to\_u32(smplLoopData + 4);}
\DoxyCodeLine{2207                     pMetadata-\/>data.smpl.pLoops[iSampleLoop].firstSampleByteOffset = drwav\_bytes\_to\_u32(smplLoopData + 8);}
\DoxyCodeLine{2208                     pMetadata-\/>data.smpl.pLoops[iSampleLoop].lastSampleByteOffset  = drwav\_bytes\_to\_u32(smplLoopData + 12);}
\DoxyCodeLine{2209                     pMetadata-\/>data.smpl.pLoops[iSampleLoop].sampleFraction        = drwav\_bytes\_to\_u32(smplLoopData + 16);}
\DoxyCodeLine{2210                     pMetadata-\/>data.smpl.pLoops[iSampleLoop].playCount             = drwav\_bytes\_to\_u32(smplLoopData + 20);}
\DoxyCodeLine{2211                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2212                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2213                 \}}
\DoxyCodeLine{2214             \}}
\DoxyCodeLine{2215 }
\DoxyCodeLine{2216             \textcolor{keywordflow}{if} (pMetadata-\/>data.smpl.samplerSpecificDataSizeInBytes > 0) \{}
\DoxyCodeLine{2217                 pMetadata-\/>data.smpl.pSamplerSpecificData = drwav\_\_metadata\_get\_memory(pParser, pMetadata-\/>data.smpl.samplerSpecificDataSizeInBytes, 1);}
\DoxyCodeLine{2218                 DRWAV\_ASSERT(pMetadata-\/>data.smpl.pSamplerSpecificData != NULL);}
\DoxyCodeLine{2219 }
\DoxyCodeLine{2220                 drwav\_\_metadata\_parser\_read(pParser, pMetadata-\/>data.smpl.pSamplerSpecificData, pMetadata-\/>data.smpl.samplerSpecificDataSizeInBytes, \&totalBytesRead);}
\DoxyCodeLine{2221             \}}
\DoxyCodeLine{2222         \}}
\DoxyCodeLine{2223     \}}
\DoxyCodeLine{2224 }
\DoxyCodeLine{2225     \textcolor{keywordflow}{return} totalBytesRead;}
\DoxyCodeLine{2226 \}}
\DoxyCodeLine{2227 }
\DoxyCodeLine{2228 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_read\_cue\_to\_metadata\_obj(drwav\_\_metadata\_parser* pParser, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}}* pChunkHeader, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata)}
\DoxyCodeLine{2229 \{}
\DoxyCodeLine{2230     drwav\_uint8 cueHeaderSectionData[DRWAV\_CUE\_BYTES];}
\DoxyCodeLine{2231     drwav\_uint64 totalBytesRead = 0;}
\DoxyCodeLine{2232     \textcolor{keywordtype}{size\_t} bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, cueHeaderSectionData, \textcolor{keyword}{sizeof}(cueHeaderSectionData), \&totalBytesRead);}
\DoxyCodeLine{2233 }
\DoxyCodeLine{2234     DRWAV\_ASSERT(pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_read);}
\DoxyCodeLine{2235 }
\DoxyCodeLine{2236     \textcolor{keywordflow}{if} (bytesJustRead == \textcolor{keyword}{sizeof}(cueHeaderSectionData)) \{}
\DoxyCodeLine{2237         pMetadata-\/>type                   = drwav\_metadata\_type\_cue;}
\DoxyCodeLine{2238         pMetadata-\/>data.cue.cuePointCount = drwav\_bytes\_to\_u32(cueHeaderSectionData);}
\DoxyCodeLine{2239 }
\DoxyCodeLine{2240         \textcolor{comment}{/*}}
\DoxyCodeLine{2241 \textcolor{comment}{        We need to validate the cue point count against the size of the chunk so we don't read}}
\DoxyCodeLine{2242 \textcolor{comment}{        beyond the chunk.}}
\DoxyCodeLine{2243 \textcolor{comment}{        */}}
\DoxyCodeLine{2244         \textcolor{keywordflow}{if} (pMetadata-\/>data.cue.cuePointCount == (pChunkHeader-\/>sizeInBytes -\/ DRWAV\_CUE\_BYTES) / DRWAV\_CUE\_POINT\_BYTES) \{}
\DoxyCodeLine{2245             pMetadata-\/>data.cue.pCuePoints    = (\mbox{\hyperlink{structdrwav__cue__point}{drwav\_cue\_point}}*)drwav\_\_metadata\_get\_memory(pParser, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{structdrwav__cue__point}{drwav\_cue\_point}}) * pMetadata-\/>data.cue.cuePointCount, DRWAV\_METADATA\_ALIGNMENT);}
\DoxyCodeLine{2246             DRWAV\_ASSERT(pMetadata-\/>data.cue.pCuePoints != NULL);}
\DoxyCodeLine{2247 }
\DoxyCodeLine{2248             \textcolor{keywordflow}{if} (pMetadata-\/>data.cue.cuePointCount > 0) \{}
\DoxyCodeLine{2249                 drwav\_uint32 iCuePoint;}
\DoxyCodeLine{2250 }
\DoxyCodeLine{2251                 \textcolor{keywordflow}{for} (iCuePoint = 0; iCuePoint < pMetadata-\/>data.cue.cuePointCount; ++iCuePoint) \{}
\DoxyCodeLine{2252                     drwav\_uint8 cuePointData[DRWAV\_CUE\_POINT\_BYTES];}
\DoxyCodeLine{2253                     bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, cuePointData, \textcolor{keyword}{sizeof}(cuePointData), \&totalBytesRead);}
\DoxyCodeLine{2254 }
\DoxyCodeLine{2255                     \textcolor{keywordflow}{if} (bytesJustRead == \textcolor{keyword}{sizeof}(cuePointData)) \{}
\DoxyCodeLine{2256                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].id                = drwav\_bytes\_to\_u32(cuePointData + 0);}
\DoxyCodeLine{2257                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].playOrderPosition = drwav\_bytes\_to\_u32(cuePointData + 4);}
\DoxyCodeLine{2258                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].dataChunkId[0]    = cuePointData[8];}
\DoxyCodeLine{2259                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].dataChunkId[1]    = cuePointData[9];}
\DoxyCodeLine{2260                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].dataChunkId[2]    = cuePointData[10];}
\DoxyCodeLine{2261                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].dataChunkId[3]    = cuePointData[11];}
\DoxyCodeLine{2262                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].chunkStart        = drwav\_bytes\_to\_u32(cuePointData + 12);}
\DoxyCodeLine{2263                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].blockStart        = drwav\_bytes\_to\_u32(cuePointData + 16);}
\DoxyCodeLine{2264                         pMetadata-\/>data.cue.pCuePoints[iCuePoint].sampleByteOffset  = drwav\_bytes\_to\_u32(cuePointData + 20);}
\DoxyCodeLine{2265                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2266                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2267                     \}}
\DoxyCodeLine{2268                 \}}
\DoxyCodeLine{2269             \}}
\DoxyCodeLine{2270         \}}
\DoxyCodeLine{2271     \}}
\DoxyCodeLine{2272 }
\DoxyCodeLine{2273     \textcolor{keywordflow}{return} totalBytesRead;}
\DoxyCodeLine{2274 \}}
\DoxyCodeLine{2275 }
\DoxyCodeLine{2276 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_read\_inst\_to\_metadata\_obj(drwav\_\_metadata\_parser* pParser, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata)}
\DoxyCodeLine{2277 \{}
\DoxyCodeLine{2278     drwav\_uint8 instData[DRWAV\_INST\_BYTES];}
\DoxyCodeLine{2279     drwav\_uint64 bytesRead = drwav\_\_metadata\_parser\_read(pParser, instData, \textcolor{keyword}{sizeof}(instData), NULL);}
\DoxyCodeLine{2280 }
\DoxyCodeLine{2281     DRWAV\_ASSERT(pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_read);}
\DoxyCodeLine{2282 }
\DoxyCodeLine{2283     \textcolor{keywordflow}{if} (bytesRead == \textcolor{keyword}{sizeof}(instData)) \{}
\DoxyCodeLine{2284         pMetadata-\/>type                    = drwav\_metadata\_type\_inst;}
\DoxyCodeLine{2285         pMetadata-\/>data.inst.midiUnityNote = (drwav\_int8)instData[0];}
\DoxyCodeLine{2286         pMetadata-\/>data.inst.fineTuneCents = (drwav\_int8)instData[1];}
\DoxyCodeLine{2287         pMetadata-\/>data.inst.gainDecibels  = (drwav\_int8)instData[2];}
\DoxyCodeLine{2288         pMetadata-\/>data.inst.lowNote       = (drwav\_int8)instData[3];}
\DoxyCodeLine{2289         pMetadata-\/>data.inst.highNote      = (drwav\_int8)instData[4];}
\DoxyCodeLine{2290         pMetadata-\/>data.inst.lowVelocity   = (drwav\_int8)instData[5];}
\DoxyCodeLine{2291         pMetadata-\/>data.inst.highVelocity  = (drwav\_int8)instData[6];}
\DoxyCodeLine{2292     \}}
\DoxyCodeLine{2293 }
\DoxyCodeLine{2294     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2295 \}}
\DoxyCodeLine{2296 }
\DoxyCodeLine{2297 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_read\_acid\_to\_metadata\_obj(drwav\_\_metadata\_parser* pParser, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata)}
\DoxyCodeLine{2298 \{}
\DoxyCodeLine{2299     drwav\_uint8 acidData[DRWAV\_ACID\_BYTES];}
\DoxyCodeLine{2300     drwav\_uint64 bytesRead = drwav\_\_metadata\_parser\_read(pParser, acidData, \textcolor{keyword}{sizeof}(acidData), NULL);}
\DoxyCodeLine{2301 }
\DoxyCodeLine{2302     DRWAV\_ASSERT(pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_read);}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2304     \textcolor{keywordflow}{if} (bytesRead == \textcolor{keyword}{sizeof}(acidData)) \{}
\DoxyCodeLine{2305         pMetadata-\/>type                       = drwav\_metadata\_type\_acid;}
\DoxyCodeLine{2306         pMetadata-\/>data.acid.flags            = drwav\_bytes\_to\_u32(acidData + 0);}
\DoxyCodeLine{2307         pMetadata-\/>data.acid.midiUnityNote    = drwav\_bytes\_to\_u16(acidData + 4);}
\DoxyCodeLine{2308         pMetadata-\/>data.acid.reserved1        = drwav\_bytes\_to\_u16(acidData + 6);}
\DoxyCodeLine{2309         pMetadata-\/>data.acid.reserved2        = drwav\_bytes\_to\_f32(acidData + 8);}
\DoxyCodeLine{2310         pMetadata-\/>data.acid.numBeats         = drwav\_bytes\_to\_u32(acidData + 12);}
\DoxyCodeLine{2311         pMetadata-\/>data.acid.meterDenominator = drwav\_bytes\_to\_u16(acidData + 16);}
\DoxyCodeLine{2312         pMetadata-\/>data.acid.meterNumerator   = drwav\_bytes\_to\_u16(acidData + 18);}
\DoxyCodeLine{2313         pMetadata-\/>data.acid.tempo            = drwav\_bytes\_to\_f32(acidData + 20);}
\DoxyCodeLine{2314     \}}
\DoxyCodeLine{2315 }
\DoxyCodeLine{2316     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2317 \}}
\DoxyCodeLine{2318 }
\DoxyCodeLine{2319 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_strlen\_clamped(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \textcolor{keywordtype}{size\_t} maxToRead)}
\DoxyCodeLine{2320 \{}
\DoxyCodeLine{2321     \textcolor{keywordtype}{size\_t} result = 0;}
\DoxyCodeLine{2322 }
\DoxyCodeLine{2323     \textcolor{keywordflow}{while} (*str++ \&\& result < maxToRead) \{}
\DoxyCodeLine{2324         result += 1;}
\DoxyCodeLine{2325     \}}
\DoxyCodeLine{2326 }
\DoxyCodeLine{2327     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2328 \}}
\DoxyCodeLine{2329 }
\DoxyCodeLine{2330 DRWAV\_PRIVATE \textcolor{keywordtype}{char}* drwav\_\_metadata\_copy\_string(drwav\_\_metadata\_parser* pParser, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \textcolor{keywordtype}{size\_t} maxToRead)}
\DoxyCodeLine{2331 \{}
\DoxyCodeLine{2332     \textcolor{keywordtype}{size\_t} len = drwav\_\_strlen\_clamped(str, maxToRead);}
\DoxyCodeLine{2333 }
\DoxyCodeLine{2334     \textcolor{keywordflow}{if} (len) \{}
\DoxyCodeLine{2335         \textcolor{keywordtype}{char}* result = (\textcolor{keywordtype}{char}*)drwav\_\_metadata\_get\_memory(pParser, len + 1, 1);}
\DoxyCodeLine{2336         DRWAV\_ASSERT(result != NULL);}
\DoxyCodeLine{2337 }
\DoxyCodeLine{2338         memcpy(result, str, len);}
\DoxyCodeLine{2339         result[len] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2340 }
\DoxyCodeLine{2341         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2342     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2343         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{2344     \}}
\DoxyCodeLine{2345 \}}
\DoxyCodeLine{2346 }
\DoxyCodeLine{2347 \textcolor{keyword}{typedef} \textcolor{keyword}{struct}}
\DoxyCodeLine{2348 \{}
\DoxyCodeLine{2349     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pBuffer;}
\DoxyCodeLine{2350     \textcolor{keywordtype}{size\_t} sizeInBytes;}
\DoxyCodeLine{2351     \textcolor{keywordtype}{size\_t} cursor;}
\DoxyCodeLine{2352 \} drwav\_buffer\_reader;}
\DoxyCodeLine{2353 }
\DoxyCodeLine{2354 DRWAV\_PRIVATE drwav\_result drwav\_buffer\_reader\_init(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* pBuffer, \textcolor{keywordtype}{size\_t} sizeInBytes, drwav\_buffer\_reader* pReader)}
\DoxyCodeLine{2355 \{}
\DoxyCodeLine{2356     DRWAV\_ASSERT(pBuffer != NULL);}
\DoxyCodeLine{2357     DRWAV\_ASSERT(pReader != NULL);}
\DoxyCodeLine{2358 }
\DoxyCodeLine{2359     DRWAV\_ZERO\_OBJECT(pReader);}
\DoxyCodeLine{2360 }
\DoxyCodeLine{2361     pReader-\/>pBuffer     = pBuffer;}
\DoxyCodeLine{2362     pReader-\/>sizeInBytes = sizeInBytes;}
\DoxyCodeLine{2363     pReader-\/>cursor      = 0;}
\DoxyCodeLine{2364 }
\DoxyCodeLine{2365     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{2366 \}}
\DoxyCodeLine{2367 }
\DoxyCodeLine{2368 DRWAV\_PRIVATE \textcolor{keyword}{const} \textcolor{keywordtype}{void}* drwav\_buffer\_reader\_ptr(\textcolor{keyword}{const} drwav\_buffer\_reader* pReader)}
\DoxyCodeLine{2369 \{}
\DoxyCodeLine{2370     DRWAV\_ASSERT(pReader != NULL);}
\DoxyCodeLine{2371 }
\DoxyCodeLine{2372     \textcolor{keywordflow}{return} drwav\_offset\_ptr(pReader-\/>pBuffer, pReader-\/>cursor);}
\DoxyCodeLine{2373 \}}
\DoxyCodeLine{2374 }
\DoxyCodeLine{2375 DRWAV\_PRIVATE drwav\_result drwav\_buffer\_reader\_seek(drwav\_buffer\_reader* pReader, \textcolor{keywordtype}{size\_t} bytesToSeek)}
\DoxyCodeLine{2376 \{}
\DoxyCodeLine{2377     DRWAV\_ASSERT(pReader != NULL);}
\DoxyCodeLine{2378 }
\DoxyCodeLine{2379     \textcolor{keywordflow}{if} (pReader-\/>cursor + bytesToSeek > pReader-\/>sizeInBytes) \{}
\DoxyCodeLine{2380         \textcolor{keywordflow}{return} DRWAV\_BAD\_SEEK;  \textcolor{comment}{/* Seeking too far forward. */}}
\DoxyCodeLine{2381     \}}
\DoxyCodeLine{2382 }
\DoxyCodeLine{2383     pReader-\/>cursor += bytesToSeek;}
\DoxyCodeLine{2384 }
\DoxyCodeLine{2385     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{2386 \}}
\DoxyCodeLine{2387 }
\DoxyCodeLine{2388 DRWAV\_PRIVATE drwav\_result drwav\_buffer\_reader\_read(drwav\_buffer\_reader* pReader, \textcolor{keywordtype}{void}* pDst, \textcolor{keywordtype}{size\_t} bytesToRead, \textcolor{keywordtype}{size\_t}* pBytesRead)}
\DoxyCodeLine{2389 \{}
\DoxyCodeLine{2390     drwav\_result result = DRWAV\_SUCCESS;}
\DoxyCodeLine{2391     \textcolor{keywordtype}{size\_t} bytesRemaining;}
\DoxyCodeLine{2392 }
\DoxyCodeLine{2393     DRWAV\_ASSERT(pReader != NULL);}
\DoxyCodeLine{2394     }
\DoxyCodeLine{2395     \textcolor{keywordflow}{if} (pBytesRead != NULL) \{}
\DoxyCodeLine{2396         *pBytesRead = 0;}
\DoxyCodeLine{2397     \}}
\DoxyCodeLine{2398 }
\DoxyCodeLine{2399     bytesRemaining = (pReader-\/>sizeInBytes -\/ pReader-\/>cursor);}
\DoxyCodeLine{2400     \textcolor{keywordflow}{if} (bytesToRead > bytesRemaining) \{}
\DoxyCodeLine{2401         bytesToRead = bytesRemaining;}
\DoxyCodeLine{2402     \}}
\DoxyCodeLine{2403 }
\DoxyCodeLine{2404     \textcolor{keywordflow}{if} (pDst == NULL) \{}
\DoxyCodeLine{2405         \textcolor{comment}{/* Seek. */}}
\DoxyCodeLine{2406         result = drwav\_buffer\_reader\_seek(pReader, bytesToRead);}
\DoxyCodeLine{2407     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2408         \textcolor{comment}{/* Read. */}}
\DoxyCodeLine{2409         DRWAV\_COPY\_MEMORY(pDst, drwav\_buffer\_reader\_ptr(pReader), bytesToRead);}
\DoxyCodeLine{2410         pReader-\/>cursor += bytesToRead;}
\DoxyCodeLine{2411     \}}
\DoxyCodeLine{2412 }
\DoxyCodeLine{2413     DRWAV\_ASSERT(pReader-\/>cursor <= pReader-\/>sizeInBytes);}
\DoxyCodeLine{2414 }
\DoxyCodeLine{2415     \textcolor{keywordflow}{if} (result == DRWAV\_SUCCESS) \{}
\DoxyCodeLine{2416         \textcolor{keywordflow}{if} (pBytesRead != NULL) \{}
\DoxyCodeLine{2417             *pBytesRead = bytesToRead;}
\DoxyCodeLine{2418         \}}
\DoxyCodeLine{2419     \}}
\DoxyCodeLine{2420 }
\DoxyCodeLine{2421     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{2422 \}}
\DoxyCodeLine{2423 }
\DoxyCodeLine{2424 DRWAV\_PRIVATE drwav\_result drwav\_buffer\_reader\_read\_u16(drwav\_buffer\_reader* pReader, drwav\_uint16* pDst)}
\DoxyCodeLine{2425 \{}
\DoxyCodeLine{2426     drwav\_result result;}
\DoxyCodeLine{2427     \textcolor{keywordtype}{size\_t} bytesRead;}
\DoxyCodeLine{2428     drwav\_uint8 data[2];}
\DoxyCodeLine{2429 }
\DoxyCodeLine{2430     DRWAV\_ASSERT(pReader != NULL);}
\DoxyCodeLine{2431     DRWAV\_ASSERT(pDst != NULL);}
\DoxyCodeLine{2432 }
\DoxyCodeLine{2433     *pDst = 0;  \textcolor{comment}{/* Safety. */}}
\DoxyCodeLine{2434 }
\DoxyCodeLine{2435     result = drwav\_buffer\_reader\_read(pReader, data, \textcolor{keyword}{sizeof}(*pDst), \&bytesRead);}
\DoxyCodeLine{2436     \textcolor{keywordflow}{if} (result != DRWAV\_SUCCESS || bytesRead != \textcolor{keyword}{sizeof}(*pDst)) \{}
\DoxyCodeLine{2437         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2438     \}}
\DoxyCodeLine{2439 }
\DoxyCodeLine{2440     *pDst = drwav\_bytes\_to\_u16(data);}
\DoxyCodeLine{2441 }
\DoxyCodeLine{2442     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{2443 \}}
\DoxyCodeLine{2444 }
\DoxyCodeLine{2445 DRWAV\_PRIVATE drwav\_result drwav\_buffer\_reader\_read\_u32(drwav\_buffer\_reader* pReader, drwav\_uint32* pDst)}
\DoxyCodeLine{2446 \{}
\DoxyCodeLine{2447     drwav\_result result;}
\DoxyCodeLine{2448     \textcolor{keywordtype}{size\_t} bytesRead;}
\DoxyCodeLine{2449     drwav\_uint8 data[4];}
\DoxyCodeLine{2450 }
\DoxyCodeLine{2451     DRWAV\_ASSERT(pReader != NULL);}
\DoxyCodeLine{2452     DRWAV\_ASSERT(pDst != NULL);}
\DoxyCodeLine{2453 }
\DoxyCodeLine{2454     *pDst = 0;  \textcolor{comment}{/* Safety. */}}
\DoxyCodeLine{2455 }
\DoxyCodeLine{2456     result = drwav\_buffer\_reader\_read(pReader, data, \textcolor{keyword}{sizeof}(*pDst), \&bytesRead);}
\DoxyCodeLine{2457     \textcolor{keywordflow}{if} (result != DRWAV\_SUCCESS || bytesRead != \textcolor{keyword}{sizeof}(*pDst)) \{}
\DoxyCodeLine{2458         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2459     \}}
\DoxyCodeLine{2460 }
\DoxyCodeLine{2461     *pDst = drwav\_bytes\_to\_u32(data);}
\DoxyCodeLine{2462 }
\DoxyCodeLine{2463     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{2464 \}}
\DoxyCodeLine{2465 }
\DoxyCodeLine{2466 }
\DoxyCodeLine{2467 }
\DoxyCodeLine{2468 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_read\_bext\_to\_metadata\_obj(drwav\_\_metadata\_parser* pParser, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata, drwav\_uint64 chunkSize)}
\DoxyCodeLine{2469 \{}
\DoxyCodeLine{2470     drwav\_uint8 bextData[DRWAV\_BEXT\_BYTES];}
\DoxyCodeLine{2471     \textcolor{keywordtype}{size\_t} bytesRead = drwav\_\_metadata\_parser\_read(pParser, bextData, \textcolor{keyword}{sizeof}(bextData), NULL);}
\DoxyCodeLine{2472 }
\DoxyCodeLine{2473     DRWAV\_ASSERT(pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_read);}
\DoxyCodeLine{2474     }
\DoxyCodeLine{2475     \textcolor{keywordflow}{if} (bytesRead == \textcolor{keyword}{sizeof}(bextData)) \{}
\DoxyCodeLine{2476         drwav\_buffer\_reader reader;}
\DoxyCodeLine{2477         drwav\_uint32 timeReferenceLow;}
\DoxyCodeLine{2478         drwav\_uint32 timeReferenceHigh;}
\DoxyCodeLine{2479         \textcolor{keywordtype}{size\_t} extraBytes;}
\DoxyCodeLine{2480 }
\DoxyCodeLine{2481         pMetadata-\/>type = drwav\_metadata\_type\_bext;}
\DoxyCodeLine{2482 }
\DoxyCodeLine{2483         \textcolor{keywordflow}{if} (drwav\_buffer\_reader\_init(bextData, bytesRead, \&reader) == DRWAV\_SUCCESS) \{}
\DoxyCodeLine{2484             pMetadata-\/>data.bext.pDescription = drwav\_\_metadata\_copy\_string(pParser, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)drwav\_buffer\_reader\_ptr(\&reader), DRWAV\_BEXT\_DESCRIPTION\_BYTES);}
\DoxyCodeLine{2485             drwav\_buffer\_reader\_seek(\&reader, DRWAV\_BEXT\_DESCRIPTION\_BYTES);}
\DoxyCodeLine{2486 }
\DoxyCodeLine{2487             pMetadata-\/>data.bext.pOriginatorName = drwav\_\_metadata\_copy\_string(pParser, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)drwav\_buffer\_reader\_ptr(\&reader), DRWAV\_BEXT\_ORIGINATOR\_NAME\_BYTES);}
\DoxyCodeLine{2488             drwav\_buffer\_reader\_seek(\&reader, DRWAV\_BEXT\_ORIGINATOR\_NAME\_BYTES);}
\DoxyCodeLine{2489 }
\DoxyCodeLine{2490             pMetadata-\/>data.bext.pOriginatorReference = drwav\_\_metadata\_copy\_string(pParser, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)drwav\_buffer\_reader\_ptr(\&reader), DRWAV\_BEXT\_ORIGINATOR\_REF\_BYTES);}
\DoxyCodeLine{2491             drwav\_buffer\_reader\_seek(\&reader, DRWAV\_BEXT\_ORIGINATOR\_REF\_BYTES);}
\DoxyCodeLine{2492 }
\DoxyCodeLine{2493             drwav\_buffer\_reader\_read(\&reader, pMetadata-\/>data.bext.pOriginationDate, \textcolor{keyword}{sizeof}(pMetadata-\/>data.bext.pOriginationDate), NULL);}
\DoxyCodeLine{2494             drwav\_buffer\_reader\_read(\&reader, pMetadata-\/>data.bext.pOriginationTime, \textcolor{keyword}{sizeof}(pMetadata-\/>data.bext.pOriginationTime), NULL);}
\DoxyCodeLine{2495 }
\DoxyCodeLine{2496             drwav\_buffer\_reader\_read\_u32(\&reader, \&timeReferenceLow);}
\DoxyCodeLine{2497             drwav\_buffer\_reader\_read\_u32(\&reader, \&timeReferenceHigh);}
\DoxyCodeLine{2498             pMetadata-\/>data.bext.timeReference = ((drwav\_uint64)timeReferenceHigh << 32) + timeReferenceLow;}
\DoxyCodeLine{2499 }
\DoxyCodeLine{2500             drwav\_buffer\_reader\_read\_u16(\&reader, \&pMetadata-\/>data.bext.version);}
\DoxyCodeLine{2501 }
\DoxyCodeLine{2502             pMetadata-\/>data.bext.pUMID = drwav\_\_metadata\_get\_memory(pParser, DRWAV\_BEXT\_UMID\_BYTES, 1);}
\DoxyCodeLine{2503             drwav\_buffer\_reader\_read(\&reader, pMetadata-\/>data.bext.pUMID, DRWAV\_BEXT\_UMID\_BYTES, NULL);}
\DoxyCodeLine{2504 }
\DoxyCodeLine{2505             drwav\_buffer\_reader\_read\_u16(\&reader, \&pMetadata-\/>data.bext.loudnessValue);}
\DoxyCodeLine{2506             drwav\_buffer\_reader\_read\_u16(\&reader, \&pMetadata-\/>data.bext.loudnessRange);}
\DoxyCodeLine{2507             drwav\_buffer\_reader\_read\_u16(\&reader, \&pMetadata-\/>data.bext.maxTruePeakLevel);}
\DoxyCodeLine{2508             drwav\_buffer\_reader\_read\_u16(\&reader, \&pMetadata-\/>data.bext.maxMomentaryLoudness);}
\DoxyCodeLine{2509             drwav\_buffer\_reader\_read\_u16(\&reader, \&pMetadata-\/>data.bext.maxShortTermLoudness);}
\DoxyCodeLine{2510 }
\DoxyCodeLine{2511             DRWAV\_ASSERT((drwav\_offset\_ptr(drwav\_buffer\_reader\_ptr(\&reader), DRWAV\_BEXT\_RESERVED\_BYTES)) == (bextData + DRWAV\_BEXT\_BYTES));}
\DoxyCodeLine{2512 }
\DoxyCodeLine{2513             extraBytes = (size\_t)(chunkSize -\/ DRWAV\_BEXT\_BYTES);}
\DoxyCodeLine{2514             \textcolor{keywordflow}{if} (extraBytes > 0) \{}
\DoxyCodeLine{2515                 pMetadata-\/>data.bext.pCodingHistory = (\textcolor{keywordtype}{char}*)drwav\_\_metadata\_get\_memory(pParser, extraBytes + 1, 1);}
\DoxyCodeLine{2516                 DRWAV\_ASSERT(pMetadata-\/>data.bext.pCodingHistory != NULL);}
\DoxyCodeLine{2517 }
\DoxyCodeLine{2518                 bytesRead += drwav\_\_metadata\_parser\_read(pParser, pMetadata-\/>data.bext.pCodingHistory, extraBytes, NULL);}
\DoxyCodeLine{2519                 pMetadata-\/>data.bext.codingHistorySize = (drwav\_uint32)strlen(pMetadata-\/>data.bext.pCodingHistory);}
\DoxyCodeLine{2520             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2521                 pMetadata-\/>data.bext.pCodingHistory    = NULL;}
\DoxyCodeLine{2522                 pMetadata-\/>data.bext.codingHistorySize = 0;}
\DoxyCodeLine{2523             \}}
\DoxyCodeLine{2524         \}}
\DoxyCodeLine{2525     \}}
\DoxyCodeLine{2526 }
\DoxyCodeLine{2527     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2528 \}}
\DoxyCodeLine{2529 }
\DoxyCodeLine{2530 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_read\_list\_label\_or\_note\_to\_metadata\_obj(drwav\_\_metadata\_parser* pParser, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata, drwav\_uint64 chunkSize, drwav\_metadata\_type type)}
\DoxyCodeLine{2531 \{}
\DoxyCodeLine{2532     drwav\_uint8 cueIDBuffer[DRWAV\_LIST\_LABEL\_OR\_NOTE\_BYTES];}
\DoxyCodeLine{2533     drwav\_uint64 totalBytesRead = 0;}
\DoxyCodeLine{2534     \textcolor{keywordtype}{size\_t} bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, cueIDBuffer, \textcolor{keyword}{sizeof}(cueIDBuffer), \&totalBytesRead);}
\DoxyCodeLine{2535 }
\DoxyCodeLine{2536     DRWAV\_ASSERT(pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_read);    }
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538     \textcolor{keywordflow}{if} (bytesJustRead == \textcolor{keyword}{sizeof}(cueIDBuffer)) \{}
\DoxyCodeLine{2539         drwav\_uint32 sizeIncludingNullTerminator;}
\DoxyCodeLine{2540 }
\DoxyCodeLine{2541         pMetadata-\/>type = type;}
\DoxyCodeLine{2542         pMetadata-\/>data.labelOrNote.cuePointId = drwav\_bytes\_to\_u32(cueIDBuffer);}
\DoxyCodeLine{2543 }
\DoxyCodeLine{2544         sizeIncludingNullTerminator = (drwav\_uint32)chunkSize -\/ DRWAV\_LIST\_LABEL\_OR\_NOTE\_BYTES;}
\DoxyCodeLine{2545         \textcolor{keywordflow}{if} (sizeIncludingNullTerminator > 0) \{}
\DoxyCodeLine{2546             pMetadata-\/>data.labelOrNote.stringLength = sizeIncludingNullTerminator -\/ 1;}
\DoxyCodeLine{2547             pMetadata-\/>data.labelOrNote.pString      = (\textcolor{keywordtype}{char}*)drwav\_\_metadata\_get\_memory(pParser, sizeIncludingNullTerminator, 1);}
\DoxyCodeLine{2548             DRWAV\_ASSERT(pMetadata-\/>data.labelOrNote.pString != NULL);}
\DoxyCodeLine{2549 }
\DoxyCodeLine{2550             drwav\_\_metadata\_parser\_read(pParser, pMetadata-\/>data.labelOrNote.pString, sizeIncludingNullTerminator, \&totalBytesRead);}
\DoxyCodeLine{2551         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2552             pMetadata-\/>data.labelOrNote.stringLength = 0;}
\DoxyCodeLine{2553             pMetadata-\/>data.labelOrNote.pString      = NULL;}
\DoxyCodeLine{2554         \}}
\DoxyCodeLine{2555     \}}
\DoxyCodeLine{2556 }
\DoxyCodeLine{2557     \textcolor{keywordflow}{return} totalBytesRead;}
\DoxyCodeLine{2558 \}}
\DoxyCodeLine{2559 }
\DoxyCodeLine{2560 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_read\_list\_labelled\_cue\_region\_to\_metadata\_obj(drwav\_\_metadata\_parser* pParser, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata, drwav\_uint64 chunkSize)}
\DoxyCodeLine{2561 \{}
\DoxyCodeLine{2562     drwav\_uint8 buffer[DRWAV\_LIST\_LABELLED\_TEXT\_BYTES];}
\DoxyCodeLine{2563     drwav\_uint64 totalBytesRead = 0;}
\DoxyCodeLine{2564     \textcolor{keywordtype}{size\_t} bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, buffer, \textcolor{keyword}{sizeof}(buffer), \&totalBytesRead);}
\DoxyCodeLine{2565 }
\DoxyCodeLine{2566     DRWAV\_ASSERT(pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_read);}
\DoxyCodeLine{2567 }
\DoxyCodeLine{2568     \textcolor{keywordflow}{if} (bytesJustRead == \textcolor{keyword}{sizeof}(buffer)) \{}
\DoxyCodeLine{2569         drwav\_uint32 sizeIncludingNullTerminator;}
\DoxyCodeLine{2570 }
\DoxyCodeLine{2571         pMetadata-\/>type                                = drwav\_metadata\_type\_list\_labelled\_cue\_region;}
\DoxyCodeLine{2572         pMetadata-\/>data.labelledCueRegion.cuePointId   = drwav\_bytes\_to\_u32(buffer + 0);}
\DoxyCodeLine{2573         pMetadata-\/>data.labelledCueRegion.sampleLength = drwav\_bytes\_to\_u32(buffer + 4);}
\DoxyCodeLine{2574         pMetadata-\/>data.labelledCueRegion.purposeId[0] = buffer[8];}
\DoxyCodeLine{2575         pMetadata-\/>data.labelledCueRegion.purposeId[1] = buffer[9];}
\DoxyCodeLine{2576         pMetadata-\/>data.labelledCueRegion.purposeId[2] = buffer[10];}
\DoxyCodeLine{2577         pMetadata-\/>data.labelledCueRegion.purposeId[3] = buffer[11];}
\DoxyCodeLine{2578         pMetadata-\/>data.labelledCueRegion.country      = drwav\_bytes\_to\_u16(buffer + 12);}
\DoxyCodeLine{2579         pMetadata-\/>data.labelledCueRegion.language     = drwav\_bytes\_to\_u16(buffer + 14);}
\DoxyCodeLine{2580         pMetadata-\/>data.labelledCueRegion.dialect      = drwav\_bytes\_to\_u16(buffer + 16);}
\DoxyCodeLine{2581         pMetadata-\/>data.labelledCueRegion.codePage     = drwav\_bytes\_to\_u16(buffer + 18);}
\DoxyCodeLine{2582 }
\DoxyCodeLine{2583         sizeIncludingNullTerminator = (drwav\_uint32)chunkSize -\/ DRWAV\_LIST\_LABELLED\_TEXT\_BYTES;}
\DoxyCodeLine{2584         \textcolor{keywordflow}{if} (sizeIncludingNullTerminator > 0) \{}
\DoxyCodeLine{2585             pMetadata-\/>data.labelledCueRegion.stringLength = sizeIncludingNullTerminator -\/ 1;}
\DoxyCodeLine{2586             pMetadata-\/>data.labelledCueRegion.pString      = (\textcolor{keywordtype}{char}*)drwav\_\_metadata\_get\_memory(pParser, sizeIncludingNullTerminator, 1);}
\DoxyCodeLine{2587             DRWAV\_ASSERT(pMetadata-\/>data.labelledCueRegion.pString != NULL);}
\DoxyCodeLine{2588 }
\DoxyCodeLine{2589             drwav\_\_metadata\_parser\_read(pParser, pMetadata-\/>data.labelledCueRegion.pString, sizeIncludingNullTerminator, \&totalBytesRead);}
\DoxyCodeLine{2590         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2591             pMetadata-\/>data.labelledCueRegion.stringLength = 0;}
\DoxyCodeLine{2592             pMetadata-\/>data.labelledCueRegion.pString      = NULL;}
\DoxyCodeLine{2593         \}}
\DoxyCodeLine{2594     \}}
\DoxyCodeLine{2595 }
\DoxyCodeLine{2596     \textcolor{keywordflow}{return} totalBytesRead;}
\DoxyCodeLine{2597 \}}
\DoxyCodeLine{2598 }
\DoxyCodeLine{2599 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_metadata\_process\_info\_text\_chunk(drwav\_\_metadata\_parser* pParser, drwav\_uint64 chunkSize, drwav\_metadata\_type type)}
\DoxyCodeLine{2600 \{}
\DoxyCodeLine{2601     drwav\_uint64 bytesRead = 0;}
\DoxyCodeLine{2602     drwav\_uint32 stringSizeWithNullTerminator = (drwav\_uint32)chunkSize;}
\DoxyCodeLine{2603 }
\DoxyCodeLine{2604     \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2605         pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2606         drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(pParser, stringSizeWithNullTerminator, 1);}
\DoxyCodeLine{2607     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2608         \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata = \&pParser-\/>pMetadata[pParser-\/>metadataCursor];}
\DoxyCodeLine{2609         pMetadata-\/>type = type;}
\DoxyCodeLine{2610         \textcolor{keywordflow}{if} (stringSizeWithNullTerminator > 0) \{}
\DoxyCodeLine{2611             pMetadata-\/>data.infoText.stringLength = stringSizeWithNullTerminator -\/ 1;}
\DoxyCodeLine{2612             pMetadata-\/>data.infoText.pString = (\textcolor{keywordtype}{char}*)drwav\_\_metadata\_get\_memory(pParser, stringSizeWithNullTerminator, 1);}
\DoxyCodeLine{2613             DRWAV\_ASSERT(pMetadata-\/>data.infoText.pString != NULL);}
\DoxyCodeLine{2614 }
\DoxyCodeLine{2615             bytesRead = drwav\_\_metadata\_parser\_read(pParser, pMetadata-\/>data.infoText.pString, (\textcolor{keywordtype}{size\_t})stringSizeWithNullTerminator, NULL);}
\DoxyCodeLine{2616             \textcolor{keywordflow}{if} (bytesRead == chunkSize) \{}
\DoxyCodeLine{2617                 pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2618             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2619                 \textcolor{comment}{/* Failed to parse. */}}
\DoxyCodeLine{2620             \}}
\DoxyCodeLine{2621         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2622             pMetadata-\/>data.infoText.stringLength = 0;}
\DoxyCodeLine{2623             pMetadata-\/>data.infoText.pString      = NULL;}
\DoxyCodeLine{2624             pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2625         \}}
\DoxyCodeLine{2626     \}}
\DoxyCodeLine{2627 }
\DoxyCodeLine{2628     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2629 \}}
\DoxyCodeLine{2630 }
\DoxyCodeLine{2631 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_metadata\_process\_unknown\_chunk(drwav\_\_metadata\_parser* pParser, \textcolor{keyword}{const} drwav\_uint8* pChunkId, drwav\_uint64 chunkSize, drwav\_metadata\_location location)}
\DoxyCodeLine{2632 \{}
\DoxyCodeLine{2633     drwav\_uint64 bytesRead = 0;}
\DoxyCodeLine{2634 }
\DoxyCodeLine{2635     \textcolor{keywordflow}{if} (location == drwav\_metadata\_location\_invalid) \{}
\DoxyCodeLine{2636         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2637     \}}
\DoxyCodeLine{2638 }
\DoxyCodeLine{2639     \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(pChunkId, \textcolor{stringliteral}{"{}data"{}}) || drwav\_fourcc\_equal(pChunkId, \textcolor{stringliteral}{"{}fmt"{}}) || drwav\_fourcc\_equal(pChunkId, \textcolor{stringliteral}{"{}fact"{}})) \{}
\DoxyCodeLine{2640         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2641     \}}
\DoxyCodeLine{2642 }
\DoxyCodeLine{2643     \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2644         pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2645         drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(pParser, (\textcolor{keywordtype}{size\_t})chunkSize, 1);}
\DoxyCodeLine{2646     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2647         \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata = \&pParser-\/>pMetadata[pParser-\/>metadataCursor];}
\DoxyCodeLine{2648         pMetadata-\/>type                         = drwav\_metadata\_type\_unknown;}
\DoxyCodeLine{2649         pMetadata-\/>data.unknown.chunkLocation   = location;}
\DoxyCodeLine{2650         pMetadata-\/>data.unknown.id[0]           = pChunkId[0];}
\DoxyCodeLine{2651         pMetadata-\/>data.unknown.id[1]           = pChunkId[1];}
\DoxyCodeLine{2652         pMetadata-\/>data.unknown.id[2]           = pChunkId[2];}
\DoxyCodeLine{2653         pMetadata-\/>data.unknown.id[3]           = pChunkId[3];}
\DoxyCodeLine{2654         pMetadata-\/>data.unknown.dataSizeInBytes = (drwav\_uint32)chunkSize;}
\DoxyCodeLine{2655         pMetadata-\/>data.unknown.pData           = (drwav\_uint8 *)drwav\_\_metadata\_get\_memory(pParser, (\textcolor{keywordtype}{size\_t})chunkSize, 1);}
\DoxyCodeLine{2656         DRWAV\_ASSERT(pMetadata-\/>data.unknown.pData != NULL);}
\DoxyCodeLine{2657 }
\DoxyCodeLine{2658         bytesRead = drwav\_\_metadata\_parser\_read(pParser, pMetadata-\/>data.unknown.pData, pMetadata-\/>data.unknown.dataSizeInBytes, NULL);}
\DoxyCodeLine{2659         \textcolor{keywordflow}{if} (bytesRead == pMetadata-\/>data.unknown.dataSizeInBytes) \{}
\DoxyCodeLine{2660             pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2661         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2662             \textcolor{comment}{/* Failed to read. */}}
\DoxyCodeLine{2663         \}}
\DoxyCodeLine{2664     \}}
\DoxyCodeLine{2665 }
\DoxyCodeLine{2666     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2667 \}}
\DoxyCodeLine{2668 }
\DoxyCodeLine{2669 DRWAV\_PRIVATE drwav\_bool32 drwav\_\_chunk\_matches(drwav\_metadata\_type allowedMetadataTypes, \textcolor{keyword}{const} drwav\_uint8* pChunkID, drwav\_metadata\_type type, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pID)}
\DoxyCodeLine{2670 \{}
\DoxyCodeLine{2671     \textcolor{keywordflow}{return} (allowedMetadataTypes \& type) \&\& drwav\_fourcc\_equal(pChunkID, pID);}
\DoxyCodeLine{2672 \}}
\DoxyCodeLine{2673 }
\DoxyCodeLine{2674 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_metadata\_process\_chunk(drwav\_\_metadata\_parser* pParser, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}}* pChunkHeader, drwav\_metadata\_type allowedMetadataTypes)}
\DoxyCodeLine{2675 \{}
\DoxyCodeLine{2676     \textcolor{keyword}{const} drwav\_uint8 *pChunkID = pChunkHeader-\/>id.fourcc;}
\DoxyCodeLine{2677     drwav\_uint64 bytesRead = 0;}
\DoxyCodeLine{2678 }
\DoxyCodeLine{2679     \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, pChunkID, drwav\_metadata\_type\_smpl, \textcolor{stringliteral}{"{}smpl"{}})) \{}
\DoxyCodeLine{2680         \textcolor{keywordflow}{if} (pChunkHeader-\/>sizeInBytes >= DRWAV\_SMPL\_BYTES) \{}
\DoxyCodeLine{2681             \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2682                 drwav\_uint8 buffer[4];}
\DoxyCodeLine{2683                 \textcolor{keywordtype}{size\_t} bytesJustRead;}
\DoxyCodeLine{2684 }
\DoxyCodeLine{2685                 \textcolor{keywordflow}{if} (!pParser-\/>onSeek(pParser-\/>pReadSeekUserData, 28, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{2686                     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2687                 \}}
\DoxyCodeLine{2688                 bytesRead += 28;}
\DoxyCodeLine{2689 }
\DoxyCodeLine{2690                 bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, buffer, \textcolor{keyword}{sizeof}(buffer), \&bytesRead);}
\DoxyCodeLine{2691                 \textcolor{keywordflow}{if} (bytesJustRead == \textcolor{keyword}{sizeof}(buffer)) \{}
\DoxyCodeLine{2692                     drwav\_uint32 loopCount = drwav\_bytes\_to\_u32(buffer);}
\DoxyCodeLine{2693                     drwav\_uint64 calculatedLoopCount;}
\DoxyCodeLine{2694 }
\DoxyCodeLine{2695                     \textcolor{comment}{/* The loop count must be validated against the size of the chunk. */}}
\DoxyCodeLine{2696                     calculatedLoopCount = (pChunkHeader-\/>sizeInBytes -\/ DRWAV\_SMPL\_BYTES) / DRWAV\_SMPL\_LOOP\_BYTES;}
\DoxyCodeLine{2697                     \textcolor{keywordflow}{if} (calculatedLoopCount == loopCount) \{}
\DoxyCodeLine{2698                         bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, buffer, \textcolor{keyword}{sizeof}(buffer), \&bytesRead);}
\DoxyCodeLine{2699                         \textcolor{keywordflow}{if} (bytesJustRead == \textcolor{keyword}{sizeof}(buffer)) \{}
\DoxyCodeLine{2700                             drwav\_uint32 samplerSpecificDataSizeInBytes = drwav\_bytes\_to\_u32(buffer);}
\DoxyCodeLine{2701 }
\DoxyCodeLine{2702                             pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2703                             drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(pParser, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{structdrwav__smpl__loop}{drwav\_smpl\_loop}}) * loopCount, DRWAV\_METADATA\_ALIGNMENT);}
\DoxyCodeLine{2704                             drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(pParser, samplerSpecificDataSizeInBytes, 1);}
\DoxyCodeLine{2705                         \}}
\DoxyCodeLine{2706                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2707                         \textcolor{comment}{/* Loop count in header does not match the size of the chunk. */}}
\DoxyCodeLine{2708                     \}                    }
\DoxyCodeLine{2709                 \}}
\DoxyCodeLine{2710             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2711                 bytesRead = drwav\_\_read\_smpl\_to\_metadata\_obj(pParser, pChunkHeader, \&pParser-\/>pMetadata[pParser-\/>metadataCursor]);}
\DoxyCodeLine{2712                 \textcolor{keywordflow}{if} (bytesRead == pChunkHeader-\/>sizeInBytes) \{}
\DoxyCodeLine{2713                     pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2714                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2715                     \textcolor{comment}{/* Failed to parse. */}}
\DoxyCodeLine{2716                 \}}
\DoxyCodeLine{2717             \}}
\DoxyCodeLine{2718         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2719             \textcolor{comment}{/* Incorrectly formed chunk. */}}
\DoxyCodeLine{2720         \}}
\DoxyCodeLine{2721     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, pChunkID, drwav\_metadata\_type\_inst, \textcolor{stringliteral}{"{}inst"{}})) \{}
\DoxyCodeLine{2722         \textcolor{keywordflow}{if} (pChunkHeader-\/>sizeInBytes == DRWAV\_INST\_BYTES) \{}
\DoxyCodeLine{2723             \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2724                 pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2725             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2726                 bytesRead = drwav\_\_read\_inst\_to\_metadata\_obj(pParser, \&pParser-\/>pMetadata[pParser-\/>metadataCursor]);}
\DoxyCodeLine{2727                 \textcolor{keywordflow}{if} (bytesRead == pChunkHeader-\/>sizeInBytes) \{}
\DoxyCodeLine{2728                     pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2729                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2730                     \textcolor{comment}{/* Failed to parse. */}}
\DoxyCodeLine{2731                 \}}
\DoxyCodeLine{2732             \}}
\DoxyCodeLine{2733         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2734             \textcolor{comment}{/* Incorrectly formed chunk. */}}
\DoxyCodeLine{2735         \}}
\DoxyCodeLine{2736     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, pChunkID, drwav\_metadata\_type\_acid, \textcolor{stringliteral}{"{}acid"{}})) \{}
\DoxyCodeLine{2737         \textcolor{keywordflow}{if} (pChunkHeader-\/>sizeInBytes == DRWAV\_ACID\_BYTES) \{}
\DoxyCodeLine{2738             \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2739                 pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2740             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2741                 bytesRead = drwav\_\_read\_acid\_to\_metadata\_obj(pParser, \&pParser-\/>pMetadata[pParser-\/>metadataCursor]);}
\DoxyCodeLine{2742                 \textcolor{keywordflow}{if} (bytesRead == pChunkHeader-\/>sizeInBytes) \{}
\DoxyCodeLine{2743                     pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2744                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2745                     \textcolor{comment}{/* Failed to parse. */}}
\DoxyCodeLine{2746                 \}}
\DoxyCodeLine{2747             \}}
\DoxyCodeLine{2748         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2749             \textcolor{comment}{/* Incorrectly formed chunk. */}}
\DoxyCodeLine{2750         \}}
\DoxyCodeLine{2751     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, pChunkID, drwav\_metadata\_type\_cue, \textcolor{stringliteral}{"{}cue "{}})) \{}
\DoxyCodeLine{2752         \textcolor{keywordflow}{if} (pChunkHeader-\/>sizeInBytes >= DRWAV\_CUE\_BYTES) \{}
\DoxyCodeLine{2753             \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2754                 \textcolor{keywordtype}{size\_t} cueCount;}
\DoxyCodeLine{2755 }
\DoxyCodeLine{2756                 pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2757                 cueCount = (size\_t)(pChunkHeader-\/>sizeInBytes -\/ DRWAV\_CUE\_BYTES) / DRWAV\_CUE\_POINT\_BYTES;}
\DoxyCodeLine{2758                 drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(pParser, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{structdrwav__cue__point}{drwav\_cue\_point}}) * cueCount, DRWAV\_METADATA\_ALIGNMENT);}
\DoxyCodeLine{2759             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2760                 bytesRead = drwav\_\_read\_cue\_to\_metadata\_obj(pParser, pChunkHeader, \&pParser-\/>pMetadata[pParser-\/>metadataCursor]);}
\DoxyCodeLine{2761                 \textcolor{keywordflow}{if} (bytesRead == pChunkHeader-\/>sizeInBytes) \{}
\DoxyCodeLine{2762                     pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2763                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2764                     \textcolor{comment}{/* Failed to parse. */}}
\DoxyCodeLine{2765                 \}}
\DoxyCodeLine{2766             \}}
\DoxyCodeLine{2767         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2768             \textcolor{comment}{/* Incorrectly formed chunk. */}}
\DoxyCodeLine{2769         \}}
\DoxyCodeLine{2770     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, pChunkID, drwav\_metadata\_type\_bext, \textcolor{stringliteral}{"{}bext"{}})) \{}
\DoxyCodeLine{2771         \textcolor{keywordflow}{if} (pChunkHeader-\/>sizeInBytes >= DRWAV\_BEXT\_BYTES) \{}
\DoxyCodeLine{2772             \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2773                 \textcolor{comment}{/* The description field is the largest one in a bext chunk, so that is the max size of this temporary buffer. */}}
\DoxyCodeLine{2774                 \textcolor{keywordtype}{char} buffer[DRWAV\_BEXT\_DESCRIPTION\_BYTES + 1];}
\DoxyCodeLine{2775                 \textcolor{keywordtype}{size\_t} allocSizeNeeded = DRWAV\_BEXT\_UMID\_BYTES; \textcolor{comment}{/* We know we will need SMPTE umid size. */}}
\DoxyCodeLine{2776                 \textcolor{keywordtype}{size\_t} bytesJustRead;}
\DoxyCodeLine{2777 }
\DoxyCodeLine{2778                 buffer[DRWAV\_BEXT\_DESCRIPTION\_BYTES] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2779                 bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, buffer, DRWAV\_BEXT\_DESCRIPTION\_BYTES, \&bytesRead);}
\DoxyCodeLine{2780                 \textcolor{keywordflow}{if} (bytesJustRead != DRWAV\_BEXT\_DESCRIPTION\_BYTES) \{}
\DoxyCodeLine{2781                     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2782                 \}}
\DoxyCodeLine{2783                 allocSizeNeeded += strlen(buffer) + 1;}
\DoxyCodeLine{2784 }
\DoxyCodeLine{2785                 buffer[DRWAV\_BEXT\_ORIGINATOR\_NAME\_BYTES] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2786                 bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, buffer, DRWAV\_BEXT\_ORIGINATOR\_NAME\_BYTES, \&bytesRead);}
\DoxyCodeLine{2787                 \textcolor{keywordflow}{if} (bytesJustRead != DRWAV\_BEXT\_ORIGINATOR\_NAME\_BYTES) \{}
\DoxyCodeLine{2788                     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2789                 \}}
\DoxyCodeLine{2790                 allocSizeNeeded += strlen(buffer) + 1;}
\DoxyCodeLine{2791 }
\DoxyCodeLine{2792                 buffer[DRWAV\_BEXT\_ORIGINATOR\_REF\_BYTES] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2793                 bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, buffer, DRWAV\_BEXT\_ORIGINATOR\_REF\_BYTES, \&bytesRead);}
\DoxyCodeLine{2794                 \textcolor{keywordflow}{if} (bytesJustRead != DRWAV\_BEXT\_ORIGINATOR\_REF\_BYTES) \{}
\DoxyCodeLine{2795                     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2796                 \}}
\DoxyCodeLine{2797                 allocSizeNeeded += strlen(buffer) + 1;}
\DoxyCodeLine{2798                 allocSizeNeeded += (size\_t)pChunkHeader-\/>sizeInBytes -\/ DRWAV\_BEXT\_BYTES; \textcolor{comment}{/* Coding history. */}}
\DoxyCodeLine{2799 }
\DoxyCodeLine{2800                 drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(pParser, allocSizeNeeded, 1);}
\DoxyCodeLine{2801 }
\DoxyCodeLine{2802                 pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2803             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2804                 bytesRead = drwav\_\_read\_bext\_to\_metadata\_obj(pParser, \&pParser-\/>pMetadata[pParser-\/>metadataCursor], pChunkHeader-\/>sizeInBytes);}
\DoxyCodeLine{2805                 \textcolor{keywordflow}{if} (bytesRead == pChunkHeader-\/>sizeInBytes) \{}
\DoxyCodeLine{2806                     pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2807                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2808                     \textcolor{comment}{/* Failed to parse. */}}
\DoxyCodeLine{2809                 \}}
\DoxyCodeLine{2810             \}}
\DoxyCodeLine{2811         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2812             \textcolor{comment}{/* Incorrectly formed chunk. */}}
\DoxyCodeLine{2813         \}}
\DoxyCodeLine{2814     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(pChunkID, \textcolor{stringliteral}{"{}LIST"{}}) || drwav\_fourcc\_equal(pChunkID, \textcolor{stringliteral}{"{}list"{}})) \{}
\DoxyCodeLine{2815         drwav\_metadata\_location listType = drwav\_metadata\_location\_invalid;}
\DoxyCodeLine{2816         \textcolor{keywordflow}{while} (bytesRead < pChunkHeader-\/>sizeInBytes) \{}
\DoxyCodeLine{2817             drwav\_uint8 subchunkId[4];}
\DoxyCodeLine{2818             drwav\_uint8 subchunkSizeBuffer[4];}
\DoxyCodeLine{2819             drwav\_uint64 subchunkDataSize;}
\DoxyCodeLine{2820             drwav\_uint64 subchunkBytesRead = 0;}
\DoxyCodeLine{2821             drwav\_uint64 bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, subchunkId, \textcolor{keyword}{sizeof}(subchunkId), \&bytesRead);}
\DoxyCodeLine{2822             \textcolor{keywordflow}{if} (bytesJustRead != \textcolor{keyword}{sizeof}(subchunkId)) \{}
\DoxyCodeLine{2823                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2824             \}}
\DoxyCodeLine{2825 }
\DoxyCodeLine{2826             \textcolor{comment}{/*}}
\DoxyCodeLine{2827 \textcolor{comment}{            The first thing in a list chunk should be "{}adtl"{} or "{}INFO"{}.}}
\DoxyCodeLine{2828 \textcolor{comment}{}}
\DoxyCodeLine{2829 \textcolor{comment}{              -\/ adtl means this list is a Associated Data List Chunk and will contain labels, notes}}
\DoxyCodeLine{2830 \textcolor{comment}{                or labelled cue regions.}}
\DoxyCodeLine{2831 \textcolor{comment}{              -\/ INFO means this list is an Info List Chunk containing info text chunks such as IPRD}}
\DoxyCodeLine{2832 \textcolor{comment}{                which would specifies the album of this wav file.}}
\DoxyCodeLine{2833 \textcolor{comment}{}}
\DoxyCodeLine{2834 \textcolor{comment}{            No data follows the adtl or INFO id so we just make note of what type this list is and}}
\DoxyCodeLine{2835 \textcolor{comment}{            continue.}}
\DoxyCodeLine{2836 \textcolor{comment}{            */}}
\DoxyCodeLine{2837             \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(subchunkId, \textcolor{stringliteral}{"{}adtl"{}})) \{}
\DoxyCodeLine{2838                 listType = drwav\_metadata\_location\_inside\_adtl\_list;}
\DoxyCodeLine{2839                 \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2840             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(subchunkId, \textcolor{stringliteral}{"{}INFO"{}})) \{}
\DoxyCodeLine{2841                 listType = drwav\_metadata\_location\_inside\_info\_list;}
\DoxyCodeLine{2842                 \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2843             \}}
\DoxyCodeLine{2844 }
\DoxyCodeLine{2845             bytesJustRead = drwav\_\_metadata\_parser\_read(pParser, subchunkSizeBuffer, \textcolor{keyword}{sizeof}(subchunkSizeBuffer), \&bytesRead);}
\DoxyCodeLine{2846             \textcolor{keywordflow}{if} (bytesJustRead != \textcolor{keyword}{sizeof}(subchunkSizeBuffer)) \{}
\DoxyCodeLine{2847                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2848             \}}
\DoxyCodeLine{2849             subchunkDataSize = drwav\_bytes\_to\_u32(subchunkSizeBuffer);}
\DoxyCodeLine{2850 }
\DoxyCodeLine{2851             \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_label, \textcolor{stringliteral}{"{}labl"{}}) || drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_note, \textcolor{stringliteral}{"{}note"{}})) \{}
\DoxyCodeLine{2852                 \textcolor{keywordflow}{if} (subchunkDataSize >= DRWAV\_LIST\_LABEL\_OR\_NOTE\_BYTES) \{}
\DoxyCodeLine{2853                     drwav\_uint64 stringSizeWithNullTerm = subchunkDataSize -\/ DRWAV\_LIST\_LABEL\_OR\_NOTE\_BYTES;}
\DoxyCodeLine{2854                     \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2855                         pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2856                         drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(pParser, (\textcolor{keywordtype}{size\_t})stringSizeWithNullTerm, 1);}
\DoxyCodeLine{2857                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2858                         subchunkBytesRead = drwav\_\_read\_list\_label\_or\_note\_to\_metadata\_obj(pParser, \&pParser-\/>pMetadata[pParser-\/>metadataCursor], subchunkDataSize, drwav\_fourcc\_equal(subchunkId, \textcolor{stringliteral}{"{}labl"{}}) ? drwav\_metadata\_type\_list\_label : drwav\_metadata\_type\_list\_note);}
\DoxyCodeLine{2859                         \textcolor{keywordflow}{if} (subchunkBytesRead == subchunkDataSize) \{}
\DoxyCodeLine{2860                             pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2861                         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2862                             \textcolor{comment}{/* Failed to parse. */}}
\DoxyCodeLine{2863                         \}}
\DoxyCodeLine{2864                     \}}
\DoxyCodeLine{2865                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2866                     \textcolor{comment}{/* Incorrectly formed chunk. */}}
\DoxyCodeLine{2867                 \}}
\DoxyCodeLine{2868             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_labelled\_cue\_region, \textcolor{stringliteral}{"{}ltxt"{}})) \{}
\DoxyCodeLine{2869                 \textcolor{keywordflow}{if} (subchunkDataSize >= DRWAV\_LIST\_LABELLED\_TEXT\_BYTES) \{}
\DoxyCodeLine{2870                     drwav\_uint64 stringSizeWithNullTerminator = subchunkDataSize -\/ DRWAV\_LIST\_LABELLED\_TEXT\_BYTES;}
\DoxyCodeLine{2871                     \textcolor{keywordflow}{if} (pParser-\/>stage == drwav\_\_metadata\_parser\_stage\_count) \{}
\DoxyCodeLine{2872                         pParser-\/>metadataCount += 1;}
\DoxyCodeLine{2873                         drwav\_\_metadata\_request\_extra\_memory\_for\_stage\_2(pParser, (\textcolor{keywordtype}{size\_t})stringSizeWithNullTerminator, 1);}
\DoxyCodeLine{2874                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2875                         subchunkBytesRead = drwav\_\_read\_list\_labelled\_cue\_region\_to\_metadata\_obj(pParser, \&pParser-\/>pMetadata[pParser-\/>metadataCursor], subchunkDataSize);}
\DoxyCodeLine{2876                         \textcolor{keywordflow}{if} (subchunkBytesRead == subchunkDataSize) \{}
\DoxyCodeLine{2877                             pParser-\/>metadataCursor += 1;}
\DoxyCodeLine{2878                         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2879                             \textcolor{comment}{/* Failed to parse. */}}
\DoxyCodeLine{2880                         \}}
\DoxyCodeLine{2881                     \}}
\DoxyCodeLine{2882                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2883                     \textcolor{comment}{/* Incorrectly formed chunk. */}}
\DoxyCodeLine{2884                 \}}
\DoxyCodeLine{2885             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_software, \textcolor{stringliteral}{"{}ISFT"{}})) \{}
\DoxyCodeLine{2886                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_software);}
\DoxyCodeLine{2887             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_copyright, \textcolor{stringliteral}{"{}ICOP"{}})) \{}
\DoxyCodeLine{2888                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_copyright);}
\DoxyCodeLine{2889             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_title, \textcolor{stringliteral}{"{}INAM"{}})) \{}
\DoxyCodeLine{2890                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_title);}
\DoxyCodeLine{2891             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_artist, \textcolor{stringliteral}{"{}IART"{}})) \{}
\DoxyCodeLine{2892                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_artist);}
\DoxyCodeLine{2893             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_comment, \textcolor{stringliteral}{"{}ICMT"{}})) \{}
\DoxyCodeLine{2894                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_comment);}
\DoxyCodeLine{2895             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_date, \textcolor{stringliteral}{"{}ICRD"{}})) \{}
\DoxyCodeLine{2896                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_date);}
\DoxyCodeLine{2897             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_genre, \textcolor{stringliteral}{"{}IGNR"{}})) \{}
\DoxyCodeLine{2898                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_genre);}
\DoxyCodeLine{2899             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_album, \textcolor{stringliteral}{"{}IPRD"{}})) \{}
\DoxyCodeLine{2900                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_album);}
\DoxyCodeLine{2901             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_\_chunk\_matches(allowedMetadataTypes, subchunkId, drwav\_metadata\_type\_list\_info\_tracknumber, \textcolor{stringliteral}{"{}ITRK"{}})) \{}
\DoxyCodeLine{2902                 subchunkBytesRead = drwav\_\_metadata\_process\_info\_text\_chunk(pParser, subchunkDataSize,  drwav\_metadata\_type\_list\_info\_tracknumber);}
\DoxyCodeLine{2903             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((allowedMetadataTypes \& drwav\_metadata\_type\_unknown) != 0) \{}
\DoxyCodeLine{2904                 subchunkBytesRead = drwav\_\_metadata\_process\_unknown\_chunk(pParser, subchunkId, subchunkDataSize, listType);}
\DoxyCodeLine{2905             \}}
\DoxyCodeLine{2906 }
\DoxyCodeLine{2907             bytesRead += subchunkBytesRead;}
\DoxyCodeLine{2908             DRWAV\_ASSERT(subchunkBytesRead <= subchunkDataSize);}
\DoxyCodeLine{2909 }
\DoxyCodeLine{2910             \textcolor{keywordflow}{if} (subchunkBytesRead < subchunkDataSize) \{}
\DoxyCodeLine{2911                 drwav\_uint64 bytesToSeek = subchunkDataSize -\/ subchunkBytesRead;}
\DoxyCodeLine{2912 }
\DoxyCodeLine{2913                 \textcolor{keywordflow}{if} (!pParser-\/>onSeek(pParser-\/>pReadSeekUserData, (\textcolor{keywordtype}{int})bytesToSeek, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{2914                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2915                 \}}
\DoxyCodeLine{2916                 bytesRead += bytesToSeek;}
\DoxyCodeLine{2917             \}}
\DoxyCodeLine{2918 }
\DoxyCodeLine{2919             \textcolor{keywordflow}{if} ((subchunkDataSize \% 2) == 1) \{}
\DoxyCodeLine{2920                 \textcolor{keywordflow}{if} (!pParser-\/>onSeek(pParser-\/>pReadSeekUserData, 1, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{2921                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2922                 \}}
\DoxyCodeLine{2923                 bytesRead += 1;}
\DoxyCodeLine{2924             \}}
\DoxyCodeLine{2925         \}}
\DoxyCodeLine{2926     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((allowedMetadataTypes \& drwav\_metadata\_type\_unknown) != 0) \{}
\DoxyCodeLine{2927         bytesRead = drwav\_\_metadata\_process\_unknown\_chunk(pParser, pChunkID, pChunkHeader-\/>sizeInBytes, drwav\_metadata\_location\_top\_level);}
\DoxyCodeLine{2928     \}}
\DoxyCodeLine{2929 }
\DoxyCodeLine{2930     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{2931 \}}
\DoxyCodeLine{2932 }
\DoxyCodeLine{2933 }
\DoxyCodeLine{2934 DRWAV\_PRIVATE drwav\_uint32 drwav\_get\_bytes\_per\_pcm\_frame(\mbox{\hyperlink{structdrwav}{drwav}}* pWav)}
\DoxyCodeLine{2935 \{}
\DoxyCodeLine{2936     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{2937 }
\DoxyCodeLine{2938     \textcolor{comment}{/*}}
\DoxyCodeLine{2939 \textcolor{comment}{    The bytes per frame is a bit ambiguous. It can be either be based on the bits per sample, or the block align. The way I'm doing it here}}
\DoxyCodeLine{2940 \textcolor{comment}{    is that if the bits per sample is a multiple of 8, use floor(bitsPerSample*channels/8), otherwise fall back to the block align.}}
\DoxyCodeLine{2941 \textcolor{comment}{    */}}
\DoxyCodeLine{2942     \textcolor{keywordflow}{if} ((pWav-\/>bitsPerSample \& 0x7) == 0) \{}
\DoxyCodeLine{2943         \textcolor{comment}{/* Bits per sample is a multiple of 8. */}}
\DoxyCodeLine{2944         bytesPerFrame = (pWav-\/>bitsPerSample * pWav-\/>fmt.channels) >> 3;}
\DoxyCodeLine{2945     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2946         bytesPerFrame = pWav-\/>fmt.blockAlign;}
\DoxyCodeLine{2947     \}}
\DoxyCodeLine{2948 }
\DoxyCodeLine{2949     \textcolor{comment}{/* Validation for known formats. a-\/law and mu-\/law should be 1 byte per channel. If it's not, it's not decodable. */}}
\DoxyCodeLine{2950     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ALAW || pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_MULAW) \{}
\DoxyCodeLine{2951         \textcolor{keywordflow}{if} (bytesPerFrame != pWav-\/>fmt.channels) \{}
\DoxyCodeLine{2952             \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Invalid file. */}}
\DoxyCodeLine{2953         \}}
\DoxyCodeLine{2954     \}}
\DoxyCodeLine{2955 }
\DoxyCodeLine{2956     \textcolor{keywordflow}{return} bytesPerFrame;}
\DoxyCodeLine{2957 \}}
\DoxyCodeLine{2958 }
\DoxyCodeLine{2959 DRWAV\_API drwav\_uint16 drwav\_fmt\_get\_format(\textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__fmt}{drwav\_fmt}}* pFMT)}
\DoxyCodeLine{2960 \{}
\DoxyCodeLine{2961     \textcolor{keywordflow}{if} (pFMT == NULL) \{}
\DoxyCodeLine{2962         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2963     \}}
\DoxyCodeLine{2964 }
\DoxyCodeLine{2965     \textcolor{keywordflow}{if} (pFMT-\/>formatTag != DR\_WAVE\_FORMAT\_EXTENSIBLE) \{}
\DoxyCodeLine{2966         \textcolor{keywordflow}{return} pFMT-\/>formatTag;}
\DoxyCodeLine{2967     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2968         \textcolor{keywordflow}{return} drwav\_bytes\_to\_u16(pFMT-\/>subFormat);    \textcolor{comment}{/* Only the first two bytes are required. */}}
\DoxyCodeLine{2969     \}}
\DoxyCodeLine{2970 \}}
\DoxyCodeLine{2971 }
\DoxyCodeLine{2972 DRWAV\_PRIVATE drwav\_bool32 drwav\_preinit(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pReadSeekUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{2973 \{}
\DoxyCodeLine{2974     \textcolor{keywordflow}{if} (pWav == NULL || onRead == NULL || onSeek == NULL) \{}
\DoxyCodeLine{2975         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{2976     \}}
\DoxyCodeLine{2977 }
\DoxyCodeLine{2978     DRWAV\_ZERO\_MEMORY(pWav, \textcolor{keyword}{sizeof}(*pWav));}
\DoxyCodeLine{2979     pWav-\/>onRead    = onRead;}
\DoxyCodeLine{2980     pWav-\/>onSeek    = onSeek;}
\DoxyCodeLine{2981     pWav-\/>pUserData = pReadSeekUserData;}
\DoxyCodeLine{2982     pWav-\/>allocationCallbacks = drwav\_copy\_allocation\_callbacks\_or\_defaults(pAllocationCallbacks);}
\DoxyCodeLine{2983 }
\DoxyCodeLine{2984     \textcolor{keywordflow}{if} (pWav-\/>allocationCallbacks.onFree == NULL || (pWav-\/>allocationCallbacks.onMalloc == NULL \&\& pWav-\/>allocationCallbacks.onRealloc == NULL)) \{}
\DoxyCodeLine{2985         \textcolor{keywordflow}{return} DRWAV\_FALSE;    \textcolor{comment}{/* Invalid allocation callbacks. */}}
\DoxyCodeLine{2986     \}}
\DoxyCodeLine{2987 }
\DoxyCodeLine{2988     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{2989 \}}
\DoxyCodeLine{2990 }
\DoxyCodeLine{2991 DRWAV\_PRIVATE drwav\_bool32 drwav\_init\_\_internal(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags)}
\DoxyCodeLine{2992 \{}
\DoxyCodeLine{2993     \textcolor{comment}{/* This function assumes drwav\_preinit() has been called beforehand. */}}
\DoxyCodeLine{2994 }
\DoxyCodeLine{2995     drwav\_uint64 cursor;    \textcolor{comment}{/* <-\/-\/ Keeps track of the byte position so we can seek to specific locations. */}}
\DoxyCodeLine{2996     drwav\_bool32 sequential;}
\DoxyCodeLine{2997     drwav\_uint8 riff[4];}
\DoxyCodeLine{2998     \mbox{\hyperlink{structdrwav__fmt}{drwav\_fmt}} fmt;}
\DoxyCodeLine{2999     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} translatedFormatTag;}
\DoxyCodeLine{3000     drwav\_bool32 foundDataChunk;}
\DoxyCodeLine{3001     drwav\_uint64 dataChunkSize = 0; \textcolor{comment}{/* <-\/-\/ Important! Don't explicitly set this to 0 anywhere else. Calculation of the size of the data chunk is performed in different paths depending on the container. */}}
\DoxyCodeLine{3002     drwav\_uint64 sampleCountFromFactChunk = 0;  \textcolor{comment}{/* Same as dataChunkSize -\/ make sure this is the only place this is initialized to 0. */}}
\DoxyCodeLine{3003     drwav\_uint64 chunkSize;}
\DoxyCodeLine{3004     drwav\_\_metadata\_parser metadataParser;}
\DoxyCodeLine{3005 }
\DoxyCodeLine{3006     cursor = 0;}
\DoxyCodeLine{3007     sequential = (flags \& DRWAV\_SEQUENTIAL) != 0;}
\DoxyCodeLine{3008 }
\DoxyCodeLine{3009     \textcolor{comment}{/* The first 4 bytes should be the RIFF identifier. */}}
\DoxyCodeLine{3010     \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, riff, \textcolor{keyword}{sizeof}(riff), \&cursor) != \textcolor{keyword}{sizeof}(riff)) \{}
\DoxyCodeLine{3011         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3012     \}}
\DoxyCodeLine{3013 }
\DoxyCodeLine{3014     \textcolor{comment}{/*}}
\DoxyCodeLine{3015 \textcolor{comment}{    The first 4 bytes can be used to identify the container. For RIFF files it will start with "{}RIFF"{} and for}}
\DoxyCodeLine{3016 \textcolor{comment}{    w64 it will start with "{}riff"{}.}}
\DoxyCodeLine{3017 \textcolor{comment}{    */}}
\DoxyCodeLine{3018     \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(riff, \textcolor{stringliteral}{"{}RIFF"{}})) \{}
\DoxyCodeLine{3019         pWav-\/>container = drwav\_container\_riff;}
\DoxyCodeLine{3020     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(riff, \textcolor{stringliteral}{"{}riff"{}})) \{}
\DoxyCodeLine{3021         \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{3022         drwav\_uint8 riff2[12];}
\DoxyCodeLine{3023 }
\DoxyCodeLine{3024         pWav-\/>container = drwav\_container\_w64;}
\DoxyCodeLine{3025 }
\DoxyCodeLine{3026         \textcolor{comment}{/* Check the rest of the GUID for validity. */}}
\DoxyCodeLine{3027         \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, riff2, \textcolor{keyword}{sizeof}(riff2), \&cursor) != \textcolor{keyword}{sizeof}(riff2)) \{}
\DoxyCodeLine{3028             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3029         \}}
\DoxyCodeLine{3030 }
\DoxyCodeLine{3031         \textcolor{keywordflow}{for} (i = 0; i < 12; ++i) \{}
\DoxyCodeLine{3032             \textcolor{keywordflow}{if} (riff2[i] != drwavGUID\_W64\_RIFF[i+4]) \{}
\DoxyCodeLine{3033                 \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3034             \}}
\DoxyCodeLine{3035         \}}
\DoxyCodeLine{3036     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(riff, \textcolor{stringliteral}{"{}RF64"{}})) \{}
\DoxyCodeLine{3037         pWav-\/>container = drwav\_container\_rf64;}
\DoxyCodeLine{3038     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3039         \textcolor{keywordflow}{return} DRWAV\_FALSE;   \textcolor{comment}{/* Unknown or unsupported container. */}}
\DoxyCodeLine{3040     \}}
\DoxyCodeLine{3041 }
\DoxyCodeLine{3042 }
\DoxyCodeLine{3043     \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_riff || pWav-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{3044         drwav\_uint8 chunkSizeBytes[4];}
\DoxyCodeLine{3045         drwav\_uint8 wave[4];}
\DoxyCodeLine{3046 }
\DoxyCodeLine{3047         \textcolor{comment}{/* RIFF/WAVE */}}
\DoxyCodeLine{3048         \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, chunkSizeBytes, \textcolor{keyword}{sizeof}(chunkSizeBytes), \&cursor) != \textcolor{keyword}{sizeof}(chunkSizeBytes)) \{}
\DoxyCodeLine{3049             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3050         \}}
\DoxyCodeLine{3051 }
\DoxyCodeLine{3052         \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_riff) \{}
\DoxyCodeLine{3053             \textcolor{keywordflow}{if} (drwav\_bytes\_to\_u32(chunkSizeBytes) < 36) \{}
\DoxyCodeLine{3054                 \textcolor{keywordflow}{return} DRWAV\_FALSE;    \textcolor{comment}{/* Chunk size should always be at least 36 bytes. */}}
\DoxyCodeLine{3055             \}}
\DoxyCodeLine{3056         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3057             \textcolor{keywordflow}{if} (drwav\_bytes\_to\_u32(chunkSizeBytes) != 0xFFFFFFFF) \{}
\DoxyCodeLine{3058                 \textcolor{keywordflow}{return} DRWAV\_FALSE;    \textcolor{comment}{/* Chunk size should always be set to -\/1/0xFFFFFFFF for RF64. The actual size is retrieved later. */}}
\DoxyCodeLine{3059             \}}
\DoxyCodeLine{3060         \}}
\DoxyCodeLine{3061 }
\DoxyCodeLine{3062         \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, wave, \textcolor{keyword}{sizeof}(wave), \&cursor) != \textcolor{keyword}{sizeof}(wave)) \{}
\DoxyCodeLine{3063             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3064         \}}
\DoxyCodeLine{3065 }
\DoxyCodeLine{3066         \textcolor{keywordflow}{if} (!drwav\_fourcc\_equal(wave, \textcolor{stringliteral}{"{}WAVE"{}})) \{}
\DoxyCodeLine{3067             \textcolor{keywordflow}{return} DRWAV\_FALSE;    \textcolor{comment}{/* Expecting "{}WAVE"{}. */}}
\DoxyCodeLine{3068         \}}
\DoxyCodeLine{3069     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3070         drwav\_uint8 chunkSizeBytes[8];}
\DoxyCodeLine{3071         drwav\_uint8 wave[16];}
\DoxyCodeLine{3072 }
\DoxyCodeLine{3073         \textcolor{comment}{/* W64 */}}
\DoxyCodeLine{3074         \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, chunkSizeBytes, \textcolor{keyword}{sizeof}(chunkSizeBytes), \&cursor) != \textcolor{keyword}{sizeof}(chunkSizeBytes)) \{}
\DoxyCodeLine{3075             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3076         \}}
\DoxyCodeLine{3077 }
\DoxyCodeLine{3078         \textcolor{keywordflow}{if} (drwav\_bytes\_to\_u64(chunkSizeBytes) < 80) \{}
\DoxyCodeLine{3079             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3080         \}}
\DoxyCodeLine{3081 }
\DoxyCodeLine{3082         \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, wave, \textcolor{keyword}{sizeof}(wave), \&cursor) != \textcolor{keyword}{sizeof}(wave)) \{}
\DoxyCodeLine{3083             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3084         \}}
\DoxyCodeLine{3085 }
\DoxyCodeLine{3086         \textcolor{keywordflow}{if} (!drwav\_guid\_equal(wave, drwavGUID\_W64\_WAVE)) \{}
\DoxyCodeLine{3087             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3088         \}}
\DoxyCodeLine{3089     \}}
\DoxyCodeLine{3090 }
\DoxyCodeLine{3091 }
\DoxyCodeLine{3092     \textcolor{comment}{/* For RF64, the "{}ds64"{} chunk must come next, before the "{}fmt "{} chunk. */}}
\DoxyCodeLine{3093     \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{3094         drwav\_uint8 sizeBytes[8];}
\DoxyCodeLine{3095         drwav\_uint64 bytesRemainingInChunk;}
\DoxyCodeLine{3096         \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}} header;}
\DoxyCodeLine{3097         drwav\_result result = drwav\_\_read\_chunk\_header(pWav-\/>onRead, pWav-\/>pUserData, pWav-\/>container, \&cursor, \&header);}
\DoxyCodeLine{3098         \textcolor{keywordflow}{if} (result != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{3099             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3100         \}}
\DoxyCodeLine{3101 }
\DoxyCodeLine{3102         \textcolor{keywordflow}{if} (!drwav\_fourcc\_equal(header.id.fourcc, \textcolor{stringliteral}{"{}ds64"{}})) \{}
\DoxyCodeLine{3103             \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* Expecting "{}ds64"{}. */}}
\DoxyCodeLine{3104         \}}
\DoxyCodeLine{3105 }
\DoxyCodeLine{3106         bytesRemainingInChunk = header.sizeInBytes + header.paddingSize;}
\DoxyCodeLine{3107 }
\DoxyCodeLine{3108         \textcolor{comment}{/* We don't care about the size of the RIFF chunk -\/ skip it. */}}
\DoxyCodeLine{3109         \textcolor{keywordflow}{if} (!drwav\_\_seek\_forward(pWav-\/>onSeek, 8, pWav-\/>pUserData)) \{}
\DoxyCodeLine{3110             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3111         \}}
\DoxyCodeLine{3112         bytesRemainingInChunk -\/= 8;}
\DoxyCodeLine{3113         cursor += 8;}
\DoxyCodeLine{3114 }
\DoxyCodeLine{3115 }
\DoxyCodeLine{3116         \textcolor{comment}{/* Next 8 bytes is the size of the "{}data"{} chunk. */}}
\DoxyCodeLine{3117         \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, sizeBytes, \textcolor{keyword}{sizeof}(sizeBytes), \&cursor) != \textcolor{keyword}{sizeof}(sizeBytes)) \{}
\DoxyCodeLine{3118             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3119         \}}
\DoxyCodeLine{3120         bytesRemainingInChunk -\/= 8;}
\DoxyCodeLine{3121         dataChunkSize = drwav\_bytes\_to\_u64(sizeBytes);}
\DoxyCodeLine{3122 }
\DoxyCodeLine{3123 }
\DoxyCodeLine{3124         \textcolor{comment}{/* Next 8 bytes is the same count which we would usually derived from the FACT chunk if it was available. */}}
\DoxyCodeLine{3125         \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, sizeBytes, \textcolor{keyword}{sizeof}(sizeBytes), \&cursor) != \textcolor{keyword}{sizeof}(sizeBytes)) \{}
\DoxyCodeLine{3126             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3127         \}}
\DoxyCodeLine{3128         bytesRemainingInChunk -\/= 8;}
\DoxyCodeLine{3129         sampleCountFromFactChunk = drwav\_bytes\_to\_u64(sizeBytes);}
\DoxyCodeLine{3130 }
\DoxyCodeLine{3131 }
\DoxyCodeLine{3132         \textcolor{comment}{/* Skip over everything else. */}}
\DoxyCodeLine{3133         \textcolor{keywordflow}{if} (!drwav\_\_seek\_forward(pWav-\/>onSeek, bytesRemainingInChunk, pWav-\/>pUserData)) \{}
\DoxyCodeLine{3134             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3135         \}}
\DoxyCodeLine{3136         cursor += bytesRemainingInChunk;}
\DoxyCodeLine{3137     \}}
\DoxyCodeLine{3138 }
\DoxyCodeLine{3139 }
\DoxyCodeLine{3140     \textcolor{comment}{/* The next bytes should be the "{}fmt "{} chunk. */}}
\DoxyCodeLine{3141     \textcolor{keywordflow}{if} (!drwav\_\_read\_fmt(pWav-\/>onRead, pWav-\/>onSeek, pWav-\/>pUserData, pWav-\/>container, \&cursor, \&fmt)) \{}
\DoxyCodeLine{3142         \textcolor{keywordflow}{return} DRWAV\_FALSE;    \textcolor{comment}{/* Failed to read the "{}fmt "{} chunk. */}}
\DoxyCodeLine{3143     \}}
\DoxyCodeLine{3144 }
\DoxyCodeLine{3145     \textcolor{comment}{/* Basic validation. */}}
\DoxyCodeLine{3146     \textcolor{keywordflow}{if} ((fmt.sampleRate    == 0 || fmt.sampleRate    > DRWAV\_MAX\_SAMPLE\_RATE)     ||}
\DoxyCodeLine{3147         (fmt.channels      == 0 || fmt.channels      > DRWAV\_MAX\_CHANNELS)        ||}
\DoxyCodeLine{3148         (fmt.bitsPerSample == 0 || fmt.bitsPerSample > DRWAV\_MAX\_BITS\_PER\_SAMPLE) ||}
\DoxyCodeLine{3149         fmt.blockAlign == 0) \{}
\DoxyCodeLine{3150         \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* Probably an invalid WAV file. */}}
\DoxyCodeLine{3151     \}}
\DoxyCodeLine{3152 }
\DoxyCodeLine{3153 }
\DoxyCodeLine{3154     \textcolor{comment}{/* Translate the internal format. */}}
\DoxyCodeLine{3155     translatedFormatTag = fmt.formatTag;}
\DoxyCodeLine{3156     \textcolor{keywordflow}{if} (translatedFormatTag == DR\_WAVE\_FORMAT\_EXTENSIBLE) \{}
\DoxyCodeLine{3157         translatedFormatTag = drwav\_bytes\_to\_u16(fmt.subFormat + 0);}
\DoxyCodeLine{3158     \}}
\DoxyCodeLine{3159 }
\DoxyCodeLine{3160     memset(\&metadataParser, 0, \textcolor{keyword}{sizeof}(metadataParser));}
\DoxyCodeLine{3161 }
\DoxyCodeLine{3162     \textcolor{comment}{/* Not tested on W64. */}}
\DoxyCodeLine{3163     \textcolor{keywordflow}{if} (!sequential \&\& pWav-\/>allowedMetadataTypes != drwav\_metadata\_type\_none \&\& (pWav-\/>container == drwav\_container\_riff || pWav-\/>container == drwav\_container\_rf64)) \{}
\DoxyCodeLine{3164         drwav\_uint64 cursorForMetadata = cursor;}
\DoxyCodeLine{3165 }
\DoxyCodeLine{3166         metadataParser.onRead = pWav-\/>onRead;}
\DoxyCodeLine{3167         metadataParser.onSeek = pWav-\/>onSeek;}
\DoxyCodeLine{3168         metadataParser.pReadSeekUserData = pWav-\/>pUserData;}
\DoxyCodeLine{3169         metadataParser.stage = drwav\_\_metadata\_parser\_stage\_count;}
\DoxyCodeLine{3170 }
\DoxyCodeLine{3171         \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{3172             drwav\_result result;}
\DoxyCodeLine{3173             drwav\_uint64 bytesRead;}
\DoxyCodeLine{3174             drwav\_uint64 remainingBytes;}
\DoxyCodeLine{3175             \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}} header;}
\DoxyCodeLine{3176             }
\DoxyCodeLine{3177             result = drwav\_\_read\_chunk\_header(pWav-\/>onRead, pWav-\/>pUserData, pWav-\/>container, \&cursorForMetadata, \&header);}
\DoxyCodeLine{3178             \textcolor{keywordflow}{if} (result != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{3179                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{3180             \}}
\DoxyCodeLine{3181 }
\DoxyCodeLine{3182             bytesRead = drwav\_\_metadata\_process\_chunk(\&metadataParser, \&header, pWav-\/>allowedMetadataTypes);}
\DoxyCodeLine{3183             DRWAV\_ASSERT(bytesRead <= header.sizeInBytes);}
\DoxyCodeLine{3184 }
\DoxyCodeLine{3185             remainingBytes = header.sizeInBytes -\/ bytesRead + header.paddingSize;}
\DoxyCodeLine{3186             \textcolor{keywordflow}{if} (!drwav\_\_seek\_forward(pWav-\/>onSeek, remainingBytes, pWav-\/>pUserData)) \{}
\DoxyCodeLine{3187                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{3188             \}}
\DoxyCodeLine{3189             cursorForMetadata += remainingBytes;}
\DoxyCodeLine{3190         \}}
\DoxyCodeLine{3191 }
\DoxyCodeLine{3192         \textcolor{keywordflow}{if} (!drwav\_\_seek\_from\_start(pWav-\/>onSeek, cursor, pWav-\/>pUserData)) \{}
\DoxyCodeLine{3193             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3194         \}}
\DoxyCodeLine{3195 }
\DoxyCodeLine{3196         drwav\_\_metadata\_alloc(\&metadataParser, \&pWav-\/>allocationCallbacks);}
\DoxyCodeLine{3197         metadataParser.stage = drwav\_\_metadata\_parser\_stage\_read;}
\DoxyCodeLine{3198     \}}
\DoxyCodeLine{3199 }
\DoxyCodeLine{3200     \textcolor{comment}{/*}}
\DoxyCodeLine{3201 \textcolor{comment}{    We need to enumerate over each chunk for two reasons:}}
\DoxyCodeLine{3202 \textcolor{comment}{      1) The "{}data"{} chunk may not be the next one}}
\DoxyCodeLine{3203 \textcolor{comment}{      2) We may want to report each chunk back to the client}}
\DoxyCodeLine{3204 \textcolor{comment}{}}
\DoxyCodeLine{3205 \textcolor{comment}{    In order to correctly report each chunk back to the client we will need to keep looping until the end of the file.}}
\DoxyCodeLine{3206 \textcolor{comment}{    */}}
\DoxyCodeLine{3207     foundDataChunk = DRWAV\_FALSE;}
\DoxyCodeLine{3208 }
\DoxyCodeLine{3209     \textcolor{comment}{/* The next chunk we care about is the "{}data"{} chunk. This is not necessarily the next chunk so we'll need to loop. */}}
\DoxyCodeLine{3210     \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{3211         \mbox{\hyperlink{structdrwav__chunk__header}{drwav\_chunk\_header}} header;}
\DoxyCodeLine{3212         drwav\_result result = drwav\_\_read\_chunk\_header(pWav-\/>onRead, pWav-\/>pUserData, pWav-\/>container, \&cursor, \&header);}
\DoxyCodeLine{3213         \textcolor{keywordflow}{if} (result != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{3214             \textcolor{keywordflow}{if} (!foundDataChunk) \{}
\DoxyCodeLine{3215                 \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3216             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3217                 \textcolor{keywordflow}{break};  \textcolor{comment}{/* Probably at the end of the file. Get out of the loop. */}}
\DoxyCodeLine{3218             \}}
\DoxyCodeLine{3219         \}}
\DoxyCodeLine{3220 }
\DoxyCodeLine{3221         \textcolor{comment}{/* Tell the client about this chunk. */}}
\DoxyCodeLine{3222         \textcolor{keywordflow}{if} (!sequential \&\& onChunk != NULL) \{}
\DoxyCodeLine{3223             drwav\_uint64 callbackBytesRead = onChunk(pChunkUserData, pWav-\/>onRead, pWav-\/>onSeek, pWav-\/>pUserData, \&header, pWav-\/>container, \&fmt);}
\DoxyCodeLine{3224 }
\DoxyCodeLine{3225             \textcolor{comment}{/*}}
\DoxyCodeLine{3226 \textcolor{comment}{            dr\_wav may need to read the contents of the chunk, so we now need to seek back to the position before}}
\DoxyCodeLine{3227 \textcolor{comment}{            we called the callback.}}
\DoxyCodeLine{3228 \textcolor{comment}{            */}}
\DoxyCodeLine{3229             \textcolor{keywordflow}{if} (callbackBytesRead > 0) \{}
\DoxyCodeLine{3230                 \textcolor{keywordflow}{if} (!drwav\_\_seek\_from\_start(pWav-\/>onSeek, cursor, pWav-\/>pUserData)) \{}
\DoxyCodeLine{3231                     \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3232                 \}}
\DoxyCodeLine{3233             \}}
\DoxyCodeLine{3234         \}}
\DoxyCodeLine{3235 }
\DoxyCodeLine{3236         \textcolor{keywordflow}{if} (!sequential \&\& pWav-\/>allowedMetadataTypes != drwav\_metadata\_type\_none \&\& (pWav-\/>container == drwav\_container\_riff || pWav-\/>container == drwav\_container\_rf64)) \{}
\DoxyCodeLine{3237             drwav\_uint64 bytesRead = drwav\_\_metadata\_process\_chunk(\&metadataParser, \&header, pWav-\/>allowedMetadataTypes);}
\DoxyCodeLine{3238 }
\DoxyCodeLine{3239             \textcolor{keywordflow}{if} (bytesRead > 0) \{}
\DoxyCodeLine{3240                 \textcolor{keywordflow}{if} (!drwav\_\_seek\_from\_start(pWav-\/>onSeek, cursor, pWav-\/>pUserData)) \{}
\DoxyCodeLine{3241                     \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3242                 \}}
\DoxyCodeLine{3243             \}}
\DoxyCodeLine{3244         \}}
\DoxyCodeLine{3245 }
\DoxyCodeLine{3246 }
\DoxyCodeLine{3247         \textcolor{keywordflow}{if} (!foundDataChunk) \{}
\DoxyCodeLine{3248             pWav-\/>dataChunkDataPos = cursor;}
\DoxyCodeLine{3249         \}}
\DoxyCodeLine{3250 }
\DoxyCodeLine{3251         chunkSize = header.sizeInBytes;}
\DoxyCodeLine{3252         \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_riff || pWav-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{3253             \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(header.id.fourcc, \textcolor{stringliteral}{"{}data"{}})) \{}
\DoxyCodeLine{3254                 foundDataChunk = DRWAV\_TRUE;}
\DoxyCodeLine{3255                 \textcolor{keywordflow}{if} (pWav-\/>container != drwav\_container\_rf64) \{  \textcolor{comment}{/* The data chunk size for RF64 will always be set to 0xFFFFFFFF here. It was set to it's true value earlier. */}}
\DoxyCodeLine{3256                     dataChunkSize = chunkSize;}
\DoxyCodeLine{3257                 \}}
\DoxyCodeLine{3258             \}}
\DoxyCodeLine{3259         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3260             \textcolor{keywordflow}{if} (drwav\_guid\_equal(header.id.guid, drwavGUID\_W64\_DATA)) \{}
\DoxyCodeLine{3261                 foundDataChunk = DRWAV\_TRUE;}
\DoxyCodeLine{3262                 dataChunkSize = chunkSize;}
\DoxyCodeLine{3263             \}}
\DoxyCodeLine{3264         \}}
\DoxyCodeLine{3265 }
\DoxyCodeLine{3266         \textcolor{comment}{/*}}
\DoxyCodeLine{3267 \textcolor{comment}{        If at this point we have found the data chunk and we're running in sequential mode, we need to break out of this loop. The reason for}}
\DoxyCodeLine{3268 \textcolor{comment}{        this is that we would otherwise require a backwards seek which sequential mode forbids.}}
\DoxyCodeLine{3269 \textcolor{comment}{        */}}
\DoxyCodeLine{3270         \textcolor{keywordflow}{if} (foundDataChunk \&\& sequential) \{}
\DoxyCodeLine{3271             \textcolor{keywordflow}{break};}
\DoxyCodeLine{3272         \}}
\DoxyCodeLine{3273 }
\DoxyCodeLine{3274         \textcolor{comment}{/* Optional. Get the total sample count from the FACT chunk. This is useful for compressed formats. */}}
\DoxyCodeLine{3275         \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_riff) \{}
\DoxyCodeLine{3276             \textcolor{keywordflow}{if} (drwav\_fourcc\_equal(header.id.fourcc, \textcolor{stringliteral}{"{}fact"{}})) \{}
\DoxyCodeLine{3277                 drwav\_uint32 sampleCount;}
\DoxyCodeLine{3278                 \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, \&sampleCount, 4, \&cursor) != 4) \{}
\DoxyCodeLine{3279                     \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3280                 \}}
\DoxyCodeLine{3281                 chunkSize -\/= 4;}
\DoxyCodeLine{3282 }
\DoxyCodeLine{3283                 \textcolor{keywordflow}{if} (!foundDataChunk) \{}
\DoxyCodeLine{3284                     pWav-\/>dataChunkDataPos = cursor;}
\DoxyCodeLine{3285                 \}}
\DoxyCodeLine{3286 }
\DoxyCodeLine{3287                 \textcolor{comment}{/*}}
\DoxyCodeLine{3288 \textcolor{comment}{                The sample count in the "{}fact"{} chunk is either unreliable, or I'm not understanding it properly. For now I am only enabling this}}
\DoxyCodeLine{3289 \textcolor{comment}{                for Microsoft ADPCM formats.}}
\DoxyCodeLine{3290 \textcolor{comment}{                */}}
\DoxyCodeLine{3291                 \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM) \{}
\DoxyCodeLine{3292                     sampleCountFromFactChunk = sampleCount;}
\DoxyCodeLine{3293                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3294                     sampleCountFromFactChunk = 0;}
\DoxyCodeLine{3295                 \}}
\DoxyCodeLine{3296             \}}
\DoxyCodeLine{3297         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_w64) \{}
\DoxyCodeLine{3298             \textcolor{keywordflow}{if} (drwav\_guid\_equal(header.id.guid, drwavGUID\_W64\_FACT)) \{}
\DoxyCodeLine{3299                 \textcolor{keywordflow}{if} (drwav\_\_on\_read(pWav-\/>onRead, pWav-\/>pUserData, \&sampleCountFromFactChunk, 8, \&cursor) != 8) \{}
\DoxyCodeLine{3300                     \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3301                 \}}
\DoxyCodeLine{3302                 chunkSize -\/= 8;}
\DoxyCodeLine{3303 }
\DoxyCodeLine{3304                 \textcolor{keywordflow}{if} (!foundDataChunk) \{}
\DoxyCodeLine{3305                     pWav-\/>dataChunkDataPos = cursor;}
\DoxyCodeLine{3306                 \}}
\DoxyCodeLine{3307             \}}
\DoxyCodeLine{3308         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{3309             \textcolor{comment}{/* We retrieved the sample count from the ds64 chunk earlier so no need to do that here. */}}
\DoxyCodeLine{3310         \}}
\DoxyCodeLine{3311 }
\DoxyCodeLine{3312         \textcolor{comment}{/* Make sure we seek past the padding. */}}
\DoxyCodeLine{3313         chunkSize += header.paddingSize;}
\DoxyCodeLine{3314         \textcolor{keywordflow}{if} (!drwav\_\_seek\_forward(pWav-\/>onSeek, chunkSize, pWav-\/>pUserData)) \{}
\DoxyCodeLine{3315             \textcolor{keywordflow}{break};}
\DoxyCodeLine{3316         \}}
\DoxyCodeLine{3317         cursor += chunkSize;}
\DoxyCodeLine{3318 }
\DoxyCodeLine{3319         \textcolor{keywordflow}{if} (!foundDataChunk) \{}
\DoxyCodeLine{3320             pWav-\/>dataChunkDataPos = cursor;}
\DoxyCodeLine{3321         \}}
\DoxyCodeLine{3322     \}}
\DoxyCodeLine{3323 }
\DoxyCodeLine{3324     pWav-\/>pMetadata     = metadataParser.pMetadata;}
\DoxyCodeLine{3325     pWav-\/>metadataCount = metadataParser.metadataCount;}
\DoxyCodeLine{3326 }
\DoxyCodeLine{3327     \textcolor{comment}{/* If we haven't found a data chunk, return an error. */}}
\DoxyCodeLine{3328     \textcolor{keywordflow}{if} (!foundDataChunk) \{}
\DoxyCodeLine{3329         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3330     \}}
\DoxyCodeLine{3331 }
\DoxyCodeLine{3332     \textcolor{comment}{/* We may have moved passed the data chunk. If so we need to move back. If running in sequential mode we can assume we are already sitting on the data chunk. */}}
\DoxyCodeLine{3333     \textcolor{keywordflow}{if} (!sequential) \{}
\DoxyCodeLine{3334         \textcolor{keywordflow}{if} (!drwav\_\_seek\_from\_start(pWav-\/>onSeek, pWav-\/>dataChunkDataPos, pWav-\/>pUserData)) \{}
\DoxyCodeLine{3335             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3336         \}}
\DoxyCodeLine{3337         cursor = pWav-\/>dataChunkDataPos;}
\DoxyCodeLine{3338     \}}
\DoxyCodeLine{3339 }
\DoxyCodeLine{3340 }
\DoxyCodeLine{3341     \textcolor{comment}{/* At this point we should be sitting on the first byte of the raw audio data. */}}
\DoxyCodeLine{3342 }
\DoxyCodeLine{3343     pWav-\/>fmt                 = fmt;}
\DoxyCodeLine{3344     pWav-\/>sampleRate          = fmt.sampleRate;}
\DoxyCodeLine{3345     pWav-\/>channels            = fmt.channels;}
\DoxyCodeLine{3346     pWav-\/>bitsPerSample       = fmt.bitsPerSample;}
\DoxyCodeLine{3347     pWav-\/>bytesRemaining      = dataChunkSize;}
\DoxyCodeLine{3348     pWav-\/>translatedFormatTag = translatedFormatTag;}
\DoxyCodeLine{3349     pWav-\/>dataChunkDataSize   = dataChunkSize;}
\DoxyCodeLine{3350 }
\DoxyCodeLine{3351     \textcolor{keywordflow}{if} (sampleCountFromFactChunk != 0) \{}
\DoxyCodeLine{3352         pWav-\/>totalPCMFrameCount = sampleCountFromFactChunk;}
\DoxyCodeLine{3353     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3354         drwav\_uint32 bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{3355         \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{3356             \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* Invalid file. */}}
\DoxyCodeLine{3357         \}}
\DoxyCodeLine{3358 }
\DoxyCodeLine{3359         pWav-\/>totalPCMFrameCount = dataChunkSize / bytesPerFrame;}
\DoxyCodeLine{3360 }
\DoxyCodeLine{3361         \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM) \{}
\DoxyCodeLine{3362             drwav\_uint64 totalBlockHeaderSizeInBytes;}
\DoxyCodeLine{3363             drwav\_uint64 blockCount = dataChunkSize / fmt.blockAlign;}
\DoxyCodeLine{3364 }
\DoxyCodeLine{3365             \textcolor{comment}{/* Make sure any trailing partial block is accounted for. */}}
\DoxyCodeLine{3366             \textcolor{keywordflow}{if} ((blockCount * fmt.blockAlign) < dataChunkSize) \{}
\DoxyCodeLine{3367                 blockCount += 1;}
\DoxyCodeLine{3368             \}}
\DoxyCodeLine{3369 }
\DoxyCodeLine{3370             \textcolor{comment}{/* We decode two samples per byte. There will be blockCount headers in the data chunk. This is enough to know how to calculate the total PCM frame count. */}}
\DoxyCodeLine{3371             totalBlockHeaderSizeInBytes = blockCount * (6*fmt.channels);}
\DoxyCodeLine{3372             pWav-\/>totalPCMFrameCount = ((dataChunkSize -\/ totalBlockHeaderSizeInBytes) * 2) / fmt.channels;}
\DoxyCodeLine{3373         \}}
\DoxyCodeLine{3374         \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{3375             drwav\_uint64 totalBlockHeaderSizeInBytes;}
\DoxyCodeLine{3376             drwav\_uint64 blockCount = dataChunkSize / fmt.blockAlign;}
\DoxyCodeLine{3377 }
\DoxyCodeLine{3378             \textcolor{comment}{/* Make sure any trailing partial block is accounted for. */}}
\DoxyCodeLine{3379             \textcolor{keywordflow}{if} ((blockCount * fmt.blockAlign) < dataChunkSize) \{}
\DoxyCodeLine{3380                 blockCount += 1;}
\DoxyCodeLine{3381             \}}
\DoxyCodeLine{3382 }
\DoxyCodeLine{3383             \textcolor{comment}{/* We decode two samples per byte. There will be blockCount headers in the data chunk. This is enough to know how to calculate the total PCM frame count. */}}
\DoxyCodeLine{3384             totalBlockHeaderSizeInBytes = blockCount * (4*fmt.channels);}
\DoxyCodeLine{3385             pWav-\/>totalPCMFrameCount = ((dataChunkSize -\/ totalBlockHeaderSizeInBytes) * 2) / fmt.channels;}
\DoxyCodeLine{3386 }
\DoxyCodeLine{3387             \textcolor{comment}{/* The header includes a decoded sample for each channel which acts as the initial predictor sample. */}}
\DoxyCodeLine{3388             pWav-\/>totalPCMFrameCount += blockCount;}
\DoxyCodeLine{3389         \}}
\DoxyCodeLine{3390     \}}
\DoxyCodeLine{3391 }
\DoxyCodeLine{3392     \textcolor{comment}{/* Some formats only support a certain number of channels. */}}
\DoxyCodeLine{3393     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM || pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{3394         \textcolor{keywordflow}{if} (pWav-\/>channels > 2) \{}
\DoxyCodeLine{3395             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3396         \}}
\DoxyCodeLine{3397     \}}
\DoxyCodeLine{3398 }
\DoxyCodeLine{3399     \textcolor{comment}{/* The number of bytes per frame must be known. If not, it's an invalid file and not decodable. */}}
\DoxyCodeLine{3400     \textcolor{keywordflow}{if} (drwav\_get\_bytes\_per\_pcm\_frame(pWav) == 0) \{}
\DoxyCodeLine{3401         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3402     \}}
\DoxyCodeLine{3403 }
\DoxyCodeLine{3404 \textcolor{preprocessor}{\#ifdef DR\_WAV\_LIBSNDFILE\_COMPAT}}
\DoxyCodeLine{3405     \textcolor{comment}{/*}}
\DoxyCodeLine{3406 \textcolor{comment}{    I use libsndfile as a benchmark for testing, however in the version I'm using (from the Windows installer on the libsndfile website),}}
\DoxyCodeLine{3407 \textcolor{comment}{    it appears the total sample count libsndfile uses for MS-\/ADPCM is incorrect. It would seem they are computing the total sample count}}
\DoxyCodeLine{3408 \textcolor{comment}{    from the number of blocks, however this results in the inclusion of extra silent samples at the end of the last block. The correct}}
\DoxyCodeLine{3409 \textcolor{comment}{    way to know the total sample count is to inspect the "{}fact"{} chunk, which should always be present for compressed formats, and should}}
\DoxyCodeLine{3410 \textcolor{comment}{    always include the sample count. This little block of code below is only used to emulate the libsndfile logic so I can properly run my}}
\DoxyCodeLine{3411 \textcolor{comment}{    correctness tests against libsndfile, and is disabled by default.}}
\DoxyCodeLine{3412 \textcolor{comment}{    */}}
\DoxyCodeLine{3413     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM) \{}
\DoxyCodeLine{3414         drwav\_uint64 blockCount = dataChunkSize / fmt.blockAlign;}
\DoxyCodeLine{3415         pWav-\/>totalPCMFrameCount = (((blockCount * (fmt.blockAlign -\/ (6*pWav-\/>channels))) * 2)) / fmt.channels;  \textcolor{comment}{/* x2 because two samples per byte. */}}
\DoxyCodeLine{3416     \}}
\DoxyCodeLine{3417     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{3418         drwav\_uint64 blockCount = dataChunkSize / fmt.blockAlign;}
\DoxyCodeLine{3419         pWav-\/>totalPCMFrameCount = (((blockCount * (fmt.blockAlign -\/ (4*pWav-\/>channels))) * 2) + (blockCount * pWav-\/>channels)) / fmt.channels;}
\DoxyCodeLine{3420     \}}
\DoxyCodeLine{3421 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3422 }
\DoxyCodeLine{3423     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{3424 \}}
\DoxyCodeLine{3425 }
\DoxyCodeLine{3426 DRWAV\_API drwav\_bool32 drwav\_init(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{3427 \{}
\DoxyCodeLine{3428     \textcolor{keywordflow}{return} drwav\_init\_ex(pWav, onRead, onSeek, NULL, pUserData, NULL, 0, pAllocationCallbacks);}
\DoxyCodeLine{3429 \}}
\DoxyCodeLine{3430 }
\DoxyCodeLine{3431 DRWAV\_API drwav\_bool32 drwav\_init\_ex(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pReadSeekUserData, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{3432 \{}
\DoxyCodeLine{3433     \textcolor{keywordflow}{if} (!drwav\_preinit(pWav, onRead, onSeek, pReadSeekUserData, pAllocationCallbacks)) \{}
\DoxyCodeLine{3434         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3435     \}}
\DoxyCodeLine{3436 }
\DoxyCodeLine{3437     \textcolor{keywordflow}{return} drwav\_init\_\_internal(pWav, onChunk, pChunkUserData, flags);}
\DoxyCodeLine{3438 \}}
\DoxyCodeLine{3439 }
\DoxyCodeLine{3440 DRWAV\_API drwav\_bool32 drwav\_init\_with\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{3441 \{}
\DoxyCodeLine{3442     \textcolor{keywordflow}{if} (!drwav\_preinit(pWav, onRead, onSeek, pUserData, pAllocationCallbacks)) \{}
\DoxyCodeLine{3443         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{3444     \}}
\DoxyCodeLine{3445 }
\DoxyCodeLine{3446     pWav-\/>allowedMetadataTypes = drwav\_metadata\_type\_all\_including\_unknown;   \textcolor{comment}{/* <-\/-\/ Needs to be set to tell drwav\_init\_ex() that we need to process metadata. */}}
\DoxyCodeLine{3447     \textcolor{keywordflow}{return} drwav\_init\_\_internal(pWav, NULL, NULL, flags);}
\DoxyCodeLine{3448 \}}
\DoxyCodeLine{3449 }
\DoxyCodeLine{3450 DRWAV\_API \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* drwav\_take\_ownership\_of\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav)}
\DoxyCodeLine{3451 \{}
\DoxyCodeLine{3452     \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}} *result = pWav-\/>pMetadata;}
\DoxyCodeLine{3453 }
\DoxyCodeLine{3454     pWav-\/>pMetadata     = NULL;}
\DoxyCodeLine{3455     pWav-\/>metadataCount = 0;}
\DoxyCodeLine{3456 }
\DoxyCodeLine{3457     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{3458 \}}
\DoxyCodeLine{3459 }
\DoxyCodeLine{3460 }
\DoxyCodeLine{3461 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData, \textcolor{keywordtype}{size\_t} dataSize)}
\DoxyCodeLine{3462 \{}
\DoxyCodeLine{3463     DRWAV\_ASSERT(pWav          != NULL);}
\DoxyCodeLine{3464     DRWAV\_ASSERT(pWav-\/>onWrite != NULL);}
\DoxyCodeLine{3465 }
\DoxyCodeLine{3466     \textcolor{comment}{/* Generic write. Assumes no byte reordering required. */}}
\DoxyCodeLine{3467     \textcolor{keywordflow}{return} pWav-\/>onWrite(pWav-\/>pUserData, pData, dataSize);}
\DoxyCodeLine{3468 \}}
\DoxyCodeLine{3469 }
\DoxyCodeLine{3470 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_byte(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint8 \textcolor{keywordtype}{byte})}
\DoxyCodeLine{3471 \{}
\DoxyCodeLine{3472     DRWAV\_ASSERT(pWav          != NULL);}
\DoxyCodeLine{3473     DRWAV\_ASSERT(pWav-\/>onWrite != NULL);}
\DoxyCodeLine{3474 }
\DoxyCodeLine{3475     \textcolor{keywordflow}{return} pWav-\/>onWrite(pWav-\/>pUserData, \&\textcolor{keywordtype}{byte}, 1);}
\DoxyCodeLine{3476 \}}
\DoxyCodeLine{3477 }
\DoxyCodeLine{3478 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_u16ne\_to\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint16 value)}
\DoxyCodeLine{3479 \{}
\DoxyCodeLine{3480     DRWAV\_ASSERT(pWav          != NULL);}
\DoxyCodeLine{3481     DRWAV\_ASSERT(pWav-\/>onWrite != NULL);}
\DoxyCodeLine{3482 }
\DoxyCodeLine{3483     \textcolor{keywordflow}{if} (!drwav\_\_is\_little\_endian()) \{}
\DoxyCodeLine{3484         value = drwav\_\_bswap16(value);}
\DoxyCodeLine{3485     \}}
\DoxyCodeLine{3486 }
\DoxyCodeLine{3487     \textcolor{keywordflow}{return} drwav\_\_write(pWav, \&value, 2);}
\DoxyCodeLine{3488 \}}
\DoxyCodeLine{3489 }
\DoxyCodeLine{3490 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_u32ne\_to\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint32 value)}
\DoxyCodeLine{3491 \{}
\DoxyCodeLine{3492     DRWAV\_ASSERT(pWav          != NULL);}
\DoxyCodeLine{3493     DRWAV\_ASSERT(pWav-\/>onWrite != NULL);}
\DoxyCodeLine{3494 }
\DoxyCodeLine{3495     \textcolor{keywordflow}{if} (!drwav\_\_is\_little\_endian()) \{}
\DoxyCodeLine{3496         value = drwav\_\_bswap32(value);}
\DoxyCodeLine{3497     \}}
\DoxyCodeLine{3498 }
\DoxyCodeLine{3499     \textcolor{keywordflow}{return} drwav\_\_write(pWav, \&value, 4);}
\DoxyCodeLine{3500 \}}
\DoxyCodeLine{3501 }
\DoxyCodeLine{3502 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_u64ne\_to\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 value)}
\DoxyCodeLine{3503 \{}
\DoxyCodeLine{3504     DRWAV\_ASSERT(pWav          != NULL);}
\DoxyCodeLine{3505     DRWAV\_ASSERT(pWav-\/>onWrite != NULL);}
\DoxyCodeLine{3506 }
\DoxyCodeLine{3507     \textcolor{keywordflow}{if} (!drwav\_\_is\_little\_endian()) \{}
\DoxyCodeLine{3508         value = drwav\_\_bswap64(value);}
\DoxyCodeLine{3509     \}}
\DoxyCodeLine{3510 }
\DoxyCodeLine{3511     \textcolor{keywordflow}{return} drwav\_\_write(pWav, \&value, 8);}
\DoxyCodeLine{3512 \}}
\DoxyCodeLine{3513 }
\DoxyCodeLine{3514 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_f32ne\_to\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{float} value)}
\DoxyCodeLine{3515 \{}
\DoxyCodeLine{3516     \textcolor{keyword}{union }\{}
\DoxyCodeLine{3517        drwav\_uint32 u32;}
\DoxyCodeLine{3518        \textcolor{keywordtype}{float} f32;}
\DoxyCodeLine{3519     \} u;}
\DoxyCodeLine{3520 }
\DoxyCodeLine{3521     DRWAV\_ASSERT(pWav          != NULL);}
\DoxyCodeLine{3522     DRWAV\_ASSERT(pWav-\/>onWrite != NULL);}
\DoxyCodeLine{3523 }
\DoxyCodeLine{3524     u.f32 = value;}
\DoxyCodeLine{3525 }
\DoxyCodeLine{3526     \textcolor{keywordflow}{if} (!drwav\_\_is\_little\_endian()) \{}
\DoxyCodeLine{3527         u.u32 = drwav\_\_bswap32(u.u32);}
\DoxyCodeLine{3528     \}}
\DoxyCodeLine{3529 }
\DoxyCodeLine{3530     \textcolor{keywordflow}{return} drwav\_\_write(pWav, \&u.u32, 4);}
\DoxyCodeLine{3531 \}}
\DoxyCodeLine{3532 }
\DoxyCodeLine{3533 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_or\_count(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData, \textcolor{keywordtype}{size\_t} dataSize)}
\DoxyCodeLine{3534 \{}
\DoxyCodeLine{3535     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{3536         \textcolor{keywordflow}{return} dataSize;}
\DoxyCodeLine{3537     \}}
\DoxyCodeLine{3538 }
\DoxyCodeLine{3539     \textcolor{keywordflow}{return} drwav\_\_write(pWav, pData, dataSize);}
\DoxyCodeLine{3540 \}}
\DoxyCodeLine{3541 }
\DoxyCodeLine{3542 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_or\_count\_byte(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint8 \textcolor{keywordtype}{byte})}
\DoxyCodeLine{3543 \{}
\DoxyCodeLine{3544     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{3545         \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{3546     \}}
\DoxyCodeLine{3547 }
\DoxyCodeLine{3548     \textcolor{keywordflow}{return} drwav\_\_write\_byte(pWav, \textcolor{keywordtype}{byte});}
\DoxyCodeLine{3549 \}}
\DoxyCodeLine{3550 }
\DoxyCodeLine{3551 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_or\_count\_u16ne\_to\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint16 value)}
\DoxyCodeLine{3552 \{}
\DoxyCodeLine{3553     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{3554         \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{3555     \}}
\DoxyCodeLine{3556 }
\DoxyCodeLine{3557     \textcolor{keywordflow}{return} drwav\_\_write\_u16ne\_to\_le(pWav, value);}
\DoxyCodeLine{3558 \}}
\DoxyCodeLine{3559 }
\DoxyCodeLine{3560 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_or\_count\_u32ne\_to\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint32 value)}
\DoxyCodeLine{3561 \{}
\DoxyCodeLine{3562     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{3563         \textcolor{keywordflow}{return} 4;}
\DoxyCodeLine{3564     \}}
\DoxyCodeLine{3565 }
\DoxyCodeLine{3566     \textcolor{keywordflow}{return} drwav\_\_write\_u32ne\_to\_le(pWav, value);}
\DoxyCodeLine{3567 \}}
\DoxyCodeLine{3568 }
\DoxyCodeLine{3569 \textcolor{preprocessor}{\#if 0   }\textcolor{comment}{/* Unused for now. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{3570 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_or\_count\_u64ne\_to\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 value)}
\DoxyCodeLine{3571 \{}
\DoxyCodeLine{3572     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{3573         \textcolor{keywordflow}{return} 8;}
\DoxyCodeLine{3574     \}}
\DoxyCodeLine{3575 }
\DoxyCodeLine{3576     \textcolor{keywordflow}{return} drwav\_\_write\_u64ne\_to\_le(pWav, value);}
\DoxyCodeLine{3577 \}}
\DoxyCodeLine{3578 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3579 }
\DoxyCodeLine{3580 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_or\_count\_f32ne\_to\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{float} value)}
\DoxyCodeLine{3581 \{}
\DoxyCodeLine{3582     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{3583         \textcolor{keywordflow}{return} 4;}
\DoxyCodeLine{3584     \}}
\DoxyCodeLine{3585 }
\DoxyCodeLine{3586     \textcolor{keywordflow}{return} drwav\_\_write\_f32ne\_to\_le(pWav, value);}
\DoxyCodeLine{3587 \}}
\DoxyCodeLine{3588 }
\DoxyCodeLine{3589 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_or\_count\_string\_to\_fixed\_size\_buf(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{char}* str, \textcolor{keywordtype}{size\_t} bufFixedSize)}
\DoxyCodeLine{3590 \{}
\DoxyCodeLine{3591     \textcolor{keywordtype}{size\_t} len;}
\DoxyCodeLine{3592 }
\DoxyCodeLine{3593     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{3594         \textcolor{keywordflow}{return} bufFixedSize;}
\DoxyCodeLine{3595     \}}
\DoxyCodeLine{3596 }
\DoxyCodeLine{3597     len = drwav\_\_strlen\_clamped(str, bufFixedSize);}
\DoxyCodeLine{3598     drwav\_\_write\_or\_count(pWav, str, len);}
\DoxyCodeLine{3599 }
\DoxyCodeLine{3600     \textcolor{keywordflow}{if} (len < bufFixedSize) \{}
\DoxyCodeLine{3601         \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{3602         \textcolor{keywordflow}{for} (i = 0; i < bufFixedSize -\/ len; ++i) \{}
\DoxyCodeLine{3603             drwav\_\_write\_byte(pWav, 0);}
\DoxyCodeLine{3604         \}}
\DoxyCodeLine{3605     \}}
\DoxyCodeLine{3606 }
\DoxyCodeLine{3607     \textcolor{keywordflow}{return} bufFixedSize;}
\DoxyCodeLine{3608 \}}
\DoxyCodeLine{3609 }
\DoxyCodeLine{3610 }
\DoxyCodeLine{3611 \textcolor{comment}{/* pWav can be NULL meaning just count the bytes that would be written. */}}
\DoxyCodeLine{3612 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_write\_or\_count\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadatas, drwav\_uint32 metadataCount)}
\DoxyCodeLine{3613 \{}
\DoxyCodeLine{3614     \textcolor{keywordtype}{size\_t} bytesWritten = 0;}
\DoxyCodeLine{3615     drwav\_bool32 hasListAdtl = DRWAV\_FALSE;}
\DoxyCodeLine{3616     drwav\_bool32 hasListInfo = DRWAV\_FALSE;}
\DoxyCodeLine{3617     drwav\_uint32 iMetadata;}
\DoxyCodeLine{3618 }
\DoxyCodeLine{3619     \textcolor{keywordflow}{if} (pMetadatas == NULL || metadataCount == 0) \{}
\DoxyCodeLine{3620         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3621     \}}
\DoxyCodeLine{3622 }
\DoxyCodeLine{3623     \textcolor{keywordflow}{for} (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) \{}
\DoxyCodeLine{3624         \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata = \&pMetadatas[iMetadata];}
\DoxyCodeLine{3625         drwav\_uint32 chunkSize = 0;}
\DoxyCodeLine{3626 }
\DoxyCodeLine{3627         \textcolor{keywordflow}{if} ((pMetadata-\/>type \& drwav\_metadata\_type\_list\_all\_info\_strings) || (pMetadata-\/>type == drwav\_metadata\_type\_unknown \&\& pMetadata-\/>data.unknown.chunkLocation == drwav\_metadata\_location\_inside\_info\_list)) \{}
\DoxyCodeLine{3628             hasListInfo = DRWAV\_TRUE;}
\DoxyCodeLine{3629         \}}
\DoxyCodeLine{3630 }
\DoxyCodeLine{3631         \textcolor{keywordflow}{if} ((pMetadata-\/>type \& drwav\_metadata\_type\_list\_all\_adtl) || (pMetadata-\/>type == drwav\_metadata\_type\_unknown \&\& pMetadata-\/>data.unknown.chunkLocation == drwav\_metadata\_location\_inside\_adtl\_list)) \{}
\DoxyCodeLine{3632             hasListAdtl = DRWAV\_TRUE;}
\DoxyCodeLine{3633         \}}
\DoxyCodeLine{3634 }
\DoxyCodeLine{3635         \textcolor{keywordflow}{switch} (pMetadata-\/>type) \{}
\DoxyCodeLine{3636             \textcolor{keywordflow}{case} drwav\_metadata\_type\_smpl:}
\DoxyCodeLine{3637             \{}
\DoxyCodeLine{3638                 drwav\_uint32 iLoop;}
\DoxyCodeLine{3639 }
\DoxyCodeLine{3640                 chunkSize = DRWAV\_SMPL\_BYTES + DRWAV\_SMPL\_LOOP\_BYTES * pMetadata-\/>data.smpl.sampleLoopCount + pMetadata-\/>data.smpl.samplerSpecificDataSizeInBytes;}
\DoxyCodeLine{3641 }
\DoxyCodeLine{3642                 bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}smpl"{}}, 4);}
\DoxyCodeLine{3643                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, chunkSize);}
\DoxyCodeLine{3644 }
\DoxyCodeLine{3645                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.manufacturerId);}
\DoxyCodeLine{3646                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.productId);}
\DoxyCodeLine{3647                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.samplePeriodNanoseconds);}
\DoxyCodeLine{3648                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.midiUnityNote);}
\DoxyCodeLine{3649                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.midiPitchFraction);}
\DoxyCodeLine{3650                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.smpteFormat);}
\DoxyCodeLine{3651                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.smpteOffset);}
\DoxyCodeLine{3652                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.sampleLoopCount);}
\DoxyCodeLine{3653                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.samplerSpecificDataSizeInBytes);}
\DoxyCodeLine{3654 }
\DoxyCodeLine{3655                 \textcolor{keywordflow}{for} (iLoop = 0; iLoop < pMetadata-\/>data.smpl.sampleLoopCount; ++iLoop) \{}
\DoxyCodeLine{3656                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.pLoops[iLoop].cuePointId);}
\DoxyCodeLine{3657                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.pLoops[iLoop].type);}
\DoxyCodeLine{3658                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.pLoops[iLoop].firstSampleByteOffset);}
\DoxyCodeLine{3659                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.pLoops[iLoop].lastSampleByteOffset);}
\DoxyCodeLine{3660                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.pLoops[iLoop].sampleFraction);}
\DoxyCodeLine{3661                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.smpl.pLoops[iLoop].playCount);}
\DoxyCodeLine{3662                 \}}
\DoxyCodeLine{3663 }
\DoxyCodeLine{3664                 \textcolor{keywordflow}{if} (pMetadata-\/>data.smpl.samplerSpecificDataSizeInBytes > 0) \{}
\DoxyCodeLine{3665                     bytesWritten += drwav\_\_write(pWav, pMetadata-\/>data.smpl.pSamplerSpecificData, pMetadata-\/>data.smpl.samplerSpecificDataSizeInBytes);}
\DoxyCodeLine{3666                 \}  }
\DoxyCodeLine{3667             \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3668 }
\DoxyCodeLine{3669             \textcolor{keywordflow}{case} drwav\_metadata\_type\_inst:}
\DoxyCodeLine{3670             \{}
\DoxyCodeLine{3671                 chunkSize = DRWAV\_INST\_BYTES;}
\DoxyCodeLine{3672 }
\DoxyCodeLine{3673                 bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}inst"{}}, 4);}
\DoxyCodeLine{3674                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, chunkSize);}
\DoxyCodeLine{3675                 bytesWritten += drwav\_\_write\_or\_count(pWav, \&pMetadata-\/>data.inst.midiUnityNote, 1);}
\DoxyCodeLine{3676                 bytesWritten += drwav\_\_write\_or\_count(pWav, \&pMetadata-\/>data.inst.fineTuneCents, 1);}
\DoxyCodeLine{3677                 bytesWritten += drwav\_\_write\_or\_count(pWav, \&pMetadata-\/>data.inst.gainDecibels, 1);}
\DoxyCodeLine{3678                 bytesWritten += drwav\_\_write\_or\_count(pWav, \&pMetadata-\/>data.inst.lowNote, 1);}
\DoxyCodeLine{3679                 bytesWritten += drwav\_\_write\_or\_count(pWav, \&pMetadata-\/>data.inst.highNote, 1);}
\DoxyCodeLine{3680                 bytesWritten += drwav\_\_write\_or\_count(pWav, \&pMetadata-\/>data.inst.lowVelocity, 1);}
\DoxyCodeLine{3681                 bytesWritten += drwav\_\_write\_or\_count(pWav, \&pMetadata-\/>data.inst.highVelocity, 1);}
\DoxyCodeLine{3682             \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3683 }
\DoxyCodeLine{3684             \textcolor{keywordflow}{case} drwav\_metadata\_type\_cue:}
\DoxyCodeLine{3685             \{}
\DoxyCodeLine{3686                 drwav\_uint32 iCuePoint;}
\DoxyCodeLine{3687 }
\DoxyCodeLine{3688                 chunkSize = DRWAV\_CUE\_BYTES + DRWAV\_CUE\_POINT\_BYTES * pMetadata-\/>data.cue.cuePointCount;}
\DoxyCodeLine{3689 }
\DoxyCodeLine{3690                 bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}cue "{}}, 4);}
\DoxyCodeLine{3691                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, chunkSize);}
\DoxyCodeLine{3692                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.cue.cuePointCount);}
\DoxyCodeLine{3693                 \textcolor{keywordflow}{for} (iCuePoint = 0; iCuePoint < pMetadata-\/>data.cue.cuePointCount; ++iCuePoint) \{}
\DoxyCodeLine{3694                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.cue.pCuePoints[iCuePoint].id);}
\DoxyCodeLine{3695                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.cue.pCuePoints[iCuePoint].playOrderPosition);}
\DoxyCodeLine{3696                     bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.cue.pCuePoints[iCuePoint].dataChunkId, 4);}
\DoxyCodeLine{3697                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.cue.pCuePoints[iCuePoint].chunkStart);}
\DoxyCodeLine{3698                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.cue.pCuePoints[iCuePoint].blockStart);}
\DoxyCodeLine{3699                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.cue.pCuePoints[iCuePoint].sampleByteOffset);}
\DoxyCodeLine{3700                 \}}
\DoxyCodeLine{3701             \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3702 }
\DoxyCodeLine{3703             \textcolor{keywordflow}{case} drwav\_metadata\_type\_acid:}
\DoxyCodeLine{3704             \{}
\DoxyCodeLine{3705                 chunkSize = DRWAV\_ACID\_BYTES;}
\DoxyCodeLine{3706 }
\DoxyCodeLine{3707                 bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}acid"{}}, 4);}
\DoxyCodeLine{3708                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, chunkSize);}
\DoxyCodeLine{3709                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.acid.flags);}
\DoxyCodeLine{3710                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.acid.midiUnityNote);}
\DoxyCodeLine{3711                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.acid.reserved1);}
\DoxyCodeLine{3712                 bytesWritten += drwav\_\_write\_or\_count\_f32ne\_to\_le(pWav, pMetadata-\/>data.acid.reserved2);}
\DoxyCodeLine{3713                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.acid.numBeats);}
\DoxyCodeLine{3714                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.acid.meterDenominator);}
\DoxyCodeLine{3715                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.acid.meterNumerator);}
\DoxyCodeLine{3716                 bytesWritten += drwav\_\_write\_or\_count\_f32ne\_to\_le(pWav, pMetadata-\/>data.acid.tempo);}
\DoxyCodeLine{3717             \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3718 }
\DoxyCodeLine{3719             \textcolor{keywordflow}{case} drwav\_metadata\_type\_bext:}
\DoxyCodeLine{3720             \{}
\DoxyCodeLine{3721                 \textcolor{keywordtype}{char} reservedBuf[DRWAV\_BEXT\_RESERVED\_BYTES];}
\DoxyCodeLine{3722                 drwav\_uint32 timeReferenceLow;}
\DoxyCodeLine{3723                 drwav\_uint32 timeReferenceHigh;}
\DoxyCodeLine{3724 }
\DoxyCodeLine{3725                 chunkSize = DRWAV\_BEXT\_BYTES + pMetadata-\/>data.bext.codingHistorySize;}
\DoxyCodeLine{3726 }
\DoxyCodeLine{3727                 bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}bext"{}}, 4);}
\DoxyCodeLine{3728                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, chunkSize);}
\DoxyCodeLine{3729 }
\DoxyCodeLine{3730                 bytesWritten += drwav\_\_write\_or\_count\_string\_to\_fixed\_size\_buf(pWav, pMetadata-\/>data.bext.pDescription, DRWAV\_BEXT\_DESCRIPTION\_BYTES);}
\DoxyCodeLine{3731                 bytesWritten += drwav\_\_write\_or\_count\_string\_to\_fixed\_size\_buf(pWav, pMetadata-\/>data.bext.pOriginatorName, DRWAV\_BEXT\_ORIGINATOR\_NAME\_BYTES);}
\DoxyCodeLine{3732                 bytesWritten += drwav\_\_write\_or\_count\_string\_to\_fixed\_size\_buf(pWav, pMetadata-\/>data.bext.pOriginatorReference, DRWAV\_BEXT\_ORIGINATOR\_REF\_BYTES);}
\DoxyCodeLine{3733                 bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.bext.pOriginationDate, \textcolor{keyword}{sizeof}(pMetadata-\/>data.bext.pOriginationDate));}
\DoxyCodeLine{3734                 bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.bext.pOriginationTime, \textcolor{keyword}{sizeof}(pMetadata-\/>data.bext.pOriginationTime));}
\DoxyCodeLine{3735 }
\DoxyCodeLine{3736                 timeReferenceLow  = (drwav\_uint32)(pMetadata-\/>data.bext.timeReference \& 0xFFFFFFFF);}
\DoxyCodeLine{3737                 timeReferenceHigh = (drwav\_uint32)(pMetadata-\/>data.bext.timeReference >> 32);}
\DoxyCodeLine{3738                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, timeReferenceLow);}
\DoxyCodeLine{3739                 bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, timeReferenceHigh);}
\DoxyCodeLine{3740 }
\DoxyCodeLine{3741                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.bext.version);}
\DoxyCodeLine{3742                 bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.bext.pUMID, DRWAV\_BEXT\_UMID\_BYTES);}
\DoxyCodeLine{3743                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.bext.loudnessValue);}
\DoxyCodeLine{3744                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.bext.loudnessRange);}
\DoxyCodeLine{3745                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.bext.maxTruePeakLevel);}
\DoxyCodeLine{3746                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.bext.maxMomentaryLoudness);}
\DoxyCodeLine{3747                 bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.bext.maxShortTermLoudness);}
\DoxyCodeLine{3748 }
\DoxyCodeLine{3749                 memset(reservedBuf, 0, \textcolor{keyword}{sizeof}(reservedBuf));}
\DoxyCodeLine{3750                 bytesWritten += drwav\_\_write\_or\_count(pWav, reservedBuf, \textcolor{keyword}{sizeof}(reservedBuf));}
\DoxyCodeLine{3751 }
\DoxyCodeLine{3752                 \textcolor{keywordflow}{if} (pMetadata-\/>data.bext.codingHistorySize > 0) \{}
\DoxyCodeLine{3753                     bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.bext.pCodingHistory, pMetadata-\/>data.bext.codingHistorySize);}
\DoxyCodeLine{3754                 \}}
\DoxyCodeLine{3755             \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3756 }
\DoxyCodeLine{3757             \textcolor{keywordflow}{case} drwav\_metadata\_type\_unknown:}
\DoxyCodeLine{3758             \{}
\DoxyCodeLine{3759                 \textcolor{keywordflow}{if} (pMetadata-\/>data.unknown.chunkLocation == drwav\_metadata\_location\_top\_level) \{}
\DoxyCodeLine{3760                     chunkSize = pMetadata-\/>data.unknown.dataSizeInBytes;}
\DoxyCodeLine{3761 }
\DoxyCodeLine{3762                     bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.unknown.id, 4);}
\DoxyCodeLine{3763                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, chunkSize);}
\DoxyCodeLine{3764                     bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.unknown.pData, pMetadata-\/>data.unknown.dataSizeInBytes);}
\DoxyCodeLine{3765                 \}}
\DoxyCodeLine{3766             \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3767 }
\DoxyCodeLine{3768             \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};}
\DoxyCodeLine{3769         \}}
\DoxyCodeLine{3770         \textcolor{keywordflow}{if} ((chunkSize \% 2) != 0) \{}
\DoxyCodeLine{3771             bytesWritten += drwav\_\_write\_or\_count\_byte(pWav, 0);}
\DoxyCodeLine{3772         \}}
\DoxyCodeLine{3773     \}}
\DoxyCodeLine{3774 }
\DoxyCodeLine{3775     \textcolor{keywordflow}{if} (hasListInfo) \{}
\DoxyCodeLine{3776         drwav\_uint32 chunkSize = 4; \textcolor{comment}{/* Start with 4 bytes for "{}INFO"{}. */}}
\DoxyCodeLine{3777         \textcolor{keywordflow}{for} (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) \{}
\DoxyCodeLine{3778             \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata = \&pMetadatas[iMetadata];}
\DoxyCodeLine{3779 }
\DoxyCodeLine{3780             \textcolor{keywordflow}{if} ((pMetadata-\/>type \& drwav\_metadata\_type\_list\_all\_info\_strings)) \{}
\DoxyCodeLine{3781                 chunkSize += 8; \textcolor{comment}{/* For id and string size. */}}
\DoxyCodeLine{3782                 chunkSize += pMetadata-\/>data.infoText.stringLength + 1; \textcolor{comment}{/* Include null terminator. */}}
\DoxyCodeLine{3783             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pMetadata-\/>type == drwav\_metadata\_type\_unknown \&\& pMetadata-\/>data.unknown.chunkLocation == drwav\_metadata\_location\_inside\_info\_list) \{}
\DoxyCodeLine{3784                 chunkSize += 8; \textcolor{comment}{/* For id string size. */}}
\DoxyCodeLine{3785                 chunkSize += pMetadata-\/>data.unknown.dataSizeInBytes;}
\DoxyCodeLine{3786             \}}
\DoxyCodeLine{3787 }
\DoxyCodeLine{3788             \textcolor{keywordflow}{if} ((chunkSize \% 2) != 0) \{}
\DoxyCodeLine{3789                 chunkSize += 1;}
\DoxyCodeLine{3790             \}}
\DoxyCodeLine{3791         \}}
\DoxyCodeLine{3792 }
\DoxyCodeLine{3793         bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}LIST"{}}, 4);}
\DoxyCodeLine{3794         bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, chunkSize);}
\DoxyCodeLine{3795         bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}INFO"{}}, 4);}
\DoxyCodeLine{3796 }
\DoxyCodeLine{3797         \textcolor{keywordflow}{for} (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) \{}
\DoxyCodeLine{3798             \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata = \&pMetadatas[iMetadata];}
\DoxyCodeLine{3799             drwav\_uint32 subchunkSize = 0;}
\DoxyCodeLine{3800 }
\DoxyCodeLine{3801             \textcolor{keywordflow}{if} (pMetadata-\/>type \& drwav\_metadata\_type\_list\_all\_info\_strings) \{}
\DoxyCodeLine{3802                 \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pID = NULL;}
\DoxyCodeLine{3803 }
\DoxyCodeLine{3804                 \textcolor{keywordflow}{switch} (pMetadata-\/>type) \{}
\DoxyCodeLine{3805                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_software:    pID = \textcolor{stringliteral}{"{}ISFT"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3806                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_copyright:   pID = \textcolor{stringliteral}{"{}ICOP"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3807                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_title:       pID = \textcolor{stringliteral}{"{}INAM"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3808                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_artist:      pID = \textcolor{stringliteral}{"{}IART"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3809                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_comment:     pID = \textcolor{stringliteral}{"{}ICMT"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3810                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_date:        pID = \textcolor{stringliteral}{"{}ICRD"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3811                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_genre:       pID = \textcolor{stringliteral}{"{}IGNR"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3812                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_album:       pID = \textcolor{stringliteral}{"{}IPRD"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3813                     \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_info\_tracknumber: pID = \textcolor{stringliteral}{"{}ITRK"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{3814                     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};}
\DoxyCodeLine{3815                 \}}
\DoxyCodeLine{3816 }
\DoxyCodeLine{3817                 DRWAV\_ASSERT(pID != NULL);}
\DoxyCodeLine{3818 }
\DoxyCodeLine{3819                 \textcolor{keywordflow}{if} (pMetadata-\/>data.infoText.stringLength) \{}
\DoxyCodeLine{3820                     subchunkSize = pMetadata-\/>data.infoText.stringLength + 1;}
\DoxyCodeLine{3821                     bytesWritten += drwav\_\_write\_or\_count(pWav, pID, 4);}
\DoxyCodeLine{3822                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, subchunkSize);}
\DoxyCodeLine{3823                     bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.infoText.pString, pMetadata-\/>data.infoText.stringLength);}
\DoxyCodeLine{3824                     bytesWritten += drwav\_\_write\_or\_count\_byte(pWav, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{3825                 \}}
\DoxyCodeLine{3826             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pMetadata-\/>type == drwav\_metadata\_type\_unknown \&\& pMetadata-\/>data.unknown.chunkLocation == drwav\_metadata\_location\_inside\_info\_list) \{}
\DoxyCodeLine{3827                 \textcolor{keywordflow}{if} (pMetadata-\/>data.unknown.dataSizeInBytes) \{}
\DoxyCodeLine{3828                     subchunkSize = pMetadata-\/>data.unknown.dataSizeInBytes;}
\DoxyCodeLine{3829 }
\DoxyCodeLine{3830                     bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.unknown.id, 4);}
\DoxyCodeLine{3831                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.unknown.dataSizeInBytes);}
\DoxyCodeLine{3832                     bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.unknown.pData, subchunkSize);}
\DoxyCodeLine{3833                 \}}
\DoxyCodeLine{3834             \}}
\DoxyCodeLine{3835 }
\DoxyCodeLine{3836             \textcolor{keywordflow}{if} ((subchunkSize \% 2) != 0) \{}
\DoxyCodeLine{3837                 bytesWritten += drwav\_\_write\_or\_count\_byte(pWav, 0);}
\DoxyCodeLine{3838             \}}
\DoxyCodeLine{3839         \}}
\DoxyCodeLine{3840     \}}
\DoxyCodeLine{3841 }
\DoxyCodeLine{3842     \textcolor{keywordflow}{if} (hasListAdtl) \{}
\DoxyCodeLine{3843         drwav\_uint32 chunkSize = 4; \textcolor{comment}{/* start with 4 bytes for "{}adtl"{} */}}
\DoxyCodeLine{3844 }
\DoxyCodeLine{3845         \textcolor{keywordflow}{for} (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) \{}
\DoxyCodeLine{3846             \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata = \&pMetadatas[iMetadata];}
\DoxyCodeLine{3847 }
\DoxyCodeLine{3848             \textcolor{keywordflow}{switch} (pMetadata-\/>type)}
\DoxyCodeLine{3849             \{}
\DoxyCodeLine{3850                 \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_label:}
\DoxyCodeLine{3851                 \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_note:}
\DoxyCodeLine{3852                 \{}
\DoxyCodeLine{3853                     chunkSize += 8; \textcolor{comment}{/* for id and chunk size */}}
\DoxyCodeLine{3854                     chunkSize += DRWAV\_LIST\_LABEL\_OR\_NOTE\_BYTES;}
\DoxyCodeLine{3855 }
\DoxyCodeLine{3856                     \textcolor{keywordflow}{if} (pMetadata-\/>data.labelOrNote.stringLength > 0) \{}
\DoxyCodeLine{3857                         chunkSize += pMetadata-\/>data.labelOrNote.stringLength + 1;}
\DoxyCodeLine{3858                     \}    }
\DoxyCodeLine{3859                 \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3860 }
\DoxyCodeLine{3861                 \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_labelled\_cue\_region:}
\DoxyCodeLine{3862                 \{}
\DoxyCodeLine{3863                     chunkSize += 8; \textcolor{comment}{/* for id and chunk size */}}
\DoxyCodeLine{3864                     chunkSize += DRWAV\_LIST\_LABELLED\_TEXT\_BYTES;}
\DoxyCodeLine{3865 }
\DoxyCodeLine{3866                     \textcolor{keywordflow}{if} (pMetadata-\/>data.labelledCueRegion.stringLength > 0) \{}
\DoxyCodeLine{3867                         chunkSize += pMetadata-\/>data.labelledCueRegion.stringLength + 1;}
\DoxyCodeLine{3868                     \}}
\DoxyCodeLine{3869                 \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3870 }
\DoxyCodeLine{3871                 \textcolor{keywordflow}{case} drwav\_metadata\_type\_unknown:}
\DoxyCodeLine{3872                 \{}
\DoxyCodeLine{3873                     \textcolor{keywordflow}{if} (pMetadata-\/>data.unknown.chunkLocation == drwav\_metadata\_location\_inside\_adtl\_list) \{}
\DoxyCodeLine{3874                         chunkSize += 8; \textcolor{comment}{/* for id and chunk size */}}
\DoxyCodeLine{3875                         chunkSize += pMetadata-\/>data.unknown.dataSizeInBytes;}
\DoxyCodeLine{3876                     \}}
\DoxyCodeLine{3877                 \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3878 }
\DoxyCodeLine{3879                 \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};}
\DoxyCodeLine{3880             \}}
\DoxyCodeLine{3881 }
\DoxyCodeLine{3882             \textcolor{keywordflow}{if} ((chunkSize \% 2) != 0) \{}
\DoxyCodeLine{3883                 chunkSize += 1;}
\DoxyCodeLine{3884             \}}
\DoxyCodeLine{3885         \}}
\DoxyCodeLine{3886 }
\DoxyCodeLine{3887         bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}LIST"{}}, 4);}
\DoxyCodeLine{3888         bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, chunkSize);}
\DoxyCodeLine{3889         bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}adtl"{}}, 4);}
\DoxyCodeLine{3890 }
\DoxyCodeLine{3891         \textcolor{keywordflow}{for} (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) \{}
\DoxyCodeLine{3892             \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata = \&pMetadatas[iMetadata];}
\DoxyCodeLine{3893             drwav\_uint32 subchunkSize = 0;}
\DoxyCodeLine{3894 }
\DoxyCodeLine{3895             \textcolor{keywordflow}{switch} (pMetadata-\/>type)}
\DoxyCodeLine{3896             \{}
\DoxyCodeLine{3897                 \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_label:}
\DoxyCodeLine{3898                 \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_note:}
\DoxyCodeLine{3899                 \{}
\DoxyCodeLine{3900                     \textcolor{keywordflow}{if} (pMetadata-\/>data.labelOrNote.stringLength > 0) \{}
\DoxyCodeLine{3901                         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pID = NULL;}
\DoxyCodeLine{3902 }
\DoxyCodeLine{3903                         \textcolor{keywordflow}{if} (pMetadata-\/>type == drwav\_metadata\_type\_list\_label) \{}
\DoxyCodeLine{3904                             pID = \textcolor{stringliteral}{"{}labl"{}};}
\DoxyCodeLine{3905                         \}}
\DoxyCodeLine{3906                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pMetadata-\/>type == drwav\_metadata\_type\_list\_note) \{}
\DoxyCodeLine{3907                             pID = \textcolor{stringliteral}{"{}note"{}};}
\DoxyCodeLine{3908                         \}}
\DoxyCodeLine{3909 }
\DoxyCodeLine{3910                         DRWAV\_ASSERT(pID != NULL);}
\DoxyCodeLine{3911                         DRWAV\_ASSERT(pMetadata-\/>data.labelOrNote.pString != NULL);}
\DoxyCodeLine{3912 }
\DoxyCodeLine{3913                         subchunkSize = DRWAV\_LIST\_LABEL\_OR\_NOTE\_BYTES;}
\DoxyCodeLine{3914 }
\DoxyCodeLine{3915                         bytesWritten += drwav\_\_write\_or\_count(pWav, pID, 4);}
\DoxyCodeLine{3916                         subchunkSize += pMetadata-\/>data.labelOrNote.stringLength + 1;}
\DoxyCodeLine{3917                         bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, subchunkSize);}
\DoxyCodeLine{3918 }
\DoxyCodeLine{3919                         bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.labelOrNote.cuePointId);}
\DoxyCodeLine{3920                         bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.labelOrNote.pString, pMetadata-\/>data.labelOrNote.stringLength);}
\DoxyCodeLine{3921                         bytesWritten += drwav\_\_write\_or\_count\_byte(pWav, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{3922                     \}}
\DoxyCodeLine{3923                 \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3924 }
\DoxyCodeLine{3925                 \textcolor{keywordflow}{case} drwav\_metadata\_type\_list\_labelled\_cue\_region:}
\DoxyCodeLine{3926                 \{}
\DoxyCodeLine{3927                     subchunkSize = DRWAV\_LIST\_LABELLED\_TEXT\_BYTES;}
\DoxyCodeLine{3928 }
\DoxyCodeLine{3929                     bytesWritten += drwav\_\_write\_or\_count(pWav, \textcolor{stringliteral}{"{}ltxt"{}}, 4);}
\DoxyCodeLine{3930                     \textcolor{keywordflow}{if} (pMetadata-\/>data.labelledCueRegion.stringLength > 0) \{}
\DoxyCodeLine{3931                         subchunkSize += pMetadata-\/>data.labelledCueRegion.stringLength + 1;}
\DoxyCodeLine{3932                     \}}
\DoxyCodeLine{3933                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, subchunkSize);}
\DoxyCodeLine{3934                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.labelledCueRegion.cuePointId);}
\DoxyCodeLine{3935                     bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, pMetadata-\/>data.labelledCueRegion.sampleLength);}
\DoxyCodeLine{3936                     bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.labelledCueRegion.purposeId, 4);}
\DoxyCodeLine{3937                     bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.labelledCueRegion.country);}
\DoxyCodeLine{3938                     bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.labelledCueRegion.language);}
\DoxyCodeLine{3939                     bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.labelledCueRegion.dialect);}
\DoxyCodeLine{3940                     bytesWritten += drwav\_\_write\_or\_count\_u16ne\_to\_le(pWav, pMetadata-\/>data.labelledCueRegion.codePage);}
\DoxyCodeLine{3941 }
\DoxyCodeLine{3942                     \textcolor{keywordflow}{if} (pMetadata-\/>data.labelledCueRegion.stringLength > 0) \{}
\DoxyCodeLine{3943                         DRWAV\_ASSERT(pMetadata-\/>data.labelledCueRegion.pString != NULL);}
\DoxyCodeLine{3944 }
\DoxyCodeLine{3945                         bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.labelledCueRegion.pString, pMetadata-\/>data.labelledCueRegion.stringLength);}
\DoxyCodeLine{3946                         bytesWritten += drwav\_\_write\_or\_count\_byte(pWav, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{3947                     \}}
\DoxyCodeLine{3948                 \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3949 }
\DoxyCodeLine{3950                 \textcolor{keywordflow}{case} drwav\_metadata\_type\_unknown:}
\DoxyCodeLine{3951                 \{}
\DoxyCodeLine{3952                     \textcolor{keywordflow}{if} (pMetadata-\/>data.unknown.chunkLocation == drwav\_metadata\_location\_inside\_adtl\_list) \{}
\DoxyCodeLine{3953                         subchunkSize = pMetadata-\/>data.unknown.dataSizeInBytes;}
\DoxyCodeLine{3954 }
\DoxyCodeLine{3955                         DRWAV\_ASSERT(pMetadata-\/>data.unknown.pData != NULL);}
\DoxyCodeLine{3956                         bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.unknown.id, 4);}
\DoxyCodeLine{3957                         bytesWritten += drwav\_\_write\_or\_count\_u32ne\_to\_le(pWav, subchunkSize);}
\DoxyCodeLine{3958                         bytesWritten += drwav\_\_write\_or\_count(pWav, pMetadata-\/>data.unknown.pData, subchunkSize);}
\DoxyCodeLine{3959                     \}}
\DoxyCodeLine{3960                 \} \textcolor{keywordflow}{break};}
\DoxyCodeLine{3961 }
\DoxyCodeLine{3962                 \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};}
\DoxyCodeLine{3963             \}}
\DoxyCodeLine{3964 }
\DoxyCodeLine{3965             \textcolor{keywordflow}{if} ((subchunkSize \% 2) != 0) \{}
\DoxyCodeLine{3966                 bytesWritten += drwav\_\_write\_or\_count\_byte(pWav, 0);}
\DoxyCodeLine{3967             \}}
\DoxyCodeLine{3968         \}}
\DoxyCodeLine{3969     \}}
\DoxyCodeLine{3970 }
\DoxyCodeLine{3971     DRWAV\_ASSERT((bytesWritten \% 2) == 0);}
\DoxyCodeLine{3972 }
\DoxyCodeLine{3973     \textcolor{keywordflow}{return} bytesWritten;}
\DoxyCodeLine{3974 \}}
\DoxyCodeLine{3975 }
\DoxyCodeLine{3976 DRWAV\_PRIVATE drwav\_uint32 drwav\_\_riff\_chunk\_size\_riff(drwav\_uint64 dataChunkSize, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata, drwav\_uint32 metadataCount)}
\DoxyCodeLine{3977 \{}
\DoxyCodeLine{3978     drwav\_uint64 chunkSize = 4 + 24 + (drwav\_uint64)drwav\_\_write\_or\_count\_metadata(NULL, pMetadata, metadataCount) + 8 + dataChunkSize + drwav\_\_chunk\_padding\_size\_riff(dataChunkSize); \textcolor{comment}{/* 4 = "{}WAVE"{}. 24 = "{}fmt "{} chunk. 8 = "{}data"{} + u32 data size. */}}
\DoxyCodeLine{3979     \textcolor{keywordflow}{if} (chunkSize > 0xFFFFFFFFUL) \{}
\DoxyCodeLine{3980         chunkSize = 0xFFFFFFFFUL;}
\DoxyCodeLine{3981     \}}
\DoxyCodeLine{3982 }
\DoxyCodeLine{3983     \textcolor{keywordflow}{return} (drwav\_uint32)chunkSize; \textcolor{comment}{/* Safe cast due to the clamp above. */}}
\DoxyCodeLine{3984 \}}
\DoxyCodeLine{3985 }
\DoxyCodeLine{3986 DRWAV\_PRIVATE drwav\_uint32 drwav\_\_data\_chunk\_size\_riff(drwav\_uint64 dataChunkSize)}
\DoxyCodeLine{3987 \{}
\DoxyCodeLine{3988     \textcolor{keywordflow}{if} (dataChunkSize <= 0xFFFFFFFFUL) \{}
\DoxyCodeLine{3989         \textcolor{keywordflow}{return} (drwav\_uint32)dataChunkSize;}
\DoxyCodeLine{3990     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3991         \textcolor{keywordflow}{return} 0xFFFFFFFFUL;}
\DoxyCodeLine{3992     \}}
\DoxyCodeLine{3993 \}}
\DoxyCodeLine{3994 }
\DoxyCodeLine{3995 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_riff\_chunk\_size\_w64(drwav\_uint64 dataChunkSize)}
\DoxyCodeLine{3996 \{}
\DoxyCodeLine{3997     drwav\_uint64 dataSubchunkPaddingSize = drwav\_\_chunk\_padding\_size\_w64(dataChunkSize);}
\DoxyCodeLine{3998 }
\DoxyCodeLine{3999     \textcolor{keywordflow}{return} 80 + 24 + dataChunkSize + dataSubchunkPaddingSize;   \textcolor{comment}{/* +24 because W64 includes the size of the GUID and size fields. */}}
\DoxyCodeLine{4000 \}}
\DoxyCodeLine{4001 }
\DoxyCodeLine{4002 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_data\_chunk\_size\_w64(drwav\_uint64 dataChunkSize)}
\DoxyCodeLine{4003 \{}
\DoxyCodeLine{4004     \textcolor{keywordflow}{return} 24 + dataChunkSize;        \textcolor{comment}{/* +24 because W64 includes the size of the GUID and size fields. */}}
\DoxyCodeLine{4005 \}}
\DoxyCodeLine{4006 }
\DoxyCodeLine{4007 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_riff\_chunk\_size\_rf64(drwav\_uint64 dataChunkSize, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}} *metadata, drwav\_uint32 numMetadata)}
\DoxyCodeLine{4008 \{}
\DoxyCodeLine{4009     drwav\_uint64 chunkSize = 4 + 36 + 24 + (drwav\_uint64)drwav\_\_write\_or\_count\_metadata(NULL, metadata, numMetadata) + 8 + dataChunkSize + drwav\_\_chunk\_padding\_size\_riff(dataChunkSize); \textcolor{comment}{/* 4 = "{}WAVE"{}. 36 = "{}ds64"{} chunk. 24 = "{}fmt "{} chunk. 8 = "{}data"{} + u32 data size. */}}
\DoxyCodeLine{4010     \textcolor{keywordflow}{if} (chunkSize > 0xFFFFFFFFUL) \{}
\DoxyCodeLine{4011         chunkSize = 0xFFFFFFFFUL;}
\DoxyCodeLine{4012     \}}
\DoxyCodeLine{4013 }
\DoxyCodeLine{4014     \textcolor{keywordflow}{return} chunkSize;}
\DoxyCodeLine{4015 \}}
\DoxyCodeLine{4016 }
\DoxyCodeLine{4017 DRWAV\_PRIVATE drwav\_uint64 drwav\_\_data\_chunk\_size\_rf64(drwav\_uint64 dataChunkSize)}
\DoxyCodeLine{4018 \{}
\DoxyCodeLine{4019     \textcolor{keywordflow}{return} dataChunkSize;}
\DoxyCodeLine{4020 \}}
\DoxyCodeLine{4021 }
\DoxyCodeLine{4022 }
\DoxyCodeLine{4023 }
\DoxyCodeLine{4024 DRWAV\_PRIVATE drwav\_bool32 drwav\_preinit\_write(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_bool32 isSequential, drwav\_write\_proc onWrite, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4025 \{}
\DoxyCodeLine{4026     \textcolor{keywordflow}{if} (pWav == NULL || onWrite == NULL) \{}
\DoxyCodeLine{4027         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4028     \}}
\DoxyCodeLine{4029 }
\DoxyCodeLine{4030     \textcolor{keywordflow}{if} (!isSequential \&\& onSeek == NULL) \{}
\DoxyCodeLine{4031         \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* <-\/-\/ onSeek is required when in non-\/sequential mode. */}}
\DoxyCodeLine{4032     \}}
\DoxyCodeLine{4033 }
\DoxyCodeLine{4034     \textcolor{comment}{/* Not currently supporting compressed formats. Will need to add support for the "{}fact"{} chunk before we enable this. */}}
\DoxyCodeLine{4035     \textcolor{keywordflow}{if} (pFormat-\/>format == DR\_WAVE\_FORMAT\_EXTENSIBLE) \{}
\DoxyCodeLine{4036         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4037     \}}
\DoxyCodeLine{4038     \textcolor{keywordflow}{if} (pFormat-\/>format == DR\_WAVE\_FORMAT\_ADPCM || pFormat-\/>format == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{4039         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4040     \}}
\DoxyCodeLine{4041 }
\DoxyCodeLine{4042     DRWAV\_ZERO\_MEMORY(pWav, \textcolor{keyword}{sizeof}(*pWav));}
\DoxyCodeLine{4043     pWav-\/>onWrite   = onWrite;}
\DoxyCodeLine{4044     pWav-\/>onSeek    = onSeek;}
\DoxyCodeLine{4045     pWav-\/>pUserData = pUserData;}
\DoxyCodeLine{4046     pWav-\/>allocationCallbacks = drwav\_copy\_allocation\_callbacks\_or\_defaults(pAllocationCallbacks);}
\DoxyCodeLine{4047 }
\DoxyCodeLine{4048     \textcolor{keywordflow}{if} (pWav-\/>allocationCallbacks.onFree == NULL || (pWav-\/>allocationCallbacks.onMalloc == NULL \&\& pWav-\/>allocationCallbacks.onRealloc == NULL)) \{}
\DoxyCodeLine{4049         \textcolor{keywordflow}{return} DRWAV\_FALSE;    \textcolor{comment}{/* Invalid allocation callbacks. */}}
\DoxyCodeLine{4050     \}}
\DoxyCodeLine{4051 }
\DoxyCodeLine{4052     pWav-\/>fmt.formatTag = (drwav\_uint16)pFormat-\/>format;}
\DoxyCodeLine{4053     pWav-\/>fmt.channels = (drwav\_uint16)pFormat-\/>channels;}
\DoxyCodeLine{4054     pWav-\/>fmt.sampleRate = pFormat-\/>sampleRate;}
\DoxyCodeLine{4055     pWav-\/>fmt.avgBytesPerSec = (drwav\_uint32)((pFormat-\/>bitsPerSample * pFormat-\/>sampleRate * pFormat-\/>channels) / 8);}
\DoxyCodeLine{4056     pWav-\/>fmt.blockAlign = (drwav\_uint16)((pFormat-\/>channels * pFormat-\/>bitsPerSample) / 8);}
\DoxyCodeLine{4057     pWav-\/>fmt.bitsPerSample = (drwav\_uint16)pFormat-\/>bitsPerSample;}
\DoxyCodeLine{4058     pWav-\/>fmt.extendedSize = 0;}
\DoxyCodeLine{4059     pWav-\/>isSequentialWrite = isSequential;}
\DoxyCodeLine{4060 }
\DoxyCodeLine{4061     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{4062 \}}
\DoxyCodeLine{4063 }
\DoxyCodeLine{4064 }
\DoxyCodeLine{4065 DRWAV\_PRIVATE drwav\_bool32 drwav\_init\_write\_\_internal(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount)}
\DoxyCodeLine{4066 \{}
\DoxyCodeLine{4067     \textcolor{comment}{/* The function assumes drwav\_preinit\_write() was called beforehand. */}}
\DoxyCodeLine{4068 }
\DoxyCodeLine{4069     \textcolor{keywordtype}{size\_t} runningPos = 0;}
\DoxyCodeLine{4070     drwav\_uint64 initialDataChunkSize = 0;}
\DoxyCodeLine{4071     drwav\_uint64 chunkSizeFMT;}
\DoxyCodeLine{4072 }
\DoxyCodeLine{4073     \textcolor{comment}{/*}}
\DoxyCodeLine{4074 \textcolor{comment}{    The initial values for the "{}RIFF"{} and "{}data"{} chunks depends on whether or not we are initializing in sequential mode or not. In}}
\DoxyCodeLine{4075 \textcolor{comment}{    sequential mode we set this to its final values straight away since they can be calculated from the total sample count. In non-\/}}
\DoxyCodeLine{4076 \textcolor{comment}{    sequential mode we initialize it all to zero and fill it out in drwav\_uninit() using a backwards seek.}}
\DoxyCodeLine{4077 \textcolor{comment}{    */}}
\DoxyCodeLine{4078     \textcolor{keywordflow}{if} (pWav-\/>isSequentialWrite) \{}
\DoxyCodeLine{4079         initialDataChunkSize = (totalSampleCount * pWav-\/>fmt.bitsPerSample) / 8;}
\DoxyCodeLine{4080 }
\DoxyCodeLine{4081         \textcolor{comment}{/*}}
\DoxyCodeLine{4082 \textcolor{comment}{        The RIFF container has a limit on the number of samples. drwav is not allowing this. There's no practical limits for Wave64}}
\DoxyCodeLine{4083 \textcolor{comment}{        so for the sake of simplicity I'm not doing any validation for that.}}
\DoxyCodeLine{4084 \textcolor{comment}{        */}}
\DoxyCodeLine{4085         \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_riff) \{}
\DoxyCodeLine{4086             \textcolor{keywordflow}{if} (initialDataChunkSize > (0xFFFFFFFFUL -\/ 36)) \{}
\DoxyCodeLine{4087                 \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* Not enough room to store every sample. */}}
\DoxyCodeLine{4088             \}}
\DoxyCodeLine{4089         \}}
\DoxyCodeLine{4090     \}}
\DoxyCodeLine{4091 }
\DoxyCodeLine{4092     pWav-\/>dataChunkDataSizeTargetWrite = initialDataChunkSize;}
\DoxyCodeLine{4093 }
\DoxyCodeLine{4094 }
\DoxyCodeLine{4095     \textcolor{comment}{/* "{}RIFF"{} chunk. */}}
\DoxyCodeLine{4096     \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_riff) \{}
\DoxyCodeLine{4097         drwav\_uint32 chunkSizeRIFF = 28 + (drwav\_uint32)initialDataChunkSize;   \textcolor{comment}{/* +28 = "{}WAVE"{} + [sizeof "{}fmt "{} chunk] */}}
\DoxyCodeLine{4098         runningPos += drwav\_\_write(pWav, \textcolor{stringliteral}{"{}RIFF"{}}, 4);}
\DoxyCodeLine{4099         runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, chunkSizeRIFF);}
\DoxyCodeLine{4100         runningPos += drwav\_\_write(pWav, \textcolor{stringliteral}{"{}WAVE"{}}, 4);}
\DoxyCodeLine{4101     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_w64) \{}
\DoxyCodeLine{4102         drwav\_uint64 chunkSizeRIFF = 80 + 24 + initialDataChunkSize;            \textcolor{comment}{/* +24 because W64 includes the size of the GUID and size fields. */}}
\DoxyCodeLine{4103         runningPos += drwav\_\_write(pWav, drwavGUID\_W64\_RIFF, 16);}
\DoxyCodeLine{4104         runningPos += drwav\_\_write\_u64ne\_to\_le(pWav, chunkSizeRIFF);}
\DoxyCodeLine{4105         runningPos += drwav\_\_write(pWav, drwavGUID\_W64\_WAVE, 16);}
\DoxyCodeLine{4106     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{4107         runningPos += drwav\_\_write(pWav, \textcolor{stringliteral}{"{}RF64"{}}, 4);}
\DoxyCodeLine{4108         runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, 0xFFFFFFFF);               \textcolor{comment}{/* Always 0xFFFFFFFF for RF64. Set to a proper value in the "{}ds64"{} chunk. */}}
\DoxyCodeLine{4109         runningPos += drwav\_\_write(pWav, \textcolor{stringliteral}{"{}WAVE"{}}, 4);}
\DoxyCodeLine{4110     \}}
\DoxyCodeLine{4111 }
\DoxyCodeLine{4112 }
\DoxyCodeLine{4113     \textcolor{comment}{/* "{}ds64"{} chunk (RF64 only). */}}
\DoxyCodeLine{4114     \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{4115         drwav\_uint32 initialds64ChunkSize = 28;                                 \textcolor{comment}{/* 28 = [Size of RIFF (8 bytes)] + [Size of DATA (8 bytes)] + [Sample Count (8 bytes)] + [Table Length (4 bytes)]. Table length always set to 0. */}}
\DoxyCodeLine{4116         drwav\_uint64 initialRiffChunkSize = 8 + initialds64ChunkSize + initialDataChunkSize;    \textcolor{comment}{/* +8 for the ds64 header. */}}
\DoxyCodeLine{4117 }
\DoxyCodeLine{4118         runningPos += drwav\_\_write(pWav, \textcolor{stringliteral}{"{}ds64"{}}, 4);}
\DoxyCodeLine{4119         runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, initialds64ChunkSize);     \textcolor{comment}{/* Size of ds64. */}}
\DoxyCodeLine{4120         runningPos += drwav\_\_write\_u64ne\_to\_le(pWav, initialRiffChunkSize);     \textcolor{comment}{/* Size of RIFF. Set to true value at the end. */}}
\DoxyCodeLine{4121         runningPos += drwav\_\_write\_u64ne\_to\_le(pWav, initialDataChunkSize);     \textcolor{comment}{/* Size of DATA. Set to true value at the end. */}}
\DoxyCodeLine{4122         runningPos += drwav\_\_write\_u64ne\_to\_le(pWav, totalSampleCount);         \textcolor{comment}{/* Sample count. */}}
\DoxyCodeLine{4123         runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, 0);                        \textcolor{comment}{/* Table length. Always set to zero in our case since we're not doing any other chunks than "{}DATA"{}. */}}
\DoxyCodeLine{4124     \}}
\DoxyCodeLine{4125 }
\DoxyCodeLine{4126 }
\DoxyCodeLine{4127     \textcolor{comment}{/* "{}fmt "{} chunk. */}}
\DoxyCodeLine{4128     \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_riff || pFormat-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{4129         chunkSizeFMT = 16;}
\DoxyCodeLine{4130         runningPos += drwav\_\_write(pWav, \textcolor{stringliteral}{"{}fmt "{}}, 4);}
\DoxyCodeLine{4131         runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, (drwav\_uint32)chunkSizeFMT);}
\DoxyCodeLine{4132     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_w64) \{}
\DoxyCodeLine{4133         chunkSizeFMT = 40;}
\DoxyCodeLine{4134         runningPos += drwav\_\_write(pWav, drwavGUID\_W64\_FMT, 16);}
\DoxyCodeLine{4135         runningPos += drwav\_\_write\_u64ne\_to\_le(pWav, chunkSizeFMT);}
\DoxyCodeLine{4136     \}}
\DoxyCodeLine{4137 }
\DoxyCodeLine{4138     runningPos += drwav\_\_write\_u16ne\_to\_le(pWav, pWav-\/>fmt.formatTag);}
\DoxyCodeLine{4139     runningPos += drwav\_\_write\_u16ne\_to\_le(pWav, pWav-\/>fmt.channels);}
\DoxyCodeLine{4140     runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, pWav-\/>fmt.sampleRate);}
\DoxyCodeLine{4141     runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, pWav-\/>fmt.avgBytesPerSec);}
\DoxyCodeLine{4142     runningPos += drwav\_\_write\_u16ne\_to\_le(pWav, pWav-\/>fmt.blockAlign);}
\DoxyCodeLine{4143     runningPos += drwav\_\_write\_u16ne\_to\_le(pWav, pWav-\/>fmt.bitsPerSample);}
\DoxyCodeLine{4144 }
\DoxyCodeLine{4145     \textcolor{comment}{/* TODO: is a 'fact' chunk required for DR\_WAVE\_FORMAT\_IEEE\_FLOAT? */}}
\DoxyCodeLine{4146 }
\DoxyCodeLine{4147     \textcolor{keywordflow}{if} (!pWav-\/>isSequentialWrite \&\& pWav-\/>pMetadata != NULL \&\& pWav-\/>metadataCount > 0 \&\& (pFormat-\/>container == drwav\_container\_riff || pFormat-\/>container == drwav\_container\_rf64)) \{}
\DoxyCodeLine{4148         runningPos += drwav\_\_write\_or\_count\_metadata(pWav, pWav-\/>pMetadata, pWav-\/>metadataCount);}
\DoxyCodeLine{4149     \}}
\DoxyCodeLine{4150 }
\DoxyCodeLine{4151     pWav-\/>dataChunkDataPos = runningPos;}
\DoxyCodeLine{4152 }
\DoxyCodeLine{4153     \textcolor{comment}{/* "{}data"{} chunk. */}}
\DoxyCodeLine{4154     \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_riff) \{}
\DoxyCodeLine{4155         drwav\_uint32 chunkSizeDATA = (drwav\_uint32)initialDataChunkSize;}
\DoxyCodeLine{4156         runningPos += drwav\_\_write(pWav, \textcolor{stringliteral}{"{}data"{}}, 4);}
\DoxyCodeLine{4157         runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, chunkSizeDATA);}
\DoxyCodeLine{4158     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_w64) \{}
\DoxyCodeLine{4159         drwav\_uint64 chunkSizeDATA = 24 + initialDataChunkSize;     \textcolor{comment}{/* +24 because W64 includes the size of the GUID and size fields. */}}
\DoxyCodeLine{4160         runningPos += drwav\_\_write(pWav, drwavGUID\_W64\_DATA, 16);}
\DoxyCodeLine{4161         runningPos += drwav\_\_write\_u64ne\_to\_le(pWav, chunkSizeDATA);}
\DoxyCodeLine{4162     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{4163         runningPos += drwav\_\_write(pWav, \textcolor{stringliteral}{"{}data"{}}, 4);}
\DoxyCodeLine{4164         runningPos += drwav\_\_write\_u32ne\_to\_le(pWav, 0xFFFFFFFF);   \textcolor{comment}{/* Always set to 0xFFFFFFFF for RF64. The true size of the data chunk is specified in the ds64 chunk. */}}
\DoxyCodeLine{4165     \}}
\DoxyCodeLine{4166 }
\DoxyCodeLine{4167     \textcolor{comment}{/* Set some properties for the client's convenience. */}}
\DoxyCodeLine{4168     pWav-\/>container = pFormat-\/>container;}
\DoxyCodeLine{4169     pWav-\/>channels = (drwav\_uint16)pFormat-\/>channels;}
\DoxyCodeLine{4170     pWav-\/>sampleRate = pFormat-\/>sampleRate;}
\DoxyCodeLine{4171     pWav-\/>bitsPerSample = (drwav\_uint16)pFormat-\/>bitsPerSample;}
\DoxyCodeLine{4172     pWav-\/>translatedFormatTag = (drwav\_uint16)pFormat-\/>format;}
\DoxyCodeLine{4173     pWav-\/>dataChunkDataPos = runningPos;}
\DoxyCodeLine{4174 }
\DoxyCodeLine{4175     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{4176 \}}
\DoxyCodeLine{4177 }
\DoxyCodeLine{4178 }
\DoxyCodeLine{4179 DRWAV\_API drwav\_bool32 drwav\_init\_write(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_write\_proc onWrite, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4180 \{}
\DoxyCodeLine{4181     \textcolor{keywordflow}{if} (!drwav\_preinit\_write(pWav, pFormat, DRWAV\_FALSE, onWrite, onSeek, pUserData, pAllocationCallbacks)) \{}
\DoxyCodeLine{4182         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4183     \}}
\DoxyCodeLine{4184 }
\DoxyCodeLine{4185     \textcolor{keywordflow}{return} drwav\_init\_write\_\_internal(pWav, pFormat, 0);               \textcolor{comment}{/* DRWAV\_FALSE = Not Sequential */}}
\DoxyCodeLine{4186 \}}
\DoxyCodeLine{4187 }
\DoxyCodeLine{4188 DRWAV\_API drwav\_bool32 drwav\_init\_write\_sequential(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, drwav\_write\_proc onWrite, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4189 \{}
\DoxyCodeLine{4190     \textcolor{keywordflow}{if} (!drwav\_preinit\_write(pWav, pFormat, DRWAV\_TRUE, onWrite, NULL, pUserData, pAllocationCallbacks)) \{}
\DoxyCodeLine{4191         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4192     \}}
\DoxyCodeLine{4193 }
\DoxyCodeLine{4194     \textcolor{keywordflow}{return} drwav\_init\_write\_\_internal(pWav, pFormat, totalSampleCount); \textcolor{comment}{/* DRWAV\_TRUE = Sequential */}}
\DoxyCodeLine{4195 \}}
\DoxyCodeLine{4196 }
\DoxyCodeLine{4197 DRWAV\_API drwav\_bool32 drwav\_init\_write\_sequential\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalPCMFrameCount, drwav\_write\_proc onWrite, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4198 \{}
\DoxyCodeLine{4199     \textcolor{keywordflow}{if} (pFormat == NULL) \{}
\DoxyCodeLine{4200         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4201     \}}
\DoxyCodeLine{4202 }
\DoxyCodeLine{4203     \textcolor{keywordflow}{return} drwav\_init\_write\_sequential(pWav, pFormat, totalPCMFrameCount*pFormat-\/>channels, onWrite, pUserData, pAllocationCallbacks);}
\DoxyCodeLine{4204 \}}
\DoxyCodeLine{4205 }
\DoxyCodeLine{4206 DRWAV\_API drwav\_bool32 drwav\_init\_write\_with\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_write\_proc onWrite, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata, drwav\_uint32 metadataCount)}
\DoxyCodeLine{4207 \{}
\DoxyCodeLine{4208     \textcolor{keywordflow}{if} (!drwav\_preinit\_write(pWav, pFormat, DRWAV\_FALSE, onWrite, onSeek, pUserData, pAllocationCallbacks)) \{}
\DoxyCodeLine{4209         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4210     \}}
\DoxyCodeLine{4211 }
\DoxyCodeLine{4212     pWav-\/>pMetadata     = pMetadata;}
\DoxyCodeLine{4213     pWav-\/>metadataCount = metadataCount;}
\DoxyCodeLine{4214 }
\DoxyCodeLine{4215     \textcolor{keywordflow}{return} drwav\_init\_write\_\_internal(pWav, pFormat, 0);}
\DoxyCodeLine{4216 \}}
\DoxyCodeLine{4217 }
\DoxyCodeLine{4218 }
\DoxyCodeLine{4219 DRWAV\_API drwav\_uint64 drwav\_target\_write\_size\_bytes(\textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalFrameCount, \mbox{\hyperlink{structdrwav__metadata}{drwav\_metadata}}* pMetadata, drwav\_uint32 metadataCount)}
\DoxyCodeLine{4220 \{}
\DoxyCodeLine{4221     \textcolor{comment}{/* Casting totalFrameCount to drwav\_int64 for VC6 compatibility. No issues in practice because nobody is going to exhaust the whole 63 bits. */}}
\DoxyCodeLine{4222     drwav\_uint64 targetDataSizeBytes = (drwav\_uint64)((drwav\_int64)totalFrameCount * pFormat-\/>channels * pFormat-\/>bitsPerSample/8.0);}
\DoxyCodeLine{4223     drwav\_uint64 riffChunkSizeBytes;}
\DoxyCodeLine{4224     drwav\_uint64 fileSizeBytes = 0;}
\DoxyCodeLine{4225 }
\DoxyCodeLine{4226     \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_riff) \{}
\DoxyCodeLine{4227         riffChunkSizeBytes = drwav\_\_riff\_chunk\_size\_riff(targetDataSizeBytes, pMetadata, metadataCount);}
\DoxyCodeLine{4228         fileSizeBytes = (8 + riffChunkSizeBytes);   \textcolor{comment}{/* +8 because WAV doesn't include the size of the ChunkID and ChunkSize fields. */}}
\DoxyCodeLine{4229     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_w64) \{}
\DoxyCodeLine{4230         riffChunkSizeBytes = drwav\_\_riff\_chunk\_size\_w64(targetDataSizeBytes);}
\DoxyCodeLine{4231         fileSizeBytes = riffChunkSizeBytes;}
\DoxyCodeLine{4232     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pFormat-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{4233         riffChunkSizeBytes = drwav\_\_riff\_chunk\_size\_rf64(targetDataSizeBytes, pMetadata, metadataCount);}
\DoxyCodeLine{4234         fileSizeBytes = (8 + riffChunkSizeBytes);   \textcolor{comment}{/* +8 because WAV doesn't include the size of the ChunkID and ChunkSize fields. */}}
\DoxyCodeLine{4235     \}}
\DoxyCodeLine{4236 }
\DoxyCodeLine{4237     \textcolor{keywordflow}{return} fileSizeBytes;}
\DoxyCodeLine{4238 \}}
\DoxyCodeLine{4239 }
\DoxyCodeLine{4240 }
\DoxyCodeLine{4241 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_STDIO}}
\DoxyCodeLine{4242 }
\DoxyCodeLine{4243 \textcolor{comment}{/* drwav\_result\_from\_errno() is only used for fopen() and wfopen() so putting it inside DR\_WAV\_NO\_STDIO for now. If something else needs this later we can move it out. */}}
\DoxyCodeLine{4244 \textcolor{preprocessor}{\#include <errno.h>}}
\DoxyCodeLine{4245 DRWAV\_PRIVATE drwav\_result drwav\_result\_from\_errno(\textcolor{keywordtype}{int} e)}
\DoxyCodeLine{4246 \{}
\DoxyCodeLine{4247     \textcolor{keywordflow}{switch} (e)}
\DoxyCodeLine{4248     \{}
\DoxyCodeLine{4249         \textcolor{keywordflow}{case} 0: \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{4250 \textcolor{preprocessor}{    \#ifdef EPERM}}
\DoxyCodeLine{4251         \textcolor{keywordflow}{case} EPERM: \textcolor{keywordflow}{return} DRWAV\_INVALID\_OPERATION;}
\DoxyCodeLine{4252 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4253 \textcolor{preprocessor}{    \#ifdef ENOENT}}
\DoxyCodeLine{4254         \textcolor{keywordflow}{case} ENOENT: \textcolor{keywordflow}{return} DRWAV\_DOES\_NOT\_EXIST;}
\DoxyCodeLine{4255 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4256 \textcolor{preprocessor}{    \#ifdef ESRCH}}
\DoxyCodeLine{4257         \textcolor{keywordflow}{case} ESRCH: \textcolor{keywordflow}{return} DRWAV\_DOES\_NOT\_EXIST;}
\DoxyCodeLine{4258 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4259 \textcolor{preprocessor}{    \#ifdef EINTR}}
\DoxyCodeLine{4260         \textcolor{keywordflow}{case} EINTR: \textcolor{keywordflow}{return} DRWAV\_INTERRUPT;}
\DoxyCodeLine{4261 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4262 \textcolor{preprocessor}{    \#ifdef EIO}}
\DoxyCodeLine{4263         \textcolor{keywordflow}{case} EIO: \textcolor{keywordflow}{return} DRWAV\_IO\_ERROR;}
\DoxyCodeLine{4264 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4265 \textcolor{preprocessor}{    \#ifdef ENXIO}}
\DoxyCodeLine{4266         \textcolor{keywordflow}{case} ENXIO: \textcolor{keywordflow}{return} DRWAV\_DOES\_NOT\_EXIST;}
\DoxyCodeLine{4267 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4268 \textcolor{preprocessor}{    \#ifdef E2BIG}}
\DoxyCodeLine{4269         \textcolor{keywordflow}{case} E2BIG: \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{4270 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4271 \textcolor{preprocessor}{    \#ifdef ENOEXEC}}
\DoxyCodeLine{4272         \textcolor{keywordflow}{case} ENOEXEC: \textcolor{keywordflow}{return} DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{4273 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4274 \textcolor{preprocessor}{    \#ifdef EBADF}}
\DoxyCodeLine{4275         \textcolor{keywordflow}{case} EBADF: \textcolor{keywordflow}{return} DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{4276 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4277 \textcolor{preprocessor}{    \#ifdef ECHILD}}
\DoxyCodeLine{4278         \textcolor{keywordflow}{case} ECHILD: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4279 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4280 \textcolor{preprocessor}{    \#ifdef EAGAIN}}
\DoxyCodeLine{4281         \textcolor{keywordflow}{case} EAGAIN: \textcolor{keywordflow}{return} DRWAV\_UNAVAILABLE;}
\DoxyCodeLine{4282 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4283 \textcolor{preprocessor}{    \#ifdef ENOMEM}}
\DoxyCodeLine{4284         \textcolor{keywordflow}{case} ENOMEM: \textcolor{keywordflow}{return} DRWAV\_OUT\_OF\_MEMORY;}
\DoxyCodeLine{4285 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4286 \textcolor{preprocessor}{    \#ifdef EACCES}}
\DoxyCodeLine{4287         \textcolor{keywordflow}{case} EACCES: \textcolor{keywordflow}{return} DRWAV\_ACCESS\_DENIED;}
\DoxyCodeLine{4288 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4289 \textcolor{preprocessor}{    \#ifdef EFAULT}}
\DoxyCodeLine{4290         \textcolor{keywordflow}{case} EFAULT: \textcolor{keywordflow}{return} DRWAV\_BAD\_ADDRESS;}
\DoxyCodeLine{4291 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4292 \textcolor{preprocessor}{    \#ifdef ENOTBLK}}
\DoxyCodeLine{4293         \textcolor{keywordflow}{case} ENOTBLK: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4294 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4295 \textcolor{preprocessor}{    \#ifdef EBUSY}}
\DoxyCodeLine{4296         \textcolor{keywordflow}{case} EBUSY: \textcolor{keywordflow}{return} DRWAV\_BUSY;}
\DoxyCodeLine{4297 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4298 \textcolor{preprocessor}{    \#ifdef EEXIST}}
\DoxyCodeLine{4299         \textcolor{keywordflow}{case} EEXIST: \textcolor{keywordflow}{return} DRWAV\_ALREADY\_EXISTS;}
\DoxyCodeLine{4300 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4301 \textcolor{preprocessor}{    \#ifdef EXDEV}}
\DoxyCodeLine{4302         \textcolor{keywordflow}{case} EXDEV: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4303 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4304 \textcolor{preprocessor}{    \#ifdef ENODEV}}
\DoxyCodeLine{4305         \textcolor{keywordflow}{case} ENODEV: \textcolor{keywordflow}{return} DRWAV\_DOES\_NOT\_EXIST;}
\DoxyCodeLine{4306 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4307 \textcolor{preprocessor}{    \#ifdef ENOTDIR}}
\DoxyCodeLine{4308         \textcolor{keywordflow}{case} ENOTDIR: \textcolor{keywordflow}{return} DRWAV\_NOT\_DIRECTORY;}
\DoxyCodeLine{4309 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4310 \textcolor{preprocessor}{    \#ifdef EISDIR}}
\DoxyCodeLine{4311         \textcolor{keywordflow}{case} EISDIR: \textcolor{keywordflow}{return} DRWAV\_IS\_DIRECTORY;}
\DoxyCodeLine{4312 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4313 \textcolor{preprocessor}{    \#ifdef EINVAL}}
\DoxyCodeLine{4314         \textcolor{keywordflow}{case} EINVAL: \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{4315 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4316 \textcolor{preprocessor}{    \#ifdef ENFILE}}
\DoxyCodeLine{4317         \textcolor{keywordflow}{case} ENFILE: \textcolor{keywordflow}{return} DRWAV\_TOO\_MANY\_OPEN\_FILES;}
\DoxyCodeLine{4318 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4319 \textcolor{preprocessor}{    \#ifdef EMFILE}}
\DoxyCodeLine{4320         \textcolor{keywordflow}{case} EMFILE: \textcolor{keywordflow}{return} DRWAV\_TOO\_MANY\_OPEN\_FILES;}
\DoxyCodeLine{4321 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4322 \textcolor{preprocessor}{    \#ifdef ENOTTY}}
\DoxyCodeLine{4323         \textcolor{keywordflow}{case} ENOTTY: \textcolor{keywordflow}{return} DRWAV\_INVALID\_OPERATION;}
\DoxyCodeLine{4324 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4325 \textcolor{preprocessor}{    \#ifdef ETXTBSY}}
\DoxyCodeLine{4326         \textcolor{keywordflow}{case} ETXTBSY: \textcolor{keywordflow}{return} DRWAV\_BUSY;}
\DoxyCodeLine{4327 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4328 \textcolor{preprocessor}{    \#ifdef EFBIG}}
\DoxyCodeLine{4329         \textcolor{keywordflow}{case} EFBIG: \textcolor{keywordflow}{return} DRWAV\_TOO\_BIG;}
\DoxyCodeLine{4330 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4331 \textcolor{preprocessor}{    \#ifdef ENOSPC}}
\DoxyCodeLine{4332         \textcolor{keywordflow}{case} ENOSPC: \textcolor{keywordflow}{return} DRWAV\_NO\_SPACE;}
\DoxyCodeLine{4333 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4334 \textcolor{preprocessor}{    \#ifdef ESPIPE}}
\DoxyCodeLine{4335         \textcolor{keywordflow}{case} ESPIPE: \textcolor{keywordflow}{return} DRWAV\_BAD\_SEEK;}
\DoxyCodeLine{4336 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4337 \textcolor{preprocessor}{    \#ifdef EROFS}}
\DoxyCodeLine{4338         \textcolor{keywordflow}{case} EROFS: \textcolor{keywordflow}{return} DRWAV\_ACCESS\_DENIED;}
\DoxyCodeLine{4339 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4340 \textcolor{preprocessor}{    \#ifdef EMLINK}}
\DoxyCodeLine{4341         \textcolor{keywordflow}{case} EMLINK: \textcolor{keywordflow}{return} DRWAV\_TOO\_MANY\_LINKS;}
\DoxyCodeLine{4342 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4343 \textcolor{preprocessor}{    \#ifdef EPIPE}}
\DoxyCodeLine{4344         \textcolor{keywordflow}{case} EPIPE: \textcolor{keywordflow}{return} DRWAV\_BAD\_PIPE;}
\DoxyCodeLine{4345 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4346 \textcolor{preprocessor}{    \#ifdef EDOM}}
\DoxyCodeLine{4347         \textcolor{keywordflow}{case} EDOM: \textcolor{keywordflow}{return} DRWAV\_OUT\_OF\_RANGE;}
\DoxyCodeLine{4348 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4349 \textcolor{preprocessor}{    \#ifdef ERANGE}}
\DoxyCodeLine{4350         \textcolor{keywordflow}{case} ERANGE: \textcolor{keywordflow}{return} DRWAV\_OUT\_OF\_RANGE;}
\DoxyCodeLine{4351 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4352 \textcolor{preprocessor}{    \#ifdef EDEADLK}}
\DoxyCodeLine{4353         \textcolor{keywordflow}{case} EDEADLK: \textcolor{keywordflow}{return} DRWAV\_DEADLOCK;}
\DoxyCodeLine{4354 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4355 \textcolor{preprocessor}{    \#ifdef ENAMETOOLONG}}
\DoxyCodeLine{4356         \textcolor{keywordflow}{case} ENAMETOOLONG: \textcolor{keywordflow}{return} DRWAV\_PATH\_TOO\_LONG;}
\DoxyCodeLine{4357 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4358 \textcolor{preprocessor}{    \#ifdef ENOLCK}}
\DoxyCodeLine{4359         \textcolor{keywordflow}{case} ENOLCK: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4360 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4361 \textcolor{preprocessor}{    \#ifdef ENOSYS}}
\DoxyCodeLine{4362         \textcolor{keywordflow}{case} ENOSYS: \textcolor{keywordflow}{return} DRWAV\_NOT\_IMPLEMENTED;}
\DoxyCodeLine{4363 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4364 \textcolor{preprocessor}{    \#ifdef ENOTEMPTY}}
\DoxyCodeLine{4365         \textcolor{keywordflow}{case} ENOTEMPTY: \textcolor{keywordflow}{return} DRWAV\_DIRECTORY\_NOT\_EMPTY;}
\DoxyCodeLine{4366 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4367 \textcolor{preprocessor}{    \#ifdef ELOOP}}
\DoxyCodeLine{4368         \textcolor{keywordflow}{case} ELOOP: \textcolor{keywordflow}{return} DRWAV\_TOO\_MANY\_LINKS;}
\DoxyCodeLine{4369 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4370 \textcolor{preprocessor}{    \#ifdef ENOMSG}}
\DoxyCodeLine{4371         \textcolor{keywordflow}{case} ENOMSG: \textcolor{keywordflow}{return} DRWAV\_NO\_MESSAGE;}
\DoxyCodeLine{4372 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4373 \textcolor{preprocessor}{    \#ifdef EIDRM}}
\DoxyCodeLine{4374         \textcolor{keywordflow}{case} EIDRM: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4375 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4376 \textcolor{preprocessor}{    \#ifdef ECHRNG}}
\DoxyCodeLine{4377         \textcolor{keywordflow}{case} ECHRNG: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4378 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4379 \textcolor{preprocessor}{    \#ifdef EL2NSYNC}}
\DoxyCodeLine{4380         \textcolor{keywordflow}{case} EL2NSYNC: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4381 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4382 \textcolor{preprocessor}{    \#ifdef EL3HLT}}
\DoxyCodeLine{4383         \textcolor{keywordflow}{case} EL3HLT: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4384 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4385 \textcolor{preprocessor}{    \#ifdef EL3RST}}
\DoxyCodeLine{4386         \textcolor{keywordflow}{case} EL3RST: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4387 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4388 \textcolor{preprocessor}{    \#ifdef ELNRNG}}
\DoxyCodeLine{4389         \textcolor{keywordflow}{case} ELNRNG: \textcolor{keywordflow}{return} DRWAV\_OUT\_OF\_RANGE;}
\DoxyCodeLine{4390 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4391 \textcolor{preprocessor}{    \#ifdef EUNATCH}}
\DoxyCodeLine{4392         \textcolor{keywordflow}{case} EUNATCH: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4393 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4394 \textcolor{preprocessor}{    \#ifdef ENOCSI}}
\DoxyCodeLine{4395         \textcolor{keywordflow}{case} ENOCSI: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4396 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4397 \textcolor{preprocessor}{    \#ifdef EL2HLT}}
\DoxyCodeLine{4398         \textcolor{keywordflow}{case} EL2HLT: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4399 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4400 \textcolor{preprocessor}{    \#ifdef EBADE}}
\DoxyCodeLine{4401         \textcolor{keywordflow}{case} EBADE: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4402 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4403 \textcolor{preprocessor}{    \#ifdef EBADR}}
\DoxyCodeLine{4404         \textcolor{keywordflow}{case} EBADR: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4405 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4406 \textcolor{preprocessor}{    \#ifdef EXFULL}}
\DoxyCodeLine{4407         \textcolor{keywordflow}{case} EXFULL: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4408 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4409 \textcolor{preprocessor}{    \#ifdef ENOANO}}
\DoxyCodeLine{4410         \textcolor{keywordflow}{case} ENOANO: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4411 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4412 \textcolor{preprocessor}{    \#ifdef EBADRQC}}
\DoxyCodeLine{4413         \textcolor{keywordflow}{case} EBADRQC: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4414 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4415 \textcolor{preprocessor}{    \#ifdef EBADSLT}}
\DoxyCodeLine{4416         \textcolor{keywordflow}{case} EBADSLT: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4417 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4418 \textcolor{preprocessor}{    \#ifdef EBFONT}}
\DoxyCodeLine{4419         \textcolor{keywordflow}{case} EBFONT: \textcolor{keywordflow}{return} DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{4420 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4421 \textcolor{preprocessor}{    \#ifdef ENOSTR}}
\DoxyCodeLine{4422         \textcolor{keywordflow}{case} ENOSTR: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4423 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4424 \textcolor{preprocessor}{    \#ifdef ENODATA}}
\DoxyCodeLine{4425         \textcolor{keywordflow}{case} ENODATA: \textcolor{keywordflow}{return} DRWAV\_NO\_DATA\_AVAILABLE;}
\DoxyCodeLine{4426 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4427 \textcolor{preprocessor}{    \#ifdef ETIME}}
\DoxyCodeLine{4428         \textcolor{keywordflow}{case} ETIME: \textcolor{keywordflow}{return} DRWAV\_TIMEOUT;}
\DoxyCodeLine{4429 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4430 \textcolor{preprocessor}{    \#ifdef ENOSR}}
\DoxyCodeLine{4431         \textcolor{keywordflow}{case} ENOSR: \textcolor{keywordflow}{return} DRWAV\_NO\_DATA\_AVAILABLE;}
\DoxyCodeLine{4432 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4433 \textcolor{preprocessor}{    \#ifdef ENONET}}
\DoxyCodeLine{4434         \textcolor{keywordflow}{case} ENONET: \textcolor{keywordflow}{return} DRWAV\_NO\_NETWORK;}
\DoxyCodeLine{4435 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4436 \textcolor{preprocessor}{    \#ifdef ENOPKG}}
\DoxyCodeLine{4437         \textcolor{keywordflow}{case} ENOPKG: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4438 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4439 \textcolor{preprocessor}{    \#ifdef EREMOTE}}
\DoxyCodeLine{4440         \textcolor{keywordflow}{case} EREMOTE: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4441 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4442 \textcolor{preprocessor}{    \#ifdef ENOLINK}}
\DoxyCodeLine{4443         \textcolor{keywordflow}{case} ENOLINK: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4444 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4445 \textcolor{preprocessor}{    \#ifdef EADV}}
\DoxyCodeLine{4446         \textcolor{keywordflow}{case} EADV: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4447 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4448 \textcolor{preprocessor}{    \#ifdef ESRMNT}}
\DoxyCodeLine{4449         \textcolor{keywordflow}{case} ESRMNT: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4450 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4451 \textcolor{preprocessor}{    \#ifdef ECOMM}}
\DoxyCodeLine{4452         \textcolor{keywordflow}{case} ECOMM: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4453 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4454 \textcolor{preprocessor}{    \#ifdef EPROTO}}
\DoxyCodeLine{4455         \textcolor{keywordflow}{case} EPROTO: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4456 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4457 \textcolor{preprocessor}{    \#ifdef EMULTIHOP}}
\DoxyCodeLine{4458         \textcolor{keywordflow}{case} EMULTIHOP: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4459 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4460 \textcolor{preprocessor}{    \#ifdef EDOTDOT}}
\DoxyCodeLine{4461         \textcolor{keywordflow}{case} EDOTDOT: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4462 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4463 \textcolor{preprocessor}{    \#ifdef EBADMSG}}
\DoxyCodeLine{4464         \textcolor{keywordflow}{case} EBADMSG: \textcolor{keywordflow}{return} DRWAV\_BAD\_MESSAGE;}
\DoxyCodeLine{4465 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4466 \textcolor{preprocessor}{    \#ifdef EOVERFLOW}}
\DoxyCodeLine{4467         \textcolor{keywordflow}{case} EOVERFLOW: \textcolor{keywordflow}{return} DRWAV\_TOO\_BIG;}
\DoxyCodeLine{4468 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4469 \textcolor{preprocessor}{    \#ifdef ENOTUNIQ}}
\DoxyCodeLine{4470         \textcolor{keywordflow}{case} ENOTUNIQ: \textcolor{keywordflow}{return} DRWAV\_NOT\_UNIQUE;}
\DoxyCodeLine{4471 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4472 \textcolor{preprocessor}{    \#ifdef EBADFD}}
\DoxyCodeLine{4473         \textcolor{keywordflow}{case} EBADFD: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4474 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4475 \textcolor{preprocessor}{    \#ifdef EREMCHG}}
\DoxyCodeLine{4476         \textcolor{keywordflow}{case} EREMCHG: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4477 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4478 \textcolor{preprocessor}{    \#ifdef ELIBACC}}
\DoxyCodeLine{4479         \textcolor{keywordflow}{case} ELIBACC: \textcolor{keywordflow}{return} DRWAV\_ACCESS\_DENIED;}
\DoxyCodeLine{4480 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4481 \textcolor{preprocessor}{    \#ifdef ELIBBAD}}
\DoxyCodeLine{4482         \textcolor{keywordflow}{case} ELIBBAD: \textcolor{keywordflow}{return} DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{4483 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4484 \textcolor{preprocessor}{    \#ifdef ELIBSCN}}
\DoxyCodeLine{4485         \textcolor{keywordflow}{case} ELIBSCN: \textcolor{keywordflow}{return} DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{4486 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4487 \textcolor{preprocessor}{    \#ifdef ELIBMAX}}
\DoxyCodeLine{4488         \textcolor{keywordflow}{case} ELIBMAX: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4489 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4490 \textcolor{preprocessor}{    \#ifdef ELIBEXEC}}
\DoxyCodeLine{4491         \textcolor{keywordflow}{case} ELIBEXEC: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4492 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4493 \textcolor{preprocessor}{    \#ifdef EILSEQ}}
\DoxyCodeLine{4494         \textcolor{keywordflow}{case} EILSEQ: \textcolor{keywordflow}{return} DRWAV\_INVALID\_DATA;}
\DoxyCodeLine{4495 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4496 \textcolor{preprocessor}{    \#ifdef ERESTART}}
\DoxyCodeLine{4497         \textcolor{keywordflow}{case} ERESTART: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4498 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4499 \textcolor{preprocessor}{    \#ifdef ESTRPIPE}}
\DoxyCodeLine{4500         \textcolor{keywordflow}{case} ESTRPIPE: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4501 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4502 \textcolor{preprocessor}{    \#ifdef EUSERS}}
\DoxyCodeLine{4503         \textcolor{keywordflow}{case} EUSERS: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4504 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4505 \textcolor{preprocessor}{    \#ifdef ENOTSOCK}}
\DoxyCodeLine{4506         \textcolor{keywordflow}{case} ENOTSOCK: \textcolor{keywordflow}{return} DRWAV\_NOT\_SOCKET;}
\DoxyCodeLine{4507 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4508 \textcolor{preprocessor}{    \#ifdef EDESTADDRREQ}}
\DoxyCodeLine{4509         \textcolor{keywordflow}{case} EDESTADDRREQ: \textcolor{keywordflow}{return} DRWAV\_NO\_ADDRESS;}
\DoxyCodeLine{4510 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4511 \textcolor{preprocessor}{    \#ifdef EMSGSIZE}}
\DoxyCodeLine{4512         \textcolor{keywordflow}{case} EMSGSIZE: \textcolor{keywordflow}{return} DRWAV\_TOO\_BIG;}
\DoxyCodeLine{4513 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4514 \textcolor{preprocessor}{    \#ifdef EPROTOTYPE}}
\DoxyCodeLine{4515         \textcolor{keywordflow}{case} EPROTOTYPE: \textcolor{keywordflow}{return} DRWAV\_BAD\_PROTOCOL;}
\DoxyCodeLine{4516 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4517 \textcolor{preprocessor}{    \#ifdef ENOPROTOOPT}}
\DoxyCodeLine{4518         \textcolor{keywordflow}{case} ENOPROTOOPT: \textcolor{keywordflow}{return} DRWAV\_PROTOCOL\_UNAVAILABLE;}
\DoxyCodeLine{4519 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4520 \textcolor{preprocessor}{    \#ifdef EPROTONOSUPPORT}}
\DoxyCodeLine{4521         \textcolor{keywordflow}{case} EPROTONOSUPPORT: \textcolor{keywordflow}{return} DRWAV\_PROTOCOL\_NOT\_SUPPORTED;}
\DoxyCodeLine{4522 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4523 \textcolor{preprocessor}{    \#ifdef ESOCKTNOSUPPORT}}
\DoxyCodeLine{4524         \textcolor{keywordflow}{case} ESOCKTNOSUPPORT: \textcolor{keywordflow}{return} DRWAV\_SOCKET\_NOT\_SUPPORTED;}
\DoxyCodeLine{4525 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4526 \textcolor{preprocessor}{    \#ifdef EOPNOTSUPP}}
\DoxyCodeLine{4527         \textcolor{keywordflow}{case} EOPNOTSUPP: \textcolor{keywordflow}{return} DRWAV\_INVALID\_OPERATION;}
\DoxyCodeLine{4528 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4529 \textcolor{preprocessor}{    \#ifdef EPFNOSUPPORT}}
\DoxyCodeLine{4530         \textcolor{keywordflow}{case} EPFNOSUPPORT: \textcolor{keywordflow}{return} DRWAV\_PROTOCOL\_FAMILY\_NOT\_SUPPORTED;}
\DoxyCodeLine{4531 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4532 \textcolor{preprocessor}{    \#ifdef EAFNOSUPPORT}}
\DoxyCodeLine{4533         \textcolor{keywordflow}{case} EAFNOSUPPORT: \textcolor{keywordflow}{return} DRWAV\_ADDRESS\_FAMILY\_NOT\_SUPPORTED;}
\DoxyCodeLine{4534 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4535 \textcolor{preprocessor}{    \#ifdef EADDRINUSE}}
\DoxyCodeLine{4536         \textcolor{keywordflow}{case} EADDRINUSE: \textcolor{keywordflow}{return} DRWAV\_ALREADY\_IN\_USE;}
\DoxyCodeLine{4537 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4538 \textcolor{preprocessor}{    \#ifdef EADDRNOTAVAIL}}
\DoxyCodeLine{4539         \textcolor{keywordflow}{case} EADDRNOTAVAIL: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4540 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4541 \textcolor{preprocessor}{    \#ifdef ENETDOWN}}
\DoxyCodeLine{4542         \textcolor{keywordflow}{case} ENETDOWN: \textcolor{keywordflow}{return} DRWAV\_NO\_NETWORK;}
\DoxyCodeLine{4543 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4544 \textcolor{preprocessor}{    \#ifdef ENETUNREACH}}
\DoxyCodeLine{4545         \textcolor{keywordflow}{case} ENETUNREACH: \textcolor{keywordflow}{return} DRWAV\_NO\_NETWORK;}
\DoxyCodeLine{4546 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4547 \textcolor{preprocessor}{    \#ifdef ENETRESET}}
\DoxyCodeLine{4548         \textcolor{keywordflow}{case} ENETRESET: \textcolor{keywordflow}{return} DRWAV\_NO\_NETWORK;}
\DoxyCodeLine{4549 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4550 \textcolor{preprocessor}{    \#ifdef ECONNABORTED}}
\DoxyCodeLine{4551         \textcolor{keywordflow}{case} ECONNABORTED: \textcolor{keywordflow}{return} DRWAV\_NO\_NETWORK;}
\DoxyCodeLine{4552 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4553 \textcolor{preprocessor}{    \#ifdef ECONNRESET}}
\DoxyCodeLine{4554         \textcolor{keywordflow}{case} ECONNRESET: \textcolor{keywordflow}{return} DRWAV\_CONNECTION\_RESET;}
\DoxyCodeLine{4555 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4556 \textcolor{preprocessor}{    \#ifdef ENOBUFS}}
\DoxyCodeLine{4557         \textcolor{keywordflow}{case} ENOBUFS: \textcolor{keywordflow}{return} DRWAV\_NO\_SPACE;}
\DoxyCodeLine{4558 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4559 \textcolor{preprocessor}{    \#ifdef EISCONN}}
\DoxyCodeLine{4560         \textcolor{keywordflow}{case} EISCONN: \textcolor{keywordflow}{return} DRWAV\_ALREADY\_CONNECTED;}
\DoxyCodeLine{4561 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4562 \textcolor{preprocessor}{    \#ifdef ENOTCONN}}
\DoxyCodeLine{4563         \textcolor{keywordflow}{case} ENOTCONN: \textcolor{keywordflow}{return} DRWAV\_NOT\_CONNECTED;}
\DoxyCodeLine{4564 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4565 \textcolor{preprocessor}{    \#ifdef ESHUTDOWN}}
\DoxyCodeLine{4566         \textcolor{keywordflow}{case} ESHUTDOWN: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4567 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4568 \textcolor{preprocessor}{    \#ifdef ETOOMANYREFS}}
\DoxyCodeLine{4569         \textcolor{keywordflow}{case} ETOOMANYREFS: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4570 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4571 \textcolor{preprocessor}{    \#ifdef ETIMEDOUT}}
\DoxyCodeLine{4572         \textcolor{keywordflow}{case} ETIMEDOUT: \textcolor{keywordflow}{return} DRWAV\_TIMEOUT;}
\DoxyCodeLine{4573 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4574 \textcolor{preprocessor}{    \#ifdef ECONNREFUSED}}
\DoxyCodeLine{4575         \textcolor{keywordflow}{case} ECONNREFUSED: \textcolor{keywordflow}{return} DRWAV\_CONNECTION\_REFUSED;}
\DoxyCodeLine{4576 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4577 \textcolor{preprocessor}{    \#ifdef EHOSTDOWN}}
\DoxyCodeLine{4578         \textcolor{keywordflow}{case} EHOSTDOWN: \textcolor{keywordflow}{return} DRWAV\_NO\_HOST;}
\DoxyCodeLine{4579 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4580 \textcolor{preprocessor}{    \#ifdef EHOSTUNREACH}}
\DoxyCodeLine{4581         \textcolor{keywordflow}{case} EHOSTUNREACH: \textcolor{keywordflow}{return} DRWAV\_NO\_HOST;}
\DoxyCodeLine{4582 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4583 \textcolor{preprocessor}{    \#ifdef EALREADY}}
\DoxyCodeLine{4584         \textcolor{keywordflow}{case} EALREADY: \textcolor{keywordflow}{return} DRWAV\_IN\_PROGRESS;}
\DoxyCodeLine{4585 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4586 \textcolor{preprocessor}{    \#ifdef EINPROGRESS}}
\DoxyCodeLine{4587         \textcolor{keywordflow}{case} EINPROGRESS: \textcolor{keywordflow}{return} DRWAV\_IN\_PROGRESS;}
\DoxyCodeLine{4588 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4589 \textcolor{preprocessor}{    \#ifdef ESTALE}}
\DoxyCodeLine{4590         \textcolor{keywordflow}{case} ESTALE: \textcolor{keywordflow}{return} DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{4591 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4592 \textcolor{preprocessor}{    \#ifdef EUCLEAN}}
\DoxyCodeLine{4593         \textcolor{keywordflow}{case} EUCLEAN: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4594 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4595 \textcolor{preprocessor}{    \#ifdef ENOTNAM}}
\DoxyCodeLine{4596         \textcolor{keywordflow}{case} ENOTNAM: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4597 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4598 \textcolor{preprocessor}{    \#ifdef ENAVAIL}}
\DoxyCodeLine{4599         \textcolor{keywordflow}{case} ENAVAIL: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4600 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4601 \textcolor{preprocessor}{    \#ifdef EISNAM}}
\DoxyCodeLine{4602         \textcolor{keywordflow}{case} EISNAM: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4603 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4604 \textcolor{preprocessor}{    \#ifdef EREMOTEIO}}
\DoxyCodeLine{4605         \textcolor{keywordflow}{case} EREMOTEIO: \textcolor{keywordflow}{return} DRWAV\_IO\_ERROR;}
\DoxyCodeLine{4606 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4607 \textcolor{preprocessor}{    \#ifdef EDQUOT}}
\DoxyCodeLine{4608         \textcolor{keywordflow}{case} EDQUOT: \textcolor{keywordflow}{return} DRWAV\_NO\_SPACE;}
\DoxyCodeLine{4609 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4610 \textcolor{preprocessor}{    \#ifdef ENOMEDIUM}}
\DoxyCodeLine{4611         \textcolor{keywordflow}{case} ENOMEDIUM: \textcolor{keywordflow}{return} DRWAV\_DOES\_NOT\_EXIST;}
\DoxyCodeLine{4612 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4613 \textcolor{preprocessor}{    \#ifdef EMEDIUMTYPE}}
\DoxyCodeLine{4614         \textcolor{keywordflow}{case} EMEDIUMTYPE: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4615 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4616 \textcolor{preprocessor}{    \#ifdef ECANCELED}}
\DoxyCodeLine{4617         \textcolor{keywordflow}{case} ECANCELED: \textcolor{keywordflow}{return} DRWAV\_CANCELLED;}
\DoxyCodeLine{4618 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4619 \textcolor{preprocessor}{    \#ifdef ENOKEY}}
\DoxyCodeLine{4620         \textcolor{keywordflow}{case} ENOKEY: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4621 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4622 \textcolor{preprocessor}{    \#ifdef EKEYEXPIRED}}
\DoxyCodeLine{4623         \textcolor{keywordflow}{case} EKEYEXPIRED: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4624 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4625 \textcolor{preprocessor}{    \#ifdef EKEYREVOKED}}
\DoxyCodeLine{4626         \textcolor{keywordflow}{case} EKEYREVOKED: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4627 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4628 \textcolor{preprocessor}{    \#ifdef EKEYREJECTED}}
\DoxyCodeLine{4629         \textcolor{keywordflow}{case} EKEYREJECTED: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4630 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4631 \textcolor{preprocessor}{    \#ifdef EOWNERDEAD}}
\DoxyCodeLine{4632         \textcolor{keywordflow}{case} EOWNERDEAD: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4633 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4634 \textcolor{preprocessor}{    \#ifdef ENOTRECOVERABLE}}
\DoxyCodeLine{4635         \textcolor{keywordflow}{case} ENOTRECOVERABLE: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4636 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4637 \textcolor{preprocessor}{    \#ifdef ERFKILL}}
\DoxyCodeLine{4638         \textcolor{keywordflow}{case} ERFKILL: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4639 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4640 \textcolor{preprocessor}{    \#ifdef EHWPOISON}}
\DoxyCodeLine{4641         \textcolor{keywordflow}{case} EHWPOISON: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4642 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4643         \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4644     \}}
\DoxyCodeLine{4645 \}}
\DoxyCodeLine{4646 }
\DoxyCodeLine{4647 DRWAV\_PRIVATE drwav\_result drwav\_fopen(FILE** ppFile, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pFilePath, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* pOpenMode)}
\DoxyCodeLine{4648 \{}
\DoxyCodeLine{4649 \textcolor{preprocessor}{\#if defined(\_MSC\_VER) \&\& \_MSC\_VER >= 1400}}
\DoxyCodeLine{4650     errno\_t err;}
\DoxyCodeLine{4651 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4652 }
\DoxyCodeLine{4653     \textcolor{keywordflow}{if} (ppFile != NULL) \{}
\DoxyCodeLine{4654         *ppFile = NULL;  \textcolor{comment}{/* Safety. */}}
\DoxyCodeLine{4655     \}}
\DoxyCodeLine{4656 }
\DoxyCodeLine{4657     \textcolor{keywordflow}{if} (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) \{}
\DoxyCodeLine{4658         \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{4659     \}}
\DoxyCodeLine{4660 }
\DoxyCodeLine{4661 \textcolor{preprocessor}{\#if defined(\_MSC\_VER) \&\& \_MSC\_VER >= 1400}}
\DoxyCodeLine{4662     err = fopen\_s(ppFile, pFilePath, pOpenMode);}
\DoxyCodeLine{4663     \textcolor{keywordflow}{if} (err != 0) \{}
\DoxyCodeLine{4664         \textcolor{keywordflow}{return} drwav\_result\_from\_errno(err);}
\DoxyCodeLine{4665     \}}
\DoxyCodeLine{4666 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4667 \textcolor{preprocessor}{\#if defined(\_WIN32) || defined(\_\_APPLE\_\_)}}
\DoxyCodeLine{4668     *ppFile = fopen(pFilePath, pOpenMode);}
\DoxyCodeLine{4669 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4670 \textcolor{preprocessor}{    \#if defined(\_FILE\_OFFSET\_BITS) \&\& \_FILE\_OFFSET\_BITS == 64 \&\& defined(\_LARGEFILE64\_SOURCE)}}
\DoxyCodeLine{4671         *ppFile = fopen64(pFilePath, pOpenMode);}
\DoxyCodeLine{4672 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{4673         *ppFile = fopen(pFilePath, pOpenMode);}
\DoxyCodeLine{4674 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4675 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4676     \textcolor{keywordflow}{if} (*ppFile == NULL) \{}
\DoxyCodeLine{4677         drwav\_result result = drwav\_result\_from\_errno(errno);}
\DoxyCodeLine{4678         \textcolor{keywordflow}{if} (result == DRWAV\_SUCCESS) \{}
\DoxyCodeLine{4679             result = DRWAV\_ERROR;   \textcolor{comment}{/* Just a safety check to make sure we never ever return success when pFile == NULL. */}}
\DoxyCodeLine{4680         \}}
\DoxyCodeLine{4681 }
\DoxyCodeLine{4682         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{4683     \}}
\DoxyCodeLine{4684 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4685 }
\DoxyCodeLine{4686     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{4687 \}}
\DoxyCodeLine{4688 }
\DoxyCodeLine{4689 \textcolor{comment}{/*}}
\DoxyCodeLine{4690 \textcolor{comment}{\_wfopen() isn't always available in all compilation environments.}}
\DoxyCodeLine{4691 \textcolor{comment}{}}
\DoxyCodeLine{4692 \textcolor{comment}{    * Windows only.}}
\DoxyCodeLine{4693 \textcolor{comment}{    * MSVC seems to support it universally as far back as VC6 from what I can tell (haven't checked further back).}}
\DoxyCodeLine{4694 \textcolor{comment}{    * MinGW-\/64 (both 32-\/ and 64-\/bit) seems to support it.}}
\DoxyCodeLine{4695 \textcolor{comment}{    * MinGW wraps it in !defined(\_\_STRICT\_ANSI\_\_).}}
\DoxyCodeLine{4696 \textcolor{comment}{    * OpenWatcom wraps it in !defined(\_NO\_EXT\_KEYS).}}
\DoxyCodeLine{4697 \textcolor{comment}{}}
\DoxyCodeLine{4698 \textcolor{comment}{This can be reviewed as compatibility issues arise. The preference is to use \_wfopen\_s() and \_wfopen() as opposed to the wcsrtombs()}}
\DoxyCodeLine{4699 \textcolor{comment}{fallback, so if you notice your compiler not detecting this properly I'm happy to look at adding support.}}
\DoxyCodeLine{4700 \textcolor{comment}{*/}}
\DoxyCodeLine{4701 \textcolor{preprocessor}{\#if defined(\_WIN32)}}
\DoxyCodeLine{4702 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER) || defined(\_\_MINGW64\_\_) || (!defined(\_\_STRICT\_ANSI\_\_) \&\& !defined(\_NO\_EXT\_KEYS))}}
\DoxyCodeLine{4703 \textcolor{preprocessor}{        \#define DRWAV\_HAS\_WFOPEN}}
\DoxyCodeLine{4704 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4705 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4706 }
\DoxyCodeLine{4707 DRWAV\_PRIVATE drwav\_result drwav\_wfopen(FILE** ppFile, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pFilePath, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pOpenMode, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4708 \{}
\DoxyCodeLine{4709     \textcolor{keywordflow}{if} (ppFile != NULL) \{}
\DoxyCodeLine{4710         *ppFile = NULL;  \textcolor{comment}{/* Safety. */}}
\DoxyCodeLine{4711     \}}
\DoxyCodeLine{4712 }
\DoxyCodeLine{4713     \textcolor{keywordflow}{if} (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) \{}
\DoxyCodeLine{4714         \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{4715     \}}
\DoxyCodeLine{4716 }
\DoxyCodeLine{4717 \textcolor{preprocessor}{\#if defined(DRWAV\_HAS\_WFOPEN)}}
\DoxyCodeLine{4718     \{}
\DoxyCodeLine{4719         \textcolor{comment}{/* Use \_wfopen() on Windows. */}}
\DoxyCodeLine{4720 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER) \&\& \_MSC\_VER >= 1400}}
\DoxyCodeLine{4721         errno\_t err = \_wfopen\_s(ppFile, pFilePath, pOpenMode);}
\DoxyCodeLine{4722         \textcolor{keywordflow}{if} (err != 0) \{}
\DoxyCodeLine{4723             \textcolor{keywordflow}{return} drwav\_result\_from\_errno(err);}
\DoxyCodeLine{4724         \}}
\DoxyCodeLine{4725 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{4726         *ppFile = \_wfopen(pFilePath, pOpenMode);}
\DoxyCodeLine{4727         \textcolor{keywordflow}{if} (*ppFile == NULL) \{}
\DoxyCodeLine{4728             \textcolor{keywordflow}{return} drwav\_result\_from\_errno(errno);}
\DoxyCodeLine{4729         \}}
\DoxyCodeLine{4730 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{4731         (void)pAllocationCallbacks;}
\DoxyCodeLine{4732     \}}
\DoxyCodeLine{4733 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4734     \textcolor{comment}{/*}}
\DoxyCodeLine{4735 \textcolor{comment}{    Use fopen() on anything other than Windows. Requires a conversion. This is annoying because fopen() is locale specific. The only real way I can}}
\DoxyCodeLine{4736 \textcolor{comment}{    think of to do this is with wcsrtombs(). Note that wcstombs() is apparently not thread-\/safe because it uses a static global mbstate\_t object for}}
\DoxyCodeLine{4737 \textcolor{comment}{    maintaining state. I've checked this with -\/std=c89 and it works, but if somebody get's a compiler error I'll look into improving compatibility.}}
\DoxyCodeLine{4738 \textcolor{comment}{    */}}
\DoxyCodeLine{4739     \{}
\DoxyCodeLine{4740         mbstate\_t mbs;}
\DoxyCodeLine{4741         \textcolor{keywordtype}{size\_t} lenMB;}
\DoxyCodeLine{4742         \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* pFilePathTemp = pFilePath;}
\DoxyCodeLine{4743         \textcolor{keywordtype}{char}* pFilePathMB = NULL;}
\DoxyCodeLine{4744         \textcolor{keywordtype}{char} pOpenModeMB[32] = \{0\};}
\DoxyCodeLine{4745 }
\DoxyCodeLine{4746         \textcolor{comment}{/* Get the length first. */}}
\DoxyCodeLine{4747         DRWAV\_ZERO\_OBJECT(\&mbs);}
\DoxyCodeLine{4748         lenMB = wcsrtombs(NULL, \&pFilePathTemp, 0, \&mbs);}
\DoxyCodeLine{4749         \textcolor{keywordflow}{if} (lenMB == (\textcolor{keywordtype}{size\_t})-\/1) \{}
\DoxyCodeLine{4750             \textcolor{keywordflow}{return} drwav\_result\_from\_errno(errno);}
\DoxyCodeLine{4751         \}}
\DoxyCodeLine{4752 }
\DoxyCodeLine{4753         pFilePathMB = (\textcolor{keywordtype}{char}*)drwav\_\_malloc\_from\_callbacks(lenMB + 1, pAllocationCallbacks);}
\DoxyCodeLine{4754         \textcolor{keywordflow}{if} (pFilePathMB == NULL) \{}
\DoxyCodeLine{4755             \textcolor{keywordflow}{return} DRWAV\_OUT\_OF\_MEMORY;}
\DoxyCodeLine{4756         \}}
\DoxyCodeLine{4757 }
\DoxyCodeLine{4758         pFilePathTemp = pFilePath;}
\DoxyCodeLine{4759         DRWAV\_ZERO\_OBJECT(\&mbs);}
\DoxyCodeLine{4760         wcsrtombs(pFilePathMB, \&pFilePathTemp, lenMB + 1, \&mbs);}
\DoxyCodeLine{4761 }
\DoxyCodeLine{4762         \textcolor{comment}{/* The open mode should always consist of ASCII characters so we should be able to do a trivial conversion. */}}
\DoxyCodeLine{4763         \{}
\DoxyCodeLine{4764             \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{4765             \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{4766                 \textcolor{keywordflow}{if} (pOpenMode[i] == 0) \{}
\DoxyCodeLine{4767                     pOpenModeMB[i] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4768                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{4769                 \}}
\DoxyCodeLine{4770 }
\DoxyCodeLine{4771                 pOpenModeMB[i] = (char)pOpenMode[i];}
\DoxyCodeLine{4772                 i += 1;}
\DoxyCodeLine{4773             \}}
\DoxyCodeLine{4774         \}}
\DoxyCodeLine{4775 }
\DoxyCodeLine{4776         *ppFile = fopen(pFilePathMB, pOpenModeMB);}
\DoxyCodeLine{4777 }
\DoxyCodeLine{4778         drwav\_\_free\_from\_callbacks(pFilePathMB, pAllocationCallbacks);}
\DoxyCodeLine{4779     \}}
\DoxyCodeLine{4780 }
\DoxyCodeLine{4781     \textcolor{keywordflow}{if} (*ppFile == NULL) \{}
\DoxyCodeLine{4782         \textcolor{keywordflow}{return} DRWAV\_ERROR;}
\DoxyCodeLine{4783     \}}
\DoxyCodeLine{4784 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4785 }
\DoxyCodeLine{4786     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{4787 \}}
\DoxyCodeLine{4788 }
\DoxyCodeLine{4789 }
\DoxyCodeLine{4790 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_on\_read\_stdio(\textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{void}* pBufferOut, \textcolor{keywordtype}{size\_t} bytesToRead)}
\DoxyCodeLine{4791 \{}
\DoxyCodeLine{4792     \textcolor{keywordflow}{return} fread(pBufferOut, 1, bytesToRead, (FILE*)pUserData);}
\DoxyCodeLine{4793 \}}
\DoxyCodeLine{4794 }
\DoxyCodeLine{4795 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_on\_write\_stdio(\textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData, \textcolor{keywordtype}{size\_t} bytesToWrite)}
\DoxyCodeLine{4796 \{}
\DoxyCodeLine{4797     \textcolor{keywordflow}{return} fwrite(pData, 1, bytesToWrite, (FILE*)pUserData);}
\DoxyCodeLine{4798 \}}
\DoxyCodeLine{4799 }
\DoxyCodeLine{4800 DRWAV\_PRIVATE drwav\_bool32 drwav\_\_on\_seek\_stdio(\textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{int} offset, drwav\_seek\_origin origin)}
\DoxyCodeLine{4801 \{}
\DoxyCodeLine{4802     \textcolor{keywordflow}{return} fseek((FILE*)pUserData, offset, (origin == drwav\_seek\_origin\_current) ? SEEK\_CUR : SEEK\_SET) == 0;}
\DoxyCodeLine{4803 \}}
\DoxyCodeLine{4804 }
\DoxyCodeLine{4805 DRWAV\_API drwav\_bool32 drwav\_init\_file(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4806 \{}
\DoxyCodeLine{4807     \textcolor{keywordflow}{return} drwav\_init\_file\_ex(pWav, filename, NULL, NULL, 0, pAllocationCallbacks);}
\DoxyCodeLine{4808 \}}
\DoxyCodeLine{4809 }
\DoxyCodeLine{4810 }
\DoxyCodeLine{4811 DRWAV\_PRIVATE drwav\_bool32 drwav\_init\_file\_\_internal\_FILE(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, FILE* pFile, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, drwav\_metadata\_type allowedMetadataTypes, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4812 \{}
\DoxyCodeLine{4813     drwav\_bool32 result;}
\DoxyCodeLine{4814 }
\DoxyCodeLine{4815     result = drwav\_preinit(pWav, drwav\_\_on\_read\_stdio, drwav\_\_on\_seek\_stdio, (\textcolor{keywordtype}{void}*)pFile, pAllocationCallbacks);}
\DoxyCodeLine{4816     \textcolor{keywordflow}{if} (result != DRWAV\_TRUE) \{}
\DoxyCodeLine{4817         fclose(pFile);}
\DoxyCodeLine{4818         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{4819     \}}
\DoxyCodeLine{4820     }
\DoxyCodeLine{4821     pWav-\/>allowedMetadataTypes = allowedMetadataTypes;}
\DoxyCodeLine{4822 }
\DoxyCodeLine{4823     result = drwav\_init\_\_internal(pWav, onChunk, pChunkUserData, flags);}
\DoxyCodeLine{4824     \textcolor{keywordflow}{if} (result != DRWAV\_TRUE) \{}
\DoxyCodeLine{4825         fclose(pFile);}
\DoxyCodeLine{4826         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{4827     \}}
\DoxyCodeLine{4828 }
\DoxyCodeLine{4829     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{4830 \}}
\DoxyCodeLine{4831 }
\DoxyCodeLine{4832 DRWAV\_API drwav\_bool32 drwav\_init\_file\_ex(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4833 \{}
\DoxyCodeLine{4834     FILE* pFile;}
\DoxyCodeLine{4835     \textcolor{keywordflow}{if} (drwav\_fopen(\&pFile, filename, \textcolor{stringliteral}{"{}rb"{}}) != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{4836         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4837     \}}
\DoxyCodeLine{4838 }
\DoxyCodeLine{4839     \textcolor{comment}{/* This takes ownership of the FILE* object. */}}
\DoxyCodeLine{4840     \textcolor{keywordflow}{return} drwav\_init\_file\_\_internal\_FILE(pWav, pFile, onChunk, pChunkUserData, flags, drwav\_metadata\_type\_none, pAllocationCallbacks);}
\DoxyCodeLine{4841 \}}
\DoxyCodeLine{4842 }
\DoxyCodeLine{4843 DRWAV\_API drwav\_bool32 drwav\_init\_file\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4844 \{}
\DoxyCodeLine{4845     \textcolor{keywordflow}{return} drwav\_init\_file\_ex\_w(pWav, filename, NULL, NULL, 0, pAllocationCallbacks);}
\DoxyCodeLine{4846 \}}
\DoxyCodeLine{4847 }
\DoxyCodeLine{4848 DRWAV\_API drwav\_bool32 drwav\_init\_file\_ex\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4849 \{}
\DoxyCodeLine{4850     FILE* pFile;}
\DoxyCodeLine{4851     \textcolor{keywordflow}{if} (drwav\_wfopen(\&pFile, filename, L\textcolor{stringliteral}{"{}rb"{}}, pAllocationCallbacks) != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{4852         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4853     \}}
\DoxyCodeLine{4854 }
\DoxyCodeLine{4855     \textcolor{comment}{/* This takes ownership of the FILE* object. */}}
\DoxyCodeLine{4856     \textcolor{keywordflow}{return} drwav\_init\_file\_\_internal\_FILE(pWav, pFile, onChunk, pChunkUserData, flags, drwav\_metadata\_type\_none, pAllocationCallbacks);}
\DoxyCodeLine{4857 \}}
\DoxyCodeLine{4858 }
\DoxyCodeLine{4859 DRWAV\_API drwav\_bool32 drwav\_init\_file\_with\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4860 \{}
\DoxyCodeLine{4861     FILE* pFile;}
\DoxyCodeLine{4862     \textcolor{keywordflow}{if} (drwav\_fopen(\&pFile, filename, \textcolor{stringliteral}{"{}rb"{}}) != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{4863         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4864     \}}
\DoxyCodeLine{4865 }
\DoxyCodeLine{4866     \textcolor{comment}{/* This takes ownership of the FILE* object. */}}
\DoxyCodeLine{4867     \textcolor{keywordflow}{return} drwav\_init\_file\_\_internal\_FILE(pWav, pFile, NULL, NULL, flags, drwav\_metadata\_type\_all\_including\_unknown, pAllocationCallbacks);}
\DoxyCodeLine{4868 \}}
\DoxyCodeLine{4869 }
\DoxyCodeLine{4870 DRWAV\_API drwav\_bool32 drwav\_init\_file\_with\_metadata\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4871 \{}
\DoxyCodeLine{4872     FILE* pFile;}
\DoxyCodeLine{4873     \textcolor{keywordflow}{if} (drwav\_wfopen(\&pFile, filename, L\textcolor{stringliteral}{"{}rb"{}}, pAllocationCallbacks) != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{4874         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4875     \}}
\DoxyCodeLine{4876 }
\DoxyCodeLine{4877     \textcolor{comment}{/* This takes ownership of the FILE* object. */}}
\DoxyCodeLine{4878     \textcolor{keywordflow}{return} drwav\_init\_file\_\_internal\_FILE(pWav, pFile, NULL, NULL, flags, drwav\_metadata\_type\_all\_including\_unknown, pAllocationCallbacks);}
\DoxyCodeLine{4879 \}}
\DoxyCodeLine{4880 }
\DoxyCodeLine{4881 }
\DoxyCodeLine{4882 DRWAV\_PRIVATE drwav\_bool32 drwav\_init\_file\_write\_\_internal\_FILE(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, FILE* pFile, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, drwav\_bool32 isSequential, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4883 \{}
\DoxyCodeLine{4884     drwav\_bool32 result;}
\DoxyCodeLine{4885 }
\DoxyCodeLine{4886     result = drwav\_preinit\_write(pWav, pFormat, isSequential, drwav\_\_on\_write\_stdio, drwav\_\_on\_seek\_stdio, (\textcolor{keywordtype}{void}*)pFile, pAllocationCallbacks);}
\DoxyCodeLine{4887     \textcolor{keywordflow}{if} (result != DRWAV\_TRUE) \{}
\DoxyCodeLine{4888         fclose(pFile);}
\DoxyCodeLine{4889         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{4890     \}}
\DoxyCodeLine{4891 }
\DoxyCodeLine{4892     result = drwav\_init\_write\_\_internal(pWav, pFormat, totalSampleCount);}
\DoxyCodeLine{4893     \textcolor{keywordflow}{if} (result != DRWAV\_TRUE) \{}
\DoxyCodeLine{4894         fclose(pFile);}
\DoxyCodeLine{4895         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{4896     \}}
\DoxyCodeLine{4897 }
\DoxyCodeLine{4898     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{4899 \}}
\DoxyCodeLine{4900 }
\DoxyCodeLine{4901 DRWAV\_PRIVATE drwav\_bool32 drwav\_init\_file\_write\_\_internal(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, drwav\_bool32 isSequential, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4902 \{}
\DoxyCodeLine{4903     FILE* pFile;}
\DoxyCodeLine{4904     \textcolor{keywordflow}{if} (drwav\_fopen(\&pFile, filename, \textcolor{stringliteral}{"{}wb"{}}) != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{4905         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4906     \}}
\DoxyCodeLine{4907 }
\DoxyCodeLine{4908     \textcolor{comment}{/* This takes ownership of the FILE* object. */}}
\DoxyCodeLine{4909     \textcolor{keywordflow}{return} drwav\_init\_file\_write\_\_internal\_FILE(pWav, pFile, pFormat, totalSampleCount, isSequential, pAllocationCallbacks);}
\DoxyCodeLine{4910 \}}
\DoxyCodeLine{4911 }
\DoxyCodeLine{4912 DRWAV\_PRIVATE drwav\_bool32 drwav\_init\_file\_write\_w\_\_internal(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, drwav\_bool32 isSequential, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4913 \{}
\DoxyCodeLine{4914     FILE* pFile;}
\DoxyCodeLine{4915     \textcolor{keywordflow}{if} (drwav\_wfopen(\&pFile, filename, L\textcolor{stringliteral}{"{}wb"{}}, pAllocationCallbacks) != DRWAV\_SUCCESS) \{}
\DoxyCodeLine{4916         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4917     \}}
\DoxyCodeLine{4918 }
\DoxyCodeLine{4919     \textcolor{comment}{/* This takes ownership of the FILE* object. */}}
\DoxyCodeLine{4920     \textcolor{keywordflow}{return} drwav\_init\_file\_write\_\_internal\_FILE(pWav, pFile, pFormat, totalSampleCount, isSequential, pAllocationCallbacks);}
\DoxyCodeLine{4921 \}}
\DoxyCodeLine{4922 }
\DoxyCodeLine{4923 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4924 \{}
\DoxyCodeLine{4925     \textcolor{keywordflow}{return} drwav\_init\_file\_write\_\_internal(pWav, filename, pFormat, 0, DRWAV\_FALSE, pAllocationCallbacks);}
\DoxyCodeLine{4926 \}}
\DoxyCodeLine{4927 }
\DoxyCodeLine{4928 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_sequential(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4929 \{}
\DoxyCodeLine{4930     \textcolor{keywordflow}{return} drwav\_init\_file\_write\_\_internal(pWav, filename, pFormat, totalSampleCount, DRWAV\_TRUE, pAllocationCallbacks);}
\DoxyCodeLine{4931 \}}
\DoxyCodeLine{4932 }
\DoxyCodeLine{4933 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_sequential\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalPCMFrameCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4934 \{}
\DoxyCodeLine{4935     \textcolor{keywordflow}{if} (pFormat == NULL) \{}
\DoxyCodeLine{4936         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4937     \}}
\DoxyCodeLine{4938 }
\DoxyCodeLine{4939     \textcolor{keywordflow}{return} drwav\_init\_file\_write\_sequential(pWav, filename, pFormat, totalPCMFrameCount*pFormat-\/>channels, pAllocationCallbacks);}
\DoxyCodeLine{4940 \}}
\DoxyCodeLine{4941 }
\DoxyCodeLine{4942 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4943 \{}
\DoxyCodeLine{4944     \textcolor{keywordflow}{return} drwav\_init\_file\_write\_w\_\_internal(pWav, filename, pFormat, 0, DRWAV\_FALSE, pAllocationCallbacks);}
\DoxyCodeLine{4945 \}}
\DoxyCodeLine{4946 }
\DoxyCodeLine{4947 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_sequential\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4948 \{}
\DoxyCodeLine{4949     \textcolor{keywordflow}{return} drwav\_init\_file\_write\_w\_\_internal(pWav, filename, pFormat, totalSampleCount, DRWAV\_TRUE, pAllocationCallbacks);}
\DoxyCodeLine{4950 \}}
\DoxyCodeLine{4951 }
\DoxyCodeLine{4952 DRWAV\_API drwav\_bool32 drwav\_init\_file\_write\_sequential\_pcm\_frames\_w(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalPCMFrameCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{4953 \{}
\DoxyCodeLine{4954     \textcolor{keywordflow}{if} (pFormat == NULL) \{}
\DoxyCodeLine{4955         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{4956     \}}
\DoxyCodeLine{4957 }
\DoxyCodeLine{4958     \textcolor{keywordflow}{return} drwav\_init\_file\_write\_sequential\_w(pWav, filename, pFormat, totalPCMFrameCount*pFormat-\/>channels, pAllocationCallbacks);}
\DoxyCodeLine{4959 \}}
\DoxyCodeLine{4960 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{/* DR\_WAV\_NO\_STDIO */}\textcolor{preprocessor}{}}
\DoxyCodeLine{4961 }
\DoxyCodeLine{4962 }
\DoxyCodeLine{4963 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_on\_read\_memory(\textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{void}* pBufferOut, \textcolor{keywordtype}{size\_t} bytesToRead)}
\DoxyCodeLine{4964 \{}
\DoxyCodeLine{4965     \mbox{\hyperlink{structdrwav}{drwav}}* pWav = (\mbox{\hyperlink{structdrwav}{drwav}}*)pUserData;}
\DoxyCodeLine{4966     \textcolor{keywordtype}{size\_t} bytesRemaining;}
\DoxyCodeLine{4967 }
\DoxyCodeLine{4968     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{4969     DRWAV\_ASSERT(pWav-\/>memoryStream.dataSize >= pWav-\/>memoryStream.currentReadPos);}
\DoxyCodeLine{4970 }
\DoxyCodeLine{4971     bytesRemaining = pWav-\/>memoryStream.dataSize -\/ pWav-\/>memoryStream.currentReadPos;}
\DoxyCodeLine{4972     \textcolor{keywordflow}{if} (bytesToRead > bytesRemaining) \{}
\DoxyCodeLine{4973         bytesToRead = bytesRemaining;}
\DoxyCodeLine{4974     \}}
\DoxyCodeLine{4975 }
\DoxyCodeLine{4976     \textcolor{keywordflow}{if} (bytesToRead > 0) \{}
\DoxyCodeLine{4977         DRWAV\_COPY\_MEMORY(pBufferOut, pWav-\/>memoryStream.data + pWav-\/>memoryStream.currentReadPos, bytesToRead);}
\DoxyCodeLine{4978         pWav-\/>memoryStream.currentReadPos += bytesToRead;}
\DoxyCodeLine{4979     \}}
\DoxyCodeLine{4980 }
\DoxyCodeLine{4981     \textcolor{keywordflow}{return} bytesToRead;}
\DoxyCodeLine{4982 \}}
\DoxyCodeLine{4983 }
\DoxyCodeLine{4984 DRWAV\_PRIVATE drwav\_bool32 drwav\_\_on\_seek\_memory(\textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{int} offset, drwav\_seek\_origin origin)}
\DoxyCodeLine{4985 \{}
\DoxyCodeLine{4986     \mbox{\hyperlink{structdrwav}{drwav}}* pWav = (\mbox{\hyperlink{structdrwav}{drwav}}*)pUserData;}
\DoxyCodeLine{4987     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{4988 }
\DoxyCodeLine{4989     \textcolor{keywordflow}{if} (origin == drwav\_seek\_origin\_current) \{}
\DoxyCodeLine{4990         \textcolor{keywordflow}{if} (offset > 0) \{}
\DoxyCodeLine{4991             \textcolor{keywordflow}{if} (pWav-\/>memoryStream.currentReadPos + offset > pWav-\/>memoryStream.dataSize) \{}
\DoxyCodeLine{4992                 \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* Trying to seek too far forward. */}}
\DoxyCodeLine{4993             \}}
\DoxyCodeLine{4994         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{4995             \textcolor{keywordflow}{if} (pWav-\/>memoryStream.currentReadPos < (\textcolor{keywordtype}{size\_t})-\/offset) \{}
\DoxyCodeLine{4996                 \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* Trying to seek too far backwards. */}}
\DoxyCodeLine{4997             \}}
\DoxyCodeLine{4998         \}}
\DoxyCodeLine{4999 }
\DoxyCodeLine{5000         \textcolor{comment}{/* This will never underflow thanks to the clamps above. */}}
\DoxyCodeLine{5001         pWav-\/>memoryStream.currentReadPos += offset;}
\DoxyCodeLine{5002     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5003         \textcolor{keywordflow}{if} ((drwav\_uint32)offset <= pWav-\/>memoryStream.dataSize) \{}
\DoxyCodeLine{5004             pWav-\/>memoryStream.currentReadPos = offset;}
\DoxyCodeLine{5005         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5006             \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* Trying to seek too far forward. */}}
\DoxyCodeLine{5007         \}}
\DoxyCodeLine{5008     \}}
\DoxyCodeLine{5009 }
\DoxyCodeLine{5010     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{5011 \}}
\DoxyCodeLine{5012 }
\DoxyCodeLine{5013 DRWAV\_PRIVATE \textcolor{keywordtype}{size\_t} drwav\_\_on\_write\_memory(\textcolor{keywordtype}{void}* pUserData, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pDataIn, \textcolor{keywordtype}{size\_t} bytesToWrite)}
\DoxyCodeLine{5014 \{}
\DoxyCodeLine{5015     \mbox{\hyperlink{structdrwav}{drwav}}* pWav = (\mbox{\hyperlink{structdrwav}{drwav}}*)pUserData;}
\DoxyCodeLine{5016     \textcolor{keywordtype}{size\_t} bytesRemaining;}
\DoxyCodeLine{5017 }
\DoxyCodeLine{5018     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{5019     DRWAV\_ASSERT(pWav-\/>memoryStreamWrite.dataCapacity >= pWav-\/>memoryStreamWrite.currentWritePos);}
\DoxyCodeLine{5020 }
\DoxyCodeLine{5021     bytesRemaining = pWav-\/>memoryStreamWrite.dataCapacity -\/ pWav-\/>memoryStreamWrite.currentWritePos;}
\DoxyCodeLine{5022     \textcolor{keywordflow}{if} (bytesRemaining < bytesToWrite) \{}
\DoxyCodeLine{5023         \textcolor{comment}{/* Need to reallocate. */}}
\DoxyCodeLine{5024         \textcolor{keywordtype}{void}* pNewData;}
\DoxyCodeLine{5025         \textcolor{keywordtype}{size\_t} newDataCapacity = (pWav-\/>memoryStreamWrite.dataCapacity == 0) ? 256 : pWav-\/>memoryStreamWrite.dataCapacity * 2;}
\DoxyCodeLine{5026 }
\DoxyCodeLine{5027         \textcolor{comment}{/* If doubling wasn't enough, just make it the minimum required size to write the data. */}}
\DoxyCodeLine{5028         if ((newDataCapacity -\/ pWav-\/>memoryStreamWrite.currentWritePos) < bytesToWrite) \{}
\DoxyCodeLine{5029             newDataCapacity = pWav-\/>memoryStreamWrite.currentWritePos + bytesToWrite;}
\DoxyCodeLine{5030         \}}
\DoxyCodeLine{5031 }
\DoxyCodeLine{5032         pNewData = drwav\_\_realloc\_from\_callbacks(*pWav-\/>memoryStreamWrite.ppData, newDataCapacity, pWav-\/>memoryStreamWrite.dataCapacity, \&pWav-\/>allocationCallbacks);}
\DoxyCodeLine{5033         \textcolor{keywordflow}{if} (pNewData == NULL) \{}
\DoxyCodeLine{5034             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5035         \}}
\DoxyCodeLine{5036 }
\DoxyCodeLine{5037         *pWav-\/>memoryStreamWrite.ppData = pNewData;}
\DoxyCodeLine{5038         pWav-\/>memoryStreamWrite.dataCapacity = newDataCapacity;}
\DoxyCodeLine{5039     \}}
\DoxyCodeLine{5040 }
\DoxyCodeLine{5041     DRWAV\_COPY\_MEMORY(((drwav\_uint8*)(*pWav-\/>memoryStreamWrite.ppData)) + pWav-\/>memoryStreamWrite.currentWritePos, pDataIn, bytesToWrite);}
\DoxyCodeLine{5042 }
\DoxyCodeLine{5043     pWav-\/>memoryStreamWrite.currentWritePos += bytesToWrite;}
\DoxyCodeLine{5044     \textcolor{keywordflow}{if} (pWav-\/>memoryStreamWrite.dataSize < pWav-\/>memoryStreamWrite.currentWritePos) \{}
\DoxyCodeLine{5045         pWav-\/>memoryStreamWrite.dataSize = pWav-\/>memoryStreamWrite.currentWritePos;}
\DoxyCodeLine{5046     \}}
\DoxyCodeLine{5047 }
\DoxyCodeLine{5048     *pWav-\/>memoryStreamWrite.pDataSize = pWav-\/>memoryStreamWrite.dataSize;}
\DoxyCodeLine{5049 }
\DoxyCodeLine{5050     \textcolor{keywordflow}{return} bytesToWrite;}
\DoxyCodeLine{5051 \}}
\DoxyCodeLine{5052 }
\DoxyCodeLine{5053 DRWAV\_PRIVATE drwav\_bool32 drwav\_\_on\_seek\_memory\_write(\textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{int} offset, drwav\_seek\_origin origin)}
\DoxyCodeLine{5054 \{}
\DoxyCodeLine{5055     \mbox{\hyperlink{structdrwav}{drwav}}* pWav = (\mbox{\hyperlink{structdrwav}{drwav}}*)pUserData;}
\DoxyCodeLine{5056     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{5057 }
\DoxyCodeLine{5058     \textcolor{keywordflow}{if} (origin == drwav\_seek\_origin\_current) \{}
\DoxyCodeLine{5059         \textcolor{keywordflow}{if} (offset > 0) \{}
\DoxyCodeLine{5060             \textcolor{keywordflow}{if} (pWav-\/>memoryStreamWrite.currentWritePos + offset > pWav-\/>memoryStreamWrite.dataSize) \{}
\DoxyCodeLine{5061                 offset = (int)(pWav-\/>memoryStreamWrite.dataSize -\/ pWav-\/>memoryStreamWrite.currentWritePos);  \textcolor{comment}{/* Trying to seek too far forward. */}}
\DoxyCodeLine{5062             \}}
\DoxyCodeLine{5063         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5064             \textcolor{keywordflow}{if} (pWav-\/>memoryStreamWrite.currentWritePos < (\textcolor{keywordtype}{size\_t})-\/offset) \{}
\DoxyCodeLine{5065                 offset = -\/(int)pWav-\/>memoryStreamWrite.currentWritePos;  \textcolor{comment}{/* Trying to seek too far backwards. */}}
\DoxyCodeLine{5066             \}}
\DoxyCodeLine{5067         \}}
\DoxyCodeLine{5068 }
\DoxyCodeLine{5069         \textcolor{comment}{/* This will never underflow thanks to the clamps above. */}}
\DoxyCodeLine{5070         pWav-\/>memoryStreamWrite.currentWritePos += offset;}
\DoxyCodeLine{5071     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5072         \textcolor{keywordflow}{if} ((drwav\_uint32)offset <= pWav-\/>memoryStreamWrite.dataSize) \{}
\DoxyCodeLine{5073             pWav-\/>memoryStreamWrite.currentWritePos = offset;}
\DoxyCodeLine{5074         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5075             pWav-\/>memoryStreamWrite.currentWritePos = pWav-\/>memoryStreamWrite.dataSize;  \textcolor{comment}{/* Trying to seek too far forward. */}}
\DoxyCodeLine{5076         \}}
\DoxyCodeLine{5077     \}}
\DoxyCodeLine{5078 }
\DoxyCodeLine{5079     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{5080 \}}
\DoxyCodeLine{5081 }
\DoxyCodeLine{5082 DRWAV\_API drwav\_bool32 drwav\_init\_memory(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{5083 \{}
\DoxyCodeLine{5084     \textcolor{keywordflow}{return} drwav\_init\_memory\_ex(pWav, data, dataSize, NULL, NULL, 0, pAllocationCallbacks);}
\DoxyCodeLine{5085 \}}
\DoxyCodeLine{5086 }
\DoxyCodeLine{5087 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_ex(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, drwav\_chunk\_proc onChunk, \textcolor{keywordtype}{void}* pChunkUserData, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{5088 \{}
\DoxyCodeLine{5089     \textcolor{keywordflow}{if} (data == NULL || dataSize == 0) \{}
\DoxyCodeLine{5090         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5091     \}}
\DoxyCodeLine{5092 }
\DoxyCodeLine{5093     \textcolor{keywordflow}{if} (!drwav\_preinit(pWav, drwav\_\_on\_read\_memory, drwav\_\_on\_seek\_memory, pWav, pAllocationCallbacks)) \{}
\DoxyCodeLine{5094         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5095     \}}
\DoxyCodeLine{5096 }
\DoxyCodeLine{5097     pWav-\/>memoryStream.data = (\textcolor{keyword}{const} drwav\_uint8*)data;}
\DoxyCodeLine{5098     pWav-\/>memoryStream.dataSize = dataSize;}
\DoxyCodeLine{5099     pWav-\/>memoryStream.currentReadPos = 0;}
\DoxyCodeLine{5100 }
\DoxyCodeLine{5101     \textcolor{keywordflow}{return} drwav\_init\_\_internal(pWav, onChunk, pChunkUserData, flags);}
\DoxyCodeLine{5102 \}}
\DoxyCodeLine{5103 }
\DoxyCodeLine{5104 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_with\_metadata(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, drwav\_uint32 flags, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{5105 \{}
\DoxyCodeLine{5106     \textcolor{keywordflow}{if} (data == NULL || dataSize == 0) \{}
\DoxyCodeLine{5107         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5108     \}}
\DoxyCodeLine{5109 }
\DoxyCodeLine{5110     \textcolor{keywordflow}{if} (!drwav\_preinit(pWav, drwav\_\_on\_read\_memory, drwav\_\_on\_seek\_memory, pWav, pAllocationCallbacks)) \{}
\DoxyCodeLine{5111         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5112     \}}
\DoxyCodeLine{5113 }
\DoxyCodeLine{5114     pWav-\/>memoryStream.data = (\textcolor{keyword}{const} drwav\_uint8*)data;}
\DoxyCodeLine{5115     pWav-\/>memoryStream.dataSize = dataSize;}
\DoxyCodeLine{5116     pWav-\/>memoryStream.currentReadPos = 0;}
\DoxyCodeLine{5117 }
\DoxyCodeLine{5118     pWav-\/>allowedMetadataTypes = drwav\_metadata\_type\_all\_including\_unknown;}
\DoxyCodeLine{5119 }
\DoxyCodeLine{5120     \textcolor{keywordflow}{return} drwav\_init\_\_internal(pWav, NULL, NULL, flags);}
\DoxyCodeLine{5121 \}}
\DoxyCodeLine{5122 }
\DoxyCodeLine{5123 }
\DoxyCodeLine{5124 DRWAV\_PRIVATE drwav\_bool32 drwav\_init\_memory\_write\_\_internal(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{void}** ppData, \textcolor{keywordtype}{size\_t}* pDataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, drwav\_bool32 isSequential, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{5125 \{}
\DoxyCodeLine{5126     \textcolor{keywordflow}{if} (ppData == NULL || pDataSize == NULL) \{}
\DoxyCodeLine{5127         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5128     \}}
\DoxyCodeLine{5129 }
\DoxyCodeLine{5130     *ppData = NULL; \textcolor{comment}{/* Important because we're using realloc()! */}}
\DoxyCodeLine{5131     *pDataSize = 0;}
\DoxyCodeLine{5132 }
\DoxyCodeLine{5133     \textcolor{keywordflow}{if} (!drwav\_preinit\_write(pWav, pFormat, isSequential, drwav\_\_on\_write\_memory, drwav\_\_on\_seek\_memory\_write, pWav, pAllocationCallbacks)) \{}
\DoxyCodeLine{5134         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5135     \}}
\DoxyCodeLine{5136 }
\DoxyCodeLine{5137     pWav-\/>memoryStreamWrite.ppData = ppData;}
\DoxyCodeLine{5138     pWav-\/>memoryStreamWrite.pDataSize = pDataSize;}
\DoxyCodeLine{5139     pWav-\/>memoryStreamWrite.dataSize = 0;}
\DoxyCodeLine{5140     pWav-\/>memoryStreamWrite.dataCapacity = 0;}
\DoxyCodeLine{5141     pWav-\/>memoryStreamWrite.currentWritePos = 0;}
\DoxyCodeLine{5142 }
\DoxyCodeLine{5143     \textcolor{keywordflow}{return} drwav\_init\_write\_\_internal(pWav, pFormat, totalSampleCount);}
\DoxyCodeLine{5144 \}}
\DoxyCodeLine{5145 }
\DoxyCodeLine{5146 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_write(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{void}** ppData, \textcolor{keywordtype}{size\_t}* pDataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{5147 \{}
\DoxyCodeLine{5148     \textcolor{keywordflow}{return} drwav\_init\_memory\_write\_\_internal(pWav, ppData, pDataSize, pFormat, 0, DRWAV\_FALSE, pAllocationCallbacks);}
\DoxyCodeLine{5149 \}}
\DoxyCodeLine{5150 }
\DoxyCodeLine{5151 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_write\_sequential(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{void}** ppData, \textcolor{keywordtype}{size\_t}* pDataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalSampleCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{5152 \{}
\DoxyCodeLine{5153     \textcolor{keywordflow}{return} drwav\_init\_memory\_write\_\_internal(pWav, ppData, pDataSize, pFormat, totalSampleCount, DRWAV\_TRUE, pAllocationCallbacks);}
\DoxyCodeLine{5154 \}}
\DoxyCodeLine{5155 }
\DoxyCodeLine{5156 DRWAV\_API drwav\_bool32 drwav\_init\_memory\_write\_sequential\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{void}** ppData, \textcolor{keywordtype}{size\_t}* pDataSize, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__data__format}{drwav\_data\_format}}* pFormat, drwav\_uint64 totalPCMFrameCount, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{5157 \{}
\DoxyCodeLine{5158     \textcolor{keywordflow}{if} (pFormat == NULL) \{}
\DoxyCodeLine{5159         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5160     \}}
\DoxyCodeLine{5161 }
\DoxyCodeLine{5162     \textcolor{keywordflow}{return} drwav\_init\_memory\_write\_sequential(pWav, ppData, pDataSize, pFormat, totalPCMFrameCount*pFormat-\/>channels, pAllocationCallbacks);}
\DoxyCodeLine{5163 \}}
\DoxyCodeLine{5164 }
\DoxyCodeLine{5165 }
\DoxyCodeLine{5166 }
\DoxyCodeLine{5167 DRWAV\_API drwav\_result drwav\_uninit(\mbox{\hyperlink{structdrwav}{drwav}}* pWav)}
\DoxyCodeLine{5168 \{}
\DoxyCodeLine{5169     drwav\_result result = DRWAV\_SUCCESS;}
\DoxyCodeLine{5170 }
\DoxyCodeLine{5171     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{5172         \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{5173     \}}
\DoxyCodeLine{5174 }
\DoxyCodeLine{5175     \textcolor{comment}{/*}}
\DoxyCodeLine{5176 \textcolor{comment}{    If the drwav object was opened in write mode we'll need to finalize a few things:}}
\DoxyCodeLine{5177 \textcolor{comment}{      -\/ Make sure the "{}data"{} chunk is aligned to 16-\/bits for RIFF containers, or 64 bits for W64 containers.}}
\DoxyCodeLine{5178 \textcolor{comment}{      -\/ Set the size of the "{}data"{} chunk.}}
\DoxyCodeLine{5179 \textcolor{comment}{    */}}
\DoxyCodeLine{5180     \textcolor{keywordflow}{if} (pWav-\/>onWrite != NULL) \{}
\DoxyCodeLine{5181         drwav\_uint32 paddingSize = 0;}
\DoxyCodeLine{5182 }
\DoxyCodeLine{5183         \textcolor{comment}{/* Padding. Do not adjust pWav-\/>dataChunkDataSize -\/ this should not include the padding. */}}
\DoxyCodeLine{5184         \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_riff || pWav-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{5185             paddingSize = drwav\_\_chunk\_padding\_size\_riff(pWav-\/>dataChunkDataSize);}
\DoxyCodeLine{5186         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5187             paddingSize = drwav\_\_chunk\_padding\_size\_w64(pWav-\/>dataChunkDataSize);}
\DoxyCodeLine{5188         \}}
\DoxyCodeLine{5189 }
\DoxyCodeLine{5190         \textcolor{keywordflow}{if} (paddingSize > 0) \{}
\DoxyCodeLine{5191             drwav\_uint64 paddingData = 0;}
\DoxyCodeLine{5192             drwav\_\_write(pWav, \&paddingData, paddingSize);  \textcolor{comment}{/* Byte order does not matter for this. */}}
\DoxyCodeLine{5193         \}}
\DoxyCodeLine{5194 }
\DoxyCodeLine{5195         \textcolor{comment}{/*}}
\DoxyCodeLine{5196 \textcolor{comment}{        Chunk sizes. When using sequential mode, these will have been filled in at initialization time. We only need}}
\DoxyCodeLine{5197 \textcolor{comment}{        to do this when using non-\/sequential mode.}}
\DoxyCodeLine{5198 \textcolor{comment}{        */}}
\DoxyCodeLine{5199         \textcolor{keywordflow}{if} (pWav-\/>onSeek \&\& !pWav-\/>isSequentialWrite) \{}
\DoxyCodeLine{5200             \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_riff) \{}
\DoxyCodeLine{5201                 \textcolor{comment}{/* The "{}RIFF"{} chunk size. */}}
\DoxyCodeLine{5202                 \textcolor{keywordflow}{if} (pWav-\/>onSeek(pWav-\/>pUserData, 4, drwav\_seek\_origin\_start)) \{}
\DoxyCodeLine{5203                     drwav\_uint32 riffChunkSize = drwav\_\_riff\_chunk\_size\_riff(pWav-\/>dataChunkDataSize, pWav-\/>pMetadata, pWav-\/>metadataCount);}
\DoxyCodeLine{5204                     drwav\_\_write\_u32ne\_to\_le(pWav, riffChunkSize);}
\DoxyCodeLine{5205                 \}}
\DoxyCodeLine{5206 }
\DoxyCodeLine{5207                 \textcolor{comment}{/* The "{}data"{} chunk size. */}}
\DoxyCodeLine{5208                 \textcolor{keywordflow}{if} (pWav-\/>onSeek(pWav-\/>pUserData, (\textcolor{keywordtype}{int})pWav-\/>dataChunkDataPos -\/ 4, drwav\_seek\_origin\_start)) \{}
\DoxyCodeLine{5209                     drwav\_uint32 dataChunkSize = drwav\_\_data\_chunk\_size\_riff(pWav-\/>dataChunkDataSize);}
\DoxyCodeLine{5210                     drwav\_\_write\_u32ne\_to\_le(pWav, dataChunkSize);}
\DoxyCodeLine{5211                 \}}
\DoxyCodeLine{5212             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_w64) \{}
\DoxyCodeLine{5213                 \textcolor{comment}{/* The "{}RIFF"{} chunk size. */}}
\DoxyCodeLine{5214                 \textcolor{keywordflow}{if} (pWav-\/>onSeek(pWav-\/>pUserData, 16, drwav\_seek\_origin\_start)) \{}
\DoxyCodeLine{5215                     drwav\_uint64 riffChunkSize = drwav\_\_riff\_chunk\_size\_w64(pWav-\/>dataChunkDataSize);}
\DoxyCodeLine{5216                     drwav\_\_write\_u64ne\_to\_le(pWav, riffChunkSize);}
\DoxyCodeLine{5217                 \}}
\DoxyCodeLine{5218 }
\DoxyCodeLine{5219                 \textcolor{comment}{/* The "{}data"{} chunk size. */}}
\DoxyCodeLine{5220                 \textcolor{keywordflow}{if} (pWav-\/>onSeek(pWav-\/>pUserData, (\textcolor{keywordtype}{int})pWav-\/>dataChunkDataPos -\/ 8, drwav\_seek\_origin\_start)) \{}
\DoxyCodeLine{5221                     drwav\_uint64 dataChunkSize = drwav\_\_data\_chunk\_size\_w64(pWav-\/>dataChunkDataSize);}
\DoxyCodeLine{5222                     drwav\_\_write\_u64ne\_to\_le(pWav, dataChunkSize);}
\DoxyCodeLine{5223                 \}}
\DoxyCodeLine{5224             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pWav-\/>container == drwav\_container\_rf64) \{}
\DoxyCodeLine{5225                 \textcolor{comment}{/* We only need to update the ds64 chunk. The "{}RIFF"{} and "{}data"{} chunks always have their sizes set to 0xFFFFFFFF for RF64. */}}
\DoxyCodeLine{5226                 \textcolor{keywordtype}{int} ds64BodyPos = 12 + 8;}
\DoxyCodeLine{5227 }
\DoxyCodeLine{5228                 \textcolor{comment}{/* The "{}RIFF"{} chunk size. */}}
\DoxyCodeLine{5229                 \textcolor{keywordflow}{if} (pWav-\/>onSeek(pWav-\/>pUserData, ds64BodyPos + 0, drwav\_seek\_origin\_start)) \{}
\DoxyCodeLine{5230                     drwav\_uint64 riffChunkSize = drwav\_\_riff\_chunk\_size\_rf64(pWav-\/>dataChunkDataSize, pWav-\/>pMetadata, pWav-\/>metadataCount);}
\DoxyCodeLine{5231                     drwav\_\_write\_u64ne\_to\_le(pWav, riffChunkSize);}
\DoxyCodeLine{5232                 \}}
\DoxyCodeLine{5233 }
\DoxyCodeLine{5234                 \textcolor{comment}{/* The "{}data"{} chunk size. */}}
\DoxyCodeLine{5235                 \textcolor{keywordflow}{if} (pWav-\/>onSeek(pWav-\/>pUserData, ds64BodyPos + 8, drwav\_seek\_origin\_start)) \{}
\DoxyCodeLine{5236                     drwav\_uint64 dataChunkSize = drwav\_\_data\_chunk\_size\_rf64(pWav-\/>dataChunkDataSize);}
\DoxyCodeLine{5237                     drwav\_\_write\_u64ne\_to\_le(pWav, dataChunkSize);}
\DoxyCodeLine{5238                 \}}
\DoxyCodeLine{5239             \}}
\DoxyCodeLine{5240         \}}
\DoxyCodeLine{5241 }
\DoxyCodeLine{5242         \textcolor{comment}{/* Validation for sequential mode. */}}
\DoxyCodeLine{5243         \textcolor{keywordflow}{if} (pWav-\/>isSequentialWrite) \{}
\DoxyCodeLine{5244             \textcolor{keywordflow}{if} (pWav-\/>dataChunkDataSize != pWav-\/>dataChunkDataSizeTargetWrite) \{}
\DoxyCodeLine{5245                 result = DRWAV\_INVALID\_FILE;}
\DoxyCodeLine{5246             \}}
\DoxyCodeLine{5247         \}}
\DoxyCodeLine{5248     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5249         \textcolor{keywordflow}{if} (pWav-\/>pMetadata != NULL) \{}
\DoxyCodeLine{5250             pWav-\/>allocationCallbacks.onFree(pWav-\/>pMetadata, pWav-\/>allocationCallbacks.pUserData);}
\DoxyCodeLine{5251         \}}
\DoxyCodeLine{5252     \}}
\DoxyCodeLine{5253 }
\DoxyCodeLine{5254 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_STDIO}}
\DoxyCodeLine{5255     \textcolor{comment}{/*}}
\DoxyCodeLine{5256 \textcolor{comment}{    If we opened the file with drwav\_open\_file() we will want to close the file handle. We can know whether or not drwav\_open\_file()}}
\DoxyCodeLine{5257 \textcolor{comment}{    was used by looking at the onRead and onSeek callbacks.}}
\DoxyCodeLine{5258 \textcolor{comment}{    */}}
\DoxyCodeLine{5259     \textcolor{keywordflow}{if} (pWav-\/>onRead == drwav\_\_on\_read\_stdio || pWav-\/>onWrite == drwav\_\_on\_write\_stdio) \{}
\DoxyCodeLine{5260         fclose((FILE*)pWav-\/>pUserData);}
\DoxyCodeLine{5261     \}}
\DoxyCodeLine{5262 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5263 }
\DoxyCodeLine{5264     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{5265 \}}
\DoxyCodeLine{5266 }
\DoxyCodeLine{5267 }
\DoxyCodeLine{5268 }
\DoxyCodeLine{5269 DRWAV\_API \textcolor{keywordtype}{size\_t} drwav\_read\_raw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{size\_t} bytesToRead, \textcolor{keywordtype}{void}* pBufferOut)}
\DoxyCodeLine{5270 \{}
\DoxyCodeLine{5271     \textcolor{keywordtype}{size\_t} bytesRead;}
\DoxyCodeLine{5272     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{5273 }
\DoxyCodeLine{5274     \textcolor{keywordflow}{if} (pWav == NULL || bytesToRead == 0) \{}
\DoxyCodeLine{5275         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Invalid args. */}}
\DoxyCodeLine{5276     \}}
\DoxyCodeLine{5277 }
\DoxyCodeLine{5278     \textcolor{keywordflow}{if} (bytesToRead > pWav-\/>bytesRemaining) \{}
\DoxyCodeLine{5279         bytesToRead = (size\_t)pWav-\/>bytesRemaining;}
\DoxyCodeLine{5280     \}}
\DoxyCodeLine{5281 }
\DoxyCodeLine{5282     \textcolor{keywordflow}{if} (bytesToRead == 0) \{}
\DoxyCodeLine{5283         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* At end. */}}
\DoxyCodeLine{5284     \}}
\DoxyCodeLine{5285 }
\DoxyCodeLine{5286     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{5287     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{5288         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Could not determine the bytes per frame. */}}
\DoxyCodeLine{5289     \}}
\DoxyCodeLine{5290 }
\DoxyCodeLine{5291     \textcolor{keywordflow}{if} (pBufferOut != NULL) \{}
\DoxyCodeLine{5292         bytesRead = pWav-\/>onRead(pWav-\/>pUserData, pBufferOut, bytesToRead);}
\DoxyCodeLine{5293     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5294         \textcolor{comment}{/* We need to seek. If we fail, we need to read-\/and-\/discard to make sure we get a good byte count. */}}
\DoxyCodeLine{5295         bytesRead = 0;}
\DoxyCodeLine{5296         \textcolor{keywordflow}{while} (bytesRead < bytesToRead) \{}
\DoxyCodeLine{5297             \textcolor{keywordtype}{size\_t} bytesToSeek = (bytesToRead -\/ bytesRead);}
\DoxyCodeLine{5298             \textcolor{keywordflow}{if} (bytesToSeek > 0x7FFFFFFF) \{}
\DoxyCodeLine{5299                 bytesToSeek = 0x7FFFFFFF;}
\DoxyCodeLine{5300             \}}
\DoxyCodeLine{5301 }
\DoxyCodeLine{5302             \textcolor{keywordflow}{if} (pWav-\/>onSeek(pWav-\/>pUserData, (\textcolor{keywordtype}{int})bytesToSeek, drwav\_seek\_origin\_current) == DRWAV\_FALSE) \{}
\DoxyCodeLine{5303                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{5304             \}}
\DoxyCodeLine{5305 }
\DoxyCodeLine{5306             bytesRead += bytesToSeek;}
\DoxyCodeLine{5307         \}}
\DoxyCodeLine{5308 }
\DoxyCodeLine{5309         \textcolor{comment}{/* When we get here we may need to read-\/and-\/discard some data. */}}
\DoxyCodeLine{5310         \textcolor{keywordflow}{while} (bytesRead < bytesToRead) \{}
\DoxyCodeLine{5311             drwav\_uint8 buffer[4096];}
\DoxyCodeLine{5312             \textcolor{keywordtype}{size\_t} bytesSeeked;}
\DoxyCodeLine{5313             \textcolor{keywordtype}{size\_t} bytesToSeek = (bytesToRead -\/ bytesRead);}
\DoxyCodeLine{5314             \textcolor{keywordflow}{if} (bytesToSeek > \textcolor{keyword}{sizeof}(buffer)) \{}
\DoxyCodeLine{5315                 bytesToSeek = \textcolor{keyword}{sizeof}(buffer);}
\DoxyCodeLine{5316             \}}
\DoxyCodeLine{5317 }
\DoxyCodeLine{5318             bytesSeeked = pWav-\/>onRead(pWav-\/>pUserData, buffer, bytesToSeek);}
\DoxyCodeLine{5319             bytesRead += bytesSeeked;}
\DoxyCodeLine{5320 }
\DoxyCodeLine{5321             \textcolor{keywordflow}{if} (bytesSeeked < bytesToSeek) \{}
\DoxyCodeLine{5322                 \textcolor{keywordflow}{break};  \textcolor{comment}{/* Reached the end. */}}
\DoxyCodeLine{5323             \}}
\DoxyCodeLine{5324         \}}
\DoxyCodeLine{5325     \}}
\DoxyCodeLine{5326 }
\DoxyCodeLine{5327     pWav-\/>readCursorInPCMFrames += bytesRead / bytesPerFrame;}
\DoxyCodeLine{5328 }
\DoxyCodeLine{5329     pWav-\/>bytesRemaining -\/= bytesRead;}
\DoxyCodeLine{5330     \textcolor{keywordflow}{return} bytesRead;}
\DoxyCodeLine{5331 \}}
\DoxyCodeLine{5332 }
\DoxyCodeLine{5333 }
\DoxyCodeLine{5334 }
\DoxyCodeLine{5335 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{void}* pBufferOut)}
\DoxyCodeLine{5336 \{}
\DoxyCodeLine{5337     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{5338     drwav\_uint64 bytesToRead;   \textcolor{comment}{/* Intentionally uint64 instead of size\_t so we can do a check that we're not reading too much on 32-\/bit builds. */}}
\DoxyCodeLine{5339 }
\DoxyCodeLine{5340     \textcolor{keywordflow}{if} (pWav == NULL || framesToRead == 0) \{}
\DoxyCodeLine{5341         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5342     \}}
\DoxyCodeLine{5343 }
\DoxyCodeLine{5344     \textcolor{comment}{/* Cannot use this function for compressed formats. */}}
\DoxyCodeLine{5345     \textcolor{keywordflow}{if} (drwav\_\_is\_compressed\_format\_tag(pWav-\/>translatedFormatTag)) \{}
\DoxyCodeLine{5346         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5347     \}}
\DoxyCodeLine{5348 }
\DoxyCodeLine{5349     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{5350     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{5351         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5352     \}}
\DoxyCodeLine{5353 }
\DoxyCodeLine{5354     \textcolor{comment}{/* Don't try to read more samples than can potentially fit in the output buffer. */}}
\DoxyCodeLine{5355     bytesToRead = framesToRead * bytesPerFrame;}
\DoxyCodeLine{5356     \textcolor{keywordflow}{if} (bytesToRead > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{5357         bytesToRead = (DRWAV\_SIZE\_MAX / bytesPerFrame) * bytesPerFrame; \textcolor{comment}{/* Round the number of bytes to read to a clean frame boundary. */}}
\DoxyCodeLine{5358     \}}
\DoxyCodeLine{5359 }
\DoxyCodeLine{5360     \textcolor{comment}{/*}}
\DoxyCodeLine{5361 \textcolor{comment}{    Doing an explicit check here just to make it clear that we don't want to be attempt to read anything if there's no bytes to read. There}}
\DoxyCodeLine{5362 \textcolor{comment}{    *could* be a time where it evaluates to 0 due to overflowing.}}
\DoxyCodeLine{5363 \textcolor{comment}{    */}}
\DoxyCodeLine{5364     \textcolor{keywordflow}{if} (bytesToRead == 0) \{}
\DoxyCodeLine{5365         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5366     \}}
\DoxyCodeLine{5367 }
\DoxyCodeLine{5368     \textcolor{keywordflow}{return} drwav\_read\_raw(pWav, (\textcolor{keywordtype}{size\_t})bytesToRead, pBufferOut) / bytesPerFrame;}
\DoxyCodeLine{5369 \}}
\DoxyCodeLine{5370 }
\DoxyCodeLine{5371 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{void}* pBufferOut)}
\DoxyCodeLine{5372 \{}
\DoxyCodeLine{5373     drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_le(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{5374 }
\DoxyCodeLine{5375     \textcolor{keywordflow}{if} (pBufferOut != NULL) \{}
\DoxyCodeLine{5376         drwav\_uint32 bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{5377         \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{5378             \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Could not get the bytes per frame which means bytes per sample cannot be determined and we don't know how to byte swap. */}}
\DoxyCodeLine{5379         \}}
\DoxyCodeLine{5380 }
\DoxyCodeLine{5381         drwav\_\_bswap\_samples(pBufferOut, framesRead*pWav-\/>channels, bytesPerFrame/pWav-\/>channels, pWav-\/>translatedFormatTag);}
\DoxyCodeLine{5382     \}}
\DoxyCodeLine{5383 }
\DoxyCodeLine{5384     \textcolor{keywordflow}{return} framesRead;}
\DoxyCodeLine{5385 \}}
\DoxyCodeLine{5386 }
\DoxyCodeLine{5387 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{void}* pBufferOut)}
\DoxyCodeLine{5388 \{}
\DoxyCodeLine{5389     \textcolor{keywordflow}{if} (drwav\_\_is\_little\_endian()) \{}
\DoxyCodeLine{5390         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_le(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{5391     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5392         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_be(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{5393     \}}
\DoxyCodeLine{5394 \}}
\DoxyCodeLine{5395 }
\DoxyCodeLine{5396 }
\DoxyCodeLine{5397 }
\DoxyCodeLine{5398 DRWAV\_PRIVATE drwav\_bool32 drwav\_seek\_to\_first\_pcm\_frame(\mbox{\hyperlink{structdrwav}{drwav}}* pWav)}
\DoxyCodeLine{5399 \{}
\DoxyCodeLine{5400     \textcolor{keywordflow}{if} (pWav-\/>onWrite != NULL) \{}
\DoxyCodeLine{5401         \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* No seeking in write mode. */}}
\DoxyCodeLine{5402     \}}
\DoxyCodeLine{5403 }
\DoxyCodeLine{5404     \textcolor{keywordflow}{if} (!pWav-\/>onSeek(pWav-\/>pUserData, (\textcolor{keywordtype}{int})pWav-\/>dataChunkDataPos, drwav\_seek\_origin\_start)) \{}
\DoxyCodeLine{5405         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5406     \}}
\DoxyCodeLine{5407 }
\DoxyCodeLine{5408     \textcolor{keywordflow}{if} (drwav\_\_is\_compressed\_format\_tag(pWav-\/>translatedFormatTag)) \{}
\DoxyCodeLine{5409         \textcolor{comment}{/* Cached data needs to be cleared for compressed formats. */}}
\DoxyCodeLine{5410         \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM) \{}
\DoxyCodeLine{5411             DRWAV\_ZERO\_OBJECT(\&pWav-\/>msadpcm);}
\DoxyCodeLine{5412         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{5413             DRWAV\_ZERO\_OBJECT(\&pWav-\/>ima);}
\DoxyCodeLine{5414         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5415             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* If this assertion is triggered it means I've implemented a new compressed format but forgot to add a branch for it here. */}}
\DoxyCodeLine{5416         \}}
\DoxyCodeLine{5417     \}}
\DoxyCodeLine{5418 }
\DoxyCodeLine{5419     pWav-\/>readCursorInPCMFrames = 0;}
\DoxyCodeLine{5420     pWav-\/>bytesRemaining = pWav-\/>dataChunkDataSize;}
\DoxyCodeLine{5421 }
\DoxyCodeLine{5422     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{5423 \}}
\DoxyCodeLine{5424 }
\DoxyCodeLine{5425 DRWAV\_API drwav\_bool32 drwav\_seek\_to\_pcm\_frame(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 targetFrameIndex)}
\DoxyCodeLine{5426 \{}
\DoxyCodeLine{5427     \textcolor{comment}{/* Seeking should be compatible with wave files > 2GB. */}}
\DoxyCodeLine{5428 }
\DoxyCodeLine{5429     \textcolor{keywordflow}{if} (pWav == NULL || pWav-\/>onSeek == NULL) \{}
\DoxyCodeLine{5430         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5431     \}}
\DoxyCodeLine{5432 }
\DoxyCodeLine{5433     \textcolor{comment}{/* No seeking in write mode. */}}
\DoxyCodeLine{5434     \textcolor{keywordflow}{if} (pWav-\/>onWrite != NULL) \{}
\DoxyCodeLine{5435         \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5436     \}}
\DoxyCodeLine{5437 }
\DoxyCodeLine{5438     \textcolor{comment}{/* If there are no samples, just return DRWAV\_TRUE without doing anything. */}}
\DoxyCodeLine{5439     \textcolor{keywordflow}{if} (pWav-\/>totalPCMFrameCount == 0) \{}
\DoxyCodeLine{5440         \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{5441     \}}
\DoxyCodeLine{5442 }
\DoxyCodeLine{5443     \textcolor{comment}{/* Make sure the sample is clamped. */}}
\DoxyCodeLine{5444     \textcolor{keywordflow}{if} (targetFrameIndex >= pWav-\/>totalPCMFrameCount) \{}
\DoxyCodeLine{5445         targetFrameIndex  = pWav-\/>totalPCMFrameCount -\/ 1;}
\DoxyCodeLine{5446     \}}
\DoxyCodeLine{5447 }
\DoxyCodeLine{5448     \textcolor{comment}{/*}}
\DoxyCodeLine{5449 \textcolor{comment}{    For compressed formats we just use a slow generic seek. If we are seeking forward we just seek forward. If we are going backwards we need}}
\DoxyCodeLine{5450 \textcolor{comment}{    to seek back to the start.}}
\DoxyCodeLine{5451 \textcolor{comment}{    */}}
\DoxyCodeLine{5452     \textcolor{keywordflow}{if} (drwav\_\_is\_compressed\_format\_tag(pWav-\/>translatedFormatTag)) \{}
\DoxyCodeLine{5453         \textcolor{comment}{/* TODO: This can be optimized. */}}
\DoxyCodeLine{5454 }
\DoxyCodeLine{5455         \textcolor{comment}{/*}}
\DoxyCodeLine{5456 \textcolor{comment}{        If we're seeking forward it's simple -\/ just keep reading samples until we hit the sample we're requesting. If we're seeking backwards,}}
\DoxyCodeLine{5457 \textcolor{comment}{        we first need to seek back to the start and then just do the same thing as a forward seek.}}
\DoxyCodeLine{5458 \textcolor{comment}{        */}}
\DoxyCodeLine{5459         \textcolor{keywordflow}{if} (targetFrameIndex < pWav-\/>readCursorInPCMFrames) \{}
\DoxyCodeLine{5460             \textcolor{keywordflow}{if} (!drwav\_seek\_to\_first\_pcm\_frame(pWav)) \{}
\DoxyCodeLine{5461                 \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5462             \}}
\DoxyCodeLine{5463         \}}
\DoxyCodeLine{5464 }
\DoxyCodeLine{5465         \textcolor{keywordflow}{if} (targetFrameIndex > pWav-\/>readCursorInPCMFrames) \{}
\DoxyCodeLine{5466             drwav\_uint64 offsetInFrames = targetFrameIndex -\/ pWav-\/>readCursorInPCMFrames;}
\DoxyCodeLine{5467 }
\DoxyCodeLine{5468             drwav\_int16 devnull[2048];}
\DoxyCodeLine{5469             \textcolor{keywordflow}{while} (offsetInFrames > 0) \{}
\DoxyCodeLine{5470                 drwav\_uint64 framesRead = 0;}
\DoxyCodeLine{5471                 drwav\_uint64 framesToRead = offsetInFrames;}
\DoxyCodeLine{5472                 \textcolor{keywordflow}{if} (framesToRead > drwav\_countof(devnull)/pWav-\/>channels) \{}
\DoxyCodeLine{5473                     framesToRead = drwav\_countof(devnull)/pWav-\/>channels;}
\DoxyCodeLine{5474                 \}}
\DoxyCodeLine{5475 }
\DoxyCodeLine{5476                 \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM) \{}
\DoxyCodeLine{5477                     framesRead = drwav\_read\_pcm\_frames\_s16\_\_msadpcm(pWav, framesToRead, devnull);}
\DoxyCodeLine{5478                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{5479                     framesRead = drwav\_read\_pcm\_frames\_s16\_\_ima(pWav, framesToRead, devnull);}
\DoxyCodeLine{5480                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5481                     DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* If this assertion is triggered it means I've implemented a new compressed format but forgot to add a branch for it here. */}}
\DoxyCodeLine{5482                 \}}
\DoxyCodeLine{5483 }
\DoxyCodeLine{5484                 \textcolor{keywordflow}{if} (framesRead != framesToRead) \{}
\DoxyCodeLine{5485                     \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5486                 \}}
\DoxyCodeLine{5487 }
\DoxyCodeLine{5488                 offsetInFrames -\/= framesRead;}
\DoxyCodeLine{5489             \}}
\DoxyCodeLine{5490         \}}
\DoxyCodeLine{5491     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5492         drwav\_uint64 totalSizeInBytes;}
\DoxyCodeLine{5493         drwav\_uint64 currentBytePos;}
\DoxyCodeLine{5494         drwav\_uint64 targetBytePos;}
\DoxyCodeLine{5495         drwav\_uint64 offset;}
\DoxyCodeLine{5496         drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{5497 }
\DoxyCodeLine{5498         bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{5499         \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{5500             \textcolor{keywordflow}{return} DRWAV\_FALSE; \textcolor{comment}{/* Not able to calculate offset. */}}
\DoxyCodeLine{5501         \}}
\DoxyCodeLine{5502 }
\DoxyCodeLine{5503         totalSizeInBytes = pWav-\/>totalPCMFrameCount * bytesPerFrame;}
\DoxyCodeLine{5504         DRWAV\_ASSERT(totalSizeInBytes >= pWav-\/>bytesRemaining);}
\DoxyCodeLine{5505 }
\DoxyCodeLine{5506         currentBytePos = totalSizeInBytes -\/ pWav-\/>bytesRemaining;}
\DoxyCodeLine{5507         targetBytePos  = targetFrameIndex * bytesPerFrame;}
\DoxyCodeLine{5508 }
\DoxyCodeLine{5509         \textcolor{keywordflow}{if} (currentBytePos < targetBytePos) \{}
\DoxyCodeLine{5510             \textcolor{comment}{/* Offset forwards. */}}
\DoxyCodeLine{5511             offset = (targetBytePos -\/ currentBytePos);}
\DoxyCodeLine{5512         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5513             \textcolor{comment}{/* Offset backwards. */}}
\DoxyCodeLine{5514             \textcolor{keywordflow}{if} (!drwav\_seek\_to\_first\_pcm\_frame(pWav)) \{}
\DoxyCodeLine{5515                 \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5516             \}}
\DoxyCodeLine{5517             offset = targetBytePos;}
\DoxyCodeLine{5518         \}}
\DoxyCodeLine{5519 }
\DoxyCodeLine{5520         \textcolor{keywordflow}{while} (offset > 0) \{}
\DoxyCodeLine{5521             \textcolor{keywordtype}{int} offset32 = ((offset > INT\_MAX) ? INT\_MAX : (\textcolor{keywordtype}{int})offset);}
\DoxyCodeLine{5522             \textcolor{keywordflow}{if} (!pWav-\/>onSeek(pWav-\/>pUserData, offset32, drwav\_seek\_origin\_current)) \{}
\DoxyCodeLine{5523                 \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{5524             \}}
\DoxyCodeLine{5525 }
\DoxyCodeLine{5526             pWav-\/>readCursorInPCMFrames += offset32 / bytesPerFrame;}
\DoxyCodeLine{5527             pWav-\/>bytesRemaining        -\/= offset32;}
\DoxyCodeLine{5528             offset                      -\/= offset32;}
\DoxyCodeLine{5529         \}}
\DoxyCodeLine{5530     \}}
\DoxyCodeLine{5531 }
\DoxyCodeLine{5532     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{5533 \}}
\DoxyCodeLine{5534 }
\DoxyCodeLine{5535 DRWAV\_API drwav\_result drwav\_get\_cursor\_in\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64* pCursor)}
\DoxyCodeLine{5536 \{}
\DoxyCodeLine{5537     \textcolor{keywordflow}{if} (pCursor == NULL) \{}
\DoxyCodeLine{5538         \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{5539     \}}
\DoxyCodeLine{5540 }
\DoxyCodeLine{5541     *pCursor = 0;   \textcolor{comment}{/* Safety. */}}
\DoxyCodeLine{5542 }
\DoxyCodeLine{5543     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{5544         \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{5545     \}}
\DoxyCodeLine{5546 }
\DoxyCodeLine{5547     *pCursor = pWav-\/>readCursorInPCMFrames;}
\DoxyCodeLine{5548 }
\DoxyCodeLine{5549     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{5550 \}}
\DoxyCodeLine{5551 }
\DoxyCodeLine{5552 DRWAV\_API drwav\_result drwav\_get\_length\_in\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64* pLength)}
\DoxyCodeLine{5553 \{}
\DoxyCodeLine{5554     \textcolor{keywordflow}{if} (pLength == NULL) \{}
\DoxyCodeLine{5555         \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{5556     \}}
\DoxyCodeLine{5557 }
\DoxyCodeLine{5558     *pLength = 0;   \textcolor{comment}{/* Safety. */}}
\DoxyCodeLine{5559 }
\DoxyCodeLine{5560     \textcolor{keywordflow}{if} (pWav == NULL) \{}
\DoxyCodeLine{5561         \textcolor{keywordflow}{return} DRWAV\_INVALID\_ARGS;}
\DoxyCodeLine{5562     \}}
\DoxyCodeLine{5563 }
\DoxyCodeLine{5564     *pLength = pWav-\/>totalPCMFrameCount;}
\DoxyCodeLine{5565 }
\DoxyCodeLine{5566     \textcolor{keywordflow}{return} DRWAV\_SUCCESS;}
\DoxyCodeLine{5567 \}}
\DoxyCodeLine{5568 }
\DoxyCodeLine{5569 }
\DoxyCodeLine{5570 DRWAV\_API \textcolor{keywordtype}{size\_t} drwav\_write\_raw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{size\_t} bytesToWrite, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData)}
\DoxyCodeLine{5571 \{}
\DoxyCodeLine{5572     \textcolor{keywordtype}{size\_t} bytesWritten;}
\DoxyCodeLine{5573 }
\DoxyCodeLine{5574     \textcolor{keywordflow}{if} (pWav == NULL || bytesToWrite == 0 || pData == NULL) \{}
\DoxyCodeLine{5575         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5576     \}}
\DoxyCodeLine{5577 }
\DoxyCodeLine{5578     bytesWritten = pWav-\/>onWrite(pWav-\/>pUserData, pData, bytesToWrite);}
\DoxyCodeLine{5579     pWav-\/>dataChunkDataSize += bytesWritten;}
\DoxyCodeLine{5580 }
\DoxyCodeLine{5581     \textcolor{keywordflow}{return} bytesWritten;}
\DoxyCodeLine{5582 \}}
\DoxyCodeLine{5583 }
\DoxyCodeLine{5584 DRWAV\_API drwav\_uint64 drwav\_write\_pcm\_frames\_le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToWrite, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData)}
\DoxyCodeLine{5585 \{}
\DoxyCodeLine{5586     drwav\_uint64 bytesToWrite;}
\DoxyCodeLine{5587     drwav\_uint64 bytesWritten;}
\DoxyCodeLine{5588     \textcolor{keyword}{const} drwav\_uint8* pRunningData;}
\DoxyCodeLine{5589 }
\DoxyCodeLine{5590     \textcolor{keywordflow}{if} (pWav == NULL || framesToWrite == 0 || pData == NULL) \{}
\DoxyCodeLine{5591         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5592     \}}
\DoxyCodeLine{5593 }
\DoxyCodeLine{5594     bytesToWrite = ((framesToWrite * pWav-\/>channels * pWav-\/>bitsPerSample) / 8);}
\DoxyCodeLine{5595     \textcolor{keywordflow}{if} (bytesToWrite > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{5596         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5597     \}}
\DoxyCodeLine{5598 }
\DoxyCodeLine{5599     bytesWritten = 0;}
\DoxyCodeLine{5600     pRunningData = (\textcolor{keyword}{const} drwav\_uint8*)pData;}
\DoxyCodeLine{5601 }
\DoxyCodeLine{5602     \textcolor{keywordflow}{while} (bytesToWrite > 0) \{}
\DoxyCodeLine{5603         \textcolor{keywordtype}{size\_t} bytesJustWritten;}
\DoxyCodeLine{5604         drwav\_uint64 bytesToWriteThisIteration;}
\DoxyCodeLine{5605 }
\DoxyCodeLine{5606         bytesToWriteThisIteration = bytesToWrite;}
\DoxyCodeLine{5607         DRWAV\_ASSERT(bytesToWriteThisIteration <= DRWAV\_SIZE\_MAX);  \textcolor{comment}{/* <-\/-\/ This is checked above. */}}
\DoxyCodeLine{5608 }
\DoxyCodeLine{5609         bytesJustWritten = drwav\_write\_raw(pWav, (\textcolor{keywordtype}{size\_t})bytesToWriteThisIteration, pRunningData);}
\DoxyCodeLine{5610         \textcolor{keywordflow}{if} (bytesJustWritten == 0) \{}
\DoxyCodeLine{5611             \textcolor{keywordflow}{break};}
\DoxyCodeLine{5612         \}}
\DoxyCodeLine{5613 }
\DoxyCodeLine{5614         bytesToWrite -\/= bytesJustWritten;}
\DoxyCodeLine{5615         bytesWritten += bytesJustWritten;}
\DoxyCodeLine{5616         pRunningData += bytesJustWritten;}
\DoxyCodeLine{5617     \}}
\DoxyCodeLine{5618 }
\DoxyCodeLine{5619     \textcolor{keywordflow}{return} (bytesWritten * 8) / pWav-\/>bitsPerSample / pWav-\/>channels;}
\DoxyCodeLine{5620 \}}
\DoxyCodeLine{5621 }
\DoxyCodeLine{5622 DRWAV\_API drwav\_uint64 drwav\_write\_pcm\_frames\_be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToWrite, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData)}
\DoxyCodeLine{5623 \{}
\DoxyCodeLine{5624     drwav\_uint64 bytesToWrite;}
\DoxyCodeLine{5625     drwav\_uint64 bytesWritten;}
\DoxyCodeLine{5626     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{5627     \textcolor{keyword}{const} drwav\_uint8* pRunningData;}
\DoxyCodeLine{5628 }
\DoxyCodeLine{5629     \textcolor{keywordflow}{if} (pWav == NULL || framesToWrite == 0 || pData == NULL) \{}
\DoxyCodeLine{5630         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5631     \}}
\DoxyCodeLine{5632 }
\DoxyCodeLine{5633     bytesToWrite = ((framesToWrite * pWav-\/>channels * pWav-\/>bitsPerSample) / 8);}
\DoxyCodeLine{5634     \textcolor{keywordflow}{if} (bytesToWrite > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{5635         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{5636     \}}
\DoxyCodeLine{5637 }
\DoxyCodeLine{5638     bytesWritten = 0;}
\DoxyCodeLine{5639     pRunningData = (\textcolor{keyword}{const} drwav\_uint8*)pData;}
\DoxyCodeLine{5640 }
\DoxyCodeLine{5641     bytesPerSample = drwav\_get\_bytes\_per\_pcm\_frame(pWav) / pWav-\/>channels;}
\DoxyCodeLine{5642     \textcolor{keywordflow}{if} (bytesPerSample == 0) \{}
\DoxyCodeLine{5643         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Cannot determine bytes per sample, or bytes per sample is less than one byte. */}}
\DoxyCodeLine{5644     \}}
\DoxyCodeLine{5645 }
\DoxyCodeLine{5646     \textcolor{keywordflow}{while} (bytesToWrite > 0) \{}
\DoxyCodeLine{5647         drwav\_uint8 temp[4096];}
\DoxyCodeLine{5648         drwav\_uint32 sampleCount;}
\DoxyCodeLine{5649         \textcolor{keywordtype}{size\_t} bytesJustWritten;}
\DoxyCodeLine{5650         drwav\_uint64 bytesToWriteThisIteration;}
\DoxyCodeLine{5651 }
\DoxyCodeLine{5652         bytesToWriteThisIteration = bytesToWrite;}
\DoxyCodeLine{5653         DRWAV\_ASSERT(bytesToWriteThisIteration <= DRWAV\_SIZE\_MAX);  \textcolor{comment}{/* <-\/-\/ This is checked above. */}}
\DoxyCodeLine{5654 }
\DoxyCodeLine{5655         \textcolor{comment}{/*}}
\DoxyCodeLine{5656 \textcolor{comment}{        WAV files are always little-\/endian. We need to byte swap on big-\/endian architectures. Since our input buffer is read-\/only we need}}
\DoxyCodeLine{5657 \textcolor{comment}{        to use an intermediary buffer for the conversion.}}
\DoxyCodeLine{5658 \textcolor{comment}{        */}}
\DoxyCodeLine{5659         sampleCount = \textcolor{keyword}{sizeof}(temp)/bytesPerSample;}
\DoxyCodeLine{5660 }
\DoxyCodeLine{5661         \textcolor{keywordflow}{if} (bytesToWriteThisIteration > ((drwav\_uint64)sampleCount)*bytesPerSample) \{}
\DoxyCodeLine{5662             bytesToWriteThisIteration = ((drwav\_uint64)sampleCount)*bytesPerSample;}
\DoxyCodeLine{5663         \}}
\DoxyCodeLine{5664 }
\DoxyCodeLine{5665         DRWAV\_COPY\_MEMORY(temp, pRunningData, (\textcolor{keywordtype}{size\_t})bytesToWriteThisIteration);}
\DoxyCodeLine{5666         drwav\_\_bswap\_samples(temp, sampleCount, bytesPerSample, pWav-\/>translatedFormatTag);}
\DoxyCodeLine{5667 }
\DoxyCodeLine{5668         bytesJustWritten = drwav\_write\_raw(pWav, (\textcolor{keywordtype}{size\_t})bytesToWriteThisIteration, temp);}
\DoxyCodeLine{5669         \textcolor{keywordflow}{if} (bytesJustWritten == 0) \{}
\DoxyCodeLine{5670             \textcolor{keywordflow}{break};}
\DoxyCodeLine{5671         \}}
\DoxyCodeLine{5672 }
\DoxyCodeLine{5673         bytesToWrite -\/= bytesJustWritten;}
\DoxyCodeLine{5674         bytesWritten += bytesJustWritten;}
\DoxyCodeLine{5675         pRunningData += bytesJustWritten;}
\DoxyCodeLine{5676     \}}
\DoxyCodeLine{5677 }
\DoxyCodeLine{5678     \textcolor{keywordflow}{return} (bytesWritten * 8) / pWav-\/>bitsPerSample / pWav-\/>channels;}
\DoxyCodeLine{5679 \}}
\DoxyCodeLine{5680 }
\DoxyCodeLine{5681 DRWAV\_API drwav\_uint64 drwav\_write\_pcm\_frames(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToWrite, \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pData)}
\DoxyCodeLine{5682 \{}
\DoxyCodeLine{5683     \textcolor{keywordflow}{if} (drwav\_\_is\_little\_endian()) \{}
\DoxyCodeLine{5684         \textcolor{keywordflow}{return} drwav\_write\_pcm\_frames\_le(pWav, framesToWrite, pData);}
\DoxyCodeLine{5685     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5686         \textcolor{keywordflow}{return} drwav\_write\_pcm\_frames\_be(pWav, framesToWrite, pData);}
\DoxyCodeLine{5687     \}}
\DoxyCodeLine{5688 \}}
\DoxyCodeLine{5689 }
\DoxyCodeLine{5690 }
\DoxyCodeLine{5691 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s16\_\_msadpcm(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{5692 \{}
\DoxyCodeLine{5693     drwav\_uint64 totalFramesRead = 0;}
\DoxyCodeLine{5694 }
\DoxyCodeLine{5695     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{5696     DRWAV\_ASSERT(framesToRead > 0);}
\DoxyCodeLine{5697 }
\DoxyCodeLine{5698     \textcolor{comment}{/* TODO: Lots of room for optimization here. */}}
\DoxyCodeLine{5699 }
\DoxyCodeLine{5700     \textcolor{keywordflow}{while} (pWav-\/>readCursorInPCMFrames < pWav-\/>totalPCMFrameCount) \{}
\DoxyCodeLine{5701         DRWAV\_ASSERT(framesToRead > 0); \textcolor{comment}{/* This loop iteration will never get hit with framesToRead == 0 because it's asserted at the top, and we check for 0 inside the loop just below. */}}
\DoxyCodeLine{5702 }
\DoxyCodeLine{5703         \textcolor{comment}{/* If there are no cached frames we need to load a new block. */}}
\DoxyCodeLine{5704         \textcolor{keywordflow}{if} (pWav-\/>msadpcm.cachedFrameCount == 0 \&\& pWav-\/>msadpcm.bytesRemainingInBlock == 0) \{}
\DoxyCodeLine{5705             \textcolor{keywordflow}{if} (pWav-\/>channels == 1) \{}
\DoxyCodeLine{5706                 \textcolor{comment}{/* Mono. */}}
\DoxyCodeLine{5707                 drwav\_uint8 header[7];}
\DoxyCodeLine{5708                 \textcolor{keywordflow}{if} (pWav-\/>onRead(pWav-\/>pUserData, header, \textcolor{keyword}{sizeof}(header)) != \textcolor{keyword}{sizeof}(header)) \{}
\DoxyCodeLine{5709                     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{5710                 \}}
\DoxyCodeLine{5711                 pWav-\/>msadpcm.bytesRemainingInBlock = pWav-\/>fmt.blockAlign -\/ \textcolor{keyword}{sizeof}(header);}
\DoxyCodeLine{5712 }
\DoxyCodeLine{5713                 pWav-\/>msadpcm.predictor[0]     = header[0];}
\DoxyCodeLine{5714                 pWav-\/>msadpcm.delta[0]         = drwav\_bytes\_to\_s16(header + 1);}
\DoxyCodeLine{5715                 pWav-\/>msadpcm.prevFrames[0][1] = (drwav\_int32)drwav\_bytes\_to\_s16(header + 3);}
\DoxyCodeLine{5716                 pWav-\/>msadpcm.prevFrames[0][0] = (drwav\_int32)drwav\_bytes\_to\_s16(header + 5);}
\DoxyCodeLine{5717                 pWav-\/>msadpcm.cachedFrames[2]  = pWav-\/>msadpcm.prevFrames[0][0];}
\DoxyCodeLine{5718                 pWav-\/>msadpcm.cachedFrames[3]  = pWav-\/>msadpcm.prevFrames[0][1];}
\DoxyCodeLine{5719                 pWav-\/>msadpcm.cachedFrameCount = 2;}
\DoxyCodeLine{5720             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5721                 \textcolor{comment}{/* Stereo. */}}
\DoxyCodeLine{5722                 drwav\_uint8 header[14];}
\DoxyCodeLine{5723                 \textcolor{keywordflow}{if} (pWav-\/>onRead(pWav-\/>pUserData, header, \textcolor{keyword}{sizeof}(header)) != \textcolor{keyword}{sizeof}(header)) \{}
\DoxyCodeLine{5724                     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{5725                 \}}
\DoxyCodeLine{5726                 pWav-\/>msadpcm.bytesRemainingInBlock = pWav-\/>fmt.blockAlign -\/ \textcolor{keyword}{sizeof}(header);}
\DoxyCodeLine{5727 }
\DoxyCodeLine{5728                 pWav-\/>msadpcm.predictor[0] = header[0];}
\DoxyCodeLine{5729                 pWav-\/>msadpcm.predictor[1] = header[1];}
\DoxyCodeLine{5730                 pWav-\/>msadpcm.delta[0] = drwav\_bytes\_to\_s16(header + 2);}
\DoxyCodeLine{5731                 pWav-\/>msadpcm.delta[1] = drwav\_bytes\_to\_s16(header + 4);}
\DoxyCodeLine{5732                 pWav-\/>msadpcm.prevFrames[0][1] = (drwav\_int32)drwav\_bytes\_to\_s16(header + 6);}
\DoxyCodeLine{5733                 pWav-\/>msadpcm.prevFrames[1][1] = (drwav\_int32)drwav\_bytes\_to\_s16(header + 8);}
\DoxyCodeLine{5734                 pWav-\/>msadpcm.prevFrames[0][0] = (drwav\_int32)drwav\_bytes\_to\_s16(header + 10);}
\DoxyCodeLine{5735                 pWav-\/>msadpcm.prevFrames[1][0] = (drwav\_int32)drwav\_bytes\_to\_s16(header + 12);}
\DoxyCodeLine{5736 }
\DoxyCodeLine{5737                 pWav-\/>msadpcm.cachedFrames[0] = pWav-\/>msadpcm.prevFrames[0][0];}
\DoxyCodeLine{5738                 pWav-\/>msadpcm.cachedFrames[1] = pWav-\/>msadpcm.prevFrames[1][0];}
\DoxyCodeLine{5739                 pWav-\/>msadpcm.cachedFrames[2] = pWav-\/>msadpcm.prevFrames[0][1];}
\DoxyCodeLine{5740                 pWav-\/>msadpcm.cachedFrames[3] = pWav-\/>msadpcm.prevFrames[1][1];}
\DoxyCodeLine{5741                 pWav-\/>msadpcm.cachedFrameCount = 2;}
\DoxyCodeLine{5742             \}}
\DoxyCodeLine{5743         \}}
\DoxyCodeLine{5744 }
\DoxyCodeLine{5745         \textcolor{comment}{/* Output anything that's cached. */}}
\DoxyCodeLine{5746         \textcolor{keywordflow}{while} (framesToRead > 0 \&\& pWav-\/>msadpcm.cachedFrameCount > 0 \&\& pWav-\/>readCursorInPCMFrames < pWav-\/>totalPCMFrameCount) \{}
\DoxyCodeLine{5747             \textcolor{keywordflow}{if} (pBufferOut != NULL) \{}
\DoxyCodeLine{5748                 drwav\_uint32 iSample = 0;}
\DoxyCodeLine{5749                 \textcolor{keywordflow}{for} (iSample = 0; iSample < pWav-\/>channels; iSample += 1) \{}
\DoxyCodeLine{5750                     pBufferOut[iSample] = (drwav\_int16)pWav-\/>msadpcm.cachedFrames[(drwav\_countof(pWav-\/>msadpcm.cachedFrames) -\/ (pWav-\/>msadpcm.cachedFrameCount*pWav-\/>channels)) + iSample];}
\DoxyCodeLine{5751                 \}}
\DoxyCodeLine{5752 }
\DoxyCodeLine{5753                 pBufferOut += pWav-\/>channels;}
\DoxyCodeLine{5754             \}}
\DoxyCodeLine{5755 }
\DoxyCodeLine{5756             framesToRead    -\/= 1;}
\DoxyCodeLine{5757             totalFramesRead += 1;}
\DoxyCodeLine{5758             pWav-\/>readCursorInPCMFrames += 1;}
\DoxyCodeLine{5759             pWav-\/>msadpcm.cachedFrameCount -\/= 1;}
\DoxyCodeLine{5760         \}}
\DoxyCodeLine{5761 }
\DoxyCodeLine{5762         \textcolor{keywordflow}{if} (framesToRead == 0) \{}
\DoxyCodeLine{5763             \textcolor{keywordflow}{break};}
\DoxyCodeLine{5764         \}}
\DoxyCodeLine{5765 }
\DoxyCodeLine{5766 }
\DoxyCodeLine{5767         \textcolor{comment}{/*}}
\DoxyCodeLine{5768 \textcolor{comment}{        If there's nothing left in the cache, just go ahead and load more. If there's nothing left to load in the current block we just continue to the next}}
\DoxyCodeLine{5769 \textcolor{comment}{        loop iteration which will trigger the loading of a new block.}}
\DoxyCodeLine{5770 \textcolor{comment}{        */}}
\DoxyCodeLine{5771         \textcolor{keywordflow}{if} (pWav-\/>msadpcm.cachedFrameCount == 0) \{}
\DoxyCodeLine{5772             \textcolor{keywordflow}{if} (pWav-\/>msadpcm.bytesRemainingInBlock == 0) \{}
\DoxyCodeLine{5773                 \textcolor{keywordflow}{continue};}
\DoxyCodeLine{5774             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5775                 \textcolor{keyword}{static} drwav\_int32 adaptationTable[] = \{}
\DoxyCodeLine{5776                     230, 230, 230, 230, 307, 409, 512, 614,}
\DoxyCodeLine{5777                     768, 614, 512, 409, 307, 230, 230, 230}
\DoxyCodeLine{5778                 \};}
\DoxyCodeLine{5779                 \textcolor{keyword}{static} drwav\_int32 coeff1Table[] = \{ 256, 512, 0, 192, 240, 460,  392 \};}
\DoxyCodeLine{5780                 \textcolor{keyword}{static} drwav\_int32 coeff2Table[] = \{ 0,  -\/256, 0, 64,  0,  -\/208, -\/232 \};}
\DoxyCodeLine{5781 }
\DoxyCodeLine{5782                 drwav\_uint8 nibbles;}
\DoxyCodeLine{5783                 drwav\_int32 nibble0;}
\DoxyCodeLine{5784                 drwav\_int32 nibble1;}
\DoxyCodeLine{5785 }
\DoxyCodeLine{5786                 \textcolor{keywordflow}{if} (pWav-\/>onRead(pWav-\/>pUserData, \&nibbles, 1) != 1) \{}
\DoxyCodeLine{5787                     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{5788                 \}}
\DoxyCodeLine{5789                 pWav-\/>msadpcm.bytesRemainingInBlock -\/= 1;}
\DoxyCodeLine{5790 }
\DoxyCodeLine{5791                 \textcolor{comment}{/* TODO: Optimize away these if statements. */}}
\DoxyCodeLine{5792                 nibble0 = ((nibbles \& 0xF0) >> 4); \textcolor{keywordflow}{if} ((nibbles \& 0x80)) \{ nibble0 |= 0xFFFFFFF0UL; \}}
\DoxyCodeLine{5793                 nibble1 = ((nibbles \& 0x0F) >> 0); \textcolor{keywordflow}{if} ((nibbles \& 0x08)) \{ nibble1 |= 0xFFFFFFF0UL; \}}
\DoxyCodeLine{5794 }
\DoxyCodeLine{5795                 \textcolor{keywordflow}{if} (pWav-\/>channels == 1) \{}
\DoxyCodeLine{5796                     \textcolor{comment}{/* Mono. */}}
\DoxyCodeLine{5797                     drwav\_int32 newSample0;}
\DoxyCodeLine{5798                     drwav\_int32 newSample1;}
\DoxyCodeLine{5799 }
\DoxyCodeLine{5800                     newSample0  = ((pWav-\/>msadpcm.prevFrames[0][1] * coeff1Table[pWav-\/>msadpcm.predictor[0]]) + (pWav-\/>msadpcm.prevFrames[0][0] * coeff2Table[pWav-\/>msadpcm.predictor[0]])) >> 8;}
\DoxyCodeLine{5801                     newSample0 += nibble0 * pWav-\/>msadpcm.delta[0];}
\DoxyCodeLine{5802                     newSample0  = drwav\_clamp(newSample0, -\/32768, 32767);}
\DoxyCodeLine{5803 }
\DoxyCodeLine{5804                     pWav-\/>msadpcm.delta[0] = (adaptationTable[((nibbles \& 0xF0) >> 4)] * pWav-\/>msadpcm.delta[0]) >> 8;}
\DoxyCodeLine{5805                     \textcolor{keywordflow}{if} (pWav-\/>msadpcm.delta[0] < 16) \{}
\DoxyCodeLine{5806                         pWav-\/>msadpcm.delta[0] = 16;}
\DoxyCodeLine{5807                     \}}
\DoxyCodeLine{5808 }
\DoxyCodeLine{5809                     pWav-\/>msadpcm.prevFrames[0][0] = pWav-\/>msadpcm.prevFrames[0][1];}
\DoxyCodeLine{5810                     pWav-\/>msadpcm.prevFrames[0][1] = newSample0;}
\DoxyCodeLine{5811 }
\DoxyCodeLine{5812 }
\DoxyCodeLine{5813                     newSample1  = ((pWav-\/>msadpcm.prevFrames[0][1] * coeff1Table[pWav-\/>msadpcm.predictor[0]]) + (pWav-\/>msadpcm.prevFrames[0][0] * coeff2Table[pWav-\/>msadpcm.predictor[0]])) >> 8;}
\DoxyCodeLine{5814                     newSample1 += nibble1 * pWav-\/>msadpcm.delta[0];}
\DoxyCodeLine{5815                     newSample1  = drwav\_clamp(newSample1, -\/32768, 32767);}
\DoxyCodeLine{5816 }
\DoxyCodeLine{5817                     pWav-\/>msadpcm.delta[0] = (adaptationTable[((nibbles \& 0x0F) >> 0)] * pWav-\/>msadpcm.delta[0]) >> 8;}
\DoxyCodeLine{5818                     \textcolor{keywordflow}{if} (pWav-\/>msadpcm.delta[0] < 16) \{}
\DoxyCodeLine{5819                         pWav-\/>msadpcm.delta[0] = 16;}
\DoxyCodeLine{5820                     \}}
\DoxyCodeLine{5821 }
\DoxyCodeLine{5822                     pWav-\/>msadpcm.prevFrames[0][0] = pWav-\/>msadpcm.prevFrames[0][1];}
\DoxyCodeLine{5823                     pWav-\/>msadpcm.prevFrames[0][1] = newSample1;}
\DoxyCodeLine{5824 }
\DoxyCodeLine{5825 }
\DoxyCodeLine{5826                     pWav-\/>msadpcm.cachedFrames[2] = newSample0;}
\DoxyCodeLine{5827                     pWav-\/>msadpcm.cachedFrames[3] = newSample1;}
\DoxyCodeLine{5828                     pWav-\/>msadpcm.cachedFrameCount = 2;}
\DoxyCodeLine{5829                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5830                     \textcolor{comment}{/* Stereo. */}}
\DoxyCodeLine{5831                     drwav\_int32 newSample0;}
\DoxyCodeLine{5832                     drwav\_int32 newSample1;}
\DoxyCodeLine{5833 }
\DoxyCodeLine{5834                     \textcolor{comment}{/* Left. */}}
\DoxyCodeLine{5835                     newSample0  = ((pWav-\/>msadpcm.prevFrames[0][1] * coeff1Table[pWav-\/>msadpcm.predictor[0]]) + (pWav-\/>msadpcm.prevFrames[0][0] * coeff2Table[pWav-\/>msadpcm.predictor[0]])) >> 8;}
\DoxyCodeLine{5836                     newSample0 += nibble0 * pWav-\/>msadpcm.delta[0];}
\DoxyCodeLine{5837                     newSample0  = drwav\_clamp(newSample0, -\/32768, 32767);}
\DoxyCodeLine{5838 }
\DoxyCodeLine{5839                     pWav-\/>msadpcm.delta[0] = (adaptationTable[((nibbles \& 0xF0) >> 4)] * pWav-\/>msadpcm.delta[0]) >> 8;}
\DoxyCodeLine{5840                     \textcolor{keywordflow}{if} (pWav-\/>msadpcm.delta[0] < 16) \{}
\DoxyCodeLine{5841                         pWav-\/>msadpcm.delta[0] = 16;}
\DoxyCodeLine{5842                     \}}
\DoxyCodeLine{5843 }
\DoxyCodeLine{5844                     pWav-\/>msadpcm.prevFrames[0][0] = pWav-\/>msadpcm.prevFrames[0][1];}
\DoxyCodeLine{5845                     pWav-\/>msadpcm.prevFrames[0][1] = newSample0;}
\DoxyCodeLine{5846 }
\DoxyCodeLine{5847 }
\DoxyCodeLine{5848                     \textcolor{comment}{/* Right. */}}
\DoxyCodeLine{5849                     newSample1  = ((pWav-\/>msadpcm.prevFrames[1][1] * coeff1Table[pWav-\/>msadpcm.predictor[1]]) + (pWav-\/>msadpcm.prevFrames[1][0] * coeff2Table[pWav-\/>msadpcm.predictor[1]])) >> 8;}
\DoxyCodeLine{5850                     newSample1 += nibble1 * pWav-\/>msadpcm.delta[1];}
\DoxyCodeLine{5851                     newSample1  = drwav\_clamp(newSample1, -\/32768, 32767);}
\DoxyCodeLine{5852 }
\DoxyCodeLine{5853                     pWav-\/>msadpcm.delta[1] = (adaptationTable[((nibbles \& 0x0F) >> 0)] * pWav-\/>msadpcm.delta[1]) >> 8;}
\DoxyCodeLine{5854                     \textcolor{keywordflow}{if} (pWav-\/>msadpcm.delta[1] < 16) \{}
\DoxyCodeLine{5855                         pWav-\/>msadpcm.delta[1] = 16;}
\DoxyCodeLine{5856                     \}}
\DoxyCodeLine{5857 }
\DoxyCodeLine{5858                     pWav-\/>msadpcm.prevFrames[1][0] = pWav-\/>msadpcm.prevFrames[1][1];}
\DoxyCodeLine{5859                     pWav-\/>msadpcm.prevFrames[1][1] = newSample1;}
\DoxyCodeLine{5860 }
\DoxyCodeLine{5861                     pWav-\/>msadpcm.cachedFrames[2] = newSample0;}
\DoxyCodeLine{5862                     pWav-\/>msadpcm.cachedFrames[3] = newSample1;}
\DoxyCodeLine{5863                     pWav-\/>msadpcm.cachedFrameCount = 1;}
\DoxyCodeLine{5864                 \}}
\DoxyCodeLine{5865             \}}
\DoxyCodeLine{5866         \}}
\DoxyCodeLine{5867     \}}
\DoxyCodeLine{5868 }
\DoxyCodeLine{5869     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{5870 \}}
\DoxyCodeLine{5871 }
\DoxyCodeLine{5872 }
\DoxyCodeLine{5873 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s16\_\_ima(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{5874 \{}
\DoxyCodeLine{5875     drwav\_uint64 totalFramesRead = 0;}
\DoxyCodeLine{5876     drwav\_uint32 iChannel;}
\DoxyCodeLine{5877 }
\DoxyCodeLine{5878     \textcolor{keyword}{static} drwav\_int32 indexTable[16] = \{}
\DoxyCodeLine{5879         -\/1, -\/1, -\/1, -\/1, 2, 4, 6, 8,}
\DoxyCodeLine{5880         -\/1, -\/1, -\/1, -\/1, 2, 4, 6, 8}
\DoxyCodeLine{5881     \};}
\DoxyCodeLine{5882 }
\DoxyCodeLine{5883     \textcolor{keyword}{static} drwav\_int32 stepTable[89] = \{}
\DoxyCodeLine{5884         7,     8,     9,     10,    11,    12,    13,    14,    16,    17,}
\DoxyCodeLine{5885         19,    21,    23,    25,    28,    31,    34,    37,    41,    45,}
\DoxyCodeLine{5886         50,    55,    60,    66,    73,    80,    88,    97,    107,   118,}
\DoxyCodeLine{5887         130,   143,   157,   173,   190,   209,   230,   253,   279,   307,}
\DoxyCodeLine{5888         337,   371,   408,   449,   494,   544,   598,   658,   724,   796,}
\DoxyCodeLine{5889         876,   963,   1060,  1166,  1282,  1411,  1552,  1707,  1878,  2066,}
\DoxyCodeLine{5890         2272,  2499,  2749,  3024,  3327,  3660,  4026,  4428,  4871,  5358,}
\DoxyCodeLine{5891         5894,  6484,  7132,  7845,  8630,  9493,  10442, 11487, 12635, 13899,}
\DoxyCodeLine{5892         15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767}
\DoxyCodeLine{5893     \};}
\DoxyCodeLine{5894 }
\DoxyCodeLine{5895     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{5896     DRWAV\_ASSERT(framesToRead > 0);}
\DoxyCodeLine{5897 }
\DoxyCodeLine{5898     \textcolor{comment}{/* TODO: Lots of room for optimization here. */}}
\DoxyCodeLine{5899 }
\DoxyCodeLine{5900     \textcolor{keywordflow}{while} (pWav-\/>readCursorInPCMFrames < pWav-\/>totalPCMFrameCount) \{}
\DoxyCodeLine{5901         DRWAV\_ASSERT(framesToRead > 0); \textcolor{comment}{/* This loop iteration will never get hit with framesToRead == 0 because it's asserted at the top, and we check for 0 inside the loop just below. */}}
\DoxyCodeLine{5902 }
\DoxyCodeLine{5903         \textcolor{comment}{/* If there are no cached samples we need to load a new block. */}}
\DoxyCodeLine{5904         \textcolor{keywordflow}{if} (pWav-\/>ima.cachedFrameCount == 0 \&\& pWav-\/>ima.bytesRemainingInBlock == 0) \{}
\DoxyCodeLine{5905             \textcolor{keywordflow}{if} (pWav-\/>channels == 1) \{}
\DoxyCodeLine{5906                 \textcolor{comment}{/* Mono. */}}
\DoxyCodeLine{5907                 drwav\_uint8 header[4];}
\DoxyCodeLine{5908                 \textcolor{keywordflow}{if} (pWav-\/>onRead(pWav-\/>pUserData, header, \textcolor{keyword}{sizeof}(header)) != \textcolor{keyword}{sizeof}(header)) \{}
\DoxyCodeLine{5909                     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{5910                 \}}
\DoxyCodeLine{5911                 pWav-\/>ima.bytesRemainingInBlock = pWav-\/>fmt.blockAlign -\/ \textcolor{keyword}{sizeof}(header);}
\DoxyCodeLine{5912 }
\DoxyCodeLine{5913                 \textcolor{keywordflow}{if} (header[2] >= drwav\_countof(stepTable)) \{}
\DoxyCodeLine{5914                     pWav-\/>onSeek(pWav-\/>pUserData, pWav-\/>ima.bytesRemainingInBlock, drwav\_seek\_origin\_current);}
\DoxyCodeLine{5915                     pWav-\/>ima.bytesRemainingInBlock = 0;}
\DoxyCodeLine{5916                     \textcolor{keywordflow}{return} totalFramesRead; \textcolor{comment}{/* Invalid data. */}}
\DoxyCodeLine{5917                 \}}
\DoxyCodeLine{5918 }
\DoxyCodeLine{5919                 pWav-\/>ima.predictor[0] = drwav\_bytes\_to\_s16(header + 0);}
\DoxyCodeLine{5920                 pWav-\/>ima.stepIndex[0] = drwav\_clamp(header[2], 0, (drwav\_int32)drwav\_countof(stepTable)-\/1);    \textcolor{comment}{/* Clamp not necessary because we checked above, but adding here to silence a static analysis warning. */}}
\DoxyCodeLine{5921                 pWav-\/>ima.cachedFrames[drwav\_countof(pWav-\/>ima.cachedFrames) -\/ 1] = pWav-\/>ima.predictor[0];}
\DoxyCodeLine{5922                 pWav-\/>ima.cachedFrameCount = 1;}
\DoxyCodeLine{5923             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5924                 \textcolor{comment}{/* Stereo. */}}
\DoxyCodeLine{5925                 drwav\_uint8 header[8];}
\DoxyCodeLine{5926                 \textcolor{keywordflow}{if} (pWav-\/>onRead(pWav-\/>pUserData, header, \textcolor{keyword}{sizeof}(header)) != \textcolor{keyword}{sizeof}(header)) \{}
\DoxyCodeLine{5927                     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{5928                 \}}
\DoxyCodeLine{5929                 pWav-\/>ima.bytesRemainingInBlock = pWav-\/>fmt.blockAlign -\/ \textcolor{keyword}{sizeof}(header);}
\DoxyCodeLine{5930 }
\DoxyCodeLine{5931                 \textcolor{keywordflow}{if} (header[2] >= drwav\_countof(stepTable) || header[6] >= drwav\_countof(stepTable)) \{}
\DoxyCodeLine{5932                     pWav-\/>onSeek(pWav-\/>pUserData, pWav-\/>ima.bytesRemainingInBlock, drwav\_seek\_origin\_current);}
\DoxyCodeLine{5933                     pWav-\/>ima.bytesRemainingInBlock = 0;}
\DoxyCodeLine{5934                     \textcolor{keywordflow}{return} totalFramesRead; \textcolor{comment}{/* Invalid data. */}}
\DoxyCodeLine{5935                 \}}
\DoxyCodeLine{5936 }
\DoxyCodeLine{5937                 pWav-\/>ima.predictor[0] = drwav\_bytes\_to\_s16(header + 0);}
\DoxyCodeLine{5938                 pWav-\/>ima.stepIndex[0] = drwav\_clamp(header[2], 0, (drwav\_int32)drwav\_countof(stepTable)-\/1);    \textcolor{comment}{/* Clamp not necessary because we checked above, but adding here to silence a static analysis warning. */}}
\DoxyCodeLine{5939                 pWav-\/>ima.predictor[1] = drwav\_bytes\_to\_s16(header + 4);}
\DoxyCodeLine{5940                 pWav-\/>ima.stepIndex[1] = drwav\_clamp(header[6], 0, (drwav\_int32)drwav\_countof(stepTable)-\/1);    \textcolor{comment}{/* Clamp not necessary because we checked above, but adding here to silence a static analysis warning. */}}
\DoxyCodeLine{5941 }
\DoxyCodeLine{5942                 pWav-\/>ima.cachedFrames[drwav\_countof(pWav-\/>ima.cachedFrames) -\/ 2] = pWav-\/>ima.predictor[0];}
\DoxyCodeLine{5943                 pWav-\/>ima.cachedFrames[drwav\_countof(pWav-\/>ima.cachedFrames) -\/ 1] = pWav-\/>ima.predictor[1];}
\DoxyCodeLine{5944                 pWav-\/>ima.cachedFrameCount = 1;}
\DoxyCodeLine{5945             \}}
\DoxyCodeLine{5946         \}}
\DoxyCodeLine{5947 }
\DoxyCodeLine{5948         \textcolor{comment}{/* Output anything that's cached. */}}
\DoxyCodeLine{5949         \textcolor{keywordflow}{while} (framesToRead > 0 \&\& pWav-\/>ima.cachedFrameCount > 0 \&\& pWav-\/>readCursorInPCMFrames < pWav-\/>totalPCMFrameCount) \{}
\DoxyCodeLine{5950             \textcolor{keywordflow}{if} (pBufferOut != NULL) \{}
\DoxyCodeLine{5951                 drwav\_uint32 iSample;}
\DoxyCodeLine{5952                 \textcolor{keywordflow}{for} (iSample = 0; iSample < pWav-\/>channels; iSample += 1) \{}
\DoxyCodeLine{5953                     pBufferOut[iSample] = (drwav\_int16)pWav-\/>ima.cachedFrames[(drwav\_countof(pWav-\/>ima.cachedFrames) -\/ (pWav-\/>ima.cachedFrameCount*pWav-\/>channels)) + iSample];}
\DoxyCodeLine{5954                 \}}
\DoxyCodeLine{5955                 pBufferOut += pWav-\/>channels;}
\DoxyCodeLine{5956             \}}
\DoxyCodeLine{5957 }
\DoxyCodeLine{5958             framesToRead    -\/= 1;}
\DoxyCodeLine{5959             totalFramesRead += 1;}
\DoxyCodeLine{5960             pWav-\/>readCursorInPCMFrames += 1;}
\DoxyCodeLine{5961             pWav-\/>ima.cachedFrameCount -\/= 1;}
\DoxyCodeLine{5962         \}}
\DoxyCodeLine{5963 }
\DoxyCodeLine{5964         \textcolor{keywordflow}{if} (framesToRead == 0) \{}
\DoxyCodeLine{5965             \textcolor{keywordflow}{break};}
\DoxyCodeLine{5966         \}}
\DoxyCodeLine{5967 }
\DoxyCodeLine{5968         \textcolor{comment}{/*}}
\DoxyCodeLine{5969 \textcolor{comment}{        If there's nothing left in the cache, just go ahead and load more. If there's nothing left to load in the current block we just continue to the next}}
\DoxyCodeLine{5970 \textcolor{comment}{        loop iteration which will trigger the loading of a new block.}}
\DoxyCodeLine{5971 \textcolor{comment}{        */}}
\DoxyCodeLine{5972         \textcolor{keywordflow}{if} (pWav-\/>ima.cachedFrameCount == 0) \{}
\DoxyCodeLine{5973             \textcolor{keywordflow}{if} (pWav-\/>ima.bytesRemainingInBlock == 0) \{}
\DoxyCodeLine{5974                 \textcolor{keywordflow}{continue};}
\DoxyCodeLine{5975             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5976                 \textcolor{comment}{/*}}
\DoxyCodeLine{5977 \textcolor{comment}{                From what I can tell with stereo streams, it looks like every 4 bytes (8 samples) is for one channel. So it goes 4 bytes for the}}
\DoxyCodeLine{5978 \textcolor{comment}{                left channel, 4 bytes for the right channel.}}
\DoxyCodeLine{5979 \textcolor{comment}{                */}}
\DoxyCodeLine{5980                 pWav-\/>ima.cachedFrameCount = 8;}
\DoxyCodeLine{5981                 \textcolor{keywordflow}{for} (iChannel = 0; iChannel < pWav-\/>channels; ++iChannel) \{}
\DoxyCodeLine{5982                     drwav\_uint32 iByte;}
\DoxyCodeLine{5983                     drwav\_uint8 nibbles[4];}
\DoxyCodeLine{5984                     \textcolor{keywordflow}{if} (pWav-\/>onRead(pWav-\/>pUserData, \&nibbles, 4) != 4) \{}
\DoxyCodeLine{5985                         pWav-\/>ima.cachedFrameCount = 0;}
\DoxyCodeLine{5986                         \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{5987                     \}}
\DoxyCodeLine{5988                     pWav-\/>ima.bytesRemainingInBlock -\/= 4;}
\DoxyCodeLine{5989 }
\DoxyCodeLine{5990                     \textcolor{keywordflow}{for} (iByte = 0; iByte < 4; ++iByte) \{}
\DoxyCodeLine{5991                         drwav\_uint8 nibble0 = ((nibbles[iByte] \& 0x0F) >> 0);}
\DoxyCodeLine{5992                         drwav\_uint8 nibble1 = ((nibbles[iByte] \& 0xF0) >> 4);}
\DoxyCodeLine{5993 }
\DoxyCodeLine{5994                         drwav\_int32 step      = stepTable[pWav-\/>ima.stepIndex[iChannel]];}
\DoxyCodeLine{5995                         drwav\_int32 predictor = pWav-\/>ima.predictor[iChannel];}
\DoxyCodeLine{5996 }
\DoxyCodeLine{5997                         drwav\_int32      diff  = step >> 3;}
\DoxyCodeLine{5998                         \textcolor{keywordflow}{if} (nibble0 \& 1) diff += step >> 2;}
\DoxyCodeLine{5999                         \textcolor{keywordflow}{if} (nibble0 \& 2) diff += step >> 1;}
\DoxyCodeLine{6000                         \textcolor{keywordflow}{if} (nibble0 \& 4) diff += step;}
\DoxyCodeLine{6001                         \textcolor{keywordflow}{if} (nibble0 \& 8) diff  = -\/diff;}
\DoxyCodeLine{6002 }
\DoxyCodeLine{6003                         predictor = drwav\_clamp(predictor + diff, -\/32768, 32767);}
\DoxyCodeLine{6004                         pWav-\/>ima.predictor[iChannel] = predictor;}
\DoxyCodeLine{6005                         pWav-\/>ima.stepIndex[iChannel] = drwav\_clamp(pWav-\/>ima.stepIndex[iChannel] + indexTable[nibble0], 0, (drwav\_int32)drwav\_countof(stepTable)-\/1);}
\DoxyCodeLine{6006                         pWav-\/>ima.cachedFrames[(drwav\_countof(pWav-\/>ima.cachedFrames) -\/ (pWav-\/>ima.cachedFrameCount*pWav-\/>channels)) + (iByte*2+0)*pWav-\/>channels + iChannel] = predictor;}
\DoxyCodeLine{6007 }
\DoxyCodeLine{6008 }
\DoxyCodeLine{6009                         step      = stepTable[pWav-\/>ima.stepIndex[iChannel]];}
\DoxyCodeLine{6010                         predictor = pWav-\/>ima.predictor[iChannel];}
\DoxyCodeLine{6011 }
\DoxyCodeLine{6012                                          diff  = step >> 3;}
\DoxyCodeLine{6013                         if (nibble1 \& 1) diff += step >> 2;}
\DoxyCodeLine{6014                         \textcolor{keywordflow}{if} (nibble1 \& 2) diff += step >> 1;}
\DoxyCodeLine{6015                         \textcolor{keywordflow}{if} (nibble1 \& 4) diff += step;}
\DoxyCodeLine{6016                         \textcolor{keywordflow}{if} (nibble1 \& 8) diff  = -\/diff;}
\DoxyCodeLine{6017 }
\DoxyCodeLine{6018                         predictor = drwav\_clamp(predictor + diff, -\/32768, 32767);}
\DoxyCodeLine{6019                         pWav-\/>ima.predictor[iChannel] = predictor;}
\DoxyCodeLine{6020                         pWav-\/>ima.stepIndex[iChannel] = drwav\_clamp(pWav-\/>ima.stepIndex[iChannel] + indexTable[nibble1], 0, (drwav\_int32)drwav\_countof(stepTable)-\/1);}
\DoxyCodeLine{6021                         pWav-\/>ima.cachedFrames[(drwav\_countof(pWav-\/>ima.cachedFrames) -\/ (pWav-\/>ima.cachedFrameCount*pWav-\/>channels)) + (iByte*2+1)*pWav-\/>channels + iChannel] = predictor;}
\DoxyCodeLine{6022                     \}}
\DoxyCodeLine{6023                 \}}
\DoxyCodeLine{6024             \}}
\DoxyCodeLine{6025         \}}
\DoxyCodeLine{6026     \}}
\DoxyCodeLine{6027 }
\DoxyCodeLine{6028     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6029 \}}
\DoxyCodeLine{6030 }
\DoxyCodeLine{6031 }
\DoxyCodeLine{6032 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_CONVERSION\_API}}
\DoxyCodeLine{6033 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} g\_drwavAlawTable[256] = \{}
\DoxyCodeLine{6034     0xEA80, 0xEB80, 0xE880, 0xE980, 0xEE80, 0xEF80, 0xEC80, 0xED80, 0xE280, 0xE380, 0xE080, 0xE180, 0xE680, 0xE780, 0xE480, 0xE580,}
\DoxyCodeLine{6035     0xF540, 0xF5C0, 0xF440, 0xF4C0, 0xF740, 0xF7C0, 0xF640, 0xF6C0, 0xF140, 0xF1C0, 0xF040, 0xF0C0, 0xF340, 0xF3C0, 0xF240, 0xF2C0,}
\DoxyCodeLine{6036     0xAA00, 0xAE00, 0xA200, 0xA600, 0xBA00, 0xBE00, 0xB200, 0xB600, 0x8A00, 0x8E00, 0x8200, 0x8600, 0x9A00, 0x9E00, 0x9200, 0x9600,}
\DoxyCodeLine{6037     0xD500, 0xD700, 0xD100, 0xD300, 0xDD00, 0xDF00, 0xD900, 0xDB00, 0xC500, 0xC700, 0xC100, 0xC300, 0xCD00, 0xCF00, 0xC900, 0xCB00,}
\DoxyCodeLine{6038     0xFEA8, 0xFEB8, 0xFE88, 0xFE98, 0xFEE8, 0xFEF8, 0xFEC8, 0xFED8, 0xFE28, 0xFE38, 0xFE08, 0xFE18, 0xFE68, 0xFE78, 0xFE48, 0xFE58,}
\DoxyCodeLine{6039     0xFFA8, 0xFFB8, 0xFF88, 0xFF98, 0xFFE8, 0xFFF8, 0xFFC8, 0xFFD8, 0xFF28, 0xFF38, 0xFF08, 0xFF18, 0xFF68, 0xFF78, 0xFF48, 0xFF58,}
\DoxyCodeLine{6040     0xFAA0, 0xFAE0, 0xFA20, 0xFA60, 0xFBA0, 0xFBE0, 0xFB20, 0xFB60, 0xF8A0, 0xF8E0, 0xF820, 0xF860, 0xF9A0, 0xF9E0, 0xF920, 0xF960,}
\DoxyCodeLine{6041     0xFD50, 0xFD70, 0xFD10, 0xFD30, 0xFDD0, 0xFDF0, 0xFD90, 0xFDB0, 0xFC50, 0xFC70, 0xFC10, 0xFC30, 0xFCD0, 0xFCF0, 0xFC90, 0xFCB0,}
\DoxyCodeLine{6042     0x1580, 0x1480, 0x1780, 0x1680, 0x1180, 0x1080, 0x1380, 0x1280, 0x1D80, 0x1C80, 0x1F80, 0x1E80, 0x1980, 0x1880, 0x1B80, 0x1A80,}
\DoxyCodeLine{6043     0x0AC0, 0x0A40, 0x0BC0, 0x0B40, 0x08C0, 0x0840, 0x09C0, 0x0940, 0x0EC0, 0x0E40, 0x0FC0, 0x0F40, 0x0CC0, 0x0C40, 0x0DC0, 0x0D40,}
\DoxyCodeLine{6044     0x5600, 0x5200, 0x5E00, 0x5A00, 0x4600, 0x4200, 0x4E00, 0x4A00, 0x7600, 0x7200, 0x7E00, 0x7A00, 0x6600, 0x6200, 0x6E00, 0x6A00,}
\DoxyCodeLine{6045     0x2B00, 0x2900, 0x2F00, 0x2D00, 0x2300, 0x2100, 0x2700, 0x2500, 0x3B00, 0x3900, 0x3F00, 0x3D00, 0x3300, 0x3100, 0x3700, 0x3500,}
\DoxyCodeLine{6046     0x0158, 0x0148, 0x0178, 0x0168, 0x0118, 0x0108, 0x0138, 0x0128, 0x01D8, 0x01C8, 0x01F8, 0x01E8, 0x0198, 0x0188, 0x01B8, 0x01A8,}
\DoxyCodeLine{6047     0x0058, 0x0048, 0x0078, 0x0068, 0x0018, 0x0008, 0x0038, 0x0028, 0x00D8, 0x00C8, 0x00F8, 0x00E8, 0x0098, 0x0088, 0x00B8, 0x00A8,}
\DoxyCodeLine{6048     0x0560, 0x0520, 0x05E0, 0x05A0, 0x0460, 0x0420, 0x04E0, 0x04A0, 0x0760, 0x0720, 0x07E0, 0x07A0, 0x0660, 0x0620, 0x06E0, 0x06A0,}
\DoxyCodeLine{6049     0x02B0, 0x0290, 0x02F0, 0x02D0, 0x0230, 0x0210, 0x0270, 0x0250, 0x03B0, 0x0390, 0x03F0, 0x03D0, 0x0330, 0x0310, 0x0370, 0x0350}
\DoxyCodeLine{6050 \};}
\DoxyCodeLine{6051 }
\DoxyCodeLine{6052 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} g\_drwavMulawTable[256] = \{}
\DoxyCodeLine{6053     0x8284, 0x8684, 0x8A84, 0x8E84, 0x9284, 0x9684, 0x9A84, 0x9E84, 0xA284, 0xA684, 0xAA84, 0xAE84, 0xB284, 0xB684, 0xBA84, 0xBE84,}
\DoxyCodeLine{6054     0xC184, 0xC384, 0xC584, 0xC784, 0xC984, 0xCB84, 0xCD84, 0xCF84, 0xD184, 0xD384, 0xD584, 0xD784, 0xD984, 0xDB84, 0xDD84, 0xDF84,}
\DoxyCodeLine{6055     0xE104, 0xE204, 0xE304, 0xE404, 0xE504, 0xE604, 0xE704, 0xE804, 0xE904, 0xEA04, 0xEB04, 0xEC04, 0xED04, 0xEE04, 0xEF04, 0xF004,}
\DoxyCodeLine{6056     0xF0C4, 0xF144, 0xF1C4, 0xF244, 0xF2C4, 0xF344, 0xF3C4, 0xF444, 0xF4C4, 0xF544, 0xF5C4, 0xF644, 0xF6C4, 0xF744, 0xF7C4, 0xF844,}
\DoxyCodeLine{6057     0xF8A4, 0xF8E4, 0xF924, 0xF964, 0xF9A4, 0xF9E4, 0xFA24, 0xFA64, 0xFAA4, 0xFAE4, 0xFB24, 0xFB64, 0xFBA4, 0xFBE4, 0xFC24, 0xFC64,}
\DoxyCodeLine{6058     0xFC94, 0xFCB4, 0xFCD4, 0xFCF4, 0xFD14, 0xFD34, 0xFD54, 0xFD74, 0xFD94, 0xFDB4, 0xFDD4, 0xFDF4, 0xFE14, 0xFE34, 0xFE54, 0xFE74,}
\DoxyCodeLine{6059     0xFE8C, 0xFE9C, 0xFEAC, 0xFEBC, 0xFECC, 0xFEDC, 0xFEEC, 0xFEFC, 0xFF0C, 0xFF1C, 0xFF2C, 0xFF3C, 0xFF4C, 0xFF5C, 0xFF6C, 0xFF7C,}
\DoxyCodeLine{6060     0xFF88, 0xFF90, 0xFF98, 0xFFA0, 0xFFA8, 0xFFB0, 0xFFB8, 0xFFC0, 0xFFC8, 0xFFD0, 0xFFD8, 0xFFE0, 0xFFE8, 0xFFF0, 0xFFF8, 0x0000,}
\DoxyCodeLine{6061     0x7D7C, 0x797C, 0x757C, 0x717C, 0x6D7C, 0x697C, 0x657C, 0x617C, 0x5D7C, 0x597C, 0x557C, 0x517C, 0x4D7C, 0x497C, 0x457C, 0x417C,}
\DoxyCodeLine{6062     0x3E7C, 0x3C7C, 0x3A7C, 0x387C, 0x367C, 0x347C, 0x327C, 0x307C, 0x2E7C, 0x2C7C, 0x2A7C, 0x287C, 0x267C, 0x247C, 0x227C, 0x207C,}
\DoxyCodeLine{6063     0x1EFC, 0x1DFC, 0x1CFC, 0x1BFC, 0x1AFC, 0x19FC, 0x18FC, 0x17FC, 0x16FC, 0x15FC, 0x14FC, 0x13FC, 0x12FC, 0x11FC, 0x10FC, 0x0FFC,}
\DoxyCodeLine{6064     0x0F3C, 0x0EBC, 0x0E3C, 0x0DBC, 0x0D3C, 0x0CBC, 0x0C3C, 0x0BBC, 0x0B3C, 0x0ABC, 0x0A3C, 0x09BC, 0x093C, 0x08BC, 0x083C, 0x07BC,}
\DoxyCodeLine{6065     0x075C, 0x071C, 0x06DC, 0x069C, 0x065C, 0x061C, 0x05DC, 0x059C, 0x055C, 0x051C, 0x04DC, 0x049C, 0x045C, 0x041C, 0x03DC, 0x039C,}
\DoxyCodeLine{6066     0x036C, 0x034C, 0x032C, 0x030C, 0x02EC, 0x02CC, 0x02AC, 0x028C, 0x026C, 0x024C, 0x022C, 0x020C, 0x01EC, 0x01CC, 0x01AC, 0x018C,}
\DoxyCodeLine{6067     0x0174, 0x0164, 0x0154, 0x0144, 0x0134, 0x0124, 0x0114, 0x0104, 0x00F4, 0x00E4, 0x00D4, 0x00C4, 0x00B4, 0x00A4, 0x0094, 0x0084,}
\DoxyCodeLine{6068     0x0078, 0x0070, 0x0068, 0x0060, 0x0058, 0x0050, 0x0048, 0x0040, 0x0038, 0x0030, 0x0028, 0x0020, 0x0018, 0x0010, 0x0008, 0x0000}
\DoxyCodeLine{6069 \};}
\DoxyCodeLine{6070 }
\DoxyCodeLine{6071 \textcolor{keyword}{static} DRWAV\_INLINE drwav\_int16 drwav\_\_alaw\_to\_s16(drwav\_uint8 sampleIn)}
\DoxyCodeLine{6072 \{}
\DoxyCodeLine{6073     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{short})g\_drwavAlawTable[sampleIn];}
\DoxyCodeLine{6074 \}}
\DoxyCodeLine{6075 }
\DoxyCodeLine{6076 \textcolor{keyword}{static} DRWAV\_INLINE drwav\_int16 drwav\_\_mulaw\_to\_s16(drwav\_uint8 sampleIn)}
\DoxyCodeLine{6077 \{}
\DoxyCodeLine{6078     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{short})g\_drwavMulawTable[sampleIn];}
\DoxyCodeLine{6079 \}}
\DoxyCodeLine{6080 }
\DoxyCodeLine{6081 }
\DoxyCodeLine{6082 }
\DoxyCodeLine{6083 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_pcm\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} totalSampleCount, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bytesPerSample)}
\DoxyCodeLine{6084 \{}
\DoxyCodeLine{6085     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6086 }
\DoxyCodeLine{6087     \textcolor{comment}{/* Special case for 8-\/bit sample data because it's treated as unsigned. */}}
\DoxyCodeLine{6088     \textcolor{keywordflow}{if} (bytesPerSample == 1) \{}
\DoxyCodeLine{6089         drwav\_u8\_to\_s16(pOut, pIn, totalSampleCount);}
\DoxyCodeLine{6090         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6091     \}}
\DoxyCodeLine{6092 }
\DoxyCodeLine{6093 }
\DoxyCodeLine{6094     \textcolor{comment}{/* Slightly more optimal implementation for common formats. */}}
\DoxyCodeLine{6095     \textcolor{keywordflow}{if} (bytesPerSample == 2) \{}
\DoxyCodeLine{6096         \textcolor{keywordflow}{for} (i = 0; i < totalSampleCount; ++i) \{}
\DoxyCodeLine{6097            *pOut++ = ((\textcolor{keyword}{const} drwav\_int16*)pIn)[i];}
\DoxyCodeLine{6098         \}}
\DoxyCodeLine{6099         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6100     \}}
\DoxyCodeLine{6101     \textcolor{keywordflow}{if} (bytesPerSample == 3) \{}
\DoxyCodeLine{6102         drwav\_s24\_to\_s16(pOut, pIn, totalSampleCount);}
\DoxyCodeLine{6103         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6104     \}}
\DoxyCodeLine{6105     \textcolor{keywordflow}{if} (bytesPerSample == 4) \{}
\DoxyCodeLine{6106         drwav\_s32\_to\_s16(pOut, (\textcolor{keyword}{const} drwav\_int32*)pIn, totalSampleCount);}
\DoxyCodeLine{6107         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6108     \}}
\DoxyCodeLine{6109 }
\DoxyCodeLine{6110 }
\DoxyCodeLine{6111     \textcolor{comment}{/* Anything more than 64 bits per sample is not supported. */}}
\DoxyCodeLine{6112     \textcolor{keywordflow}{if} (bytesPerSample > 8) \{}
\DoxyCodeLine{6113         DRWAV\_ZERO\_MEMORY(pOut, totalSampleCount * \textcolor{keyword}{sizeof}(*pOut));}
\DoxyCodeLine{6114         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6115     \}}
\DoxyCodeLine{6116 }
\DoxyCodeLine{6117 }
\DoxyCodeLine{6118     \textcolor{comment}{/* Generic, slow converter. */}}
\DoxyCodeLine{6119     \textcolor{keywordflow}{for} (i = 0; i < totalSampleCount; ++i) \{}
\DoxyCodeLine{6120         drwav\_uint64 \mbox{\hyperlink{structsample}{sample}} = 0;}
\DoxyCodeLine{6121         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} shift  = (8 -\/ bytesPerSample) * 8;}
\DoxyCodeLine{6122 }
\DoxyCodeLine{6123         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j;}
\DoxyCodeLine{6124         \textcolor{keywordflow}{for} (j = 0; j < bytesPerSample; j += 1) \{}
\DoxyCodeLine{6125             DRWAV\_ASSERT(j < 8);}
\DoxyCodeLine{6126             \mbox{\hyperlink{structsample}{sample}} |= (drwav\_uint64)(pIn[j]) << shift;}
\DoxyCodeLine{6127             shift  += 8;}
\DoxyCodeLine{6128         \}}
\DoxyCodeLine{6129 }
\DoxyCodeLine{6130         pIn += j;}
\DoxyCodeLine{6131         *pOut++ = (drwav\_int16)((drwav\_int64)\mbox{\hyperlink{structsample}{sample}} >> 48);}
\DoxyCodeLine{6132     \}}
\DoxyCodeLine{6133 \}}
\DoxyCodeLine{6134 }
\DoxyCodeLine{6135 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_ieee\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} totalSampleCount, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bytesPerSample)}
\DoxyCodeLine{6136 \{}
\DoxyCodeLine{6137     \textcolor{keywordflow}{if} (bytesPerSample == 4) \{}
\DoxyCodeLine{6138         drwav\_f32\_to\_s16(pOut, (\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)pIn, totalSampleCount);}
\DoxyCodeLine{6139         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6140     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (bytesPerSample == 8) \{}
\DoxyCodeLine{6141         drwav\_f64\_to\_s16(pOut, (\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)pIn, totalSampleCount);}
\DoxyCodeLine{6142         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6143     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{6144         \textcolor{comment}{/* Only supporting 32-\/ and 64-\/bit float. Output silence in all other cases. Contributions welcome for 16-\/bit float. */}}
\DoxyCodeLine{6145         DRWAV\_ZERO\_MEMORY(pOut, totalSampleCount * \textcolor{keyword}{sizeof}(*pOut));}
\DoxyCodeLine{6146         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6147     \}}
\DoxyCodeLine{6148 \}}
\DoxyCodeLine{6149 }
\DoxyCodeLine{6150 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s16\_\_pcm(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{6151 \{}
\DoxyCodeLine{6152     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6153     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{6154     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{6155     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{6156     drwav\_uint64 samplesRead;}
\DoxyCodeLine{6157 }
\DoxyCodeLine{6158     \textcolor{comment}{/* Fast path. */}}
\DoxyCodeLine{6159     \textcolor{keywordflow}{if} ((pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_PCM \&\& pWav-\/>bitsPerSample == 16) || pBufferOut == NULL) \{}
\DoxyCodeLine{6160         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6161     \}}
\DoxyCodeLine{6162 }
\DoxyCodeLine{6163     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{6164     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{6165         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6166     \}}
\DoxyCodeLine{6167 }
\DoxyCodeLine{6168     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{6169     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{6170         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{6171     \}}
\DoxyCodeLine{6172 }
\DoxyCodeLine{6173     totalFramesRead = 0;}
\DoxyCodeLine{6174 }
\DoxyCodeLine{6175     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6176         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{6177         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{6178         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6179             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6180         \}}
\DoxyCodeLine{6181 }
\DoxyCodeLine{6182         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6183 }
\DoxyCodeLine{6184         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{6185         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{6186         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{6187             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{6188             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6189         \}}
\DoxyCodeLine{6190 }
\DoxyCodeLine{6191         drwav\_\_pcm\_to\_s16(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead, bytesPerSample);}
\DoxyCodeLine{6192 }
\DoxyCodeLine{6193         pBufferOut      += samplesRead;}
\DoxyCodeLine{6194         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6195         totalFramesRead += framesRead;}
\DoxyCodeLine{6196     \}}
\DoxyCodeLine{6197 }
\DoxyCodeLine{6198     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6199 \}}
\DoxyCodeLine{6200 }
\DoxyCodeLine{6201 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s16\_\_ieee(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{6202 \{}
\DoxyCodeLine{6203     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6204     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{6205     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{6206     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{6207     drwav\_uint64 samplesRead;}
\DoxyCodeLine{6208 }
\DoxyCodeLine{6209     \textcolor{keywordflow}{if} (pBufferOut == NULL) \{}
\DoxyCodeLine{6210         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, NULL);}
\DoxyCodeLine{6211     \}}
\DoxyCodeLine{6212 }
\DoxyCodeLine{6213     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{6214     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{6215         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6216     \}}
\DoxyCodeLine{6217 }
\DoxyCodeLine{6218     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{6219     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{6220         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{6221     \}}
\DoxyCodeLine{6222 }
\DoxyCodeLine{6223     totalFramesRead = 0;}
\DoxyCodeLine{6224 }
\DoxyCodeLine{6225     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6226         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{6227         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{6228         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6229             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6230         \}}
\DoxyCodeLine{6231 }
\DoxyCodeLine{6232         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6233 }
\DoxyCodeLine{6234         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{6235         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{6236         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{6237             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{6238             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6239         \}}
\DoxyCodeLine{6240 }
\DoxyCodeLine{6241         drwav\_\_ieee\_to\_s16(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead, bytesPerSample);    \textcolor{comment}{/* Safe cast. */}}
\DoxyCodeLine{6242 }
\DoxyCodeLine{6243         pBufferOut      += samplesRead;}
\DoxyCodeLine{6244         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6245         totalFramesRead += framesRead;}
\DoxyCodeLine{6246     \}}
\DoxyCodeLine{6247 }
\DoxyCodeLine{6248     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6249 \}}
\DoxyCodeLine{6250 }
\DoxyCodeLine{6251 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s16\_\_alaw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{6252 \{}
\DoxyCodeLine{6253     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6254     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{6255     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{6256     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{6257     drwav\_uint64 samplesRead;}
\DoxyCodeLine{6258 }
\DoxyCodeLine{6259     \textcolor{keywordflow}{if} (pBufferOut == NULL) \{}
\DoxyCodeLine{6260         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, NULL);}
\DoxyCodeLine{6261     \}}
\DoxyCodeLine{6262 }
\DoxyCodeLine{6263     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{6264     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{6265         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6266     \}}
\DoxyCodeLine{6267 }
\DoxyCodeLine{6268     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{6269     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{6270         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{6271     \}}
\DoxyCodeLine{6272 }
\DoxyCodeLine{6273     totalFramesRead = 0;}
\DoxyCodeLine{6274 }
\DoxyCodeLine{6275     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6276         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{6277         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{6278         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6279             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6280         \}}
\DoxyCodeLine{6281 }
\DoxyCodeLine{6282         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6283 }
\DoxyCodeLine{6284         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{6285         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{6286         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{6287             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{6288             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6289         \}}
\DoxyCodeLine{6290 }
\DoxyCodeLine{6291         drwav\_alaw\_to\_s16(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead);}
\DoxyCodeLine{6292 }
\DoxyCodeLine{6293         pBufferOut      += samplesRead;}
\DoxyCodeLine{6294         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6295         totalFramesRead += framesRead;}
\DoxyCodeLine{6296     \}}
\DoxyCodeLine{6297 }
\DoxyCodeLine{6298     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6299 \}}
\DoxyCodeLine{6300 }
\DoxyCodeLine{6301 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s16\_\_mulaw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{6302 \{}
\DoxyCodeLine{6303     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6304     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{6305     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{6306     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{6307     drwav\_uint64 samplesRead;}
\DoxyCodeLine{6308 }
\DoxyCodeLine{6309     \textcolor{keywordflow}{if} (pBufferOut == NULL) \{}
\DoxyCodeLine{6310         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, NULL);}
\DoxyCodeLine{6311     \}}
\DoxyCodeLine{6312 }
\DoxyCodeLine{6313     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{6314     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{6315         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6316     \}}
\DoxyCodeLine{6317 }
\DoxyCodeLine{6318     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{6319     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{6320         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{6321     \}}
\DoxyCodeLine{6322 }
\DoxyCodeLine{6323     totalFramesRead = 0;}
\DoxyCodeLine{6324 }
\DoxyCodeLine{6325     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6326         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{6327         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{6328         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6329             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6330         \}}
\DoxyCodeLine{6331 }
\DoxyCodeLine{6332         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6333 }
\DoxyCodeLine{6334         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{6335         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{6336         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{6337             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{6338             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6339         \}}
\DoxyCodeLine{6340 }
\DoxyCodeLine{6341         drwav\_mulaw\_to\_s16(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead);}
\DoxyCodeLine{6342 }
\DoxyCodeLine{6343         pBufferOut      += samplesRead;}
\DoxyCodeLine{6344         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6345         totalFramesRead += framesRead;}
\DoxyCodeLine{6346     \}}
\DoxyCodeLine{6347 }
\DoxyCodeLine{6348     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6349 \}}
\DoxyCodeLine{6350 }
\DoxyCodeLine{6351 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s16(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{6352 \{}
\DoxyCodeLine{6353     \textcolor{keywordflow}{if} (pWav == NULL || framesToRead == 0) \{}
\DoxyCodeLine{6354         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6355     \}}
\DoxyCodeLine{6356 }
\DoxyCodeLine{6357     \textcolor{keywordflow}{if} (pBufferOut == NULL) \{}
\DoxyCodeLine{6358         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, NULL);}
\DoxyCodeLine{6359     \}}
\DoxyCodeLine{6360 }
\DoxyCodeLine{6361     \textcolor{comment}{/* Don't try to read more samples than can potentially fit in the output buffer. */}}
\DoxyCodeLine{6362     \textcolor{keywordflow}{if} (framesToRead * pWav-\/>channels * \textcolor{keyword}{sizeof}(drwav\_int16) > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{6363         framesToRead = DRWAV\_SIZE\_MAX / \textcolor{keyword}{sizeof}(drwav\_int16) / pWav-\/>channels;}
\DoxyCodeLine{6364     \}}
\DoxyCodeLine{6365 }
\DoxyCodeLine{6366     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_PCM) \{}
\DoxyCodeLine{6367         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s16\_\_pcm(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6368     \}}
\DoxyCodeLine{6369 }
\DoxyCodeLine{6370     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_IEEE\_FLOAT) \{}
\DoxyCodeLine{6371         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s16\_\_ieee(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6372     \}}
\DoxyCodeLine{6373 }
\DoxyCodeLine{6374     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ALAW) \{}
\DoxyCodeLine{6375         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s16\_\_alaw(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6376     \}}
\DoxyCodeLine{6377 }
\DoxyCodeLine{6378     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_MULAW) \{}
\DoxyCodeLine{6379         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s16\_\_mulaw(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6380     \}}
\DoxyCodeLine{6381 }
\DoxyCodeLine{6382     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM) \{}
\DoxyCodeLine{6383         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s16\_\_msadpcm(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6384     \}}
\DoxyCodeLine{6385 }
\DoxyCodeLine{6386     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{6387         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s16\_\_ima(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6388     \}}
\DoxyCodeLine{6389 }
\DoxyCodeLine{6390     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6391 \}}
\DoxyCodeLine{6392 }
\DoxyCodeLine{6393 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s16le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{6394 \{}
\DoxyCodeLine{6395     drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_s16(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6396     \textcolor{keywordflow}{if} (pBufferOut != NULL \&\& drwav\_\_is\_little\_endian() == DRWAV\_FALSE) \{}
\DoxyCodeLine{6397         drwav\_\_bswap\_samples\_s16(pBufferOut, framesRead*pWav-\/>channels);}
\DoxyCodeLine{6398     \}}
\DoxyCodeLine{6399 }
\DoxyCodeLine{6400     \textcolor{keywordflow}{return} framesRead;}
\DoxyCodeLine{6401 \}}
\DoxyCodeLine{6402 }
\DoxyCodeLine{6403 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s16be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int16* pBufferOut)}
\DoxyCodeLine{6404 \{}
\DoxyCodeLine{6405     drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_s16(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6406     \textcolor{keywordflow}{if} (pBufferOut != NULL \&\& drwav\_\_is\_little\_endian() == DRWAV\_TRUE) \{}
\DoxyCodeLine{6407         drwav\_\_bswap\_samples\_s16(pBufferOut, framesRead*pWav-\/>channels);}
\DoxyCodeLine{6408     \}}
\DoxyCodeLine{6409 }
\DoxyCodeLine{6410     \textcolor{keywordflow}{return} framesRead;}
\DoxyCodeLine{6411 \}}
\DoxyCodeLine{6412 }
\DoxyCodeLine{6413 }
\DoxyCodeLine{6414 DRWAV\_API \textcolor{keywordtype}{void} drwav\_u8\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6415 \{}
\DoxyCodeLine{6416     \textcolor{keywordtype}{int} r;}
\DoxyCodeLine{6417     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6418     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6419         \textcolor{keywordtype}{int} x = pIn[i];}
\DoxyCodeLine{6420         r = x << 8;}
\DoxyCodeLine{6421         r = r -\/ 32768;}
\DoxyCodeLine{6422         pOut[i] = (short)r;}
\DoxyCodeLine{6423     \}}
\DoxyCodeLine{6424 \}}
\DoxyCodeLine{6425 }
\DoxyCodeLine{6426 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s24\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6427 \{}
\DoxyCodeLine{6428     \textcolor{keywordtype}{int} r;}
\DoxyCodeLine{6429     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6430     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6431         \textcolor{keywordtype}{int} x = ((int)(((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})(((\textcolor{keyword}{const} drwav\_uint8*)pIn)[i*3+0]) << 8) | ((\textcolor{keywordtype}{unsigned} int)(((\textcolor{keyword}{const} drwav\_uint8*)pIn)[i*3+1]) << 16) | ((\textcolor{keywordtype}{unsigned} int)(((\textcolor{keyword}{const} drwav\_uint8*)pIn)[i*3+2])) << 24)) >> 8;}
\DoxyCodeLine{6432         r = x >> 8;}
\DoxyCodeLine{6433         pOut[i] = (short)r;}
\DoxyCodeLine{6434     \}}
\DoxyCodeLine{6435 \}}
\DoxyCodeLine{6436 }
\DoxyCodeLine{6437 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s32\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_int32* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6438 \{}
\DoxyCodeLine{6439     \textcolor{keywordtype}{int} r;}
\DoxyCodeLine{6440     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6441     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6442         \textcolor{keywordtype}{int} x = pIn[i];}
\DoxyCodeLine{6443         r = x >> 16;}
\DoxyCodeLine{6444         pOut[i] = (short)r;}
\DoxyCodeLine{6445     \}}
\DoxyCodeLine{6446 \}}
\DoxyCodeLine{6447 }
\DoxyCodeLine{6448 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f32\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{float}* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6449 \{}
\DoxyCodeLine{6450     \textcolor{keywordtype}{int} r;}
\DoxyCodeLine{6451     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6452     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6453         \textcolor{keywordtype}{float} x = pIn[i];}
\DoxyCodeLine{6454         \textcolor{keywordtype}{float} c;}
\DoxyCodeLine{6455         c = ((x < -\/1) ? -\/1 : ((x > 1) ? 1 : x));}
\DoxyCodeLine{6456         c = c + 1;}
\DoxyCodeLine{6457         r = (int)(c * 32767.5f);}
\DoxyCodeLine{6458         r = r -\/ 32768;}
\DoxyCodeLine{6459         pOut[i] = (short)r;}
\DoxyCodeLine{6460     \}}
\DoxyCodeLine{6461 \}}
\DoxyCodeLine{6462 }
\DoxyCodeLine{6463 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f64\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{double}* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6464 \{}
\DoxyCodeLine{6465     \textcolor{keywordtype}{int} r;}
\DoxyCodeLine{6466     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6467     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6468         \textcolor{keywordtype}{double} x = pIn[i];}
\DoxyCodeLine{6469         \textcolor{keywordtype}{double} c;}
\DoxyCodeLine{6470         c = ((x < -\/1) ? -\/1 : ((x > 1) ? 1 : x));}
\DoxyCodeLine{6471         c = c + 1;}
\DoxyCodeLine{6472         r = (int)(c * 32767.5);}
\DoxyCodeLine{6473         r = r -\/ 32768;}
\DoxyCodeLine{6474         pOut[i] = (short)r;}
\DoxyCodeLine{6475     \}}
\DoxyCodeLine{6476 \}}
\DoxyCodeLine{6477 }
\DoxyCodeLine{6478 DRWAV\_API \textcolor{keywordtype}{void} drwav\_alaw\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6479 \{}
\DoxyCodeLine{6480     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6481     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6482         pOut[i] = drwav\_\_alaw\_to\_s16(pIn[i]);}
\DoxyCodeLine{6483     \}}
\DoxyCodeLine{6484 \}}
\DoxyCodeLine{6485 }
\DoxyCodeLine{6486 DRWAV\_API \textcolor{keywordtype}{void} drwav\_mulaw\_to\_s16(drwav\_int16* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6487 \{}
\DoxyCodeLine{6488     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6489     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6490         pOut[i] = drwav\_\_mulaw\_to\_s16(pIn[i]);}
\DoxyCodeLine{6491     \}}
\DoxyCodeLine{6492 \}}
\DoxyCodeLine{6493 }
\DoxyCodeLine{6494 }
\DoxyCodeLine{6495 }
\DoxyCodeLine{6496 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_pcm\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bytesPerSample)}
\DoxyCodeLine{6497 \{}
\DoxyCodeLine{6498     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{6499 }
\DoxyCodeLine{6500     \textcolor{comment}{/* Special case for 8-\/bit sample data because it's treated as unsigned. */}}
\DoxyCodeLine{6501     \textcolor{keywordflow}{if} (bytesPerSample == 1) \{}
\DoxyCodeLine{6502         drwav\_u8\_to\_f32(pOut, pIn, sampleCount);}
\DoxyCodeLine{6503         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6504     \}}
\DoxyCodeLine{6505 }
\DoxyCodeLine{6506     \textcolor{comment}{/* Slightly more optimal implementation for common formats. */}}
\DoxyCodeLine{6507     \textcolor{keywordflow}{if} (bytesPerSample == 2) \{}
\DoxyCodeLine{6508         drwav\_s16\_to\_f32(pOut, (\textcolor{keyword}{const} drwav\_int16*)pIn, sampleCount);}
\DoxyCodeLine{6509         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6510     \}}
\DoxyCodeLine{6511     \textcolor{keywordflow}{if} (bytesPerSample == 3) \{}
\DoxyCodeLine{6512         drwav\_s24\_to\_f32(pOut, pIn, sampleCount);}
\DoxyCodeLine{6513         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6514     \}}
\DoxyCodeLine{6515     \textcolor{keywordflow}{if} (bytesPerSample == 4) \{}
\DoxyCodeLine{6516         drwav\_s32\_to\_f32(pOut, (\textcolor{keyword}{const} drwav\_int32*)pIn, sampleCount);}
\DoxyCodeLine{6517         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6518     \}}
\DoxyCodeLine{6519 }
\DoxyCodeLine{6520 }
\DoxyCodeLine{6521     \textcolor{comment}{/* Anything more than 64 bits per sample is not supported. */}}
\DoxyCodeLine{6522     \textcolor{keywordflow}{if} (bytesPerSample > 8) \{}
\DoxyCodeLine{6523         DRWAV\_ZERO\_MEMORY(pOut, sampleCount * \textcolor{keyword}{sizeof}(*pOut));}
\DoxyCodeLine{6524         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6525     \}}
\DoxyCodeLine{6526 }
\DoxyCodeLine{6527 }
\DoxyCodeLine{6528     \textcolor{comment}{/* Generic, slow converter. */}}
\DoxyCodeLine{6529     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6530         drwav\_uint64 \mbox{\hyperlink{structsample}{sample}} = 0;}
\DoxyCodeLine{6531         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} shift  = (8 -\/ bytesPerSample) * 8;}
\DoxyCodeLine{6532 }
\DoxyCodeLine{6533         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j;}
\DoxyCodeLine{6534         \textcolor{keywordflow}{for} (j = 0; j < bytesPerSample; j += 1) \{}
\DoxyCodeLine{6535             DRWAV\_ASSERT(j < 8);}
\DoxyCodeLine{6536             \mbox{\hyperlink{structsample}{sample}} |= (drwav\_uint64)(pIn[j]) << shift;}
\DoxyCodeLine{6537             shift  += 8;}
\DoxyCodeLine{6538         \}}
\DoxyCodeLine{6539 }
\DoxyCodeLine{6540         pIn += j;}
\DoxyCodeLine{6541         *pOut++ = (float)((drwav\_int64)\mbox{\hyperlink{structsample}{sample}} / 9223372036854775807.0);}
\DoxyCodeLine{6542     \}}
\DoxyCodeLine{6543 \}}
\DoxyCodeLine{6544 }
\DoxyCodeLine{6545 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_ieee\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bytesPerSample)}
\DoxyCodeLine{6546 \{}
\DoxyCodeLine{6547     \textcolor{keywordflow}{if} (bytesPerSample == 4) \{}
\DoxyCodeLine{6548         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{6549         \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6550             *pOut++ = ((\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)pIn)[i];}
\DoxyCodeLine{6551         \}}
\DoxyCodeLine{6552         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6553     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (bytesPerSample == 8) \{}
\DoxyCodeLine{6554         drwav\_f64\_to\_f32(pOut, (\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)pIn, sampleCount);}
\DoxyCodeLine{6555         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6556     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{6557         \textcolor{comment}{/* Only supporting 32-\/ and 64-\/bit float. Output silence in all other cases. Contributions welcome for 16-\/bit float. */}}
\DoxyCodeLine{6558         DRWAV\_ZERO\_MEMORY(pOut, sampleCount * \textcolor{keyword}{sizeof}(*pOut));}
\DoxyCodeLine{6559         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6560     \}}
\DoxyCodeLine{6561 \}}
\DoxyCodeLine{6562 }
\DoxyCodeLine{6563 }
\DoxyCodeLine{6564 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_f32\_\_pcm(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut)}
\DoxyCodeLine{6565 \{}
\DoxyCodeLine{6566     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6567     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{6568     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{6569     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{6570     drwav\_uint64 samplesRead;}
\DoxyCodeLine{6571 }
\DoxyCodeLine{6572     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{6573     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{6574         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6575     \}}
\DoxyCodeLine{6576 }
\DoxyCodeLine{6577     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{6578     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{6579         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{6580     \}}
\DoxyCodeLine{6581 }
\DoxyCodeLine{6582     totalFramesRead = 0;}
\DoxyCodeLine{6583 }
\DoxyCodeLine{6584     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6585         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{6586         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{6587         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6588             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6589         \}}
\DoxyCodeLine{6590 }
\DoxyCodeLine{6591         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6592 }
\DoxyCodeLine{6593         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{6594         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{6595         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{6596             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{6597             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6598         \}}
\DoxyCodeLine{6599 }
\DoxyCodeLine{6600         drwav\_\_pcm\_to\_f32(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead, bytesPerSample);}
\DoxyCodeLine{6601 }
\DoxyCodeLine{6602         pBufferOut      += samplesRead;}
\DoxyCodeLine{6603         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6604         totalFramesRead += framesRead;}
\DoxyCodeLine{6605     \}}
\DoxyCodeLine{6606 }
\DoxyCodeLine{6607     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6608 \}}
\DoxyCodeLine{6609 }
\DoxyCodeLine{6610 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_f32\_\_msadpcm\_ima(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut)}
\DoxyCodeLine{6611 \{}
\DoxyCodeLine{6612     \textcolor{comment}{/*}}
\DoxyCodeLine{6613 \textcolor{comment}{    We're just going to borrow the implementation from the drwav\_read\_s16() since ADPCM is a little bit more complicated than other formats and I don't}}
\DoxyCodeLine{6614 \textcolor{comment}{    want to duplicate that code.}}
\DoxyCodeLine{6615 \textcolor{comment}{    */}}
\DoxyCodeLine{6616     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6617     drwav\_int16 samples16[2048];}
\DoxyCodeLine{6618 }
\DoxyCodeLine{6619     totalFramesRead = 0;}
\DoxyCodeLine{6620 }
\DoxyCodeLine{6621     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6622         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, drwav\_countof(samples16)/pWav-\/>channels);}
\DoxyCodeLine{6623         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_s16(pWav, framesToReadThisIteration, samples16);}
\DoxyCodeLine{6624         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6625             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6626         \}}
\DoxyCodeLine{6627 }
\DoxyCodeLine{6628         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6629 }
\DoxyCodeLine{6630         drwav\_s16\_to\_f32(pBufferOut, samples16, (\textcolor{keywordtype}{size\_t})(framesRead*pWav-\/>channels));   \textcolor{comment}{/* <-\/-\/ Safe cast because we're clamping to 2048. */}}
\DoxyCodeLine{6631 }
\DoxyCodeLine{6632         pBufferOut      += framesRead*pWav-\/>channels;}
\DoxyCodeLine{6633         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6634         totalFramesRead += framesRead;}
\DoxyCodeLine{6635     \}}
\DoxyCodeLine{6636 }
\DoxyCodeLine{6637     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6638 \}}
\DoxyCodeLine{6639 }
\DoxyCodeLine{6640 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_f32\_\_ieee(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut)}
\DoxyCodeLine{6641 \{}
\DoxyCodeLine{6642     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6643     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{6644     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{6645     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{6646     drwav\_uint64 samplesRead;}
\DoxyCodeLine{6647 }
\DoxyCodeLine{6648     \textcolor{comment}{/* Fast path. */}}
\DoxyCodeLine{6649     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_IEEE\_FLOAT \&\& pWav-\/>bitsPerSample == 32) \{}
\DoxyCodeLine{6650         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6651     \}}
\DoxyCodeLine{6652 }
\DoxyCodeLine{6653     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{6654     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{6655         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6656     \}}
\DoxyCodeLine{6657 }
\DoxyCodeLine{6658     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{6659     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{6660         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{6661     \}}
\DoxyCodeLine{6662 }
\DoxyCodeLine{6663     totalFramesRead = 0;}
\DoxyCodeLine{6664 }
\DoxyCodeLine{6665     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6666         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{6667         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{6668         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6669             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6670         \}}
\DoxyCodeLine{6671 }
\DoxyCodeLine{6672         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6673 }
\DoxyCodeLine{6674         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{6675         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{6676         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{6677             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{6678             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6679         \}}
\DoxyCodeLine{6680 }
\DoxyCodeLine{6681         drwav\_\_ieee\_to\_f32(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead, bytesPerSample);}
\DoxyCodeLine{6682 }
\DoxyCodeLine{6683         pBufferOut      += samplesRead;}
\DoxyCodeLine{6684         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6685         totalFramesRead += framesRead;}
\DoxyCodeLine{6686     \}}
\DoxyCodeLine{6687 }
\DoxyCodeLine{6688     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6689 \}}
\DoxyCodeLine{6690 }
\DoxyCodeLine{6691 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_f32\_\_alaw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut)}
\DoxyCodeLine{6692 \{}
\DoxyCodeLine{6693     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6694     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{6695     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{6696     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{6697     drwav\_uint64 samplesRead;}
\DoxyCodeLine{6698 }
\DoxyCodeLine{6699     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{6700     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{6701         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6702     \}}
\DoxyCodeLine{6703 }
\DoxyCodeLine{6704     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{6705     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{6706         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{6707     \}}
\DoxyCodeLine{6708 }
\DoxyCodeLine{6709     totalFramesRead = 0;}
\DoxyCodeLine{6710 }
\DoxyCodeLine{6711     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6712         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{6713         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{6714         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6715             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6716         \}}
\DoxyCodeLine{6717 }
\DoxyCodeLine{6718         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6719 }
\DoxyCodeLine{6720         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{6721         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{6722         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{6723             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{6724             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6725         \}}
\DoxyCodeLine{6726 }
\DoxyCodeLine{6727         drwav\_alaw\_to\_f32(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead);}
\DoxyCodeLine{6728 }
\DoxyCodeLine{6729         pBufferOut      += samplesRead;}
\DoxyCodeLine{6730         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6731         totalFramesRead += framesRead;}
\DoxyCodeLine{6732     \}}
\DoxyCodeLine{6733 }
\DoxyCodeLine{6734     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6735 \}}
\DoxyCodeLine{6736 }
\DoxyCodeLine{6737 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_f32\_\_mulaw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut)}
\DoxyCodeLine{6738 \{}
\DoxyCodeLine{6739     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{6740     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{6741     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{6742     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{6743     drwav\_uint64 samplesRead;}
\DoxyCodeLine{6744 }
\DoxyCodeLine{6745     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{6746     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{6747         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6748     \}}
\DoxyCodeLine{6749 }
\DoxyCodeLine{6750     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{6751     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{6752         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{6753     \}}
\DoxyCodeLine{6754 }
\DoxyCodeLine{6755     totalFramesRead = 0;}
\DoxyCodeLine{6756 }
\DoxyCodeLine{6757     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{6758         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{6759         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{6760         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{6761             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6762         \}}
\DoxyCodeLine{6763 }
\DoxyCodeLine{6764         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{6765 }
\DoxyCodeLine{6766         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{6767         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{6768         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{6769             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{6770             \textcolor{keywordflow}{break};}
\DoxyCodeLine{6771         \}}
\DoxyCodeLine{6772 }
\DoxyCodeLine{6773         drwav\_mulaw\_to\_f32(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead);}
\DoxyCodeLine{6774 }
\DoxyCodeLine{6775         pBufferOut      += samplesRead;}
\DoxyCodeLine{6776         framesToRead    -\/= framesRead;}
\DoxyCodeLine{6777         totalFramesRead += framesRead;}
\DoxyCodeLine{6778     \}}
\DoxyCodeLine{6779 }
\DoxyCodeLine{6780     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{6781 \}}
\DoxyCodeLine{6782 }
\DoxyCodeLine{6783 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_f32(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut)}
\DoxyCodeLine{6784 \{}
\DoxyCodeLine{6785     \textcolor{keywordflow}{if} (pWav == NULL || framesToRead == 0) \{}
\DoxyCodeLine{6786         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6787     \}}
\DoxyCodeLine{6788 }
\DoxyCodeLine{6789     \textcolor{keywordflow}{if} (pBufferOut == NULL) \{}
\DoxyCodeLine{6790         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, NULL);}
\DoxyCodeLine{6791     \}}
\DoxyCodeLine{6792 }
\DoxyCodeLine{6793     \textcolor{comment}{/* Don't try to read more samples than can potentially fit in the output buffer. */}}
\DoxyCodeLine{6794     \textcolor{keywordflow}{if} (framesToRead * pWav-\/>channels * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{6795         framesToRead = DRWAV\_SIZE\_MAX / \textcolor{keyword}{sizeof}(float) / pWav-\/>channels;}
\DoxyCodeLine{6796     \}}
\DoxyCodeLine{6797 }
\DoxyCodeLine{6798     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_PCM) \{}
\DoxyCodeLine{6799         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_f32\_\_pcm(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6800     \}}
\DoxyCodeLine{6801 }
\DoxyCodeLine{6802     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM || pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{6803         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_f32\_\_msadpcm\_ima(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6804     \}}
\DoxyCodeLine{6805 }
\DoxyCodeLine{6806     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_IEEE\_FLOAT) \{}
\DoxyCodeLine{6807         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_f32\_\_ieee(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6808     \}}
\DoxyCodeLine{6809 }
\DoxyCodeLine{6810     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ALAW) \{}
\DoxyCodeLine{6811         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_f32\_\_alaw(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6812     \}}
\DoxyCodeLine{6813 }
\DoxyCodeLine{6814     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_MULAW) \{}
\DoxyCodeLine{6815         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_f32\_\_mulaw(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6816     \}}
\DoxyCodeLine{6817 }
\DoxyCodeLine{6818     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{6819 \}}
\DoxyCodeLine{6820 }
\DoxyCodeLine{6821 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_f32le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut)}
\DoxyCodeLine{6822 \{}
\DoxyCodeLine{6823     drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_f32(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6824     \textcolor{keywordflow}{if} (pBufferOut != NULL \&\& drwav\_\_is\_little\_endian() == DRWAV\_FALSE) \{}
\DoxyCodeLine{6825         drwav\_\_bswap\_samples\_f32(pBufferOut, framesRead*pWav-\/>channels);}
\DoxyCodeLine{6826     \}}
\DoxyCodeLine{6827 }
\DoxyCodeLine{6828     \textcolor{keywordflow}{return} framesRead;}
\DoxyCodeLine{6829 \}}
\DoxyCodeLine{6830 }
\DoxyCodeLine{6831 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_f32be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, \textcolor{keywordtype}{float}* pBufferOut)}
\DoxyCodeLine{6832 \{}
\DoxyCodeLine{6833     drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_f32(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{6834     \textcolor{keywordflow}{if} (pBufferOut != NULL \&\& drwav\_\_is\_little\_endian() == DRWAV\_TRUE) \{}
\DoxyCodeLine{6835         drwav\_\_bswap\_samples\_f32(pBufferOut, framesRead*pWav-\/>channels);}
\DoxyCodeLine{6836     \}}
\DoxyCodeLine{6837 }
\DoxyCodeLine{6838     \textcolor{keywordflow}{return} framesRead;}
\DoxyCodeLine{6839 \}}
\DoxyCodeLine{6840 }
\DoxyCodeLine{6841 }
\DoxyCodeLine{6842 DRWAV\_API \textcolor{keywordtype}{void} drwav\_u8\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6843 \{}
\DoxyCodeLine{6844     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6845 }
\DoxyCodeLine{6846     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{6847         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6848     \}}
\DoxyCodeLine{6849 }
\DoxyCodeLine{6850 \textcolor{preprocessor}{\#ifdef DR\_WAV\_LIBSNDFILE\_COMPAT}}
\DoxyCodeLine{6851     \textcolor{comment}{/*}}
\DoxyCodeLine{6852 \textcolor{comment}{    It appears libsndfile uses slightly different logic for the u8 -\/> f32 conversion to dr\_wav, which in my opinion is incorrect. It appears}}
\DoxyCodeLine{6853 \textcolor{comment}{    libsndfile performs the conversion something like "{}f32 = (u8 / 256) * 2 -\/ 1"{}, however I think it should be "{}f32 = (u8 / 255) * 2 -\/ 1"{} (note}}
\DoxyCodeLine{6854 \textcolor{comment}{    the divisor of 256 vs 255). I use libsndfile as a benchmark for testing, so I'm therefore leaving this block here just for my automated}}
\DoxyCodeLine{6855 \textcolor{comment}{    correctness testing. This is disabled by default.}}
\DoxyCodeLine{6856 \textcolor{comment}{    */}}
\DoxyCodeLine{6857     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6858         *pOut++ = (pIn[i] / 256.0f) * 2 -\/ 1;}
\DoxyCodeLine{6859     \}}
\DoxyCodeLine{6860 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{6861     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6862         \textcolor{keywordtype}{float} x = pIn[i];}
\DoxyCodeLine{6863         x = x * 0.00784313725490196078f;    \textcolor{comment}{/* 0..255 to 0..2 */}}
\DoxyCodeLine{6864         x = x -\/ 1;                          \textcolor{comment}{/* 0..2 to -\/1..1 */}}
\DoxyCodeLine{6865 }
\DoxyCodeLine{6866         *pOut++ = x;}
\DoxyCodeLine{6867     \}}
\DoxyCodeLine{6868 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6869 \}}
\DoxyCodeLine{6870 }
\DoxyCodeLine{6871 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s16\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_int16* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6872 \{}
\DoxyCodeLine{6873     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6874 }
\DoxyCodeLine{6875     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{6876         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6877     \}}
\DoxyCodeLine{6878 }
\DoxyCodeLine{6879     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6880         *pOut++ = pIn[i] * 0.000030517578125f;}
\DoxyCodeLine{6881     \}}
\DoxyCodeLine{6882 \}}
\DoxyCodeLine{6883 }
\DoxyCodeLine{6884 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s24\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6885 \{}
\DoxyCodeLine{6886     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6887 }
\DoxyCodeLine{6888     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{6889         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6890     \}}
\DoxyCodeLine{6891 }
\DoxyCodeLine{6892     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6893         \textcolor{keywordtype}{double} x;}
\DoxyCodeLine{6894         drwav\_uint32 a = ((drwav\_uint32)(pIn[i*3+0]) <<  8);}
\DoxyCodeLine{6895         drwav\_uint32 b = ((drwav\_uint32)(pIn[i*3+1]) << 16);}
\DoxyCodeLine{6896         drwav\_uint32 c = ((drwav\_uint32)(pIn[i*3+2]) << 24);}
\DoxyCodeLine{6897 }
\DoxyCodeLine{6898         x = (double)((drwav\_int32)(a | b | c) >> 8);}
\DoxyCodeLine{6899         *pOut++ = (float)(x * 0.00000011920928955078125);}
\DoxyCodeLine{6900     \}}
\DoxyCodeLine{6901 \}}
\DoxyCodeLine{6902 }
\DoxyCodeLine{6903 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s32\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_int32* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6904 \{}
\DoxyCodeLine{6905     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6906     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{6907         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6908     \}}
\DoxyCodeLine{6909 }
\DoxyCodeLine{6910     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6911         *pOut++ = (float)(pIn[i] / 2147483648.0);}
\DoxyCodeLine{6912     \}}
\DoxyCodeLine{6913 \}}
\DoxyCodeLine{6914 }
\DoxyCodeLine{6915 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f64\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{double}* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6916 \{}
\DoxyCodeLine{6917     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6918 }
\DoxyCodeLine{6919     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{6920         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6921     \}}
\DoxyCodeLine{6922 }
\DoxyCodeLine{6923     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6924         *pOut++ = (float)pIn[i];}
\DoxyCodeLine{6925     \}}
\DoxyCodeLine{6926 \}}
\DoxyCodeLine{6927 }
\DoxyCodeLine{6928 DRWAV\_API \textcolor{keywordtype}{void} drwav\_alaw\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6929 \{}
\DoxyCodeLine{6930     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6931 }
\DoxyCodeLine{6932     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{6933         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6934     \}}
\DoxyCodeLine{6935 }
\DoxyCodeLine{6936     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6937         *pOut++ = drwav\_\_alaw\_to\_s16(pIn[i]) / 32768.0f;}
\DoxyCodeLine{6938     \}}
\DoxyCodeLine{6939 \}}
\DoxyCodeLine{6940 }
\DoxyCodeLine{6941 DRWAV\_API \textcolor{keywordtype}{void} drwav\_mulaw\_to\_f32(\textcolor{keywordtype}{float}* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{6942 \{}
\DoxyCodeLine{6943     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{6944 }
\DoxyCodeLine{6945     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{6946         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6947     \}}
\DoxyCodeLine{6948 }
\DoxyCodeLine{6949     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{6950         *pOut++ = drwav\_\_mulaw\_to\_s16(pIn[i]) / 32768.0f;}
\DoxyCodeLine{6951     \}}
\DoxyCodeLine{6952 \}}
\DoxyCodeLine{6953 }
\DoxyCodeLine{6954 }
\DoxyCodeLine{6955 }
\DoxyCodeLine{6956 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_pcm\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} totalSampleCount, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bytesPerSample)}
\DoxyCodeLine{6957 \{}
\DoxyCodeLine{6958     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{6959 }
\DoxyCodeLine{6960     \textcolor{comment}{/* Special case for 8-\/bit sample data because it's treated as unsigned. */}}
\DoxyCodeLine{6961     \textcolor{keywordflow}{if} (bytesPerSample == 1) \{}
\DoxyCodeLine{6962         drwav\_u8\_to\_s32(pOut, pIn, totalSampleCount);}
\DoxyCodeLine{6963         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6964     \}}
\DoxyCodeLine{6965 }
\DoxyCodeLine{6966     \textcolor{comment}{/* Slightly more optimal implementation for common formats. */}}
\DoxyCodeLine{6967     \textcolor{keywordflow}{if} (bytesPerSample == 2) \{}
\DoxyCodeLine{6968         drwav\_s16\_to\_s32(pOut, (\textcolor{keyword}{const} drwav\_int16*)pIn, totalSampleCount);}
\DoxyCodeLine{6969         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6970     \}}
\DoxyCodeLine{6971     \textcolor{keywordflow}{if} (bytesPerSample == 3) \{}
\DoxyCodeLine{6972         drwav\_s24\_to\_s32(pOut, pIn, totalSampleCount);}
\DoxyCodeLine{6973         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6974     \}}
\DoxyCodeLine{6975     \textcolor{keywordflow}{if} (bytesPerSample == 4) \{}
\DoxyCodeLine{6976         \textcolor{keywordflow}{for} (i = 0; i < totalSampleCount; ++i) \{}
\DoxyCodeLine{6977            *pOut++ = ((\textcolor{keyword}{const} drwav\_int32*)pIn)[i];}
\DoxyCodeLine{6978         \}}
\DoxyCodeLine{6979         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6980     \}}
\DoxyCodeLine{6981 }
\DoxyCodeLine{6982 }
\DoxyCodeLine{6983     \textcolor{comment}{/* Anything more than 64 bits per sample is not supported. */}}
\DoxyCodeLine{6984     \textcolor{keywordflow}{if} (bytesPerSample > 8) \{}
\DoxyCodeLine{6985         DRWAV\_ZERO\_MEMORY(pOut, totalSampleCount * \textcolor{keyword}{sizeof}(*pOut));}
\DoxyCodeLine{6986         \textcolor{keywordflow}{return};}
\DoxyCodeLine{6987     \}}
\DoxyCodeLine{6988 }
\DoxyCodeLine{6989 }
\DoxyCodeLine{6990     \textcolor{comment}{/* Generic, slow converter. */}}
\DoxyCodeLine{6991     \textcolor{keywordflow}{for} (i = 0; i < totalSampleCount; ++i) \{}
\DoxyCodeLine{6992         drwav\_uint64 \mbox{\hyperlink{structsample}{sample}} = 0;}
\DoxyCodeLine{6993         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} shift  = (8 -\/ bytesPerSample) * 8;}
\DoxyCodeLine{6994 }
\DoxyCodeLine{6995         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j;}
\DoxyCodeLine{6996         \textcolor{keywordflow}{for} (j = 0; j < bytesPerSample; j += 1) \{}
\DoxyCodeLine{6997             DRWAV\_ASSERT(j < 8);}
\DoxyCodeLine{6998             \mbox{\hyperlink{structsample}{sample}} |= (drwav\_uint64)(pIn[j]) << shift;}
\DoxyCodeLine{6999             shift  += 8;}
\DoxyCodeLine{7000         \}}
\DoxyCodeLine{7001 }
\DoxyCodeLine{7002         pIn += j;}
\DoxyCodeLine{7003         *pOut++ = (drwav\_int32)((drwav\_int64)\mbox{\hyperlink{structsample}{sample}} >> 32);}
\DoxyCodeLine{7004     \}}
\DoxyCodeLine{7005 \}}
\DoxyCodeLine{7006 }
\DoxyCodeLine{7007 DRWAV\_PRIVATE \textcolor{keywordtype}{void} drwav\_\_ieee\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} totalSampleCount, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bytesPerSample)}
\DoxyCodeLine{7008 \{}
\DoxyCodeLine{7009     \textcolor{keywordflow}{if} (bytesPerSample == 4) \{}
\DoxyCodeLine{7010         drwav\_f32\_to\_s32(pOut, (\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)pIn, totalSampleCount);}
\DoxyCodeLine{7011         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7012     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (bytesPerSample == 8) \{}
\DoxyCodeLine{7013         drwav\_f64\_to\_s32(pOut, (\textcolor{keyword}{const} \textcolor{keywordtype}{double}*)pIn, totalSampleCount);}
\DoxyCodeLine{7014         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7015     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{7016         \textcolor{comment}{/* Only supporting 32-\/ and 64-\/bit float. Output silence in all other cases. Contributions welcome for 16-\/bit float. */}}
\DoxyCodeLine{7017         DRWAV\_ZERO\_MEMORY(pOut, totalSampleCount * \textcolor{keyword}{sizeof}(*pOut));}
\DoxyCodeLine{7018         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7019     \}}
\DoxyCodeLine{7020 \}}
\DoxyCodeLine{7021 }
\DoxyCodeLine{7022 }
\DoxyCodeLine{7023 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s32\_\_pcm(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut)}
\DoxyCodeLine{7024 \{}
\DoxyCodeLine{7025     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{7026     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{7027     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{7028     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{7029     drwav\_uint64 samplesRead;}
\DoxyCodeLine{7030 }
\DoxyCodeLine{7031     \textcolor{comment}{/* Fast path. */}}
\DoxyCodeLine{7032     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_PCM \&\& pWav-\/>bitsPerSample == 32) \{}
\DoxyCodeLine{7033         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{7034     \}}
\DoxyCodeLine{7035 }
\DoxyCodeLine{7036     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{7037     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{7038         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7039     \}}
\DoxyCodeLine{7040 }
\DoxyCodeLine{7041     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{7042     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{7043         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{7044     \}}
\DoxyCodeLine{7045 }
\DoxyCodeLine{7046     totalFramesRead = 0;}
\DoxyCodeLine{7047 }
\DoxyCodeLine{7048     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{7049         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{7050         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{7051         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{7052             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7053         \}}
\DoxyCodeLine{7054 }
\DoxyCodeLine{7055         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{7056 }
\DoxyCodeLine{7057         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{7058         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{7059         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{7060             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{7061             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7062         \}}
\DoxyCodeLine{7063 }
\DoxyCodeLine{7064         drwav\_\_pcm\_to\_s32(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead, bytesPerSample);}
\DoxyCodeLine{7065 }
\DoxyCodeLine{7066         pBufferOut      += samplesRead;}
\DoxyCodeLine{7067         framesToRead    -\/= framesRead;}
\DoxyCodeLine{7068         totalFramesRead += framesRead;}
\DoxyCodeLine{7069     \}}
\DoxyCodeLine{7070 }
\DoxyCodeLine{7071     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{7072 \}}
\DoxyCodeLine{7073 }
\DoxyCodeLine{7074 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s32\_\_msadpcm\_ima(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut)}
\DoxyCodeLine{7075 \{}
\DoxyCodeLine{7076     \textcolor{comment}{/*}}
\DoxyCodeLine{7077 \textcolor{comment}{    We're just going to borrow the implementation from the drwav\_read\_s16() since ADPCM is a little bit more complicated than other formats and I don't}}
\DoxyCodeLine{7078 \textcolor{comment}{    want to duplicate that code.}}
\DoxyCodeLine{7079 \textcolor{comment}{    */}}
\DoxyCodeLine{7080     drwav\_uint64 totalFramesRead = 0;}
\DoxyCodeLine{7081     drwav\_int16 samples16[2048];}
\DoxyCodeLine{7082 }
\DoxyCodeLine{7083     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{7084         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, drwav\_countof(samples16)/pWav-\/>channels);}
\DoxyCodeLine{7085         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_s16(pWav, framesToReadThisIteration, samples16);}
\DoxyCodeLine{7086         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{7087             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7088         \}}
\DoxyCodeLine{7089 }
\DoxyCodeLine{7090         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{7091 }
\DoxyCodeLine{7092         drwav\_s16\_to\_s32(pBufferOut, samples16, (\textcolor{keywordtype}{size\_t})(framesRead*pWav-\/>channels));   \textcolor{comment}{/* <-\/-\/ Safe cast because we're clamping to 2048. */}}
\DoxyCodeLine{7093 }
\DoxyCodeLine{7094         pBufferOut      += framesRead*pWav-\/>channels;}
\DoxyCodeLine{7095         framesToRead    -\/= framesRead;}
\DoxyCodeLine{7096         totalFramesRead += framesRead;}
\DoxyCodeLine{7097     \}}
\DoxyCodeLine{7098 }
\DoxyCodeLine{7099     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{7100 \}}
\DoxyCodeLine{7101 }
\DoxyCodeLine{7102 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s32\_\_ieee(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut)}
\DoxyCodeLine{7103 \{}
\DoxyCodeLine{7104     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{7105     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{7106     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{7107     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{7108     drwav\_uint64 samplesRead;}
\DoxyCodeLine{7109 }
\DoxyCodeLine{7110     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{7111     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{7112         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7113     \}}
\DoxyCodeLine{7114 }
\DoxyCodeLine{7115     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{7116     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{7117         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{7118     \}}
\DoxyCodeLine{7119 }
\DoxyCodeLine{7120     totalFramesRead = 0;}
\DoxyCodeLine{7121 }
\DoxyCodeLine{7122     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{7123         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{7124         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{7125         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{7126             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7127         \}}
\DoxyCodeLine{7128 }
\DoxyCodeLine{7129         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{7130 }
\DoxyCodeLine{7131         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{7132         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{7133         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{7134             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{7135             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7136         \}}
\DoxyCodeLine{7137 }
\DoxyCodeLine{7138         drwav\_\_ieee\_to\_s32(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead, bytesPerSample);}
\DoxyCodeLine{7139 }
\DoxyCodeLine{7140         pBufferOut      += samplesRead;}
\DoxyCodeLine{7141         framesToRead    -\/= framesRead;}
\DoxyCodeLine{7142         totalFramesRead += framesRead;}
\DoxyCodeLine{7143     \}}
\DoxyCodeLine{7144 }
\DoxyCodeLine{7145     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{7146 \}}
\DoxyCodeLine{7147 }
\DoxyCodeLine{7148 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s32\_\_alaw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut)}
\DoxyCodeLine{7149 \{}
\DoxyCodeLine{7150     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{7151     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{7152     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{7153     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{7154     drwav\_uint64 samplesRead;}
\DoxyCodeLine{7155 }
\DoxyCodeLine{7156     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{7157     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{7158         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7159     \}}
\DoxyCodeLine{7160 }
\DoxyCodeLine{7161     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{7162     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{7163         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{7164     \}}
\DoxyCodeLine{7165 }
\DoxyCodeLine{7166     totalFramesRead = 0;}
\DoxyCodeLine{7167 }
\DoxyCodeLine{7168     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{7169         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{7170         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{7171         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{7172             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7173         \}}
\DoxyCodeLine{7174 }
\DoxyCodeLine{7175         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{7176 }
\DoxyCodeLine{7177         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{7178         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{7179         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{7180             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{7181             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7182         \}}
\DoxyCodeLine{7183 }
\DoxyCodeLine{7184         drwav\_alaw\_to\_s32(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead);}
\DoxyCodeLine{7185 }
\DoxyCodeLine{7186         pBufferOut      += samplesRead;}
\DoxyCodeLine{7187         framesToRead    -\/= framesRead;}
\DoxyCodeLine{7188         totalFramesRead += framesRead;}
\DoxyCodeLine{7189     \}}
\DoxyCodeLine{7190 }
\DoxyCodeLine{7191     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{7192 \}}
\DoxyCodeLine{7193 }
\DoxyCodeLine{7194 DRWAV\_PRIVATE drwav\_uint64 drwav\_read\_pcm\_frames\_s32\_\_mulaw(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut)}
\DoxyCodeLine{7195 \{}
\DoxyCodeLine{7196     drwav\_uint64 totalFramesRead;}
\DoxyCodeLine{7197     drwav\_uint8 sampleData[4096] = \{0\};}
\DoxyCodeLine{7198     drwav\_uint32 bytesPerFrame;}
\DoxyCodeLine{7199     drwav\_uint32 bytesPerSample;}
\DoxyCodeLine{7200     drwav\_uint64 samplesRead;}
\DoxyCodeLine{7201 }
\DoxyCodeLine{7202     bytesPerFrame = drwav\_get\_bytes\_per\_pcm\_frame(pWav);}
\DoxyCodeLine{7203     \textcolor{keywordflow}{if} (bytesPerFrame == 0) \{}
\DoxyCodeLine{7204         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7205     \}}
\DoxyCodeLine{7206 }
\DoxyCodeLine{7207     bytesPerSample = bytesPerFrame / pWav-\/>channels;}
\DoxyCodeLine{7208     \textcolor{keywordflow}{if} (bytesPerSample == 0 || (bytesPerFrame \% pWav-\/>channels) != 0) \{}
\DoxyCodeLine{7209         \textcolor{keywordflow}{return} 0;   \textcolor{comment}{/* Only byte-\/aligned formats are supported. */}}
\DoxyCodeLine{7210     \}}
\DoxyCodeLine{7211 }
\DoxyCodeLine{7212     totalFramesRead = 0;}
\DoxyCodeLine{7213 }
\DoxyCodeLine{7214     \textcolor{keywordflow}{while} (framesToRead > 0) \{}
\DoxyCodeLine{7215         drwav\_uint64 framesToReadThisIteration = drwav\_min(framesToRead, \textcolor{keyword}{sizeof}(sampleData)/bytesPerFrame);}
\DoxyCodeLine{7216         drwav\_uint64 framesRead = drwav\_read\_pcm\_frames(pWav, framesToReadThisIteration, sampleData);}
\DoxyCodeLine{7217         \textcolor{keywordflow}{if} (framesRead == 0) \{}
\DoxyCodeLine{7218             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7219         \}}
\DoxyCodeLine{7220 }
\DoxyCodeLine{7221         DRWAV\_ASSERT(framesRead <= framesToReadThisIteration);   \textcolor{comment}{/* If this fails it means there's a bug in drwav\_read\_pcm\_frames(). */}}
\DoxyCodeLine{7222 }
\DoxyCodeLine{7223         \textcolor{comment}{/* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */}}
\DoxyCodeLine{7224         samplesRead = framesRead * pWav-\/>channels;}
\DoxyCodeLine{7225         \textcolor{keywordflow}{if} ((samplesRead * bytesPerSample) > \textcolor{keyword}{sizeof}(sampleData)) \{}
\DoxyCodeLine{7226             DRWAV\_ASSERT(DRWAV\_FALSE);  \textcolor{comment}{/* This should never happen with a valid file. */}}
\DoxyCodeLine{7227             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7228         \}}
\DoxyCodeLine{7229 }
\DoxyCodeLine{7230         drwav\_mulaw\_to\_s32(pBufferOut, sampleData, (\textcolor{keywordtype}{size\_t})samplesRead);}
\DoxyCodeLine{7231 }
\DoxyCodeLine{7232         pBufferOut      += samplesRead;}
\DoxyCodeLine{7233         framesToRead    -\/= framesRead;}
\DoxyCodeLine{7234         totalFramesRead += framesRead;}
\DoxyCodeLine{7235     \}}
\DoxyCodeLine{7236 }
\DoxyCodeLine{7237     \textcolor{keywordflow}{return} totalFramesRead;}
\DoxyCodeLine{7238 \}}
\DoxyCodeLine{7239 }
\DoxyCodeLine{7240 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s32(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut)}
\DoxyCodeLine{7241 \{}
\DoxyCodeLine{7242     \textcolor{keywordflow}{if} (pWav == NULL || framesToRead == 0) \{}
\DoxyCodeLine{7243         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7244     \}}
\DoxyCodeLine{7245 }
\DoxyCodeLine{7246     \textcolor{keywordflow}{if} (pBufferOut == NULL) \{}
\DoxyCodeLine{7247         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames(pWav, framesToRead, NULL);}
\DoxyCodeLine{7248     \}}
\DoxyCodeLine{7249 }
\DoxyCodeLine{7250     \textcolor{comment}{/* Don't try to read more samples than can potentially fit in the output buffer. */}}
\DoxyCodeLine{7251     \textcolor{keywordflow}{if} (framesToRead * pWav-\/>channels * \textcolor{keyword}{sizeof}(drwav\_int32) > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{7252         framesToRead = DRWAV\_SIZE\_MAX / \textcolor{keyword}{sizeof}(drwav\_int32) / pWav-\/>channels;}
\DoxyCodeLine{7253     \}}
\DoxyCodeLine{7254 }
\DoxyCodeLine{7255     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_PCM) \{}
\DoxyCodeLine{7256         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s32\_\_pcm(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{7257     \}}
\DoxyCodeLine{7258 }
\DoxyCodeLine{7259     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ADPCM || pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_DVI\_ADPCM) \{}
\DoxyCodeLine{7260         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s32\_\_msadpcm\_ima(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{7261     \}}
\DoxyCodeLine{7262 }
\DoxyCodeLine{7263     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_IEEE\_FLOAT) \{}
\DoxyCodeLine{7264         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s32\_\_ieee(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{7265     \}}
\DoxyCodeLine{7266 }
\DoxyCodeLine{7267     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_ALAW) \{}
\DoxyCodeLine{7268         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s32\_\_alaw(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{7269     \}}
\DoxyCodeLine{7270 }
\DoxyCodeLine{7271     \textcolor{keywordflow}{if} (pWav-\/>translatedFormatTag == DR\_WAVE\_FORMAT\_MULAW) \{}
\DoxyCodeLine{7272         \textcolor{keywordflow}{return} drwav\_read\_pcm\_frames\_s32\_\_mulaw(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{7273     \}}
\DoxyCodeLine{7274 }
\DoxyCodeLine{7275     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{7276 \}}
\DoxyCodeLine{7277 }
\DoxyCodeLine{7278 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s32le(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut)}
\DoxyCodeLine{7279 \{}
\DoxyCodeLine{7280     drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_s32(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{7281     \textcolor{keywordflow}{if} (pBufferOut != NULL \&\& drwav\_\_is\_little\_endian() == DRWAV\_FALSE) \{}
\DoxyCodeLine{7282         drwav\_\_bswap\_samples\_s32(pBufferOut, framesRead*pWav-\/>channels);}
\DoxyCodeLine{7283     \}}
\DoxyCodeLine{7284 }
\DoxyCodeLine{7285     \textcolor{keywordflow}{return} framesRead;}
\DoxyCodeLine{7286 \}}
\DoxyCodeLine{7287 }
\DoxyCodeLine{7288 DRWAV\_API drwav\_uint64 drwav\_read\_pcm\_frames\_s32be(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, drwav\_uint64 framesToRead, drwav\_int32* pBufferOut)}
\DoxyCodeLine{7289 \{}
\DoxyCodeLine{7290     drwav\_uint64 framesRead = drwav\_read\_pcm\_frames\_s32(pWav, framesToRead, pBufferOut);}
\DoxyCodeLine{7291     \textcolor{keywordflow}{if} (pBufferOut != NULL \&\& drwav\_\_is\_little\_endian() == DRWAV\_TRUE) \{}
\DoxyCodeLine{7292         drwav\_\_bswap\_samples\_s32(pBufferOut, framesRead*pWav-\/>channels);}
\DoxyCodeLine{7293     \}}
\DoxyCodeLine{7294 }
\DoxyCodeLine{7295     \textcolor{keywordflow}{return} framesRead;}
\DoxyCodeLine{7296 \}}
\DoxyCodeLine{7297 }
\DoxyCodeLine{7298 }
\DoxyCodeLine{7299 DRWAV\_API \textcolor{keywordtype}{void} drwav\_u8\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{7300 \{}
\DoxyCodeLine{7301     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{7302 }
\DoxyCodeLine{7303     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{7304         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7305     \}}
\DoxyCodeLine{7306 }
\DoxyCodeLine{7307     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{7308         *pOut++ = ((int)pIn[i] -\/ 128) << 24;}
\DoxyCodeLine{7309     \}}
\DoxyCodeLine{7310 \}}
\DoxyCodeLine{7311 }
\DoxyCodeLine{7312 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s16\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_int16* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{7313 \{}
\DoxyCodeLine{7314     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{7315 }
\DoxyCodeLine{7316     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{7317         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7318     \}}
\DoxyCodeLine{7319 }
\DoxyCodeLine{7320     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{7321         *pOut++ = pIn[i] << 16;}
\DoxyCodeLine{7322     \}}
\DoxyCodeLine{7323 \}}
\DoxyCodeLine{7324 }
\DoxyCodeLine{7325 DRWAV\_API \textcolor{keywordtype}{void} drwav\_s24\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{7326 \{}
\DoxyCodeLine{7327     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{7328 }
\DoxyCodeLine{7329     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{7330         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7331     \}}
\DoxyCodeLine{7332 }
\DoxyCodeLine{7333     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{7334         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} s0 = pIn[i*3 + 0];}
\DoxyCodeLine{7335         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} s1 = pIn[i*3 + 1];}
\DoxyCodeLine{7336         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} s2 = pIn[i*3 + 2];}
\DoxyCodeLine{7337 }
\DoxyCodeLine{7338         drwav\_int32 sample32 = (drwav\_int32)((s0 << 8) | (s1 << 16) | (s2 << 24));}
\DoxyCodeLine{7339         *pOut++ = sample32;}
\DoxyCodeLine{7340     \}}
\DoxyCodeLine{7341 \}}
\DoxyCodeLine{7342 }
\DoxyCodeLine{7343 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f32\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{float}* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{7344 \{}
\DoxyCodeLine{7345     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{7346 }
\DoxyCodeLine{7347     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{7348         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7349     \}}
\DoxyCodeLine{7350 }
\DoxyCodeLine{7351     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{7352         *pOut++ = (drwav\_int32)(2147483648.0 * pIn[i]);}
\DoxyCodeLine{7353     \}}
\DoxyCodeLine{7354 \}}
\DoxyCodeLine{7355 }
\DoxyCodeLine{7356 DRWAV\_API \textcolor{keywordtype}{void} drwav\_f64\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} \textcolor{keywordtype}{double}* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{7357 \{}
\DoxyCodeLine{7358     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{7359 }
\DoxyCodeLine{7360     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{7361         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7362     \}}
\DoxyCodeLine{7363 }
\DoxyCodeLine{7364     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{7365         *pOut++ = (drwav\_int32)(2147483648.0 * pIn[i]);}
\DoxyCodeLine{7366     \}}
\DoxyCodeLine{7367 \}}
\DoxyCodeLine{7368 }
\DoxyCodeLine{7369 DRWAV\_API \textcolor{keywordtype}{void} drwav\_alaw\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{7370 \{}
\DoxyCodeLine{7371     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{7372 }
\DoxyCodeLine{7373     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{7374         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7375     \}}
\DoxyCodeLine{7376 }
\DoxyCodeLine{7377     \textcolor{keywordflow}{for} (i = 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{7378         *pOut++ = ((drwav\_int32)drwav\_\_alaw\_to\_s16(pIn[i])) << 16;}
\DoxyCodeLine{7379     \}}
\DoxyCodeLine{7380 \}}
\DoxyCodeLine{7381 }
\DoxyCodeLine{7382 DRWAV\_API \textcolor{keywordtype}{void} drwav\_mulaw\_to\_s32(drwav\_int32* pOut, \textcolor{keyword}{const} drwav\_uint8* pIn, \textcolor{keywordtype}{size\_t} sampleCount)}
\DoxyCodeLine{7383 \{}
\DoxyCodeLine{7384     \textcolor{keywordtype}{size\_t} i;}
\DoxyCodeLine{7385 }
\DoxyCodeLine{7386     \textcolor{keywordflow}{if} (pOut == NULL || pIn == NULL) \{}
\DoxyCodeLine{7387         \textcolor{keywordflow}{return};}
\DoxyCodeLine{7388     \}}
\DoxyCodeLine{7389 }
\DoxyCodeLine{7390     \textcolor{keywordflow}{for} (i= 0; i < sampleCount; ++i) \{}
\DoxyCodeLine{7391         *pOut++ = ((drwav\_int32)drwav\_\_mulaw\_to\_s16(pIn[i])) << 16;}
\DoxyCodeLine{7392     \}}
\DoxyCodeLine{7393 \}}
\DoxyCodeLine{7394 }
\DoxyCodeLine{7395 }
\DoxyCodeLine{7396 }
\DoxyCodeLine{7397 DRWAV\_PRIVATE drwav\_int16* drwav\_\_read\_pcm\_frames\_and\_close\_s16(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channels, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRate, drwav\_uint64* totalFrameCount)}
\DoxyCodeLine{7398 \{}
\DoxyCodeLine{7399     drwav\_uint64 sampleDataSize;}
\DoxyCodeLine{7400     drwav\_int16* pSampleData;}
\DoxyCodeLine{7401     drwav\_uint64 framesRead;}
\DoxyCodeLine{7402 }
\DoxyCodeLine{7403     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{7404 }
\DoxyCodeLine{7405     sampleDataSize = pWav-\/>totalPCMFrameCount * pWav-\/>channels * \textcolor{keyword}{sizeof}(drwav\_int16);}
\DoxyCodeLine{7406     \textcolor{keywordflow}{if} (sampleDataSize > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{7407         drwav\_uninit(pWav);}
\DoxyCodeLine{7408         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* File's too big. */}}
\DoxyCodeLine{7409     \}}
\DoxyCodeLine{7410 }
\DoxyCodeLine{7411     pSampleData = (drwav\_int16*)drwav\_\_malloc\_from\_callbacks((\textcolor{keywordtype}{size\_t})sampleDataSize, \&pWav-\/>allocationCallbacks); \textcolor{comment}{/* <-\/-\/ Safe cast due to the check above. */}}
\DoxyCodeLine{7412     \textcolor{keywordflow}{if} (pSampleData == NULL) \{}
\DoxyCodeLine{7413         drwav\_uninit(pWav);}
\DoxyCodeLine{7414         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* Failed to allocate memory. */}}
\DoxyCodeLine{7415     \}}
\DoxyCodeLine{7416 }
\DoxyCodeLine{7417     framesRead = drwav\_read\_pcm\_frames\_s16(pWav, (\textcolor{keywordtype}{size\_t})pWav-\/>totalPCMFrameCount, pSampleData);}
\DoxyCodeLine{7418     \textcolor{keywordflow}{if} (framesRead != pWav-\/>totalPCMFrameCount) \{}
\DoxyCodeLine{7419         drwav\_\_free\_from\_callbacks(pSampleData, \&pWav-\/>allocationCallbacks);}
\DoxyCodeLine{7420         drwav\_uninit(pWav);}
\DoxyCodeLine{7421         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* There was an error reading the samples. */}}
\DoxyCodeLine{7422     \}}
\DoxyCodeLine{7423 }
\DoxyCodeLine{7424     drwav\_uninit(pWav);}
\DoxyCodeLine{7425 }
\DoxyCodeLine{7426     \textcolor{keywordflow}{if} (sampleRate) \{}
\DoxyCodeLine{7427         *sampleRate = pWav-\/>sampleRate;}
\DoxyCodeLine{7428     \}}
\DoxyCodeLine{7429     \textcolor{keywordflow}{if} (channels) \{}
\DoxyCodeLine{7430         *channels = pWav-\/>channels;}
\DoxyCodeLine{7431     \}}
\DoxyCodeLine{7432     \textcolor{keywordflow}{if} (totalFrameCount) \{}
\DoxyCodeLine{7433         *totalFrameCount = pWav-\/>totalPCMFrameCount;}
\DoxyCodeLine{7434     \}}
\DoxyCodeLine{7435 }
\DoxyCodeLine{7436     \textcolor{keywordflow}{return} pSampleData;}
\DoxyCodeLine{7437 \}}
\DoxyCodeLine{7438 }
\DoxyCodeLine{7439 DRWAV\_PRIVATE \textcolor{keywordtype}{float}* drwav\_\_read\_pcm\_frames\_and\_close\_f32(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channels, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRate, drwav\_uint64* totalFrameCount)}
\DoxyCodeLine{7440 \{}
\DoxyCodeLine{7441     drwav\_uint64 sampleDataSize;}
\DoxyCodeLine{7442     \textcolor{keywordtype}{float}* pSampleData;}
\DoxyCodeLine{7443     drwav\_uint64 framesRead;}
\DoxyCodeLine{7444 }
\DoxyCodeLine{7445     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{7446 }
\DoxyCodeLine{7447     sampleDataSize = pWav-\/>totalPCMFrameCount * pWav-\/>channels * \textcolor{keyword}{sizeof}(float);}
\DoxyCodeLine{7448     \textcolor{keywordflow}{if} (sampleDataSize > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{7449         drwav\_uninit(pWav);}
\DoxyCodeLine{7450         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* File's too big. */}}
\DoxyCodeLine{7451     \}}
\DoxyCodeLine{7452 }
\DoxyCodeLine{7453     pSampleData = (\textcolor{keywordtype}{float}*)drwav\_\_malloc\_from\_callbacks((\textcolor{keywordtype}{size\_t})sampleDataSize, \&pWav-\/>allocationCallbacks); \textcolor{comment}{/* <-\/-\/ Safe cast due to the check above. */}}
\DoxyCodeLine{7454     \textcolor{keywordflow}{if} (pSampleData == NULL) \{}
\DoxyCodeLine{7455         drwav\_uninit(pWav);}
\DoxyCodeLine{7456         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* Failed to allocate memory. */}}
\DoxyCodeLine{7457     \}}
\DoxyCodeLine{7458 }
\DoxyCodeLine{7459     framesRead = drwav\_read\_pcm\_frames\_f32(pWav, (\textcolor{keywordtype}{size\_t})pWav-\/>totalPCMFrameCount, pSampleData);}
\DoxyCodeLine{7460     \textcolor{keywordflow}{if} (framesRead != pWav-\/>totalPCMFrameCount) \{}
\DoxyCodeLine{7461         drwav\_\_free\_from\_callbacks(pSampleData, \&pWav-\/>allocationCallbacks);}
\DoxyCodeLine{7462         drwav\_uninit(pWav);}
\DoxyCodeLine{7463         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* There was an error reading the samples. */}}
\DoxyCodeLine{7464     \}}
\DoxyCodeLine{7465 }
\DoxyCodeLine{7466     drwav\_uninit(pWav);}
\DoxyCodeLine{7467 }
\DoxyCodeLine{7468     \textcolor{keywordflow}{if} (sampleRate) \{}
\DoxyCodeLine{7469         *sampleRate = pWav-\/>sampleRate;}
\DoxyCodeLine{7470     \}}
\DoxyCodeLine{7471     \textcolor{keywordflow}{if} (channels) \{}
\DoxyCodeLine{7472         *channels = pWav-\/>channels;}
\DoxyCodeLine{7473     \}}
\DoxyCodeLine{7474     \textcolor{keywordflow}{if} (totalFrameCount) \{}
\DoxyCodeLine{7475         *totalFrameCount = pWav-\/>totalPCMFrameCount;}
\DoxyCodeLine{7476     \}}
\DoxyCodeLine{7477 }
\DoxyCodeLine{7478     \textcolor{keywordflow}{return} pSampleData;}
\DoxyCodeLine{7479 \}}
\DoxyCodeLine{7480 }
\DoxyCodeLine{7481 DRWAV\_PRIVATE drwav\_int32* drwav\_\_read\_pcm\_frames\_and\_close\_s32(\mbox{\hyperlink{structdrwav}{drwav}}* pWav, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channels, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRate, drwav\_uint64* totalFrameCount)}
\DoxyCodeLine{7482 \{}
\DoxyCodeLine{7483     drwav\_uint64 sampleDataSize;}
\DoxyCodeLine{7484     drwav\_int32* pSampleData;}
\DoxyCodeLine{7485     drwav\_uint64 framesRead;}
\DoxyCodeLine{7486 }
\DoxyCodeLine{7487     DRWAV\_ASSERT(pWav != NULL);}
\DoxyCodeLine{7488 }
\DoxyCodeLine{7489     sampleDataSize = pWav-\/>totalPCMFrameCount * pWav-\/>channels * \textcolor{keyword}{sizeof}(drwav\_int32);}
\DoxyCodeLine{7490     \textcolor{keywordflow}{if} (sampleDataSize > DRWAV\_SIZE\_MAX) \{}
\DoxyCodeLine{7491         drwav\_uninit(pWav);}
\DoxyCodeLine{7492         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* File's too big. */}}
\DoxyCodeLine{7493     \}}
\DoxyCodeLine{7494 }
\DoxyCodeLine{7495     pSampleData = (drwav\_int32*)drwav\_\_malloc\_from\_callbacks((\textcolor{keywordtype}{size\_t})sampleDataSize, \&pWav-\/>allocationCallbacks); \textcolor{comment}{/* <-\/-\/ Safe cast due to the check above. */}}
\DoxyCodeLine{7496     \textcolor{keywordflow}{if} (pSampleData == NULL) \{}
\DoxyCodeLine{7497         drwav\_uninit(pWav);}
\DoxyCodeLine{7498         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* Failed to allocate memory. */}}
\DoxyCodeLine{7499     \}}
\DoxyCodeLine{7500 }
\DoxyCodeLine{7501     framesRead = drwav\_read\_pcm\_frames\_s32(pWav, (\textcolor{keywordtype}{size\_t})pWav-\/>totalPCMFrameCount, pSampleData);}
\DoxyCodeLine{7502     \textcolor{keywordflow}{if} (framesRead != pWav-\/>totalPCMFrameCount) \{}
\DoxyCodeLine{7503         drwav\_\_free\_from\_callbacks(pSampleData, \&pWav-\/>allocationCallbacks);}
\DoxyCodeLine{7504         drwav\_uninit(pWav);}
\DoxyCodeLine{7505         \textcolor{keywordflow}{return} NULL;    \textcolor{comment}{/* There was an error reading the samples. */}}
\DoxyCodeLine{7506     \}}
\DoxyCodeLine{7507 }
\DoxyCodeLine{7508     drwav\_uninit(pWav);}
\DoxyCodeLine{7509 }
\DoxyCodeLine{7510     \textcolor{keywordflow}{if} (sampleRate) \{}
\DoxyCodeLine{7511         *sampleRate = pWav-\/>sampleRate;}
\DoxyCodeLine{7512     \}}
\DoxyCodeLine{7513     \textcolor{keywordflow}{if} (channels) \{}
\DoxyCodeLine{7514         *channels = pWav-\/>channels;}
\DoxyCodeLine{7515     \}}
\DoxyCodeLine{7516     \textcolor{keywordflow}{if} (totalFrameCount) \{}
\DoxyCodeLine{7517         *totalFrameCount = pWav-\/>totalPCMFrameCount;}
\DoxyCodeLine{7518     \}}
\DoxyCodeLine{7519 }
\DoxyCodeLine{7520     \textcolor{keywordflow}{return} pSampleData;}
\DoxyCodeLine{7521 \}}
\DoxyCodeLine{7522 }
\DoxyCodeLine{7523 }
\DoxyCodeLine{7524 }
\DoxyCodeLine{7525 DRWAV\_API drwav\_int16* drwav\_open\_and\_read\_pcm\_frames\_s16(drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7526 \{}
\DoxyCodeLine{7527     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7528 }
\DoxyCodeLine{7529     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7530         *channelsOut = 0;}
\DoxyCodeLine{7531     \}}
\DoxyCodeLine{7532     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7533         *sampleRateOut = 0;}
\DoxyCodeLine{7534     \}}
\DoxyCodeLine{7535     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7536         *totalFrameCountOut = 0;}
\DoxyCodeLine{7537     \}}
\DoxyCodeLine{7538 }
\DoxyCodeLine{7539     \textcolor{keywordflow}{if} (!drwav\_init(\&wav, onRead, onSeek, pUserData, pAllocationCallbacks)) \{}
\DoxyCodeLine{7540         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7541     \}}
\DoxyCodeLine{7542 }
\DoxyCodeLine{7543     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_s16(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7544 \}}
\DoxyCodeLine{7545 }
\DoxyCodeLine{7546 DRWAV\_API \textcolor{keywordtype}{float}* drwav\_open\_and\_read\_pcm\_frames\_f32(drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7547 \{}
\DoxyCodeLine{7548     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7549 }
\DoxyCodeLine{7550     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7551         *channelsOut = 0;}
\DoxyCodeLine{7552     \}}
\DoxyCodeLine{7553     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7554         *sampleRateOut = 0;}
\DoxyCodeLine{7555     \}}
\DoxyCodeLine{7556     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7557         *totalFrameCountOut = 0;}
\DoxyCodeLine{7558     \}}
\DoxyCodeLine{7559 }
\DoxyCodeLine{7560     \textcolor{keywordflow}{if} (!drwav\_init(\&wav, onRead, onSeek, pUserData, pAllocationCallbacks)) \{}
\DoxyCodeLine{7561         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7562     \}}
\DoxyCodeLine{7563 }
\DoxyCodeLine{7564     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_f32(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7565 \}}
\DoxyCodeLine{7566 }
\DoxyCodeLine{7567 DRWAV\_API drwav\_int32* drwav\_open\_and\_read\_pcm\_frames\_s32(drwav\_read\_proc onRead, drwav\_seek\_proc onSeek, \textcolor{keywordtype}{void}* pUserData, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7568 \{}
\DoxyCodeLine{7569     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7570 }
\DoxyCodeLine{7571     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7572         *channelsOut = 0;}
\DoxyCodeLine{7573     \}}
\DoxyCodeLine{7574     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7575         *sampleRateOut = 0;}
\DoxyCodeLine{7576     \}}
\DoxyCodeLine{7577     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7578         *totalFrameCountOut = 0;}
\DoxyCodeLine{7579     \}}
\DoxyCodeLine{7580 }
\DoxyCodeLine{7581     \textcolor{keywordflow}{if} (!drwav\_init(\&wav, onRead, onSeek, pUserData, pAllocationCallbacks)) \{}
\DoxyCodeLine{7582         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7583     \}}
\DoxyCodeLine{7584 }
\DoxyCodeLine{7585     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_s32(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7586 \}}
\DoxyCodeLine{7587 }
\DoxyCodeLine{7588 \textcolor{preprocessor}{\#ifndef DR\_WAV\_NO\_STDIO}}
\DoxyCodeLine{7589 DRWAV\_API drwav\_int16* drwav\_open\_file\_and\_read\_pcm\_frames\_s16(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7590 \{}
\DoxyCodeLine{7591     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7592 }
\DoxyCodeLine{7593     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7594         *channelsOut = 0;}
\DoxyCodeLine{7595     \}}
\DoxyCodeLine{7596     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7597         *sampleRateOut = 0;}
\DoxyCodeLine{7598     \}}
\DoxyCodeLine{7599     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7600         *totalFrameCountOut = 0;}
\DoxyCodeLine{7601     \}}
\DoxyCodeLine{7602 }
\DoxyCodeLine{7603     \textcolor{keywordflow}{if} (!drwav\_init\_file(\&wav, filename, pAllocationCallbacks)) \{}
\DoxyCodeLine{7604         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7605     \}}
\DoxyCodeLine{7606 }
\DoxyCodeLine{7607     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_s16(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7608 \}}
\DoxyCodeLine{7609 }
\DoxyCodeLine{7610 DRWAV\_API \textcolor{keywordtype}{float}* drwav\_open\_file\_and\_read\_pcm\_frames\_f32(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7611 \{}
\DoxyCodeLine{7612     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7613 }
\DoxyCodeLine{7614     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7615         *channelsOut = 0;}
\DoxyCodeLine{7616     \}}
\DoxyCodeLine{7617     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7618         *sampleRateOut = 0;}
\DoxyCodeLine{7619     \}}
\DoxyCodeLine{7620     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7621         *totalFrameCountOut = 0;}
\DoxyCodeLine{7622     \}}
\DoxyCodeLine{7623 }
\DoxyCodeLine{7624     \textcolor{keywordflow}{if} (!drwav\_init\_file(\&wav, filename, pAllocationCallbacks)) \{}
\DoxyCodeLine{7625         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7626     \}}
\DoxyCodeLine{7627 }
\DoxyCodeLine{7628     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_f32(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7629 \}}
\DoxyCodeLine{7630 }
\DoxyCodeLine{7631 DRWAV\_API drwav\_int32* drwav\_open\_file\_and\_read\_pcm\_frames\_s32(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7632 \{}
\DoxyCodeLine{7633     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7634 }
\DoxyCodeLine{7635     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7636         *channelsOut = 0;}
\DoxyCodeLine{7637     \}}
\DoxyCodeLine{7638     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7639         *sampleRateOut = 0;}
\DoxyCodeLine{7640     \}}
\DoxyCodeLine{7641     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7642         *totalFrameCountOut = 0;}
\DoxyCodeLine{7643     \}}
\DoxyCodeLine{7644 }
\DoxyCodeLine{7645     \textcolor{keywordflow}{if} (!drwav\_init\_file(\&wav, filename, pAllocationCallbacks)) \{}
\DoxyCodeLine{7646         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7647     \}}
\DoxyCodeLine{7648 }
\DoxyCodeLine{7649     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_s32(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7650 \}}
\DoxyCodeLine{7651 }
\DoxyCodeLine{7652 }
\DoxyCodeLine{7653 DRWAV\_API drwav\_int16* drwav\_open\_file\_and\_read\_pcm\_frames\_s16\_w(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7654 \{}
\DoxyCodeLine{7655     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7656 }
\DoxyCodeLine{7657     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7658         *sampleRateOut = 0;}
\DoxyCodeLine{7659     \}}
\DoxyCodeLine{7660     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7661         *channelsOut = 0;}
\DoxyCodeLine{7662     \}}
\DoxyCodeLine{7663     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7664         *totalFrameCountOut = 0;}
\DoxyCodeLine{7665     \}}
\DoxyCodeLine{7666 }
\DoxyCodeLine{7667     \textcolor{keywordflow}{if} (!drwav\_init\_file\_w(\&wav, filename, pAllocationCallbacks)) \{}
\DoxyCodeLine{7668         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7669     \}}
\DoxyCodeLine{7670 }
\DoxyCodeLine{7671     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_s16(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7672 \}}
\DoxyCodeLine{7673 }
\DoxyCodeLine{7674 DRWAV\_API \textcolor{keywordtype}{float}* drwav\_open\_file\_and\_read\_pcm\_frames\_f32\_w(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7675 \{}
\DoxyCodeLine{7676     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7677 }
\DoxyCodeLine{7678     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7679         *sampleRateOut = 0;}
\DoxyCodeLine{7680     \}}
\DoxyCodeLine{7681     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7682         *channelsOut = 0;}
\DoxyCodeLine{7683     \}}
\DoxyCodeLine{7684     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7685         *totalFrameCountOut = 0;}
\DoxyCodeLine{7686     \}}
\DoxyCodeLine{7687 }
\DoxyCodeLine{7688     \textcolor{keywordflow}{if} (!drwav\_init\_file\_w(\&wav, filename, pAllocationCallbacks)) \{}
\DoxyCodeLine{7689         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7690     \}}
\DoxyCodeLine{7691 }
\DoxyCodeLine{7692     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_f32(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7693 \}}
\DoxyCodeLine{7694 }
\DoxyCodeLine{7695 DRWAV\_API drwav\_int32* drwav\_open\_file\_and\_read\_pcm\_frames\_s32\_w(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* filename, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7696 \{}
\DoxyCodeLine{7697     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7698 }
\DoxyCodeLine{7699     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7700         *sampleRateOut = 0;}
\DoxyCodeLine{7701     \}}
\DoxyCodeLine{7702     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7703         *channelsOut = 0;}
\DoxyCodeLine{7704     \}}
\DoxyCodeLine{7705     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7706         *totalFrameCountOut = 0;}
\DoxyCodeLine{7707     \}}
\DoxyCodeLine{7708 }
\DoxyCodeLine{7709     \textcolor{keywordflow}{if} (!drwav\_init\_file\_w(\&wav, filename, pAllocationCallbacks)) \{}
\DoxyCodeLine{7710         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7711     \}}
\DoxyCodeLine{7712 }
\DoxyCodeLine{7713     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_s32(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7714 \}}
\DoxyCodeLine{7715 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7716 }
\DoxyCodeLine{7717 DRWAV\_API drwav\_int16* drwav\_open\_memory\_and\_read\_pcm\_frames\_s16(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7718 \{}
\DoxyCodeLine{7719     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7720 }
\DoxyCodeLine{7721     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7722         *channelsOut = 0;}
\DoxyCodeLine{7723     \}}
\DoxyCodeLine{7724     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7725         *sampleRateOut = 0;}
\DoxyCodeLine{7726     \}}
\DoxyCodeLine{7727     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7728         *totalFrameCountOut = 0;}
\DoxyCodeLine{7729     \}}
\DoxyCodeLine{7730 }
\DoxyCodeLine{7731     \textcolor{keywordflow}{if} (!drwav\_init\_memory(\&wav, data, dataSize, pAllocationCallbacks)) \{}
\DoxyCodeLine{7732         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7733     \}}
\DoxyCodeLine{7734 }
\DoxyCodeLine{7735     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_s16(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7736 \}}
\DoxyCodeLine{7737 }
\DoxyCodeLine{7738 DRWAV\_API \textcolor{keywordtype}{float}* drwav\_open\_memory\_and\_read\_pcm\_frames\_f32(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7739 \{}
\DoxyCodeLine{7740     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7741 }
\DoxyCodeLine{7742     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7743         *channelsOut = 0;}
\DoxyCodeLine{7744     \}}
\DoxyCodeLine{7745     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7746         *sampleRateOut = 0;}
\DoxyCodeLine{7747     \}}
\DoxyCodeLine{7748     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7749         *totalFrameCountOut = 0;}
\DoxyCodeLine{7750     \}}
\DoxyCodeLine{7751 }
\DoxyCodeLine{7752     \textcolor{keywordflow}{if} (!drwav\_init\_memory(\&wav, data, dataSize, pAllocationCallbacks)) \{}
\DoxyCodeLine{7753         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7754     \}}
\DoxyCodeLine{7755 }
\DoxyCodeLine{7756     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_f32(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7757 \}}
\DoxyCodeLine{7758 }
\DoxyCodeLine{7759 DRWAV\_API drwav\_int32* drwav\_open\_memory\_and\_read\_pcm\_frames\_s32(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* data, \textcolor{keywordtype}{size\_t} dataSize, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* channelsOut, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* sampleRateOut, drwav\_uint64* totalFrameCountOut, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7760 \{}
\DoxyCodeLine{7761     \mbox{\hyperlink{structdrwav}{drwav}} wav;}
\DoxyCodeLine{7762 }
\DoxyCodeLine{7763     \textcolor{keywordflow}{if} (channelsOut) \{}
\DoxyCodeLine{7764         *channelsOut = 0;}
\DoxyCodeLine{7765     \}}
\DoxyCodeLine{7766     \textcolor{keywordflow}{if} (sampleRateOut) \{}
\DoxyCodeLine{7767         *sampleRateOut = 0;}
\DoxyCodeLine{7768     \}}
\DoxyCodeLine{7769     \textcolor{keywordflow}{if} (totalFrameCountOut) \{}
\DoxyCodeLine{7770         *totalFrameCountOut = 0;}
\DoxyCodeLine{7771     \}}
\DoxyCodeLine{7772 }
\DoxyCodeLine{7773     \textcolor{keywordflow}{if} (!drwav\_init\_memory(\&wav, data, dataSize, pAllocationCallbacks)) \{}
\DoxyCodeLine{7774         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{7775     \}}
\DoxyCodeLine{7776 }
\DoxyCodeLine{7777     \textcolor{keywordflow}{return} drwav\_\_read\_pcm\_frames\_and\_close\_s32(\&wav, channelsOut, sampleRateOut, totalFrameCountOut);}
\DoxyCodeLine{7778 \}}
\DoxyCodeLine{7779 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{/* DR\_WAV\_NO\_CONVERSION\_API */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7780 }
\DoxyCodeLine{7781 }
\DoxyCodeLine{7782 DRWAV\_API \textcolor{keywordtype}{void} drwav\_free(\textcolor{keywordtype}{void}* p, \textcolor{keyword}{const} \mbox{\hyperlink{structdrwav__allocation__callbacks}{drwav\_allocation\_callbacks}}* pAllocationCallbacks)}
\DoxyCodeLine{7783 \{}
\DoxyCodeLine{7784     \textcolor{keywordflow}{if} (pAllocationCallbacks != NULL) \{}
\DoxyCodeLine{7785         drwav\_\_free\_from\_callbacks(p, pAllocationCallbacks);}
\DoxyCodeLine{7786     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{7787         drwav\_\_free\_default(p, NULL);}
\DoxyCodeLine{7788     \}}
\DoxyCodeLine{7789 \}}
\DoxyCodeLine{7790 }
\DoxyCodeLine{7791 DRWAV\_API drwav\_uint16 drwav\_bytes\_to\_u16(\textcolor{keyword}{const} drwav\_uint8* data)}
\DoxyCodeLine{7792 \{}
\DoxyCodeLine{7793     \textcolor{keywordflow}{return} ((drwav\_uint16)data[0] << 0) | ((drwav\_uint16)data[1] << 8);}
\DoxyCodeLine{7794 \}}
\DoxyCodeLine{7795 }
\DoxyCodeLine{7796 DRWAV\_API drwav\_int16 drwav\_bytes\_to\_s16(\textcolor{keyword}{const} drwav\_uint8* data)}
\DoxyCodeLine{7797 \{}
\DoxyCodeLine{7798     \textcolor{keywordflow}{return} (drwav\_int16)drwav\_bytes\_to\_u16(data);}
\DoxyCodeLine{7799 \}}
\DoxyCodeLine{7800 }
\DoxyCodeLine{7801 DRWAV\_API drwav\_uint32 drwav\_bytes\_to\_u32(\textcolor{keyword}{const} drwav\_uint8* data)}
\DoxyCodeLine{7802 \{}
\DoxyCodeLine{7803     \textcolor{keywordflow}{return} ((drwav\_uint32)data[0] << 0) | ((drwav\_uint32)data[1] << 8) | ((drwav\_uint32)data[2] << 16) | ((drwav\_uint32)data[3] << 24);}
\DoxyCodeLine{7804 \}}
\DoxyCodeLine{7805 }
\DoxyCodeLine{7806 DRWAV\_API \textcolor{keywordtype}{float} drwav\_bytes\_to\_f32(\textcolor{keyword}{const} drwav\_uint8* data)}
\DoxyCodeLine{7807 \{}
\DoxyCodeLine{7808     \textcolor{keyword}{union }\{}
\DoxyCodeLine{7809         drwav\_uint32 u32;}
\DoxyCodeLine{7810         \textcolor{keywordtype}{float} f32;}
\DoxyCodeLine{7811     \} value;}
\DoxyCodeLine{7812 }
\DoxyCodeLine{7813     value.u32 = drwav\_bytes\_to\_u32(data);}
\DoxyCodeLine{7814     \textcolor{keywordflow}{return} value.f32;}
\DoxyCodeLine{7815 \}}
\DoxyCodeLine{7816 }
\DoxyCodeLine{7817 DRWAV\_API drwav\_int32 drwav\_bytes\_to\_s32(\textcolor{keyword}{const} drwav\_uint8* data)}
\DoxyCodeLine{7818 \{}
\DoxyCodeLine{7819     \textcolor{keywordflow}{return} (drwav\_int32)drwav\_bytes\_to\_u32(data);}
\DoxyCodeLine{7820 \}}
\DoxyCodeLine{7821 }
\DoxyCodeLine{7822 DRWAV\_API drwav\_uint64 drwav\_bytes\_to\_u64(\textcolor{keyword}{const} drwav\_uint8* data)}
\DoxyCodeLine{7823 \{}
\DoxyCodeLine{7824     \textcolor{keywordflow}{return}}
\DoxyCodeLine{7825         ((drwav\_uint64)data[0] <<  0) | ((drwav\_uint64)data[1] <<  8) | ((drwav\_uint64)data[2] << 16) | ((drwav\_uint64)data[3] << 24) |}
\DoxyCodeLine{7826         ((drwav\_uint64)data[4] << 32) | ((drwav\_uint64)data[5] << 40) | ((drwav\_uint64)data[6] << 48) | ((drwav\_uint64)data[7] << 56);}
\DoxyCodeLine{7827 \}}
\DoxyCodeLine{7828 }
\DoxyCodeLine{7829 DRWAV\_API drwav\_int64 drwav\_bytes\_to\_s64(\textcolor{keyword}{const} drwav\_uint8* data)}
\DoxyCodeLine{7830 \{}
\DoxyCodeLine{7831     \textcolor{keywordflow}{return} (drwav\_int64)drwav\_bytes\_to\_u64(data);}
\DoxyCodeLine{7832 \}}
\DoxyCodeLine{7833 }
\DoxyCodeLine{7834 }
\DoxyCodeLine{7835 DRWAV\_API drwav\_bool32 drwav\_guid\_equal(\textcolor{keyword}{const} drwav\_uint8 a[16], \textcolor{keyword}{const} drwav\_uint8 b[16])}
\DoxyCodeLine{7836 \{}
\DoxyCodeLine{7837     \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{7838     \textcolor{keywordflow}{for} (i = 0; i < 16; i += 1) \{}
\DoxyCodeLine{7839         \textcolor{keywordflow}{if} (a[i] != b[i]) \{}
\DoxyCodeLine{7840             \textcolor{keywordflow}{return} DRWAV\_FALSE;}
\DoxyCodeLine{7841         \}}
\DoxyCodeLine{7842     \}}
\DoxyCodeLine{7843 }
\DoxyCodeLine{7844     \textcolor{keywordflow}{return} DRWAV\_TRUE;}
\DoxyCodeLine{7845 \}}
\DoxyCodeLine{7846 }
\DoxyCodeLine{7847 DRWAV\_API drwav\_bool32 drwav\_fourcc\_equal(\textcolor{keyword}{const} drwav\_uint8* a, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* b)}
\DoxyCodeLine{7848 \{}
\DoxyCodeLine{7849     \textcolor{keywordflow}{return}}
\DoxyCodeLine{7850         a[0] == b[0] \&\&}
\DoxyCodeLine{7851         a[1] == b[1] \&\&}
\DoxyCodeLine{7852         a[2] == b[2] \&\&}
\DoxyCodeLine{7853         a[3] == b[3];}
\DoxyCodeLine{7854 \}}
\DoxyCodeLine{7855 }
\DoxyCodeLine{7856 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{/* dr\_wav\_c */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7857 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{/* DR\_WAV\_IMPLEMENTATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7858 }
\DoxyCodeLine{7859 \textcolor{comment}{/*}}
\DoxyCodeLine{7860 \textcolor{comment}{REVISION HISTORY}}
\DoxyCodeLine{7861 \textcolor{comment}{================}}
\DoxyCodeLine{7862 \textcolor{comment}{v0.13.4 -\/ 2021-\/12-\/08}}
\DoxyCodeLine{7863 \textcolor{comment}{  -\/ Fix some static analysis warnings.}}
\DoxyCodeLine{7864 \textcolor{comment}{}}
\DoxyCodeLine{7865 \textcolor{comment}{v0.13.3 -\/ 2021-\/11-\/24}}
\DoxyCodeLine{7866 \textcolor{comment}{  -\/ Fix an incorrect assertion when trying to endian swap 1-\/byte sample formats. This is now a no-\/op}}
\DoxyCodeLine{7867 \textcolor{comment}{    rather than a failed assertion.}}
\DoxyCodeLine{7868 \textcolor{comment}{  -\/ Fix a bug with parsing of the bext chunk.}}
\DoxyCodeLine{7869 \textcolor{comment}{  -\/ Fix some static analysis warnings.}}
\DoxyCodeLine{7870 \textcolor{comment}{}}
\DoxyCodeLine{7871 \textcolor{comment}{v0.13.2 -\/ 2021-\/10-\/02}}
\DoxyCodeLine{7872 \textcolor{comment}{  -\/ Fix a possible buffer overflow when reading from compressed formats.}}
\DoxyCodeLine{7873 \textcolor{comment}{}}
\DoxyCodeLine{7874 \textcolor{comment}{v0.13.1 -\/ 2021-\/07-\/31}}
\DoxyCodeLine{7875 \textcolor{comment}{  -\/ Fix platform detection for ARM64.}}
\DoxyCodeLine{7876 \textcolor{comment}{}}
\DoxyCodeLine{7877 \textcolor{comment}{v0.13.0 -\/ 2021-\/07-\/01}}
\DoxyCodeLine{7878 \textcolor{comment}{  -\/ Improve support for reading and writing metadata. Use the `\_with\_metadata()` APIs to initialize}}
\DoxyCodeLine{7879 \textcolor{comment}{    a WAV decoder and store the metadata within the `drwav` object. Use the `pMetadata` and}}
\DoxyCodeLine{7880 \textcolor{comment}{    `metadataCount` members of the `drwav` object to read the data. The old way of handling metadata}}
\DoxyCodeLine{7881 \textcolor{comment}{    via a callback is still usable and valid.}}
\DoxyCodeLine{7882 \textcolor{comment}{  -\/ API CHANGE: drwav\_target\_write\_size\_bytes() now takes extra parameters for calculating the}}
\DoxyCodeLine{7883 \textcolor{comment}{    required write size when writing metadata.}}
\DoxyCodeLine{7884 \textcolor{comment}{  -\/ Add drwav\_get\_cursor\_in\_pcm\_frames()}}
\DoxyCodeLine{7885 \textcolor{comment}{  -\/ Add drwav\_get\_length\_in\_pcm\_frames()}}
\DoxyCodeLine{7886 \textcolor{comment}{  -\/ Fix a bug where drwav\_read\_raw() can call the read callback with a byte count of zero.}}
\DoxyCodeLine{7887 \textcolor{comment}{}}
\DoxyCodeLine{7888 \textcolor{comment}{v0.12.20 -\/ 2021-\/06-\/11}}
\DoxyCodeLine{7889 \textcolor{comment}{  -\/ Fix some undefined behavior.}}
\DoxyCodeLine{7890 \textcolor{comment}{}}
\DoxyCodeLine{7891 \textcolor{comment}{v0.12.19 -\/ 2021-\/02-\/21}}
\DoxyCodeLine{7892 \textcolor{comment}{  -\/ Fix a warning due to referencing \_MSC\_VER when it is undefined.}}
\DoxyCodeLine{7893 \textcolor{comment}{  -\/ Minor improvements to the management of some internal state concerning the data chunk cursor.}}
\DoxyCodeLine{7894 \textcolor{comment}{}}
\DoxyCodeLine{7895 \textcolor{comment}{v0.12.18 -\/ 2021-\/01-\/31}}
\DoxyCodeLine{7896 \textcolor{comment}{  -\/ Clean up some static analysis warnings.}}
\DoxyCodeLine{7897 \textcolor{comment}{}}
\DoxyCodeLine{7898 \textcolor{comment}{v0.12.17 -\/ 2021-\/01-\/17}}
\DoxyCodeLine{7899 \textcolor{comment}{  -\/ Minor fix to sample code in documentation.}}
\DoxyCodeLine{7900 \textcolor{comment}{  -\/ Correctly qualify a private API as private rather than public.}}
\DoxyCodeLine{7901 \textcolor{comment}{  -\/ Code cleanup.}}
\DoxyCodeLine{7902 \textcolor{comment}{}}
\DoxyCodeLine{7903 \textcolor{comment}{v0.12.16 -\/ 2020-\/12-\/02}}
\DoxyCodeLine{7904 \textcolor{comment}{  -\/ Fix a bug when trying to read more bytes than can fit in a size\_t.}}
\DoxyCodeLine{7905 \textcolor{comment}{}}
\DoxyCodeLine{7906 \textcolor{comment}{v0.12.15 -\/ 2020-\/11-\/21}}
\DoxyCodeLine{7907 \textcolor{comment}{  -\/ Fix compilation with OpenWatcom.}}
\DoxyCodeLine{7908 \textcolor{comment}{}}
\DoxyCodeLine{7909 \textcolor{comment}{v0.12.14 -\/ 2020-\/11-\/13}}
\DoxyCodeLine{7910 \textcolor{comment}{  -\/ Minor code clean up.}}
\DoxyCodeLine{7911 \textcolor{comment}{}}
\DoxyCodeLine{7912 \textcolor{comment}{v0.12.13 -\/ 2020-\/11-\/01}}
\DoxyCodeLine{7913 \textcolor{comment}{  -\/ Improve compiler support for older versions of GCC.}}
\DoxyCodeLine{7914 \textcolor{comment}{}}
\DoxyCodeLine{7915 \textcolor{comment}{v0.12.12 -\/ 2020-\/09-\/28}}
\DoxyCodeLine{7916 \textcolor{comment}{  -\/ Add support for RF64.}}
\DoxyCodeLine{7917 \textcolor{comment}{  -\/ Fix a bug in writing mode where the size of the RIFF chunk incorrectly includes the header section.}}
\DoxyCodeLine{7918 \textcolor{comment}{}}
\DoxyCodeLine{7919 \textcolor{comment}{v0.12.11 -\/ 2020-\/09-\/08}}
\DoxyCodeLine{7920 \textcolor{comment}{  -\/ Fix a compilation error on older compilers.}}
\DoxyCodeLine{7921 \textcolor{comment}{}}
\DoxyCodeLine{7922 \textcolor{comment}{v0.12.10 -\/ 2020-\/08-\/24}}
\DoxyCodeLine{7923 \textcolor{comment}{  -\/ Fix a bug when seeking with ADPCM formats.}}
\DoxyCodeLine{7924 \textcolor{comment}{}}
\DoxyCodeLine{7925 \textcolor{comment}{v0.12.9 -\/ 2020-\/08-\/02}}
\DoxyCodeLine{7926 \textcolor{comment}{  -\/ Simplify sized types.}}
\DoxyCodeLine{7927 \textcolor{comment}{}}
\DoxyCodeLine{7928 \textcolor{comment}{v0.12.8 -\/ 2020-\/07-\/25}}
\DoxyCodeLine{7929 \textcolor{comment}{  -\/ Fix a compilation warning.}}
\DoxyCodeLine{7930 \textcolor{comment}{}}
\DoxyCodeLine{7931 \textcolor{comment}{v0.12.7 -\/ 2020-\/07-\/15}}
\DoxyCodeLine{7932 \textcolor{comment}{  -\/ Fix some bugs on big-\/endian architectures.}}
\DoxyCodeLine{7933 \textcolor{comment}{  -\/ Fix an error in s24 to f32 conversion.}}
\DoxyCodeLine{7934 \textcolor{comment}{}}
\DoxyCodeLine{7935 \textcolor{comment}{v0.12.6 -\/ 2020-\/06-\/23}}
\DoxyCodeLine{7936 \textcolor{comment}{  -\/ Change drwav\_read\_*() to allow NULL to be passed in as the output buffer which is equivalent to a forward seek.}}
\DoxyCodeLine{7937 \textcolor{comment}{  -\/ Fix a buffer overflow when trying to decode invalid IMA-\/ADPCM files.}}
\DoxyCodeLine{7938 \textcolor{comment}{  -\/ Add include guard for the implementation section.}}
\DoxyCodeLine{7939 \textcolor{comment}{}}
\DoxyCodeLine{7940 \textcolor{comment}{v0.12.5 -\/ 2020-\/05-\/27}}
\DoxyCodeLine{7941 \textcolor{comment}{  -\/ Minor documentation fix.}}
\DoxyCodeLine{7942 \textcolor{comment}{}}
\DoxyCodeLine{7943 \textcolor{comment}{v0.12.4 -\/ 2020-\/05-\/16}}
\DoxyCodeLine{7944 \textcolor{comment}{  -\/ Replace assert() with DRWAV\_ASSERT().}}
\DoxyCodeLine{7945 \textcolor{comment}{  -\/ Add compile-\/time and run-\/time version querying.}}
\DoxyCodeLine{7946 \textcolor{comment}{    -\/ DRWAV\_VERSION\_MINOR}}
\DoxyCodeLine{7947 \textcolor{comment}{    -\/ DRWAV\_VERSION\_MAJOR}}
\DoxyCodeLine{7948 \textcolor{comment}{    -\/ DRWAV\_VERSION\_REVISION}}
\DoxyCodeLine{7949 \textcolor{comment}{    -\/ DRWAV\_VERSION\_STRING}}
\DoxyCodeLine{7950 \textcolor{comment}{    -\/ drwav\_version()}}
\DoxyCodeLine{7951 \textcolor{comment}{    -\/ drwav\_version\_string()}}
\DoxyCodeLine{7952 \textcolor{comment}{}}
\DoxyCodeLine{7953 \textcolor{comment}{v0.12.3 -\/ 2020-\/04-\/30}}
\DoxyCodeLine{7954 \textcolor{comment}{  -\/ Fix compilation errors with VC6.}}
\DoxyCodeLine{7955 \textcolor{comment}{}}
\DoxyCodeLine{7956 \textcolor{comment}{v0.12.2 -\/ 2020-\/04-\/21}}
\DoxyCodeLine{7957 \textcolor{comment}{  -\/ Fix a bug where drwav\_init\_file() does not close the file handle after attempting to load an erroneous file.}}
\DoxyCodeLine{7958 \textcolor{comment}{}}
\DoxyCodeLine{7959 \textcolor{comment}{v0.12.1 -\/ 2020-\/04-\/13}}
\DoxyCodeLine{7960 \textcolor{comment}{  -\/ Fix some pedantic warnings.}}
\DoxyCodeLine{7961 \textcolor{comment}{}}
\DoxyCodeLine{7962 \textcolor{comment}{v0.12.0 -\/ 2020-\/04-\/04}}
\DoxyCodeLine{7963 \textcolor{comment}{  -\/ API CHANGE: Add container and format parameters to the chunk callback.}}
\DoxyCodeLine{7964 \textcolor{comment}{  -\/ Minor documentation updates.}}
\DoxyCodeLine{7965 \textcolor{comment}{}}
\DoxyCodeLine{7966 \textcolor{comment}{v0.11.5 -\/ 2020-\/03-\/07}}
\DoxyCodeLine{7967 \textcolor{comment}{  -\/ Fix compilation error with Visual Studio .NET 2003.}}
\DoxyCodeLine{7968 \textcolor{comment}{}}
\DoxyCodeLine{7969 \textcolor{comment}{v0.11.4 -\/ 2020-\/01-\/29}}
\DoxyCodeLine{7970 \textcolor{comment}{  -\/ Fix some static analysis warnings.}}
\DoxyCodeLine{7971 \textcolor{comment}{  -\/ Fix a bug when reading f32 samples from an A-\/law encoded stream.}}
\DoxyCodeLine{7972 \textcolor{comment}{}}
\DoxyCodeLine{7973 \textcolor{comment}{v0.11.3 -\/ 2020-\/01-\/12}}
\DoxyCodeLine{7974 \textcolor{comment}{  -\/ Minor changes to some f32 format conversion routines.}}
\DoxyCodeLine{7975 \textcolor{comment}{  -\/ Minor bug fix for ADPCM conversion when end of file is reached.}}
\DoxyCodeLine{7976 \textcolor{comment}{}}
\DoxyCodeLine{7977 \textcolor{comment}{v0.11.2 -\/ 2019-\/12-\/02}}
\DoxyCodeLine{7978 \textcolor{comment}{  -\/ Fix a possible crash when using custom memory allocators without a custom realloc() implementation.}}
\DoxyCodeLine{7979 \textcolor{comment}{  -\/ Fix an integer overflow bug.}}
\DoxyCodeLine{7980 \textcolor{comment}{  -\/ Fix a null pointer dereference bug.}}
\DoxyCodeLine{7981 \textcolor{comment}{  -\/ Add limits to sample rate, channels and bits per sample to tighten up some validation.}}
\DoxyCodeLine{7982 \textcolor{comment}{}}
\DoxyCodeLine{7983 \textcolor{comment}{v0.11.1 -\/ 2019-\/10-\/07}}
\DoxyCodeLine{7984 \textcolor{comment}{  -\/ Internal code clean up.}}
\DoxyCodeLine{7985 \textcolor{comment}{}}
\DoxyCodeLine{7986 \textcolor{comment}{v0.11.0 -\/ 2019-\/10-\/06}}
\DoxyCodeLine{7987 \textcolor{comment}{  -\/ API CHANGE: Add support for user defined memory allocation routines. This system allows the program to specify their own memory allocation}}
\DoxyCodeLine{7988 \textcolor{comment}{    routines with a user data pointer for client-\/specific contextual data. This adds an extra parameter to the end of the following APIs:}}
\DoxyCodeLine{7989 \textcolor{comment}{    -\/ drwav\_init()}}
\DoxyCodeLine{7990 \textcolor{comment}{    -\/ drwav\_init\_ex()}}
\DoxyCodeLine{7991 \textcolor{comment}{    -\/ drwav\_init\_file()}}
\DoxyCodeLine{7992 \textcolor{comment}{    -\/ drwav\_init\_file\_ex()}}
\DoxyCodeLine{7993 \textcolor{comment}{    -\/ drwav\_init\_file\_w()}}
\DoxyCodeLine{7994 \textcolor{comment}{    -\/ drwav\_init\_file\_w\_ex()}}
\DoxyCodeLine{7995 \textcolor{comment}{    -\/ drwav\_init\_memory()}}
\DoxyCodeLine{7996 \textcolor{comment}{    -\/ drwav\_init\_memory\_ex()}}
\DoxyCodeLine{7997 \textcolor{comment}{    -\/ drwav\_init\_write()}}
\DoxyCodeLine{7998 \textcolor{comment}{    -\/ drwav\_init\_write\_sequential()}}
\DoxyCodeLine{7999 \textcolor{comment}{    -\/ drwav\_init\_write\_sequential\_pcm\_frames()}}
\DoxyCodeLine{8000 \textcolor{comment}{    -\/ drwav\_init\_file\_write()}}
\DoxyCodeLine{8001 \textcolor{comment}{    -\/ drwav\_init\_file\_write\_sequential()}}
\DoxyCodeLine{8002 \textcolor{comment}{    -\/ drwav\_init\_file\_write\_sequential\_pcm\_frames()}}
\DoxyCodeLine{8003 \textcolor{comment}{    -\/ drwav\_init\_file\_write\_w()}}
\DoxyCodeLine{8004 \textcolor{comment}{    -\/ drwav\_init\_file\_write\_sequential\_w()}}
\DoxyCodeLine{8005 \textcolor{comment}{    -\/ drwav\_init\_file\_write\_sequential\_pcm\_frames\_w()}}
\DoxyCodeLine{8006 \textcolor{comment}{    -\/ drwav\_init\_memory\_write()}}
\DoxyCodeLine{8007 \textcolor{comment}{    -\/ drwav\_init\_memory\_write\_sequential()}}
\DoxyCodeLine{8008 \textcolor{comment}{    -\/ drwav\_init\_memory\_write\_sequential\_pcm\_frames()}}
\DoxyCodeLine{8009 \textcolor{comment}{    -\/ drwav\_open\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8010 \textcolor{comment}{    -\/ drwav\_open\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8011 \textcolor{comment}{    -\/ drwav\_open\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8012 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8013 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8014 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8015 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_s16\_w()}}
\DoxyCodeLine{8016 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_f32\_w()}}
\DoxyCodeLine{8017 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_s32\_w()}}
\DoxyCodeLine{8018 \textcolor{comment}{    -\/ drwav\_open\_memory\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8019 \textcolor{comment}{    -\/ drwav\_open\_memory\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8020 \textcolor{comment}{    -\/ drwav\_open\_memory\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8021 \textcolor{comment}{    Set this extra parameter to NULL to use defaults which is the same as the previous behaviour. Setting this NULL will use}}
\DoxyCodeLine{8022 \textcolor{comment}{    DRWAV\_MALLOC, DRWAV\_REALLOC and DRWAV\_FREE.}}
\DoxyCodeLine{8023 \textcolor{comment}{  -\/ Add support for reading and writing PCM frames in an explicit endianness. New APIs:}}
\DoxyCodeLine{8024 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_le()}}
\DoxyCodeLine{8025 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_be()}}
\DoxyCodeLine{8026 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_s16le()}}
\DoxyCodeLine{8027 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_s16be()}}
\DoxyCodeLine{8028 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_f32le()}}
\DoxyCodeLine{8029 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_f32be()}}
\DoxyCodeLine{8030 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_s32le()}}
\DoxyCodeLine{8031 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_s32be()}}
\DoxyCodeLine{8032 \textcolor{comment}{    -\/ drwav\_write\_pcm\_frames\_le()}}
\DoxyCodeLine{8033 \textcolor{comment}{    -\/ drwav\_write\_pcm\_frames\_be()}}
\DoxyCodeLine{8034 \textcolor{comment}{  -\/ Remove deprecated APIs.}}
\DoxyCodeLine{8035 \textcolor{comment}{  -\/ API CHANGE: The following APIs now return native-\/endian data. Previously they returned little-\/endian data.}}
\DoxyCodeLine{8036 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames()}}
\DoxyCodeLine{8037 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8038 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8039 \textcolor{comment}{    -\/ drwav\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8040 \textcolor{comment}{    -\/ drwav\_open\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8041 \textcolor{comment}{    -\/ drwav\_open\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8042 \textcolor{comment}{    -\/ drwav\_open\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8043 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8044 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8045 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8046 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_s16\_w()}}
\DoxyCodeLine{8047 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_s32\_w()}}
\DoxyCodeLine{8048 \textcolor{comment}{    -\/ drwav\_open\_file\_and\_read\_pcm\_frames\_f32\_w()}}
\DoxyCodeLine{8049 \textcolor{comment}{    -\/ drwav\_open\_memory\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8050 \textcolor{comment}{    -\/ drwav\_open\_memory\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8051 \textcolor{comment}{    -\/ drwav\_open\_memory\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8052 \textcolor{comment}{}}
\DoxyCodeLine{8053 \textcolor{comment}{v0.10.1 -\/ 2019-\/08-\/31}}
\DoxyCodeLine{8054 \textcolor{comment}{  -\/ Correctly handle partial trailing ADPCM blocks.}}
\DoxyCodeLine{8055 \textcolor{comment}{}}
\DoxyCodeLine{8056 \textcolor{comment}{v0.10.0 -\/ 2019-\/08-\/04}}
\DoxyCodeLine{8057 \textcolor{comment}{  -\/ Remove deprecated APIs.}}
\DoxyCodeLine{8058 \textcolor{comment}{  -\/ Add wchar\_t variants for file loading APIs:}}
\DoxyCodeLine{8059 \textcolor{comment}{      drwav\_init\_file\_w()}}
\DoxyCodeLine{8060 \textcolor{comment}{      drwav\_init\_file\_ex\_w()}}
\DoxyCodeLine{8061 \textcolor{comment}{      drwav\_init\_file\_write\_w()}}
\DoxyCodeLine{8062 \textcolor{comment}{      drwav\_init\_file\_write\_sequential\_w()}}
\DoxyCodeLine{8063 \textcolor{comment}{  -\/ Add drwav\_target\_write\_size\_bytes() which calculates the total size in bytes of a WAV file given a format and sample count.}}
\DoxyCodeLine{8064 \textcolor{comment}{  -\/ Add APIs for specifying the PCM frame count instead of the sample count when opening in sequential write mode:}}
\DoxyCodeLine{8065 \textcolor{comment}{      drwav\_init\_write\_sequential\_pcm\_frames()}}
\DoxyCodeLine{8066 \textcolor{comment}{      drwav\_init\_file\_write\_sequential\_pcm\_frames()}}
\DoxyCodeLine{8067 \textcolor{comment}{      drwav\_init\_file\_write\_sequential\_pcm\_frames\_w()}}
\DoxyCodeLine{8068 \textcolor{comment}{      drwav\_init\_memory\_write\_sequential\_pcm\_frames()}}
\DoxyCodeLine{8069 \textcolor{comment}{  -\/ Deprecate drwav\_open*() and drwav\_close():}}
\DoxyCodeLine{8070 \textcolor{comment}{      drwav\_open()}}
\DoxyCodeLine{8071 \textcolor{comment}{      drwav\_open\_ex()}}
\DoxyCodeLine{8072 \textcolor{comment}{      drwav\_open\_write()}}
\DoxyCodeLine{8073 \textcolor{comment}{      drwav\_open\_write\_sequential()}}
\DoxyCodeLine{8074 \textcolor{comment}{      drwav\_open\_file()}}
\DoxyCodeLine{8075 \textcolor{comment}{      drwav\_open\_file\_ex()}}
\DoxyCodeLine{8076 \textcolor{comment}{      drwav\_open\_file\_write()}}
\DoxyCodeLine{8077 \textcolor{comment}{      drwav\_open\_file\_write\_sequential()}}
\DoxyCodeLine{8078 \textcolor{comment}{      drwav\_open\_memory()}}
\DoxyCodeLine{8079 \textcolor{comment}{      drwav\_open\_memory\_ex()}}
\DoxyCodeLine{8080 \textcolor{comment}{      drwav\_open\_memory\_write()}}
\DoxyCodeLine{8081 \textcolor{comment}{      drwav\_open\_memory\_write\_sequential()}}
\DoxyCodeLine{8082 \textcolor{comment}{      drwav\_close()}}
\DoxyCodeLine{8083 \textcolor{comment}{  -\/ Minor documentation updates.}}
\DoxyCodeLine{8084 \textcolor{comment}{}}
\DoxyCodeLine{8085 \textcolor{comment}{v0.9.2 -\/ 2019-\/05-\/21}}
\DoxyCodeLine{8086 \textcolor{comment}{  -\/ Fix warnings.}}
\DoxyCodeLine{8087 \textcolor{comment}{}}
\DoxyCodeLine{8088 \textcolor{comment}{v0.9.1 -\/ 2019-\/05-\/05}}
\DoxyCodeLine{8089 \textcolor{comment}{  -\/ Add support for C89.}}
\DoxyCodeLine{8090 \textcolor{comment}{  -\/ Change license to choice of public domain or MIT-\/0.}}
\DoxyCodeLine{8091 \textcolor{comment}{}}
\DoxyCodeLine{8092 \textcolor{comment}{v0.9.0 -\/ 2018-\/12-\/16}}
\DoxyCodeLine{8093 \textcolor{comment}{  -\/ API CHANGE: Add new reading APIs for reading by PCM frames instead of samples. Old APIs have been deprecated and}}
\DoxyCodeLine{8094 \textcolor{comment}{    will be removed in v0.10.0. Deprecated APIs and their replacements:}}
\DoxyCodeLine{8095 \textcolor{comment}{      drwav\_read()                     -\/> drwav\_read\_pcm\_frames()}}
\DoxyCodeLine{8096 \textcolor{comment}{      drwav\_read\_s16()                 -\/> drwav\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8097 \textcolor{comment}{      drwav\_read\_f32()                 -\/> drwav\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8098 \textcolor{comment}{      drwav\_read\_s32()                 -\/> drwav\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8099 \textcolor{comment}{      drwav\_seek\_to\_sample()           -\/> drwav\_seek\_to\_pcm\_frame()}}
\DoxyCodeLine{8100 \textcolor{comment}{      drwav\_write()                    -\/> drwav\_write\_pcm\_frames()}}
\DoxyCodeLine{8101 \textcolor{comment}{      drwav\_open\_and\_read\_s16()        -\/> drwav\_open\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8102 \textcolor{comment}{      drwav\_open\_and\_read\_f32()        -\/> drwav\_open\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8103 \textcolor{comment}{      drwav\_open\_and\_read\_s32()        -\/> drwav\_open\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8104 \textcolor{comment}{      drwav\_open\_file\_and\_read\_s16()   -\/> drwav\_open\_file\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8105 \textcolor{comment}{      drwav\_open\_file\_and\_read\_f32()   -\/> drwav\_open\_file\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8106 \textcolor{comment}{      drwav\_open\_file\_and\_read\_s32()   -\/> drwav\_open\_file\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8107 \textcolor{comment}{      drwav\_open\_memory\_and\_read\_s16() -\/> drwav\_open\_memory\_and\_read\_pcm\_frames\_s16()}}
\DoxyCodeLine{8108 \textcolor{comment}{      drwav\_open\_memory\_and\_read\_f32() -\/> drwav\_open\_memory\_and\_read\_pcm\_frames\_f32()}}
\DoxyCodeLine{8109 \textcolor{comment}{      drwav\_open\_memory\_and\_read\_s32() -\/> drwav\_open\_memory\_and\_read\_pcm\_frames\_s32()}}
\DoxyCodeLine{8110 \textcolor{comment}{      drwav::totalSampleCount          -\/> drwav::totalPCMFrameCount}}
\DoxyCodeLine{8111 \textcolor{comment}{  -\/ API CHANGE: Rename drwav\_open\_and\_read\_file\_*() to drwav\_open\_file\_and\_read\_*().}}
\DoxyCodeLine{8112 \textcolor{comment}{  -\/ API CHANGE: Rename drwav\_open\_and\_read\_memory\_*() to drwav\_open\_memory\_and\_read\_*().}}
\DoxyCodeLine{8113 \textcolor{comment}{  -\/ Add built-\/in support for smpl chunks.}}
\DoxyCodeLine{8114 \textcolor{comment}{  -\/ Add support for firing a callback for each chunk in the file at initialization time.}}
\DoxyCodeLine{8115 \textcolor{comment}{    -\/ This is enabled through the drwav\_init\_ex(), etc. family of APIs.}}
\DoxyCodeLine{8116 \textcolor{comment}{  -\/ Handle invalid FMT chunks more robustly.}}
\DoxyCodeLine{8117 \textcolor{comment}{}}
\DoxyCodeLine{8118 \textcolor{comment}{v0.8.5 -\/ 2018-\/09-\/11}}
\DoxyCodeLine{8119 \textcolor{comment}{  -\/ Const correctness.}}
\DoxyCodeLine{8120 \textcolor{comment}{  -\/ Fix a potential stack overflow.}}
\DoxyCodeLine{8121 \textcolor{comment}{}}
\DoxyCodeLine{8122 \textcolor{comment}{v0.8.4 -\/ 2018-\/08-\/07}}
\DoxyCodeLine{8123 \textcolor{comment}{  -\/ Improve 64-\/bit detection.}}
\DoxyCodeLine{8124 \textcolor{comment}{}}
\DoxyCodeLine{8125 \textcolor{comment}{v0.8.3 -\/ 2018-\/08-\/05}}
\DoxyCodeLine{8126 \textcolor{comment}{  -\/ Fix C++ build on older versions of GCC.}}
\DoxyCodeLine{8127 \textcolor{comment}{}}
\DoxyCodeLine{8128 \textcolor{comment}{v0.8.2 -\/ 2018-\/08-\/02}}
\DoxyCodeLine{8129 \textcolor{comment}{  -\/ Fix some big-\/endian bugs.}}
\DoxyCodeLine{8130 \textcolor{comment}{}}
\DoxyCodeLine{8131 \textcolor{comment}{v0.8.1 -\/ 2018-\/06-\/29}}
\DoxyCodeLine{8132 \textcolor{comment}{  -\/ Add support for sequential writing APIs.}}
\DoxyCodeLine{8133 \textcolor{comment}{  -\/ Disable seeking in write mode.}}
\DoxyCodeLine{8134 \textcolor{comment}{  -\/ Fix bugs with Wave64.}}
\DoxyCodeLine{8135 \textcolor{comment}{  -\/ Fix typos.}}
\DoxyCodeLine{8136 \textcolor{comment}{}}
\DoxyCodeLine{8137 \textcolor{comment}{v0.8 -\/ 2018-\/04-\/27}}
\DoxyCodeLine{8138 \textcolor{comment}{  -\/ Bug fix.}}
\DoxyCodeLine{8139 \textcolor{comment}{  -\/ Start using major.minor.revision versioning.}}
\DoxyCodeLine{8140 \textcolor{comment}{}}
\DoxyCodeLine{8141 \textcolor{comment}{v0.7f -\/ 2018-\/02-\/05}}
\DoxyCodeLine{8142 \textcolor{comment}{  -\/ Restrict ADPCM formats to a maximum of 2 channels.}}
\DoxyCodeLine{8143 \textcolor{comment}{}}
\DoxyCodeLine{8144 \textcolor{comment}{v0.7e -\/ 2018-\/02-\/02}}
\DoxyCodeLine{8145 \textcolor{comment}{  -\/ Fix a crash.}}
\DoxyCodeLine{8146 \textcolor{comment}{}}
\DoxyCodeLine{8147 \textcolor{comment}{v0.7d -\/ 2018-\/02-\/01}}
\DoxyCodeLine{8148 \textcolor{comment}{  -\/ Fix a crash.}}
\DoxyCodeLine{8149 \textcolor{comment}{}}
\DoxyCodeLine{8150 \textcolor{comment}{v0.7c -\/ 2018-\/02-\/01}}
\DoxyCodeLine{8151 \textcolor{comment}{  -\/ Set drwav.bytesPerSample to 0 for all compressed formats.}}
\DoxyCodeLine{8152 \textcolor{comment}{  -\/ Fix a crash when reading 16-\/bit floating point WAV files. In this case dr\_wav will output silence for}}
\DoxyCodeLine{8153 \textcolor{comment}{    all format conversion reading APIs (*\_s16, *\_s32, *\_f32 APIs).}}
\DoxyCodeLine{8154 \textcolor{comment}{  -\/ Fix some divide-\/by-\/zero errors.}}
\DoxyCodeLine{8155 \textcolor{comment}{}}
\DoxyCodeLine{8156 \textcolor{comment}{v0.7b -\/ 2018-\/01-\/22}}
\DoxyCodeLine{8157 \textcolor{comment}{  -\/ Fix errors with seeking of compressed formats.}}
\DoxyCodeLine{8158 \textcolor{comment}{  -\/ Fix compilation error when DR\_WAV\_NO\_CONVERSION\_API}}
\DoxyCodeLine{8159 \textcolor{comment}{}}
\DoxyCodeLine{8160 \textcolor{comment}{v0.7a -\/ 2017-\/11-\/17}}
\DoxyCodeLine{8161 \textcolor{comment}{  -\/ Fix some GCC warnings.}}
\DoxyCodeLine{8162 \textcolor{comment}{}}
\DoxyCodeLine{8163 \textcolor{comment}{v0.7 -\/ 2017-\/11-\/04}}
\DoxyCodeLine{8164 \textcolor{comment}{  -\/ Add writing APIs.}}
\DoxyCodeLine{8165 \textcolor{comment}{}}
\DoxyCodeLine{8166 \textcolor{comment}{v0.6 -\/ 2017-\/08-\/16}}
\DoxyCodeLine{8167 \textcolor{comment}{  -\/ API CHANGE: Rename dr\_* types to drwav\_*.}}
\DoxyCodeLine{8168 \textcolor{comment}{  -\/ Add support for custom implementations of malloc(), realloc(), etc.}}
\DoxyCodeLine{8169 \textcolor{comment}{  -\/ Add support for Microsoft ADPCM.}}
\DoxyCodeLine{8170 \textcolor{comment}{  -\/ Add support for IMA ADPCM (DVI, format code 0x11).}}
\DoxyCodeLine{8171 \textcolor{comment}{  -\/ Optimizations to drwav\_read\_s16().}}
\DoxyCodeLine{8172 \textcolor{comment}{  -\/ Bug fixes.}}
\DoxyCodeLine{8173 \textcolor{comment}{}}
\DoxyCodeLine{8174 \textcolor{comment}{v0.5g -\/ 2017-\/07-\/16}}
\DoxyCodeLine{8175 \textcolor{comment}{  -\/ Change underlying type for booleans to unsigned.}}
\DoxyCodeLine{8176 \textcolor{comment}{}}
\DoxyCodeLine{8177 \textcolor{comment}{v0.5f -\/ 2017-\/04-\/04}}
\DoxyCodeLine{8178 \textcolor{comment}{  -\/ Fix a minor bug with drwav\_open\_and\_read\_s16() and family.}}
\DoxyCodeLine{8179 \textcolor{comment}{}}
\DoxyCodeLine{8180 \textcolor{comment}{v0.5e -\/ 2016-\/12-\/29}}
\DoxyCodeLine{8181 \textcolor{comment}{  -\/ Added support for reading samples as signed 16-\/bit integers. Use the \_s16() family of APIs for this.}}
\DoxyCodeLine{8182 \textcolor{comment}{  -\/ Minor fixes to documentation.}}
\DoxyCodeLine{8183 \textcolor{comment}{}}
\DoxyCodeLine{8184 \textcolor{comment}{v0.5d -\/ 2016-\/12-\/28}}
\DoxyCodeLine{8185 \textcolor{comment}{  -\/ Use drwav\_int* and drwav\_uint* sized types to improve compiler support.}}
\DoxyCodeLine{8186 \textcolor{comment}{}}
\DoxyCodeLine{8187 \textcolor{comment}{v0.5c -\/ 2016-\/11-\/11}}
\DoxyCodeLine{8188 \textcolor{comment}{  -\/ Properly handle JUNK chunks that come before the FMT chunk.}}
\DoxyCodeLine{8189 \textcolor{comment}{}}
\DoxyCodeLine{8190 \textcolor{comment}{v0.5b -\/ 2016-\/10-\/23}}
\DoxyCodeLine{8191 \textcolor{comment}{  -\/ A minor change to drwav\_bool8 and drwav\_bool32 types.}}
\DoxyCodeLine{8192 \textcolor{comment}{}}
\DoxyCodeLine{8193 \textcolor{comment}{v0.5a -\/ 2016-\/10-\/11}}
\DoxyCodeLine{8194 \textcolor{comment}{  -\/ Fixed a bug with drwav\_open\_and\_read() and family due to incorrect argument ordering.}}
\DoxyCodeLine{8195 \textcolor{comment}{  -\/ Improve A-\/law and mu-\/law efficiency.}}
\DoxyCodeLine{8196 \textcolor{comment}{}}
\DoxyCodeLine{8197 \textcolor{comment}{v0.5 -\/ 2016-\/09-\/29}}
\DoxyCodeLine{8198 \textcolor{comment}{  -\/ API CHANGE. Swap the order of "{}channels"{} and "{}sampleRate"{} parameters in drwav\_open\_and\_read*(). Rationale for this is to}}
\DoxyCodeLine{8199 \textcolor{comment}{    keep it consistent with dr\_audio and dr\_flac.}}
\DoxyCodeLine{8200 \textcolor{comment}{}}
\DoxyCodeLine{8201 \textcolor{comment}{v0.4b -\/ 2016-\/09-\/18}}
\DoxyCodeLine{8202 \textcolor{comment}{  -\/ Fixed a typo in documentation.}}
\DoxyCodeLine{8203 \textcolor{comment}{}}
\DoxyCodeLine{8204 \textcolor{comment}{v0.4a -\/ 2016-\/09-\/18}}
\DoxyCodeLine{8205 \textcolor{comment}{  -\/ Fixed a typo.}}
\DoxyCodeLine{8206 \textcolor{comment}{  -\/ Change date format to ISO 8601 (YYYY-\/MM-\/DD)}}
\DoxyCodeLine{8207 \textcolor{comment}{}}
\DoxyCodeLine{8208 \textcolor{comment}{v0.4 -\/ 2016-\/07-\/13}}
\DoxyCodeLine{8209 \textcolor{comment}{  -\/ API CHANGE. Make onSeek consistent with dr\_flac.}}
\DoxyCodeLine{8210 \textcolor{comment}{  -\/ API CHANGE. Rename drwav\_seek() to drwav\_seek\_to\_sample() for clarity and consistency with dr\_flac.}}
\DoxyCodeLine{8211 \textcolor{comment}{  -\/ Added support for Sony Wave64.}}
\DoxyCodeLine{8212 \textcolor{comment}{}}
\DoxyCodeLine{8213 \textcolor{comment}{v0.3a -\/ 2016-\/05-\/28}}
\DoxyCodeLine{8214 \textcolor{comment}{  -\/ API CHANGE. Return drwav\_bool32 instead of int in onSeek callback.}}
\DoxyCodeLine{8215 \textcolor{comment}{  -\/ Fixed a memory leak.}}
\DoxyCodeLine{8216 \textcolor{comment}{}}
\DoxyCodeLine{8217 \textcolor{comment}{v0.3 -\/ 2016-\/05-\/22}}
\DoxyCodeLine{8218 \textcolor{comment}{  -\/ Lots of API changes for consistency.}}
\DoxyCodeLine{8219 \textcolor{comment}{}}
\DoxyCodeLine{8220 \textcolor{comment}{v0.2a -\/ 2016-\/05-\/16}}
\DoxyCodeLine{8221 \textcolor{comment}{  -\/ Fixed Linux/GCC build.}}
\DoxyCodeLine{8222 \textcolor{comment}{}}
\DoxyCodeLine{8223 \textcolor{comment}{v0.2 -\/ 2016-\/05-\/11}}
\DoxyCodeLine{8224 \textcolor{comment}{  -\/ Added support for reading data as signed 32-\/bit PCM for consistency with dr\_flac.}}
\DoxyCodeLine{8225 \textcolor{comment}{}}
\DoxyCodeLine{8226 \textcolor{comment}{v0.1a -\/ 2016-\/05-\/07}}
\DoxyCodeLine{8227 \textcolor{comment}{  -\/ Fixed a bug in drwav\_open\_file() where the file handle would not be closed if the loader failed to initialize.}}
\DoxyCodeLine{8228 \textcolor{comment}{}}
\DoxyCodeLine{8229 \textcolor{comment}{v0.1 -\/ 2016-\/05-\/04}}
\DoxyCodeLine{8230 \textcolor{comment}{  -\/ Initial versioned release.}}
\DoxyCodeLine{8231 \textcolor{comment}{*/}}
\DoxyCodeLine{8232 }
\DoxyCodeLine{8233 \textcolor{comment}{/*}}
\DoxyCodeLine{8234 \textcolor{comment}{This software is available as a choice of the following licenses. Choose}}
\DoxyCodeLine{8235 \textcolor{comment}{whichever you prefer.}}
\DoxyCodeLine{8236 \textcolor{comment}{}}
\DoxyCodeLine{8237 \textcolor{comment}{===============================================================================}}
\DoxyCodeLine{8238 \textcolor{comment}{ALTERNATIVE 1 -\/ Public Domain (www.unlicense.org)}}
\DoxyCodeLine{8239 \textcolor{comment}{===============================================================================}}
\DoxyCodeLine{8240 \textcolor{comment}{This is free and unencumbered software released into the public domain.}}
\DoxyCodeLine{8241 \textcolor{comment}{}}
\DoxyCodeLine{8242 \textcolor{comment}{Anyone is free to copy, modify, publish, use, compile, sell, or distribute this}}
\DoxyCodeLine{8243 \textcolor{comment}{software, either in source code form or as a compiled binary, for any purpose,}}
\DoxyCodeLine{8244 \textcolor{comment}{commercial or non-\/commercial, and by any means.}}
\DoxyCodeLine{8245 \textcolor{comment}{}}
\DoxyCodeLine{8246 \textcolor{comment}{In jurisdictions that recognize copyright laws, the author or authors of this}}
\DoxyCodeLine{8247 \textcolor{comment}{software dedicate any and all copyright interest in the software to the public}}
\DoxyCodeLine{8248 \textcolor{comment}{domain. We make this dedication for the benefit of the public at large and to}}
\DoxyCodeLine{8249 \textcolor{comment}{the detriment of our heirs and successors. We intend this dedication to be an}}
\DoxyCodeLine{8250 \textcolor{comment}{overt act of relinquishment in perpetuity of all present and future rights to}}
\DoxyCodeLine{8251 \textcolor{comment}{this software under copyright law.}}
\DoxyCodeLine{8252 \textcolor{comment}{}}
\DoxyCodeLine{8253 \textcolor{comment}{THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{8254 \textcolor{comment}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}}
\DoxyCodeLine{8255 \textcolor{comment}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}}
\DoxyCodeLine{8256 \textcolor{comment}{AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN}}
\DoxyCodeLine{8257 \textcolor{comment}{ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION}}
\DoxyCodeLine{8258 \textcolor{comment}{WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{8259 \textcolor{comment}{}}
\DoxyCodeLine{8260 \textcolor{comment}{For more information, please refer to <http://unlicense.org/>}}
\DoxyCodeLine{8261 \textcolor{comment}{}}
\DoxyCodeLine{8262 \textcolor{comment}{===============================================================================}}
\DoxyCodeLine{8263 \textcolor{comment}{ALTERNATIVE 2 -\/ MIT No Attribution}}
\DoxyCodeLine{8264 \textcolor{comment}{===============================================================================}}
\DoxyCodeLine{8265 \textcolor{comment}{Copyright 2020 David Reid}}
\DoxyCodeLine{8266 \textcolor{comment}{}}
\DoxyCodeLine{8267 \textcolor{comment}{Permission is hereby granted, free of charge, to any person obtaining a copy of}}
\DoxyCodeLine{8268 \textcolor{comment}{this software and associated documentation files (the "{}Software"{}), to deal in}}
\DoxyCodeLine{8269 \textcolor{comment}{the Software without restriction, including without limitation the rights to}}
\DoxyCodeLine{8270 \textcolor{comment}{use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies}}
\DoxyCodeLine{8271 \textcolor{comment}{of the Software, and to permit persons to whom the Software is furnished to do}}
\DoxyCodeLine{8272 \textcolor{comment}{so.}}
\DoxyCodeLine{8273 \textcolor{comment}{}}
\DoxyCodeLine{8274 \textcolor{comment}{THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{8275 \textcolor{comment}{IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}}
\DoxyCodeLine{8276 \textcolor{comment}{FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}}
\DoxyCodeLine{8277 \textcolor{comment}{AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}}
\DoxyCodeLine{8278 \textcolor{comment}{LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,}}
\DoxyCodeLine{8279 \textcolor{comment}{OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE}}
\DoxyCodeLine{8280 \textcolor{comment}{SOFTWARE.}}
\DoxyCodeLine{8281 \textcolor{comment}{*/}}

\end{DoxyCode}
