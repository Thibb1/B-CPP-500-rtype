\hypertarget{binary__reader_8hpp_source}{}\doxysection{binary\+\_\+reader.\+hpp}
\label{binary__reader_8hpp_source}\index{build/\_deps/json-\/src/include/nlohmann/detail/input/binary\_reader.hpp@{build/\_deps/json-\/src/include/nlohmann/detail/input/binary\_reader.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{2 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{7 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// generate\_n}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <cmath>} \textcolor{comment}{// ldexp}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// uint8\_t, uint16\_t, uint32\_t, uint64\_t}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <cstdio>} \textcolor{comment}{// snprintf}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <cstring>} \textcolor{comment}{// memcpy}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// back\_inserter}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <limits>} \textcolor{comment}{// numeric\_limits}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// char\_traits, string}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// make\_pair, move}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <nlohmann/detail/input/input\_adapters.hpp>}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <nlohmann/detail/input/json\_sax.hpp>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <nlohmann/detail/input/lexer.hpp>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <nlohmann/detail/meta/is\_sax.hpp>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{35 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{36 \{}
\DoxyCodeLine{37 }
\DoxyCodeLine{39 \textcolor{keyword}{enum class} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}}}
\DoxyCodeLine{40 \{}
\DoxyCodeLine{41     \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}},   }
\DoxyCodeLine{42     \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592a567bc1d268f135496de3d5b946b691f3}{ignore}},  }
\DoxyCodeLine{43     \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592a8cd892b7b97ef9489ae4479d3f4ef0fc}{store}}    }
\DoxyCodeLine{44 \};}
\DoxyCodeLine{45 }
\DoxyCodeLine{53 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} little\_endianness(\textcolor{keywordtype}{int} num = 1) noexcept}
\DoxyCodeLine{54 \{}
\DoxyCodeLine{55     \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&num) == 1;}
\DoxyCodeLine{56 \}}
\DoxyCodeLine{57 }
\DoxyCodeLine{58 }
\DoxyCodeLine{60 \textcolor{comment}{// binary reader //}}
\DoxyCodeLine{62 \textcolor{comment}{}}
\DoxyCodeLine{66 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} InputAdapterType, \textcolor{keyword}{typename} SAX = json\_sax\_dom\_parser<BasicJsonType>>}
\DoxyCodeLine{67 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}}
\DoxyCodeLine{68 \{}
\DoxyCodeLine{69     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{70     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{71     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{72     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{73     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{74     \textcolor{keyword}{using }json\_sax\_t = SAX;}
\DoxyCodeLine{75     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} InputAdapterType::char\_type;}
\DoxyCodeLine{76     \textcolor{keyword}{using }char\_int\_type = \textcolor{keyword}{typename} std::char\_traits<char\_type>::int\_type;}
\DoxyCodeLine{77 }
\DoxyCodeLine{78   \textcolor{keyword}{public}:}
\DoxyCodeLine{84     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1binary__reader_a5dc3e9216177efe30686876d3faccf52}{binary\_reader}}(InputAdapterType\&\& adapter, \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format = input\_format\_t::json) noexcept : ia(std::move(adapter)), input\_format(format)}
\DoxyCodeLine{85     \{}
\DoxyCodeLine{86         (void)\mbox{\hyperlink{structdetail_1_1is__sax__static__asserts}{detail::is\_sax\_static\_asserts<SAX, BasicJsonType>}} \{\};}
\DoxyCodeLine{87     \}}
\DoxyCodeLine{88 }
\DoxyCodeLine{89     \textcolor{comment}{// make class move-\/only}}
\DoxyCodeLine{90     \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{91     \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}(\mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{92     \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{93     \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\& operator=(\mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{94     \mbox{\hyperlink{classdetail_1_1binary__reader}{\string~binary\_reader}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{95 }
\DoxyCodeLine{104     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{105     bool \mbox{\hyperlink{classdetail_1_1binary__reader_a8e1b5452ae426e1d7b48761859e7f52d}{sax\_parse}}(const \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format,}
\DoxyCodeLine{106                    json\_sax\_t* sax\_,}
\DoxyCodeLine{107                    const \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792}{strict}} = true,}
\DoxyCodeLine{108                    const \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}} tag\_handler = \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}}::\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}})}
\DoxyCodeLine{109     \{}
\DoxyCodeLine{110         sax = sax\_;}
\DoxyCodeLine{111         \textcolor{keywordtype}{bool} result = \textcolor{keyword}{false};}
\DoxyCodeLine{112 }
\DoxyCodeLine{113         \textcolor{keywordflow}{switch} (format)}
\DoxyCodeLine{114         \{}
\DoxyCodeLine{115             \textcolor{keywordflow}{case} input\_format\_t::bson:}
\DoxyCodeLine{116                 result = parse\_bson\_internal();}
\DoxyCodeLine{117                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{118 }
\DoxyCodeLine{119             \textcolor{keywordflow}{case} input\_format\_t::cbor:}
\DoxyCodeLine{120                 result = parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler);}
\DoxyCodeLine{121                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{122 }
\DoxyCodeLine{123             \textcolor{keywordflow}{case} input\_format\_t::msgpack:}
\DoxyCodeLine{124                 result = parse\_msgpack\_internal();}
\DoxyCodeLine{125                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{126 }
\DoxyCodeLine{127             \textcolor{keywordflow}{case} input\_format\_t::ubjson:}
\DoxyCodeLine{128             \textcolor{keywordflow}{case} input\_format\_t::bjdata:}
\DoxyCodeLine{129                 result = parse\_ubjson\_internal();}
\DoxyCodeLine{130                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{131 }
\DoxyCodeLine{132             \textcolor{keywordflow}{case} input\_format\_t::json: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{133             \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{134                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{135         \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137         \textcolor{comment}{// strict mode: next byte must be EOF}}
\DoxyCodeLine{138         \textcolor{keywordflow}{if} (result \&\& \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792}{strict}})}
\DoxyCodeLine{139         \{}
\DoxyCodeLine{140             \textcolor{keywordflow}{if} (input\_format == input\_format\_t::ubjson || input\_format == input\_format\_t::bjdata)}
\DoxyCodeLine{141             \{}
\DoxyCodeLine{142                 get\_ignore\_noop();}
\DoxyCodeLine{143             \}}
\DoxyCodeLine{144             \textcolor{keywordflow}{else}}
\DoxyCodeLine{145             \{}
\DoxyCodeLine{146                 get();}
\DoxyCodeLine{147             \}}
\DoxyCodeLine{148 }
\DoxyCodeLine{149             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(current != std::char\_traits<char\_type>::eof()))}
\DoxyCodeLine{150             \{}
\DoxyCodeLine{151                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(110, chars\_read,}
\DoxyCodeLine{152                                         exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}expected end of input; last byte: 0x"{}}, get\_token\_string()), \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{153             \}}
\DoxyCodeLine{154         \}}
\DoxyCodeLine{155 }
\DoxyCodeLine{156         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{157     \}}
\DoxyCodeLine{158 }
\DoxyCodeLine{159   \textcolor{keyword}{private}:}
\DoxyCodeLine{161     \textcolor{comment}{// BSON //}}
\DoxyCodeLine{163 \textcolor{comment}{}}
\DoxyCodeLine{168     \textcolor{keywordtype}{bool} parse\_bson\_internal()}
\DoxyCodeLine{169     \{}
\DoxyCodeLine{170         std::int32\_t document\_size\{\};}
\DoxyCodeLine{171         get\_number<std::int32\_t, true>(input\_format\_t::bson, document\_size);}
\DoxyCodeLine{172 }
\DoxyCodeLine{173         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{174         \{}
\DoxyCodeLine{175             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{176         \}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_bson\_element\_list(\textcolor{comment}{/*is\_array*/}\textcolor{keyword}{false})))}
\DoxyCodeLine{179         \{}
\DoxyCodeLine{180             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{181         \}}
\DoxyCodeLine{182 }
\DoxyCodeLine{183         \textcolor{keywordflow}{return} sax-\/>end\_object();}
\DoxyCodeLine{184     \}}
\DoxyCodeLine{185 }
\DoxyCodeLine{193     \textcolor{keywordtype}{bool} get\_bson\_cstr(string\_t\& result)}
\DoxyCodeLine{194     \{}
\DoxyCodeLine{195         \textcolor{keyword}{auto} out = std::back\_inserter(result);}
\DoxyCodeLine{196         \textcolor{keywordflow}{while} (\textcolor{keyword}{true})}
\DoxyCodeLine{197         \{}
\DoxyCodeLine{198             get();}
\DoxyCodeLine{199             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::bson, \textcolor{stringliteral}{"{}cstring"{}})))}
\DoxyCodeLine{200             \{}
\DoxyCodeLine{201                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{202             \}}
\DoxyCodeLine{203             \textcolor{keywordflow}{if} (current == 0x00)}
\DoxyCodeLine{204             \{}
\DoxyCodeLine{205                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{206             \}}
\DoxyCodeLine{207             *out++ = \textcolor{keyword}{static\_cast<}typename string\_t::value\_type\textcolor{keyword}{>}(current);}
\DoxyCodeLine{208         \}}
\DoxyCodeLine{209     \}}
\DoxyCodeLine{210 }
\DoxyCodeLine{222     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{223     \textcolor{keywordtype}{bool} get\_bson\_string(\textcolor{keyword}{const} NumberType len, string\_t\& result)}
\DoxyCodeLine{224     \{}
\DoxyCodeLine{225         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(len < 1))}
\DoxyCodeLine{226         \{}
\DoxyCodeLine{227             \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{228             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{229                                     exception\_message(input\_format\_t::bson, concat(\textcolor{stringliteral}{"{}string length must be at least 1, is "{}}, std::to\_string(len)), \textcolor{stringliteral}{"{}string"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{230         \}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232         \textcolor{keywordflow}{return} get\_string(input\_format\_t::bson, len -\/ \textcolor{keyword}{static\_cast<}NumberType\textcolor{keyword}{>}(1), result) \&\& get() != std::char\_traits<char\_type>::eof();}
\DoxyCodeLine{233     \}}
\DoxyCodeLine{234 }
\DoxyCodeLine{244     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{245     \textcolor{keywordtype}{bool} get\_bson\_binary(\textcolor{keyword}{const} NumberType len, binary\_t\& result)}
\DoxyCodeLine{246     \{}
\DoxyCodeLine{247         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(len < 0))}
\DoxyCodeLine{248         \{}
\DoxyCodeLine{249             \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{250             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{251                                     exception\_message(input\_format\_t::bson, concat(\textcolor{stringliteral}{"{}byte array length cannot be negative, is "{}}, std::to\_string(len)), \textcolor{stringliteral}{"{}binary"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{252         \}}
\DoxyCodeLine{253 }
\DoxyCodeLine{254         \textcolor{comment}{// All BSON binary values have a subtype}}
\DoxyCodeLine{255         std::uint8\_t subtype\{\};}
\DoxyCodeLine{256         get\_number<std::uint8\_t>(input\_format\_t::bson, subtype);}
\DoxyCodeLine{257         result.set\_subtype(subtype);}
\DoxyCodeLine{258 }
\DoxyCodeLine{259         \textcolor{keywordflow}{return} get\_binary(input\_format\_t::bson, len, result);}
\DoxyCodeLine{260     \}}
\DoxyCodeLine{261 }
\DoxyCodeLine{272     \textcolor{keywordtype}{bool} parse\_bson\_element\_internal(\textcolor{keyword}{const} char\_int\_type element\_type,}
\DoxyCodeLine{273                                      \textcolor{keyword}{const} std::size\_t element\_type\_parse\_position)}
\DoxyCodeLine{274     \{}
\DoxyCodeLine{275         \textcolor{keywordflow}{switch} (element\_type)}
\DoxyCodeLine{276         \{}
\DoxyCodeLine{277             \textcolor{keywordflow}{case} 0x01: \textcolor{comment}{// double}}
\DoxyCodeLine{278             \{}
\DoxyCodeLine{279                 \textcolor{keywordtype}{double} number\{\};}
\DoxyCodeLine{280                 \textcolor{keywordflow}{return} get\_number<double, true>(input\_format\_t::bson, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{281             \}}
\DoxyCodeLine{282 }
\DoxyCodeLine{283             \textcolor{keywordflow}{case} 0x02: \textcolor{comment}{// string}}
\DoxyCodeLine{284             \{}
\DoxyCodeLine{285                 std::int32\_t len\{\};}
\DoxyCodeLine{286                 string\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}};}
\DoxyCodeLine{287                 \textcolor{keywordflow}{return} get\_number<std::int32\_t, true>(input\_format\_t::bson, len) \&\& get\_bson\_string(len, value) \&\& sax-\/>string(value);}
\DoxyCodeLine{288             \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290             \textcolor{keywordflow}{case} 0x03: \textcolor{comment}{// object}}
\DoxyCodeLine{291             \{}
\DoxyCodeLine{292                 \textcolor{keywordflow}{return} parse\_bson\_internal();}
\DoxyCodeLine{293             \}}
\DoxyCodeLine{294 }
\DoxyCodeLine{295             \textcolor{keywordflow}{case} 0x04: \textcolor{comment}{// array}}
\DoxyCodeLine{296             \{}
\DoxyCodeLine{297                 \textcolor{keywordflow}{return} parse\_bson\_array();}
\DoxyCodeLine{298             \}}
\DoxyCodeLine{299 }
\DoxyCodeLine{300             \textcolor{keywordflow}{case} 0x05: \textcolor{comment}{// binary}}
\DoxyCodeLine{301             \{}
\DoxyCodeLine{302                 std::int32\_t len\{\};}
\DoxyCodeLine{303                 binary\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}};}
\DoxyCodeLine{304                 \textcolor{keywordflow}{return} get\_number<std::int32\_t, true>(input\_format\_t::bson, len) \&\& get\_bson\_binary(len, value) \&\& sax-\/>binary(value);}
\DoxyCodeLine{305             \}}
\DoxyCodeLine{306 }
\DoxyCodeLine{307             \textcolor{keywordflow}{case} 0x08: \textcolor{comment}{// boolean}}
\DoxyCodeLine{308             \{}
\DoxyCodeLine{309                 \textcolor{keywordflow}{return} sax-\/>boolean(get() != 0);}
\DoxyCodeLine{310             \}}
\DoxyCodeLine{311 }
\DoxyCodeLine{312             \textcolor{keywordflow}{case} 0x0A: \textcolor{comment}{// null}}
\DoxyCodeLine{313             \{}
\DoxyCodeLine{314                 \textcolor{keywordflow}{return} sax-\/>null();}
\DoxyCodeLine{315             \}}
\DoxyCodeLine{316 }
\DoxyCodeLine{317             \textcolor{keywordflow}{case} 0x10: \textcolor{comment}{// int32}}
\DoxyCodeLine{318             \{}
\DoxyCodeLine{319                 std::int32\_t value\{\};}
\DoxyCodeLine{320                 \textcolor{keywordflow}{return} get\_number<std::int32\_t, true>(input\_format\_t::bson, value) \&\& sax-\/>number\_integer(value);}
\DoxyCodeLine{321             \}}
\DoxyCodeLine{322 }
\DoxyCodeLine{323             \textcolor{keywordflow}{case} 0x12: \textcolor{comment}{// int64}}
\DoxyCodeLine{324             \{}
\DoxyCodeLine{325                 std::int64\_t value\{\};}
\DoxyCodeLine{326                 \textcolor{keywordflow}{return} get\_number<std::int64\_t, true>(input\_format\_t::bson, value) \&\& sax-\/>number\_integer(value);}
\DoxyCodeLine{327             \}}
\DoxyCodeLine{328 }
\DoxyCodeLine{329             \textcolor{keywordflow}{default}: \textcolor{comment}{// anything else not supported (yet)}}
\DoxyCodeLine{330             \{}
\DoxyCodeLine{331                 std::array<char, 3> cr\{\{\}\};}
\DoxyCodeLine{332                 \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((std::snprintf)(cr.data(), cr.size(), \textcolor{stringliteral}{"{}\%.2hhX"{}}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(element\_type))); \textcolor{comment}{// NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{333                 std::string cr\_str\{cr.data()\};}
\DoxyCodeLine{334                 \textcolor{keywordflow}{return} sax-\/>parse\_error(element\_type\_parse\_position, cr\_str,}
\DoxyCodeLine{335                                         \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(114, element\_type\_parse\_position, concat(\textcolor{stringliteral}{"{}Unsupported BSON record type 0x"{}}, cr\_str), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{336             \}}
\DoxyCodeLine{337         \}}
\DoxyCodeLine{338     \}}
\DoxyCodeLine{339 }
\DoxyCodeLine{352     \textcolor{keywordtype}{bool} parse\_bson\_element\_list(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_array)}
\DoxyCodeLine{353     \{}
\DoxyCodeLine{354         string\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}};}
\DoxyCodeLine{355 }
\DoxyCodeLine{356         \textcolor{keywordflow}{while} (\textcolor{keyword}{auto} element\_type = get())}
\DoxyCodeLine{357         \{}
\DoxyCodeLine{358             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::bson, \textcolor{stringliteral}{"{}element list"{}})))}
\DoxyCodeLine{359             \{}
\DoxyCodeLine{360                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{361             \}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363             \textcolor{keyword}{const} std::size\_t element\_type\_parse\_position = chars\_read;}
\DoxyCodeLine{364             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_bson\_cstr(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}})))}
\DoxyCodeLine{365             \{}
\DoxyCodeLine{366                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{367             \}}
\DoxyCodeLine{368 }
\DoxyCodeLine{369             \textcolor{keywordflow}{if} (!is\_array \&\& !sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}))}
\DoxyCodeLine{370             \{}
\DoxyCodeLine{371                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{372             \}}
\DoxyCodeLine{373 }
\DoxyCodeLine{374             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_bson\_element\_internal(element\_type, element\_type\_parse\_position)))}
\DoxyCodeLine{375             \{}
\DoxyCodeLine{376                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{377             \}}
\DoxyCodeLine{378 }
\DoxyCodeLine{379             \textcolor{comment}{// get\_bson\_cstr only appends}}
\DoxyCodeLine{380             \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}.clear();}
\DoxyCodeLine{381         \}}
\DoxyCodeLine{382 }
\DoxyCodeLine{383         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{384     \}}
\DoxyCodeLine{385 }
\DoxyCodeLine{390     \textcolor{keywordtype}{bool} parse\_bson\_array()}
\DoxyCodeLine{391     \{}
\DoxyCodeLine{392         std::int32\_t document\_size\{\};}
\DoxyCodeLine{393         get\_number<std::int32\_t, true>(input\_format\_t::bson, document\_size);}
\DoxyCodeLine{394 }
\DoxyCodeLine{395         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{396         \{}
\DoxyCodeLine{397             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{398         \}}
\DoxyCodeLine{399 }
\DoxyCodeLine{400         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_bson\_element\_list(\textcolor{comment}{/*is\_array*/}\textcolor{keyword}{true})))}
\DoxyCodeLine{401         \{}
\DoxyCodeLine{402             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{403         \}}
\DoxyCodeLine{404 }
\DoxyCodeLine{405         \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{406     \}}
\DoxyCodeLine{407 }
\DoxyCodeLine{409     \textcolor{comment}{// CBOR //}}
\DoxyCodeLine{411 \textcolor{comment}{}}
\DoxyCodeLine{420     \textcolor{keywordtype}{bool} parse\_cbor\_internal(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} get\_char,}
\DoxyCodeLine{421                              \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}} tag\_handler)}
\DoxyCodeLine{422     \{}
\DoxyCodeLine{423         \textcolor{keywordflow}{switch} (get\_char ? get() : current)}
\DoxyCodeLine{424         \{}
\DoxyCodeLine{425             \textcolor{comment}{// EOF}}
\DoxyCodeLine{426             \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():}
\DoxyCodeLine{427                 return unexpect\_eof(\mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}}::cbor, \textcolor{stringliteral}{"{}value"{}});}
\DoxyCodeLine{428 }
\DoxyCodeLine{429             \textcolor{comment}{// Integer 0x00..0x17 (0..23)}}
\DoxyCodeLine{430             \textcolor{keywordflow}{case} 0x00:}
\DoxyCodeLine{431             \textcolor{keywordflow}{case} 0x01:}
\DoxyCodeLine{432             \textcolor{keywordflow}{case} 0x02:}
\DoxyCodeLine{433             \textcolor{keywordflow}{case} 0x03:}
\DoxyCodeLine{434             \textcolor{keywordflow}{case} 0x04:}
\DoxyCodeLine{435             \textcolor{keywordflow}{case} 0x05:}
\DoxyCodeLine{436             \textcolor{keywordflow}{case} 0x06:}
\DoxyCodeLine{437             \textcolor{keywordflow}{case} 0x07:}
\DoxyCodeLine{438             \textcolor{keywordflow}{case} 0x08:}
\DoxyCodeLine{439             \textcolor{keywordflow}{case} 0x09:}
\DoxyCodeLine{440             \textcolor{keywordflow}{case} 0x0A:}
\DoxyCodeLine{441             \textcolor{keywordflow}{case} 0x0B:}
\DoxyCodeLine{442             \textcolor{keywordflow}{case} 0x0C:}
\DoxyCodeLine{443             \textcolor{keywordflow}{case} 0x0D:}
\DoxyCodeLine{444             \textcolor{keywordflow}{case} 0x0E:}
\DoxyCodeLine{445             \textcolor{keywordflow}{case} 0x0F:}
\DoxyCodeLine{446             \textcolor{keywordflow}{case} 0x10:}
\DoxyCodeLine{447             \textcolor{keywordflow}{case} 0x11:}
\DoxyCodeLine{448             \textcolor{keywordflow}{case} 0x12:}
\DoxyCodeLine{449             \textcolor{keywordflow}{case} 0x13:}
\DoxyCodeLine{450             \textcolor{keywordflow}{case} 0x14:}
\DoxyCodeLine{451             \textcolor{keywordflow}{case} 0x15:}
\DoxyCodeLine{452             \textcolor{keywordflow}{case} 0x16:}
\DoxyCodeLine{453             \textcolor{keywordflow}{case} 0x17:}
\DoxyCodeLine{454                 \textcolor{keywordflow}{return} sax-\/>number\_unsigned(\textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(current));}
\DoxyCodeLine{455 }
\DoxyCodeLine{456             \textcolor{keywordflow}{case} 0x18: \textcolor{comment}{// Unsigned integer (one-\/byte uint8\_t follows)}}
\DoxyCodeLine{457             \{}
\DoxyCodeLine{458                 std::uint8\_t number\{\};}
\DoxyCodeLine{459                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{460             \}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462             \textcolor{keywordflow}{case} 0x19: \textcolor{comment}{// Unsigned integer (two-\/byte uint16\_t follows)}}
\DoxyCodeLine{463             \{}
\DoxyCodeLine{464                 std::uint16\_t number\{\};}
\DoxyCodeLine{465                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{466             \}}
\DoxyCodeLine{467 }
\DoxyCodeLine{468             \textcolor{keywordflow}{case} 0x1A: \textcolor{comment}{// Unsigned integer (four-\/byte uint32\_t follows)}}
\DoxyCodeLine{469             \{}
\DoxyCodeLine{470                 std::uint32\_t number\{\};}
\DoxyCodeLine{471                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{472             \}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474             \textcolor{keywordflow}{case} 0x1B: \textcolor{comment}{// Unsigned integer (eight-\/byte uint64\_t follows)}}
\DoxyCodeLine{475             \{}
\DoxyCodeLine{476                 std::uint64\_t number\{\};}
\DoxyCodeLine{477                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{478             \}}
\DoxyCodeLine{479 }
\DoxyCodeLine{480             \textcolor{comment}{// Negative integer -\/1-\/0x00..-\/1-\/0x17 (-\/1..-\/24)}}
\DoxyCodeLine{481             \textcolor{keywordflow}{case} 0x20:}
\DoxyCodeLine{482             \textcolor{keywordflow}{case} 0x21:}
\DoxyCodeLine{483             \textcolor{keywordflow}{case} 0x22:}
\DoxyCodeLine{484             \textcolor{keywordflow}{case} 0x23:}
\DoxyCodeLine{485             \textcolor{keywordflow}{case} 0x24:}
\DoxyCodeLine{486             \textcolor{keywordflow}{case} 0x25:}
\DoxyCodeLine{487             \textcolor{keywordflow}{case} 0x26:}
\DoxyCodeLine{488             \textcolor{keywordflow}{case} 0x27:}
\DoxyCodeLine{489             \textcolor{keywordflow}{case} 0x28:}
\DoxyCodeLine{490             \textcolor{keywordflow}{case} 0x29:}
\DoxyCodeLine{491             \textcolor{keywordflow}{case} 0x2A:}
\DoxyCodeLine{492             \textcolor{keywordflow}{case} 0x2B:}
\DoxyCodeLine{493             \textcolor{keywordflow}{case} 0x2C:}
\DoxyCodeLine{494             \textcolor{keywordflow}{case} 0x2D:}
\DoxyCodeLine{495             \textcolor{keywordflow}{case} 0x2E:}
\DoxyCodeLine{496             \textcolor{keywordflow}{case} 0x2F:}
\DoxyCodeLine{497             \textcolor{keywordflow}{case} 0x30:}
\DoxyCodeLine{498             \textcolor{keywordflow}{case} 0x31:}
\DoxyCodeLine{499             \textcolor{keywordflow}{case} 0x32:}
\DoxyCodeLine{500             \textcolor{keywordflow}{case} 0x33:}
\DoxyCodeLine{501             \textcolor{keywordflow}{case} 0x34:}
\DoxyCodeLine{502             \textcolor{keywordflow}{case} 0x35:}
\DoxyCodeLine{503             \textcolor{keywordflow}{case} 0x36:}
\DoxyCodeLine{504             \textcolor{keywordflow}{case} 0x37:}
\DoxyCodeLine{505                 \textcolor{keywordflow}{return} sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(0x20 -\/ 1 -\/ current));}
\DoxyCodeLine{506 }
\DoxyCodeLine{507             \textcolor{keywordflow}{case} 0x38: \textcolor{comment}{// Negative integer (one-\/byte uint8\_t follows)}}
\DoxyCodeLine{508             \{}
\DoxyCodeLine{509                 std::uint8\_t number\{\};}
\DoxyCodeLine{510                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(-\/1) -\/ number);}
\DoxyCodeLine{511             \}}
\DoxyCodeLine{512 }
\DoxyCodeLine{513             \textcolor{keywordflow}{case} 0x39: \textcolor{comment}{// Negative integer -\/1-\/n (two-\/byte uint16\_t follows)}}
\DoxyCodeLine{514             \{}
\DoxyCodeLine{515                 std::uint16\_t number\{\};}
\DoxyCodeLine{516                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(-\/1) -\/ number);}
\DoxyCodeLine{517             \}}
\DoxyCodeLine{518 }
\DoxyCodeLine{519             \textcolor{keywordflow}{case} 0x3A: \textcolor{comment}{// Negative integer -\/1-\/n (four-\/byte uint32\_t follows)}}
\DoxyCodeLine{520             \{}
\DoxyCodeLine{521                 std::uint32\_t number\{\};}
\DoxyCodeLine{522                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(-\/1) -\/ number);}
\DoxyCodeLine{523             \}}
\DoxyCodeLine{524 }
\DoxyCodeLine{525             \textcolor{keywordflow}{case} 0x3B: \textcolor{comment}{// Negative integer -\/1-\/n (eight-\/byte uint64\_t follows)}}
\DoxyCodeLine{526             \{}
\DoxyCodeLine{527                 std::uint64\_t number\{\};}
\DoxyCodeLine{528                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(-\/1)}
\DoxyCodeLine{529                         -\/ \textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(number));}
\DoxyCodeLine{530             \}}
\DoxyCodeLine{531 }
\DoxyCodeLine{532             \textcolor{comment}{// Binary data (0x00..0x17 bytes follow)}}
\DoxyCodeLine{533             \textcolor{keywordflow}{case} 0x40:}
\DoxyCodeLine{534             \textcolor{keywordflow}{case} 0x41:}
\DoxyCodeLine{535             \textcolor{keywordflow}{case} 0x42:}
\DoxyCodeLine{536             \textcolor{keywordflow}{case} 0x43:}
\DoxyCodeLine{537             \textcolor{keywordflow}{case} 0x44:}
\DoxyCodeLine{538             \textcolor{keywordflow}{case} 0x45:}
\DoxyCodeLine{539             \textcolor{keywordflow}{case} 0x46:}
\DoxyCodeLine{540             \textcolor{keywordflow}{case} 0x47:}
\DoxyCodeLine{541             \textcolor{keywordflow}{case} 0x48:}
\DoxyCodeLine{542             \textcolor{keywordflow}{case} 0x49:}
\DoxyCodeLine{543             \textcolor{keywordflow}{case} 0x4A:}
\DoxyCodeLine{544             \textcolor{keywordflow}{case} 0x4B:}
\DoxyCodeLine{545             \textcolor{keywordflow}{case} 0x4C:}
\DoxyCodeLine{546             \textcolor{keywordflow}{case} 0x4D:}
\DoxyCodeLine{547             \textcolor{keywordflow}{case} 0x4E:}
\DoxyCodeLine{548             \textcolor{keywordflow}{case} 0x4F:}
\DoxyCodeLine{549             \textcolor{keywordflow}{case} 0x50:}
\DoxyCodeLine{550             \textcolor{keywordflow}{case} 0x51:}
\DoxyCodeLine{551             \textcolor{keywordflow}{case} 0x52:}
\DoxyCodeLine{552             \textcolor{keywordflow}{case} 0x53:}
\DoxyCodeLine{553             \textcolor{keywordflow}{case} 0x54:}
\DoxyCodeLine{554             \textcolor{keywordflow}{case} 0x55:}
\DoxyCodeLine{555             \textcolor{keywordflow}{case} 0x56:}
\DoxyCodeLine{556             \textcolor{keywordflow}{case} 0x57:}
\DoxyCodeLine{557             \textcolor{keywordflow}{case} 0x58: \textcolor{comment}{// Binary data (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{558             \textcolor{keywordflow}{case} 0x59: \textcolor{comment}{// Binary data (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{559             \textcolor{keywordflow}{case} 0x5A: \textcolor{comment}{// Binary data (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{560             \textcolor{keywordflow}{case} 0x5B: \textcolor{comment}{// Binary data (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{561             \textcolor{keywordflow}{case} 0x5F: \textcolor{comment}{// Binary data (indefinite length)}}
\DoxyCodeLine{562             \{}
\DoxyCodeLine{563                 binary\_t b;}
\DoxyCodeLine{564                 \textcolor{keywordflow}{return} get\_cbor\_binary(b) \&\& sax-\/>binary(b);}
\DoxyCodeLine{565             \}}
\DoxyCodeLine{566 }
\DoxyCodeLine{567             \textcolor{comment}{// UTF-\/8 string (0x00..0x17 bytes follow)}}
\DoxyCodeLine{568             \textcolor{keywordflow}{case} 0x60:}
\DoxyCodeLine{569             \textcolor{keywordflow}{case} 0x61:}
\DoxyCodeLine{570             \textcolor{keywordflow}{case} 0x62:}
\DoxyCodeLine{571             \textcolor{keywordflow}{case} 0x63:}
\DoxyCodeLine{572             \textcolor{keywordflow}{case} 0x64:}
\DoxyCodeLine{573             \textcolor{keywordflow}{case} 0x65:}
\DoxyCodeLine{574             \textcolor{keywordflow}{case} 0x66:}
\DoxyCodeLine{575             \textcolor{keywordflow}{case} 0x67:}
\DoxyCodeLine{576             \textcolor{keywordflow}{case} 0x68:}
\DoxyCodeLine{577             \textcolor{keywordflow}{case} 0x69:}
\DoxyCodeLine{578             \textcolor{keywordflow}{case} 0x6A:}
\DoxyCodeLine{579             \textcolor{keywordflow}{case} 0x6B:}
\DoxyCodeLine{580             \textcolor{keywordflow}{case} 0x6C:}
\DoxyCodeLine{581             \textcolor{keywordflow}{case} 0x6D:}
\DoxyCodeLine{582             \textcolor{keywordflow}{case} 0x6E:}
\DoxyCodeLine{583             \textcolor{keywordflow}{case} 0x6F:}
\DoxyCodeLine{584             \textcolor{keywordflow}{case} 0x70:}
\DoxyCodeLine{585             \textcolor{keywordflow}{case} 0x71:}
\DoxyCodeLine{586             \textcolor{keywordflow}{case} 0x72:}
\DoxyCodeLine{587             \textcolor{keywordflow}{case} 0x73:}
\DoxyCodeLine{588             \textcolor{keywordflow}{case} 0x74:}
\DoxyCodeLine{589             \textcolor{keywordflow}{case} 0x75:}
\DoxyCodeLine{590             \textcolor{keywordflow}{case} 0x76:}
\DoxyCodeLine{591             \textcolor{keywordflow}{case} 0x77:}
\DoxyCodeLine{592             \textcolor{keywordflow}{case} 0x78: \textcolor{comment}{// UTF-\/8 string (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{593             \textcolor{keywordflow}{case} 0x79: \textcolor{comment}{// UTF-\/8 string (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{594             \textcolor{keywordflow}{case} 0x7A: \textcolor{comment}{// UTF-\/8 string (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{595             \textcolor{keywordflow}{case} 0x7B: \textcolor{comment}{// UTF-\/8 string (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{596             \textcolor{keywordflow}{case} 0x7F: \textcolor{comment}{// UTF-\/8 string (indefinite length)}}
\DoxyCodeLine{597             \{}
\DoxyCodeLine{598                 string\_t s;}
\DoxyCodeLine{599                 \textcolor{keywordflow}{return} get\_cbor\_string(s) \&\& sax-\/>string(s);}
\DoxyCodeLine{600             \}}
\DoxyCodeLine{601 }
\DoxyCodeLine{602             \textcolor{comment}{// array (0x00..0x17 data items follow)}}
\DoxyCodeLine{603             \textcolor{keywordflow}{case} 0x80:}
\DoxyCodeLine{604             \textcolor{keywordflow}{case} 0x81:}
\DoxyCodeLine{605             \textcolor{keywordflow}{case} 0x82:}
\DoxyCodeLine{606             \textcolor{keywordflow}{case} 0x83:}
\DoxyCodeLine{607             \textcolor{keywordflow}{case} 0x84:}
\DoxyCodeLine{608             \textcolor{keywordflow}{case} 0x85:}
\DoxyCodeLine{609             \textcolor{keywordflow}{case} 0x86:}
\DoxyCodeLine{610             \textcolor{keywordflow}{case} 0x87:}
\DoxyCodeLine{611             \textcolor{keywordflow}{case} 0x88:}
\DoxyCodeLine{612             \textcolor{keywordflow}{case} 0x89:}
\DoxyCodeLine{613             \textcolor{keywordflow}{case} 0x8A:}
\DoxyCodeLine{614             \textcolor{keywordflow}{case} 0x8B:}
\DoxyCodeLine{615             \textcolor{keywordflow}{case} 0x8C:}
\DoxyCodeLine{616             \textcolor{keywordflow}{case} 0x8D:}
\DoxyCodeLine{617             \textcolor{keywordflow}{case} 0x8E:}
\DoxyCodeLine{618             \textcolor{keywordflow}{case} 0x8F:}
\DoxyCodeLine{619             \textcolor{keywordflow}{case} 0x90:}
\DoxyCodeLine{620             \textcolor{keywordflow}{case} 0x91:}
\DoxyCodeLine{621             \textcolor{keywordflow}{case} 0x92:}
\DoxyCodeLine{622             \textcolor{keywordflow}{case} 0x93:}
\DoxyCodeLine{623             \textcolor{keywordflow}{case} 0x94:}
\DoxyCodeLine{624             \textcolor{keywordflow}{case} 0x95:}
\DoxyCodeLine{625             \textcolor{keywordflow}{case} 0x96:}
\DoxyCodeLine{626             \textcolor{keywordflow}{case} 0x97:}
\DoxyCodeLine{627                 \textcolor{keywordflow}{return} get\_cbor\_array(}
\DoxyCodeLine{628                            conditional\_static\_cast<std::size\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu), tag\_handler);}
\DoxyCodeLine{629 }
\DoxyCodeLine{630             \textcolor{keywordflow}{case} 0x98: \textcolor{comment}{// array (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{631             \{}
\DoxyCodeLine{632                 std::uint8\_t len\{\};}
\DoxyCodeLine{633                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len), tag\_handler);}
\DoxyCodeLine{634             \}}
\DoxyCodeLine{635 }
\DoxyCodeLine{636             \textcolor{keywordflow}{case} 0x99: \textcolor{comment}{// array (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{637             \{}
\DoxyCodeLine{638                 std::uint16\_t len\{\};}
\DoxyCodeLine{639                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len), tag\_handler);}
\DoxyCodeLine{640             \}}
\DoxyCodeLine{641 }
\DoxyCodeLine{642             \textcolor{keywordflow}{case} 0x9A: \textcolor{comment}{// array (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{643             \{}
\DoxyCodeLine{644                 std::uint32\_t len\{\};}
\DoxyCodeLine{645                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_array(conditional\_static\_cast<std::size\_t>(len), tag\_handler);}
\DoxyCodeLine{646             \}}
\DoxyCodeLine{647 }
\DoxyCodeLine{648             \textcolor{keywordflow}{case} 0x9B: \textcolor{comment}{// array (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{649             \{}
\DoxyCodeLine{650                 std::uint64\_t len\{\};}
\DoxyCodeLine{651                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_array(conditional\_static\_cast<std::size\_t>(len), tag\_handler);}
\DoxyCodeLine{652             \}}
\DoxyCodeLine{653 }
\DoxyCodeLine{654             \textcolor{keywordflow}{case} 0x9F: \textcolor{comment}{// array (indefinite length)}}
\DoxyCodeLine{655                 \textcolor{keywordflow}{return} get\_cbor\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1), tag\_handler);}
\DoxyCodeLine{656 }
\DoxyCodeLine{657             \textcolor{comment}{// map (0x00..0x17 pairs of data items follow)}}
\DoxyCodeLine{658             \textcolor{keywordflow}{case} 0xA0:}
\DoxyCodeLine{659             \textcolor{keywordflow}{case} 0xA1:}
\DoxyCodeLine{660             \textcolor{keywordflow}{case} 0xA2:}
\DoxyCodeLine{661             \textcolor{keywordflow}{case} 0xA3:}
\DoxyCodeLine{662             \textcolor{keywordflow}{case} 0xA4:}
\DoxyCodeLine{663             \textcolor{keywordflow}{case} 0xA5:}
\DoxyCodeLine{664             \textcolor{keywordflow}{case} 0xA6:}
\DoxyCodeLine{665             \textcolor{keywordflow}{case} 0xA7:}
\DoxyCodeLine{666             \textcolor{keywordflow}{case} 0xA8:}
\DoxyCodeLine{667             \textcolor{keywordflow}{case} 0xA9:}
\DoxyCodeLine{668             \textcolor{keywordflow}{case} 0xAA:}
\DoxyCodeLine{669             \textcolor{keywordflow}{case} 0xAB:}
\DoxyCodeLine{670             \textcolor{keywordflow}{case} 0xAC:}
\DoxyCodeLine{671             \textcolor{keywordflow}{case} 0xAD:}
\DoxyCodeLine{672             \textcolor{keywordflow}{case} 0xAE:}
\DoxyCodeLine{673             \textcolor{keywordflow}{case} 0xAF:}
\DoxyCodeLine{674             \textcolor{keywordflow}{case} 0xB0:}
\DoxyCodeLine{675             \textcolor{keywordflow}{case} 0xB1:}
\DoxyCodeLine{676             \textcolor{keywordflow}{case} 0xB2:}
\DoxyCodeLine{677             \textcolor{keywordflow}{case} 0xB3:}
\DoxyCodeLine{678             \textcolor{keywordflow}{case} 0xB4:}
\DoxyCodeLine{679             \textcolor{keywordflow}{case} 0xB5:}
\DoxyCodeLine{680             \textcolor{keywordflow}{case} 0xB6:}
\DoxyCodeLine{681             \textcolor{keywordflow}{case} 0xB7:}
\DoxyCodeLine{682                 \textcolor{keywordflow}{return} get\_cbor\_object(conditional\_static\_cast<std::size\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu), tag\_handler);}
\DoxyCodeLine{683 }
\DoxyCodeLine{684             \textcolor{keywordflow}{case} 0xB8: \textcolor{comment}{// map (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{685             \{}
\DoxyCodeLine{686                 std::uint8\_t len\{\};}
\DoxyCodeLine{687                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len), tag\_handler);}
\DoxyCodeLine{688             \}}
\DoxyCodeLine{689 }
\DoxyCodeLine{690             \textcolor{keywordflow}{case} 0xB9: \textcolor{comment}{// map (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{691             \{}
\DoxyCodeLine{692                 std::uint16\_t len\{\};}
\DoxyCodeLine{693                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len), tag\_handler);}
\DoxyCodeLine{694             \}}
\DoxyCodeLine{695 }
\DoxyCodeLine{696             \textcolor{keywordflow}{case} 0xBA: \textcolor{comment}{// map (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{697             \{}
\DoxyCodeLine{698                 std::uint32\_t len\{\};}
\DoxyCodeLine{699                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_object(conditional\_static\_cast<std::size\_t>(len), tag\_handler);}
\DoxyCodeLine{700             \}}
\DoxyCodeLine{701 }
\DoxyCodeLine{702             \textcolor{keywordflow}{case} 0xBB: \textcolor{comment}{// map (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{703             \{}
\DoxyCodeLine{704                 std::uint64\_t len\{\};}
\DoxyCodeLine{705                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_object(conditional\_static\_cast<std::size\_t>(len), tag\_handler);}
\DoxyCodeLine{706             \}}
\DoxyCodeLine{707 }
\DoxyCodeLine{708             \textcolor{keywordflow}{case} 0xBF: \textcolor{comment}{// map (indefinite length)}}
\DoxyCodeLine{709                 \textcolor{keywordflow}{return} get\_cbor\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1), tag\_handler);}
\DoxyCodeLine{710 }
\DoxyCodeLine{711             \textcolor{keywordflow}{case} 0xC6: \textcolor{comment}{// tagged item}}
\DoxyCodeLine{712             \textcolor{keywordflow}{case} 0xC7:}
\DoxyCodeLine{713             \textcolor{keywordflow}{case} 0xC8:}
\DoxyCodeLine{714             \textcolor{keywordflow}{case} 0xC9:}
\DoxyCodeLine{715             \textcolor{keywordflow}{case} 0xCA:}
\DoxyCodeLine{716             \textcolor{keywordflow}{case} 0xCB:}
\DoxyCodeLine{717             \textcolor{keywordflow}{case} 0xCC:}
\DoxyCodeLine{718             \textcolor{keywordflow}{case} 0xCD:}
\DoxyCodeLine{719             \textcolor{keywordflow}{case} 0xCE:}
\DoxyCodeLine{720             \textcolor{keywordflow}{case} 0xCF:}
\DoxyCodeLine{721             \textcolor{keywordflow}{case} 0xD0:}
\DoxyCodeLine{722             \textcolor{keywordflow}{case} 0xD1:}
\DoxyCodeLine{723             \textcolor{keywordflow}{case} 0xD2:}
\DoxyCodeLine{724             \textcolor{keywordflow}{case} 0xD3:}
\DoxyCodeLine{725             \textcolor{keywordflow}{case} 0xD4:}
\DoxyCodeLine{726             \textcolor{keywordflow}{case} 0xD8: \textcolor{comment}{// tagged item (1 bytes follow)}}
\DoxyCodeLine{727             \textcolor{keywordflow}{case} 0xD9: \textcolor{comment}{// tagged item (2 bytes follow)}}
\DoxyCodeLine{728             \textcolor{keywordflow}{case} 0xDA: \textcolor{comment}{// tagged item (4 bytes follow)}}
\DoxyCodeLine{729             \textcolor{keywordflow}{case} 0xDB: \textcolor{comment}{// tagged item (8 bytes follow)}}
\DoxyCodeLine{730             \{}
\DoxyCodeLine{731                 \textcolor{keywordflow}{switch} (tag\_handler)}
\DoxyCodeLine{732                 \{}
\DoxyCodeLine{733                     \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{cbor\_tag\_handler\_t::error}}:}
\DoxyCodeLine{734                     \{}
\DoxyCodeLine{735                         \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{736                         \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{737                                                 exception\_message(input\_format\_t::cbor, concat(\textcolor{stringliteral}{"{}invalid byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{738                     \}}
\DoxyCodeLine{739 }
\DoxyCodeLine{740                     \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592a567bc1d268f135496de3d5b946b691f3}{cbor\_tag\_handler\_t::ignore}}:}
\DoxyCodeLine{741                     \{}
\DoxyCodeLine{742                         \textcolor{comment}{// ignore binary subtype}}
\DoxyCodeLine{743                         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{744                         \{}
\DoxyCodeLine{745                             \textcolor{keywordflow}{case} 0xD8:}
\DoxyCodeLine{746                             \{}
\DoxyCodeLine{747                                 std::uint8\_t subtype\_to\_ignore\{\};}
\DoxyCodeLine{748                                 get\_number(input\_format\_t::cbor, subtype\_to\_ignore);}
\DoxyCodeLine{749                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{750                             \}}
\DoxyCodeLine{751                             \textcolor{keywordflow}{case} 0xD9:}
\DoxyCodeLine{752                             \{}
\DoxyCodeLine{753                                 std::uint16\_t subtype\_to\_ignore\{\};}
\DoxyCodeLine{754                                 get\_number(input\_format\_t::cbor, subtype\_to\_ignore);}
\DoxyCodeLine{755                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{756                             \}}
\DoxyCodeLine{757                             \textcolor{keywordflow}{case} 0xDA:}
\DoxyCodeLine{758                             \{}
\DoxyCodeLine{759                                 std::uint32\_t subtype\_to\_ignore\{\};}
\DoxyCodeLine{760                                 get\_number(input\_format\_t::cbor, subtype\_to\_ignore);}
\DoxyCodeLine{761                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{762                             \}}
\DoxyCodeLine{763                             \textcolor{keywordflow}{case} 0xDB:}
\DoxyCodeLine{764                             \{}
\DoxyCodeLine{765                                 std::uint64\_t subtype\_to\_ignore\{\};}
\DoxyCodeLine{766                                 get\_number(input\_format\_t::cbor, subtype\_to\_ignore);}
\DoxyCodeLine{767                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{768                             \}}
\DoxyCodeLine{769                             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{770                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{771                         \}}
\DoxyCodeLine{772                         \textcolor{keywordflow}{return} parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler);}
\DoxyCodeLine{773                     \}}
\DoxyCodeLine{774 }
\DoxyCodeLine{775                     \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592a8cd892b7b97ef9489ae4479d3f4ef0fc}{cbor\_tag\_handler\_t::store}}:}
\DoxyCodeLine{776                     \{}
\DoxyCodeLine{777                         binary\_t b;}
\DoxyCodeLine{778                         \textcolor{comment}{// use binary subtype and store in binary container}}
\DoxyCodeLine{779                         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{780                         \{}
\DoxyCodeLine{781                             \textcolor{keywordflow}{case} 0xD8:}
\DoxyCodeLine{782                             \{}
\DoxyCodeLine{783                                 std::uint8\_t subtype\{\};}
\DoxyCodeLine{784                                 get\_number(input\_format\_t::cbor, subtype);}
\DoxyCodeLine{785                                 b.set\_subtype(detail::conditional\_static\_cast<typename binary\_t::subtype\_type>(subtype));}
\DoxyCodeLine{786                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{787                             \}}
\DoxyCodeLine{788                             \textcolor{keywordflow}{case} 0xD9:}
\DoxyCodeLine{789                             \{}
\DoxyCodeLine{790                                 std::uint16\_t subtype\{\};}
\DoxyCodeLine{791                                 get\_number(input\_format\_t::cbor, subtype);}
\DoxyCodeLine{792                                 b.set\_subtype(detail::conditional\_static\_cast<typename binary\_t::subtype\_type>(subtype));}
\DoxyCodeLine{793                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{794                             \}}
\DoxyCodeLine{795                             \textcolor{keywordflow}{case} 0xDA:}
\DoxyCodeLine{796                             \{}
\DoxyCodeLine{797                                 std::uint32\_t subtype\{\};}
\DoxyCodeLine{798                                 get\_number(input\_format\_t::cbor, subtype);}
\DoxyCodeLine{799                                 b.set\_subtype(detail::conditional\_static\_cast<typename binary\_t::subtype\_type>(subtype));}
\DoxyCodeLine{800                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{801                             \}}
\DoxyCodeLine{802                             \textcolor{keywordflow}{case} 0xDB:}
\DoxyCodeLine{803                             \{}
\DoxyCodeLine{804                                 std::uint64\_t subtype\{\};}
\DoxyCodeLine{805                                 get\_number(input\_format\_t::cbor, subtype);}
\DoxyCodeLine{806                                 b.set\_subtype(detail::conditional\_static\_cast<typename binary\_t::subtype\_type>(subtype));}
\DoxyCodeLine{807                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{808                             \}}
\DoxyCodeLine{809                             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{810                                 \textcolor{keywordflow}{return} parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler);}
\DoxyCodeLine{811                         \}}
\DoxyCodeLine{812                         get();}
\DoxyCodeLine{813                         \textcolor{keywordflow}{return} get\_cbor\_binary(b) \&\& sax-\/>binary(b);}
\DoxyCodeLine{814                     \}}
\DoxyCodeLine{815 }
\DoxyCodeLine{816                     \textcolor{keywordflow}{default}:                 \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{817                         JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{818                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};        \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{819                 \}}
\DoxyCodeLine{820             \}}
\DoxyCodeLine{821 }
\DoxyCodeLine{822             \textcolor{keywordflow}{case} 0xF4: \textcolor{comment}{// false}}
\DoxyCodeLine{823                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{false});}
\DoxyCodeLine{824 }
\DoxyCodeLine{825             \textcolor{keywordflow}{case} 0xF5: \textcolor{comment}{// true}}
\DoxyCodeLine{826                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{true});}
\DoxyCodeLine{827 }
\DoxyCodeLine{828             \textcolor{keywordflow}{case} 0xF6: \textcolor{comment}{// null}}
\DoxyCodeLine{829                 \textcolor{keywordflow}{return} sax-\/>null();}
\DoxyCodeLine{830 }
\DoxyCodeLine{831             \textcolor{keywordflow}{case} 0xF9: \textcolor{comment}{// Half-\/Precision Float (two-\/byte IEEE 754)}}
\DoxyCodeLine{832             \{}
\DoxyCodeLine{833                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte1\_raw = get();}
\DoxyCodeLine{834                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::cbor, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{835                 \{}
\DoxyCodeLine{836                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{837                 \}}
\DoxyCodeLine{838                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte2\_raw = get();}
\DoxyCodeLine{839                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::cbor, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{840                 \{}
\DoxyCodeLine{841                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{842                 \}}
\DoxyCodeLine{843 }
\DoxyCodeLine{844                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte1 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(byte1\_raw);}
\DoxyCodeLine{845                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(byte2\_raw);}
\DoxyCodeLine{846 }
\DoxyCodeLine{847                 \textcolor{comment}{// code from RFC 7049, Appendix D, Figure 3:}}
\DoxyCodeLine{848                 \textcolor{comment}{// As half-\/precision floating-\/point numbers were only added}}
\DoxyCodeLine{849                 \textcolor{comment}{// to IEEE 754 in 2008, today's programming platforms often}}
\DoxyCodeLine{850                 \textcolor{comment}{// still only have limited support for them. It is very}}
\DoxyCodeLine{851                 \textcolor{comment}{// easy to include at least decoding support for them even}}
\DoxyCodeLine{852                 \textcolor{comment}{// without such support. An example of a small decoder for}}
\DoxyCodeLine{853                 \textcolor{comment}{// half-\/precision floating-\/point numbers in the C language}}
\DoxyCodeLine{854                 \textcolor{comment}{// is shown in Fig. 3.}}
\DoxyCodeLine{855                 \textcolor{keyword}{const} \textcolor{keyword}{auto} half = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}((byte1 << 8u) + byte2);}
\DoxyCodeLine{856                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} val = [\&half]}
\DoxyCodeLine{857                 \{}
\DoxyCodeLine{858                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} exp = (half >> 10u) \& 0x1Fu;}
\DoxyCodeLine{859                     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mant = half \& 0x3FFu;}
\DoxyCodeLine{860                     JSON\_ASSERT(0 <= exp\&\& exp <= 32);}
\DoxyCodeLine{861                     JSON\_ASSERT(mant <= 1024);}
\DoxyCodeLine{862                     \textcolor{keywordflow}{switch} (exp)}
\DoxyCodeLine{863                     \{}
\DoxyCodeLine{864                         \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{865                             \textcolor{keywordflow}{return} std::ldexp(mant, -\/24);}
\DoxyCodeLine{866                         \textcolor{keywordflow}{case} 31:}
\DoxyCodeLine{867                             \textcolor{keywordflow}{return} (mant == 0)}
\DoxyCodeLine{868                             ? std::numeric\_limits<double>::infinity()}
\DoxyCodeLine{869                             : std::numeric\_limits<double>::quiet\_NaN();}
\DoxyCodeLine{870                         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{871                             \textcolor{keywordflow}{return} std::ldexp(mant + 1024, exp -\/ 25);}
\DoxyCodeLine{872                     \}}
\DoxyCodeLine{873                 \}();}
\DoxyCodeLine{874                 \textcolor{keywordflow}{return} sax-\/>number\_float((half \& 0x8000u) != 0}
\DoxyCodeLine{875                                          ? \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(-\/val)}
\DoxyCodeLine{876                                          : \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(val), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{877             \}}
\DoxyCodeLine{878 }
\DoxyCodeLine{879             \textcolor{keywordflow}{case} 0xFA: \textcolor{comment}{// Single-\/Precision Float (four-\/byte IEEE 754)}}
\DoxyCodeLine{880             \{}
\DoxyCodeLine{881                 \textcolor{keywordtype}{float} number\{\};}
\DoxyCodeLine{882                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{883             \}}
\DoxyCodeLine{884 }
\DoxyCodeLine{885             \textcolor{keywordflow}{case} 0xFB: \textcolor{comment}{// Double-\/Precision Float (eight-\/byte IEEE 754)}}
\DoxyCodeLine{886             \{}
\DoxyCodeLine{887                 \textcolor{keywordtype}{double} number\{\};}
\DoxyCodeLine{888                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{889             \}}
\DoxyCodeLine{890 }
\DoxyCodeLine{891             \textcolor{keywordflow}{default}: \textcolor{comment}{// anything else (0xFF is handled inside the other types)}}
\DoxyCodeLine{892             \{}
\DoxyCodeLine{893                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{894                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{895                                         exception\_message(input\_format\_t::cbor, concat(\textcolor{stringliteral}{"{}invalid byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{896             \}}
\DoxyCodeLine{897         \}}
\DoxyCodeLine{898     \}}
\DoxyCodeLine{899 }
\DoxyCodeLine{911     \textcolor{keywordtype}{bool} get\_cbor\_string(string\_t\& result)}
\DoxyCodeLine{912     \{}
\DoxyCodeLine{913         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::cbor, \textcolor{stringliteral}{"{}string"{}})))}
\DoxyCodeLine{914         \{}
\DoxyCodeLine{915             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{916         \}}
\DoxyCodeLine{917 }
\DoxyCodeLine{918         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{919         \{}
\DoxyCodeLine{920             \textcolor{comment}{// UTF-\/8 string (0x00..0x17 bytes follow)}}
\DoxyCodeLine{921             \textcolor{keywordflow}{case} 0x60:}
\DoxyCodeLine{922             \textcolor{keywordflow}{case} 0x61:}
\DoxyCodeLine{923             \textcolor{keywordflow}{case} 0x62:}
\DoxyCodeLine{924             \textcolor{keywordflow}{case} 0x63:}
\DoxyCodeLine{925             \textcolor{keywordflow}{case} 0x64:}
\DoxyCodeLine{926             \textcolor{keywordflow}{case} 0x65:}
\DoxyCodeLine{927             \textcolor{keywordflow}{case} 0x66:}
\DoxyCodeLine{928             \textcolor{keywordflow}{case} 0x67:}
\DoxyCodeLine{929             \textcolor{keywordflow}{case} 0x68:}
\DoxyCodeLine{930             \textcolor{keywordflow}{case} 0x69:}
\DoxyCodeLine{931             \textcolor{keywordflow}{case} 0x6A:}
\DoxyCodeLine{932             \textcolor{keywordflow}{case} 0x6B:}
\DoxyCodeLine{933             \textcolor{keywordflow}{case} 0x6C:}
\DoxyCodeLine{934             \textcolor{keywordflow}{case} 0x6D:}
\DoxyCodeLine{935             \textcolor{keywordflow}{case} 0x6E:}
\DoxyCodeLine{936             \textcolor{keywordflow}{case} 0x6F:}
\DoxyCodeLine{937             \textcolor{keywordflow}{case} 0x70:}
\DoxyCodeLine{938             \textcolor{keywordflow}{case} 0x71:}
\DoxyCodeLine{939             \textcolor{keywordflow}{case} 0x72:}
\DoxyCodeLine{940             \textcolor{keywordflow}{case} 0x73:}
\DoxyCodeLine{941             \textcolor{keywordflow}{case} 0x74:}
\DoxyCodeLine{942             \textcolor{keywordflow}{case} 0x75:}
\DoxyCodeLine{943             \textcolor{keywordflow}{case} 0x76:}
\DoxyCodeLine{944             \textcolor{keywordflow}{case} 0x77:}
\DoxyCodeLine{945             \{}
\DoxyCodeLine{946                 \textcolor{keywordflow}{return} get\_string(input\_format\_t::cbor, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu, result);}
\DoxyCodeLine{947             \}}
\DoxyCodeLine{948 }
\DoxyCodeLine{949             \textcolor{keywordflow}{case} 0x78: \textcolor{comment}{// UTF-\/8 string (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{950             \{}
\DoxyCodeLine{951                 std::uint8\_t len\{\};}
\DoxyCodeLine{952                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_string(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{953             \}}
\DoxyCodeLine{954 }
\DoxyCodeLine{955             \textcolor{keywordflow}{case} 0x79: \textcolor{comment}{// UTF-\/8 string (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{956             \{}
\DoxyCodeLine{957                 std::uint16\_t len\{\};}
\DoxyCodeLine{958                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_string(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{959             \}}
\DoxyCodeLine{960 }
\DoxyCodeLine{961             \textcolor{keywordflow}{case} 0x7A: \textcolor{comment}{// UTF-\/8 string (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{962             \{}
\DoxyCodeLine{963                 std::uint32\_t len\{\};}
\DoxyCodeLine{964                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_string(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{965             \}}
\DoxyCodeLine{966 }
\DoxyCodeLine{967             \textcolor{keywordflow}{case} 0x7B: \textcolor{comment}{// UTF-\/8 string (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{968             \{}
\DoxyCodeLine{969                 std::uint64\_t len\{\};}
\DoxyCodeLine{970                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_string(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{971             \}}
\DoxyCodeLine{972 }
\DoxyCodeLine{973             \textcolor{keywordflow}{case} 0x7F: \textcolor{comment}{// UTF-\/8 string (indefinite length)}}
\DoxyCodeLine{974             \{}
\DoxyCodeLine{975                 \textcolor{keywordflow}{while} (get() != 0xFF)}
\DoxyCodeLine{976                 \{}
\DoxyCodeLine{977                     string\_t chunk;}
\DoxyCodeLine{978                     \textcolor{keywordflow}{if} (!get\_cbor\_string(chunk))}
\DoxyCodeLine{979                     \{}
\DoxyCodeLine{980                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{981                     \}}
\DoxyCodeLine{982                     result.append(chunk);}
\DoxyCodeLine{983                 \}}
\DoxyCodeLine{984                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{985             \}}
\DoxyCodeLine{986 }
\DoxyCodeLine{987             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{988             \{}
\DoxyCodeLine{989                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{990                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read,}
\DoxyCodeLine{991                                         exception\_message(input\_format\_t::cbor, concat(\textcolor{stringliteral}{"{}expected length specification (0x60-\/0x7B) or indefinite string type (0x7F); last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}string"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{992             \}}
\DoxyCodeLine{993         \}}
\DoxyCodeLine{994     \}}
\DoxyCodeLine{995 }
\DoxyCodeLine{1007     \textcolor{keywordtype}{bool} get\_cbor\_binary(binary\_t\& result)}
\DoxyCodeLine{1008     \{}
\DoxyCodeLine{1009         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::cbor, \textcolor{stringliteral}{"{}binary"{}})))}
\DoxyCodeLine{1010         \{}
\DoxyCodeLine{1011             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1012         \}}
\DoxyCodeLine{1013 }
\DoxyCodeLine{1014         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{1015         \{}
\DoxyCodeLine{1016             \textcolor{comment}{// Binary data (0x00..0x17 bytes follow)}}
\DoxyCodeLine{1017             \textcolor{keywordflow}{case} 0x40:}
\DoxyCodeLine{1018             \textcolor{keywordflow}{case} 0x41:}
\DoxyCodeLine{1019             \textcolor{keywordflow}{case} 0x42:}
\DoxyCodeLine{1020             \textcolor{keywordflow}{case} 0x43:}
\DoxyCodeLine{1021             \textcolor{keywordflow}{case} 0x44:}
\DoxyCodeLine{1022             \textcolor{keywordflow}{case} 0x45:}
\DoxyCodeLine{1023             \textcolor{keywordflow}{case} 0x46:}
\DoxyCodeLine{1024             \textcolor{keywordflow}{case} 0x47:}
\DoxyCodeLine{1025             \textcolor{keywordflow}{case} 0x48:}
\DoxyCodeLine{1026             \textcolor{keywordflow}{case} 0x49:}
\DoxyCodeLine{1027             \textcolor{keywordflow}{case} 0x4A:}
\DoxyCodeLine{1028             \textcolor{keywordflow}{case} 0x4B:}
\DoxyCodeLine{1029             \textcolor{keywordflow}{case} 0x4C:}
\DoxyCodeLine{1030             \textcolor{keywordflow}{case} 0x4D:}
\DoxyCodeLine{1031             \textcolor{keywordflow}{case} 0x4E:}
\DoxyCodeLine{1032             \textcolor{keywordflow}{case} 0x4F:}
\DoxyCodeLine{1033             \textcolor{keywordflow}{case} 0x50:}
\DoxyCodeLine{1034             \textcolor{keywordflow}{case} 0x51:}
\DoxyCodeLine{1035             \textcolor{keywordflow}{case} 0x52:}
\DoxyCodeLine{1036             \textcolor{keywordflow}{case} 0x53:}
\DoxyCodeLine{1037             \textcolor{keywordflow}{case} 0x54:}
\DoxyCodeLine{1038             \textcolor{keywordflow}{case} 0x55:}
\DoxyCodeLine{1039             \textcolor{keywordflow}{case} 0x56:}
\DoxyCodeLine{1040             \textcolor{keywordflow}{case} 0x57:}
\DoxyCodeLine{1041             \{}
\DoxyCodeLine{1042                 \textcolor{keywordflow}{return} get\_binary(input\_format\_t::cbor, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu, result);}
\DoxyCodeLine{1043             \}}
\DoxyCodeLine{1044 }
\DoxyCodeLine{1045             \textcolor{keywordflow}{case} 0x58: \textcolor{comment}{// Binary data (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{1046             \{}
\DoxyCodeLine{1047                 std::uint8\_t len\{\};}
\DoxyCodeLine{1048                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\&}
\DoxyCodeLine{1049                        get\_binary(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{1050             \}}
\DoxyCodeLine{1051 }
\DoxyCodeLine{1052             \textcolor{keywordflow}{case} 0x59: \textcolor{comment}{// Binary data (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{1053             \{}
\DoxyCodeLine{1054                 std::uint16\_t len\{\};}
\DoxyCodeLine{1055                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\&}
\DoxyCodeLine{1056                        get\_binary(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{1057             \}}
\DoxyCodeLine{1058 }
\DoxyCodeLine{1059             \textcolor{keywordflow}{case} 0x5A: \textcolor{comment}{// Binary data (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{1060             \{}
\DoxyCodeLine{1061                 std::uint32\_t len\{\};}
\DoxyCodeLine{1062                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\&}
\DoxyCodeLine{1063                        get\_binary(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{1064             \}}
\DoxyCodeLine{1065 }
\DoxyCodeLine{1066             \textcolor{keywordflow}{case} 0x5B: \textcolor{comment}{// Binary data (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{1067             \{}
\DoxyCodeLine{1068                 std::uint64\_t len\{\};}
\DoxyCodeLine{1069                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\&}
\DoxyCodeLine{1070                        get\_binary(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{1071             \}}
\DoxyCodeLine{1072 }
\DoxyCodeLine{1073             \textcolor{keywordflow}{case} 0x5F: \textcolor{comment}{// Binary data (indefinite length)}}
\DoxyCodeLine{1074             \{}
\DoxyCodeLine{1075                 \textcolor{keywordflow}{while} (get() != 0xFF)}
\DoxyCodeLine{1076                 \{}
\DoxyCodeLine{1077                     binary\_t chunk;}
\DoxyCodeLine{1078                     \textcolor{keywordflow}{if} (!get\_cbor\_binary(chunk))}
\DoxyCodeLine{1079                     \{}
\DoxyCodeLine{1080                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1081                     \}}
\DoxyCodeLine{1082                     result.insert(result.end(), chunk.begin(), chunk.end());}
\DoxyCodeLine{1083                 \}}
\DoxyCodeLine{1084                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1085             \}}
\DoxyCodeLine{1086 }
\DoxyCodeLine{1087             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1088             \{}
\DoxyCodeLine{1089                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{1090                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read,}
\DoxyCodeLine{1091                                         exception\_message(input\_format\_t::cbor, concat(\textcolor{stringliteral}{"{}expected length specification (0x40-\/0x5B) or indefinite binary array type (0x5F); last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}binary"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{1092             \}}
\DoxyCodeLine{1093         \}}
\DoxyCodeLine{1094     \}}
\DoxyCodeLine{1095 }
\DoxyCodeLine{1102     \textcolor{keywordtype}{bool} get\_cbor\_array(\textcolor{keyword}{const} std::size\_t len,}
\DoxyCodeLine{1103                         \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}} tag\_handler)}
\DoxyCodeLine{1104     \{}
\DoxyCodeLine{1105         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(len)))}
\DoxyCodeLine{1106         \{}
\DoxyCodeLine{1107             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1108         \}}
\DoxyCodeLine{1109 }
\DoxyCodeLine{1110         \textcolor{keywordflow}{if} (len != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))}
\DoxyCodeLine{1111         \{}
\DoxyCodeLine{1112             \textcolor{keywordflow}{for} (std::size\_t i = 0; i < len; ++i)}
\DoxyCodeLine{1113             \{}
\DoxyCodeLine{1114                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler)))}
\DoxyCodeLine{1115                 \{}
\DoxyCodeLine{1116                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1117                 \}}
\DoxyCodeLine{1118             \}}
\DoxyCodeLine{1119         \}}
\DoxyCodeLine{1120         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1121         \{}
\DoxyCodeLine{1122             \textcolor{keywordflow}{while} (get() != 0xFF)}
\DoxyCodeLine{1123             \{}
\DoxyCodeLine{1124                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_cbor\_internal(\textcolor{keyword}{false}, tag\_handler)))}
\DoxyCodeLine{1125                 \{}
\DoxyCodeLine{1126                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1127                 \}}
\DoxyCodeLine{1128             \}}
\DoxyCodeLine{1129         \}}
\DoxyCodeLine{1130 }
\DoxyCodeLine{1131         \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{1132     \}}
\DoxyCodeLine{1133 }
\DoxyCodeLine{1140     \textcolor{keywordtype}{bool} get\_cbor\_object(\textcolor{keyword}{const} std::size\_t len,}
\DoxyCodeLine{1141                          \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}} tag\_handler)}
\DoxyCodeLine{1142     \{}
\DoxyCodeLine{1143         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(len)))}
\DoxyCodeLine{1144         \{}
\DoxyCodeLine{1145             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1146         \}}
\DoxyCodeLine{1147 }
\DoxyCodeLine{1148         \textcolor{keywordflow}{if} (len != 0)}
\DoxyCodeLine{1149         \{}
\DoxyCodeLine{1150             string\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}};}
\DoxyCodeLine{1151             \textcolor{keywordflow}{if} (len != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))}
\DoxyCodeLine{1152             \{}
\DoxyCodeLine{1153                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < len; ++i)}
\DoxyCodeLine{1154                 \{}
\DoxyCodeLine{1155                     get();}
\DoxyCodeLine{1156                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_cbor\_string(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}) || !sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}})))}
\DoxyCodeLine{1157                     \{}
\DoxyCodeLine{1158                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1159                     \}}
\DoxyCodeLine{1160 }
\DoxyCodeLine{1161                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler)))}
\DoxyCodeLine{1162                     \{}
\DoxyCodeLine{1163                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1164                     \}}
\DoxyCodeLine{1165                     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}.clear();}
\DoxyCodeLine{1166                 \}}
\DoxyCodeLine{1167             \}}
\DoxyCodeLine{1168             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1169             \{}
\DoxyCodeLine{1170                 \textcolor{keywordflow}{while} (get() != 0xFF)}
\DoxyCodeLine{1171                 \{}
\DoxyCodeLine{1172                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_cbor\_string(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}) || !sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}})))}
\DoxyCodeLine{1173                     \{}
\DoxyCodeLine{1174                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1175                     \}}
\DoxyCodeLine{1176 }
\DoxyCodeLine{1177                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler)))}
\DoxyCodeLine{1178                     \{}
\DoxyCodeLine{1179                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1180                     \}}
\DoxyCodeLine{1181                     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}.clear();}
\DoxyCodeLine{1182                 \}}
\DoxyCodeLine{1183             \}}
\DoxyCodeLine{1184         \}}
\DoxyCodeLine{1185 }
\DoxyCodeLine{1186         \textcolor{keywordflow}{return} sax-\/>end\_object();}
\DoxyCodeLine{1187     \}}
\DoxyCodeLine{1188 }
\DoxyCodeLine{1190     \textcolor{comment}{// MsgPack //}}
\DoxyCodeLine{1192 \textcolor{comment}{}}
\DoxyCodeLine{1196     \textcolor{keywordtype}{bool} parse\_msgpack\_internal()}
\DoxyCodeLine{1197     \{}
\DoxyCodeLine{1198         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{1199         \{}
\DoxyCodeLine{1200             \textcolor{comment}{// EOF}}
\DoxyCodeLine{1201             \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():}
\DoxyCodeLine{1202                 return unexpect\_eof(\mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}}::msgpack, \textcolor{stringliteral}{"{}value"{}});}
\DoxyCodeLine{1203 }
\DoxyCodeLine{1204             \textcolor{comment}{// positive fixint}}
\DoxyCodeLine{1205             \textcolor{keywordflow}{case} 0x00:}
\DoxyCodeLine{1206             \textcolor{keywordflow}{case} 0x01:}
\DoxyCodeLine{1207             \textcolor{keywordflow}{case} 0x02:}
\DoxyCodeLine{1208             \textcolor{keywordflow}{case} 0x03:}
\DoxyCodeLine{1209             \textcolor{keywordflow}{case} 0x04:}
\DoxyCodeLine{1210             \textcolor{keywordflow}{case} 0x05:}
\DoxyCodeLine{1211             \textcolor{keywordflow}{case} 0x06:}
\DoxyCodeLine{1212             \textcolor{keywordflow}{case} 0x07:}
\DoxyCodeLine{1213             \textcolor{keywordflow}{case} 0x08:}
\DoxyCodeLine{1214             \textcolor{keywordflow}{case} 0x09:}
\DoxyCodeLine{1215             \textcolor{keywordflow}{case} 0x0A:}
\DoxyCodeLine{1216             \textcolor{keywordflow}{case} 0x0B:}
\DoxyCodeLine{1217             \textcolor{keywordflow}{case} 0x0C:}
\DoxyCodeLine{1218             \textcolor{keywordflow}{case} 0x0D:}
\DoxyCodeLine{1219             \textcolor{keywordflow}{case} 0x0E:}
\DoxyCodeLine{1220             \textcolor{keywordflow}{case} 0x0F:}
\DoxyCodeLine{1221             \textcolor{keywordflow}{case} 0x10:}
\DoxyCodeLine{1222             \textcolor{keywordflow}{case} 0x11:}
\DoxyCodeLine{1223             \textcolor{keywordflow}{case} 0x12:}
\DoxyCodeLine{1224             \textcolor{keywordflow}{case} 0x13:}
\DoxyCodeLine{1225             \textcolor{keywordflow}{case} 0x14:}
\DoxyCodeLine{1226             \textcolor{keywordflow}{case} 0x15:}
\DoxyCodeLine{1227             \textcolor{keywordflow}{case} 0x16:}
\DoxyCodeLine{1228             \textcolor{keywordflow}{case} 0x17:}
\DoxyCodeLine{1229             \textcolor{keywordflow}{case} 0x18:}
\DoxyCodeLine{1230             \textcolor{keywordflow}{case} 0x19:}
\DoxyCodeLine{1231             \textcolor{keywordflow}{case} 0x1A:}
\DoxyCodeLine{1232             \textcolor{keywordflow}{case} 0x1B:}
\DoxyCodeLine{1233             \textcolor{keywordflow}{case} 0x1C:}
\DoxyCodeLine{1234             \textcolor{keywordflow}{case} 0x1D:}
\DoxyCodeLine{1235             \textcolor{keywordflow}{case} 0x1E:}
\DoxyCodeLine{1236             \textcolor{keywordflow}{case} 0x1F:}
\DoxyCodeLine{1237             \textcolor{keywordflow}{case} 0x20:}
\DoxyCodeLine{1238             \textcolor{keywordflow}{case} 0x21:}
\DoxyCodeLine{1239             \textcolor{keywordflow}{case} 0x22:}
\DoxyCodeLine{1240             \textcolor{keywordflow}{case} 0x23:}
\DoxyCodeLine{1241             \textcolor{keywordflow}{case} 0x24:}
\DoxyCodeLine{1242             \textcolor{keywordflow}{case} 0x25:}
\DoxyCodeLine{1243             \textcolor{keywordflow}{case} 0x26:}
\DoxyCodeLine{1244             \textcolor{keywordflow}{case} 0x27:}
\DoxyCodeLine{1245             \textcolor{keywordflow}{case} 0x28:}
\DoxyCodeLine{1246             \textcolor{keywordflow}{case} 0x29:}
\DoxyCodeLine{1247             \textcolor{keywordflow}{case} 0x2A:}
\DoxyCodeLine{1248             \textcolor{keywordflow}{case} 0x2B:}
\DoxyCodeLine{1249             \textcolor{keywordflow}{case} 0x2C:}
\DoxyCodeLine{1250             \textcolor{keywordflow}{case} 0x2D:}
\DoxyCodeLine{1251             \textcolor{keywordflow}{case} 0x2E:}
\DoxyCodeLine{1252             \textcolor{keywordflow}{case} 0x2F:}
\DoxyCodeLine{1253             \textcolor{keywordflow}{case} 0x30:}
\DoxyCodeLine{1254             \textcolor{keywordflow}{case} 0x31:}
\DoxyCodeLine{1255             \textcolor{keywordflow}{case} 0x32:}
\DoxyCodeLine{1256             \textcolor{keywordflow}{case} 0x33:}
\DoxyCodeLine{1257             \textcolor{keywordflow}{case} 0x34:}
\DoxyCodeLine{1258             \textcolor{keywordflow}{case} 0x35:}
\DoxyCodeLine{1259             \textcolor{keywordflow}{case} 0x36:}
\DoxyCodeLine{1260             \textcolor{keywordflow}{case} 0x37:}
\DoxyCodeLine{1261             \textcolor{keywordflow}{case} 0x38:}
\DoxyCodeLine{1262             \textcolor{keywordflow}{case} 0x39:}
\DoxyCodeLine{1263             \textcolor{keywordflow}{case} 0x3A:}
\DoxyCodeLine{1264             \textcolor{keywordflow}{case} 0x3B:}
\DoxyCodeLine{1265             \textcolor{keywordflow}{case} 0x3C:}
\DoxyCodeLine{1266             \textcolor{keywordflow}{case} 0x3D:}
\DoxyCodeLine{1267             \textcolor{keywordflow}{case} 0x3E:}
\DoxyCodeLine{1268             \textcolor{keywordflow}{case} 0x3F:}
\DoxyCodeLine{1269             \textcolor{keywordflow}{case} 0x40:}
\DoxyCodeLine{1270             \textcolor{keywordflow}{case} 0x41:}
\DoxyCodeLine{1271             \textcolor{keywordflow}{case} 0x42:}
\DoxyCodeLine{1272             \textcolor{keywordflow}{case} 0x43:}
\DoxyCodeLine{1273             \textcolor{keywordflow}{case} 0x44:}
\DoxyCodeLine{1274             \textcolor{keywordflow}{case} 0x45:}
\DoxyCodeLine{1275             \textcolor{keywordflow}{case} 0x46:}
\DoxyCodeLine{1276             \textcolor{keywordflow}{case} 0x47:}
\DoxyCodeLine{1277             \textcolor{keywordflow}{case} 0x48:}
\DoxyCodeLine{1278             \textcolor{keywordflow}{case} 0x49:}
\DoxyCodeLine{1279             \textcolor{keywordflow}{case} 0x4A:}
\DoxyCodeLine{1280             \textcolor{keywordflow}{case} 0x4B:}
\DoxyCodeLine{1281             \textcolor{keywordflow}{case} 0x4C:}
\DoxyCodeLine{1282             \textcolor{keywordflow}{case} 0x4D:}
\DoxyCodeLine{1283             \textcolor{keywordflow}{case} 0x4E:}
\DoxyCodeLine{1284             \textcolor{keywordflow}{case} 0x4F:}
\DoxyCodeLine{1285             \textcolor{keywordflow}{case} 0x50:}
\DoxyCodeLine{1286             \textcolor{keywordflow}{case} 0x51:}
\DoxyCodeLine{1287             \textcolor{keywordflow}{case} 0x52:}
\DoxyCodeLine{1288             \textcolor{keywordflow}{case} 0x53:}
\DoxyCodeLine{1289             \textcolor{keywordflow}{case} 0x54:}
\DoxyCodeLine{1290             \textcolor{keywordflow}{case} 0x55:}
\DoxyCodeLine{1291             \textcolor{keywordflow}{case} 0x56:}
\DoxyCodeLine{1292             \textcolor{keywordflow}{case} 0x57:}
\DoxyCodeLine{1293             \textcolor{keywordflow}{case} 0x58:}
\DoxyCodeLine{1294             \textcolor{keywordflow}{case} 0x59:}
\DoxyCodeLine{1295             \textcolor{keywordflow}{case} 0x5A:}
\DoxyCodeLine{1296             \textcolor{keywordflow}{case} 0x5B:}
\DoxyCodeLine{1297             \textcolor{keywordflow}{case} 0x5C:}
\DoxyCodeLine{1298             \textcolor{keywordflow}{case} 0x5D:}
\DoxyCodeLine{1299             \textcolor{keywordflow}{case} 0x5E:}
\DoxyCodeLine{1300             \textcolor{keywordflow}{case} 0x5F:}
\DoxyCodeLine{1301             \textcolor{keywordflow}{case} 0x60:}
\DoxyCodeLine{1302             \textcolor{keywordflow}{case} 0x61:}
\DoxyCodeLine{1303             \textcolor{keywordflow}{case} 0x62:}
\DoxyCodeLine{1304             \textcolor{keywordflow}{case} 0x63:}
\DoxyCodeLine{1305             \textcolor{keywordflow}{case} 0x64:}
\DoxyCodeLine{1306             \textcolor{keywordflow}{case} 0x65:}
\DoxyCodeLine{1307             \textcolor{keywordflow}{case} 0x66:}
\DoxyCodeLine{1308             \textcolor{keywordflow}{case} 0x67:}
\DoxyCodeLine{1309             \textcolor{keywordflow}{case} 0x68:}
\DoxyCodeLine{1310             \textcolor{keywordflow}{case} 0x69:}
\DoxyCodeLine{1311             \textcolor{keywordflow}{case} 0x6A:}
\DoxyCodeLine{1312             \textcolor{keywordflow}{case} 0x6B:}
\DoxyCodeLine{1313             \textcolor{keywordflow}{case} 0x6C:}
\DoxyCodeLine{1314             \textcolor{keywordflow}{case} 0x6D:}
\DoxyCodeLine{1315             \textcolor{keywordflow}{case} 0x6E:}
\DoxyCodeLine{1316             \textcolor{keywordflow}{case} 0x6F:}
\DoxyCodeLine{1317             \textcolor{keywordflow}{case} 0x70:}
\DoxyCodeLine{1318             \textcolor{keywordflow}{case} 0x71:}
\DoxyCodeLine{1319             \textcolor{keywordflow}{case} 0x72:}
\DoxyCodeLine{1320             \textcolor{keywordflow}{case} 0x73:}
\DoxyCodeLine{1321             \textcolor{keywordflow}{case} 0x74:}
\DoxyCodeLine{1322             \textcolor{keywordflow}{case} 0x75:}
\DoxyCodeLine{1323             \textcolor{keywordflow}{case} 0x76:}
\DoxyCodeLine{1324             \textcolor{keywordflow}{case} 0x77:}
\DoxyCodeLine{1325             \textcolor{keywordflow}{case} 0x78:}
\DoxyCodeLine{1326             \textcolor{keywordflow}{case} 0x79:}
\DoxyCodeLine{1327             \textcolor{keywordflow}{case} 0x7A:}
\DoxyCodeLine{1328             \textcolor{keywordflow}{case} 0x7B:}
\DoxyCodeLine{1329             \textcolor{keywordflow}{case} 0x7C:}
\DoxyCodeLine{1330             \textcolor{keywordflow}{case} 0x7D:}
\DoxyCodeLine{1331             \textcolor{keywordflow}{case} 0x7E:}
\DoxyCodeLine{1332             \textcolor{keywordflow}{case} 0x7F:}
\DoxyCodeLine{1333                 \textcolor{keywordflow}{return} sax-\/>number\_unsigned(\textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(current));}
\DoxyCodeLine{1334 }
\DoxyCodeLine{1335             \textcolor{comment}{// fixmap}}
\DoxyCodeLine{1336             \textcolor{keywordflow}{case} 0x80:}
\DoxyCodeLine{1337             \textcolor{keywordflow}{case} 0x81:}
\DoxyCodeLine{1338             \textcolor{keywordflow}{case} 0x82:}
\DoxyCodeLine{1339             \textcolor{keywordflow}{case} 0x83:}
\DoxyCodeLine{1340             \textcolor{keywordflow}{case} 0x84:}
\DoxyCodeLine{1341             \textcolor{keywordflow}{case} 0x85:}
\DoxyCodeLine{1342             \textcolor{keywordflow}{case} 0x86:}
\DoxyCodeLine{1343             \textcolor{keywordflow}{case} 0x87:}
\DoxyCodeLine{1344             \textcolor{keywordflow}{case} 0x88:}
\DoxyCodeLine{1345             \textcolor{keywordflow}{case} 0x89:}
\DoxyCodeLine{1346             \textcolor{keywordflow}{case} 0x8A:}
\DoxyCodeLine{1347             \textcolor{keywordflow}{case} 0x8B:}
\DoxyCodeLine{1348             \textcolor{keywordflow}{case} 0x8C:}
\DoxyCodeLine{1349             \textcolor{keywordflow}{case} 0x8D:}
\DoxyCodeLine{1350             \textcolor{keywordflow}{case} 0x8E:}
\DoxyCodeLine{1351             \textcolor{keywordflow}{case} 0x8F:}
\DoxyCodeLine{1352                 \textcolor{keywordflow}{return} get\_msgpack\_object(conditional\_static\_cast<std::size\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x0Fu));}
\DoxyCodeLine{1353 }
\DoxyCodeLine{1354             \textcolor{comment}{// fixarray}}
\DoxyCodeLine{1355             \textcolor{keywordflow}{case} 0x90:}
\DoxyCodeLine{1356             \textcolor{keywordflow}{case} 0x91:}
\DoxyCodeLine{1357             \textcolor{keywordflow}{case} 0x92:}
\DoxyCodeLine{1358             \textcolor{keywordflow}{case} 0x93:}
\DoxyCodeLine{1359             \textcolor{keywordflow}{case} 0x94:}
\DoxyCodeLine{1360             \textcolor{keywordflow}{case} 0x95:}
\DoxyCodeLine{1361             \textcolor{keywordflow}{case} 0x96:}
\DoxyCodeLine{1362             \textcolor{keywordflow}{case} 0x97:}
\DoxyCodeLine{1363             \textcolor{keywordflow}{case} 0x98:}
\DoxyCodeLine{1364             \textcolor{keywordflow}{case} 0x99:}
\DoxyCodeLine{1365             \textcolor{keywordflow}{case} 0x9A:}
\DoxyCodeLine{1366             \textcolor{keywordflow}{case} 0x9B:}
\DoxyCodeLine{1367             \textcolor{keywordflow}{case} 0x9C:}
\DoxyCodeLine{1368             \textcolor{keywordflow}{case} 0x9D:}
\DoxyCodeLine{1369             \textcolor{keywordflow}{case} 0x9E:}
\DoxyCodeLine{1370             \textcolor{keywordflow}{case} 0x9F:}
\DoxyCodeLine{1371                 \textcolor{keywordflow}{return} get\_msgpack\_array(conditional\_static\_cast<std::size\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x0Fu));}
\DoxyCodeLine{1372 }
\DoxyCodeLine{1373             \textcolor{comment}{// fixstr}}
\DoxyCodeLine{1374             \textcolor{keywordflow}{case} 0xA0:}
\DoxyCodeLine{1375             \textcolor{keywordflow}{case} 0xA1:}
\DoxyCodeLine{1376             \textcolor{keywordflow}{case} 0xA2:}
\DoxyCodeLine{1377             \textcolor{keywordflow}{case} 0xA3:}
\DoxyCodeLine{1378             \textcolor{keywordflow}{case} 0xA4:}
\DoxyCodeLine{1379             \textcolor{keywordflow}{case} 0xA5:}
\DoxyCodeLine{1380             \textcolor{keywordflow}{case} 0xA6:}
\DoxyCodeLine{1381             \textcolor{keywordflow}{case} 0xA7:}
\DoxyCodeLine{1382             \textcolor{keywordflow}{case} 0xA8:}
\DoxyCodeLine{1383             \textcolor{keywordflow}{case} 0xA9:}
\DoxyCodeLine{1384             \textcolor{keywordflow}{case} 0xAA:}
\DoxyCodeLine{1385             \textcolor{keywordflow}{case} 0xAB:}
\DoxyCodeLine{1386             \textcolor{keywordflow}{case} 0xAC:}
\DoxyCodeLine{1387             \textcolor{keywordflow}{case} 0xAD:}
\DoxyCodeLine{1388             \textcolor{keywordflow}{case} 0xAE:}
\DoxyCodeLine{1389             \textcolor{keywordflow}{case} 0xAF:}
\DoxyCodeLine{1390             \textcolor{keywordflow}{case} 0xB0:}
\DoxyCodeLine{1391             \textcolor{keywordflow}{case} 0xB1:}
\DoxyCodeLine{1392             \textcolor{keywordflow}{case} 0xB2:}
\DoxyCodeLine{1393             \textcolor{keywordflow}{case} 0xB3:}
\DoxyCodeLine{1394             \textcolor{keywordflow}{case} 0xB4:}
\DoxyCodeLine{1395             \textcolor{keywordflow}{case} 0xB5:}
\DoxyCodeLine{1396             \textcolor{keywordflow}{case} 0xB6:}
\DoxyCodeLine{1397             \textcolor{keywordflow}{case} 0xB7:}
\DoxyCodeLine{1398             \textcolor{keywordflow}{case} 0xB8:}
\DoxyCodeLine{1399             \textcolor{keywordflow}{case} 0xB9:}
\DoxyCodeLine{1400             \textcolor{keywordflow}{case} 0xBA:}
\DoxyCodeLine{1401             \textcolor{keywordflow}{case} 0xBB:}
\DoxyCodeLine{1402             \textcolor{keywordflow}{case} 0xBC:}
\DoxyCodeLine{1403             \textcolor{keywordflow}{case} 0xBD:}
\DoxyCodeLine{1404             \textcolor{keywordflow}{case} 0xBE:}
\DoxyCodeLine{1405             \textcolor{keywordflow}{case} 0xBF:}
\DoxyCodeLine{1406             \textcolor{keywordflow}{case} 0xD9: \textcolor{comment}{// str 8}}
\DoxyCodeLine{1407             \textcolor{keywordflow}{case} 0xDA: \textcolor{comment}{// str 16}}
\DoxyCodeLine{1408             \textcolor{keywordflow}{case} 0xDB: \textcolor{comment}{// str 32}}
\DoxyCodeLine{1409             \{}
\DoxyCodeLine{1410                 string\_t s;}
\DoxyCodeLine{1411                 \textcolor{keywordflow}{return} get\_msgpack\_string(s) \&\& sax-\/>string(s);}
\DoxyCodeLine{1412             \}}
\DoxyCodeLine{1413 }
\DoxyCodeLine{1414             \textcolor{keywordflow}{case} 0xC0: \textcolor{comment}{// nil}}
\DoxyCodeLine{1415                 \textcolor{keywordflow}{return} sax-\/>null();}
\DoxyCodeLine{1416 }
\DoxyCodeLine{1417             \textcolor{keywordflow}{case} 0xC2: \textcolor{comment}{// false}}
\DoxyCodeLine{1418                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{false});}
\DoxyCodeLine{1419 }
\DoxyCodeLine{1420             \textcolor{keywordflow}{case} 0xC3: \textcolor{comment}{// true}}
\DoxyCodeLine{1421                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{true});}
\DoxyCodeLine{1422 }
\DoxyCodeLine{1423             \textcolor{keywordflow}{case} 0xC4: \textcolor{comment}{// bin 8}}
\DoxyCodeLine{1424             \textcolor{keywordflow}{case} 0xC5: \textcolor{comment}{// bin 16}}
\DoxyCodeLine{1425             \textcolor{keywordflow}{case} 0xC6: \textcolor{comment}{// bin 32}}
\DoxyCodeLine{1426             \textcolor{keywordflow}{case} 0xC7: \textcolor{comment}{// ext 8}}
\DoxyCodeLine{1427             \textcolor{keywordflow}{case} 0xC8: \textcolor{comment}{// ext 16}}
\DoxyCodeLine{1428             \textcolor{keywordflow}{case} 0xC9: \textcolor{comment}{// ext 32}}
\DoxyCodeLine{1429             \textcolor{keywordflow}{case} 0xD4: \textcolor{comment}{// fixext 1}}
\DoxyCodeLine{1430             \textcolor{keywordflow}{case} 0xD5: \textcolor{comment}{// fixext 2}}
\DoxyCodeLine{1431             \textcolor{keywordflow}{case} 0xD6: \textcolor{comment}{// fixext 4}}
\DoxyCodeLine{1432             \textcolor{keywordflow}{case} 0xD7: \textcolor{comment}{// fixext 8}}
\DoxyCodeLine{1433             \textcolor{keywordflow}{case} 0xD8: \textcolor{comment}{// fixext 16}}
\DoxyCodeLine{1434             \{}
\DoxyCodeLine{1435                 binary\_t b;}
\DoxyCodeLine{1436                 \textcolor{keywordflow}{return} get\_msgpack\_binary(b) \&\& sax-\/>binary(b);}
\DoxyCodeLine{1437             \}}
\DoxyCodeLine{1438 }
\DoxyCodeLine{1439             \textcolor{keywordflow}{case} 0xCA: \textcolor{comment}{// float 32}}
\DoxyCodeLine{1440             \{}
\DoxyCodeLine{1441                 \textcolor{keywordtype}{float} number\{\};}
\DoxyCodeLine{1442                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1443             \}}
\DoxyCodeLine{1444 }
\DoxyCodeLine{1445             \textcolor{keywordflow}{case} 0xCB: \textcolor{comment}{// float 64}}
\DoxyCodeLine{1446             \{}
\DoxyCodeLine{1447                 \textcolor{keywordtype}{double} number\{\};}
\DoxyCodeLine{1448                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1449             \}}
\DoxyCodeLine{1450 }
\DoxyCodeLine{1451             \textcolor{keywordflow}{case} 0xCC: \textcolor{comment}{// uint 8}}
\DoxyCodeLine{1452             \{}
\DoxyCodeLine{1453                 std::uint8\_t number\{\};}
\DoxyCodeLine{1454                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{1455             \}}
\DoxyCodeLine{1456 }
\DoxyCodeLine{1457             \textcolor{keywordflow}{case} 0xCD: \textcolor{comment}{// uint 16}}
\DoxyCodeLine{1458             \{}
\DoxyCodeLine{1459                 std::uint16\_t number\{\};}
\DoxyCodeLine{1460                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{1461             \}}
\DoxyCodeLine{1462 }
\DoxyCodeLine{1463             \textcolor{keywordflow}{case} 0xCE: \textcolor{comment}{// uint 32}}
\DoxyCodeLine{1464             \{}
\DoxyCodeLine{1465                 std::uint32\_t number\{\};}
\DoxyCodeLine{1466                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{1467             \}}
\DoxyCodeLine{1468 }
\DoxyCodeLine{1469             \textcolor{keywordflow}{case} 0xCF: \textcolor{comment}{// uint 64}}
\DoxyCodeLine{1470             \{}
\DoxyCodeLine{1471                 std::uint64\_t number\{\};}
\DoxyCodeLine{1472                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{1473             \}}
\DoxyCodeLine{1474 }
\DoxyCodeLine{1475             \textcolor{keywordflow}{case} 0xD0: \textcolor{comment}{// int 8}}
\DoxyCodeLine{1476             \{}
\DoxyCodeLine{1477                 std::int8\_t number\{\};}
\DoxyCodeLine{1478                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{1479             \}}
\DoxyCodeLine{1480 }
\DoxyCodeLine{1481             \textcolor{keywordflow}{case} 0xD1: \textcolor{comment}{// int 16}}
\DoxyCodeLine{1482             \{}
\DoxyCodeLine{1483                 std::int16\_t number\{\};}
\DoxyCodeLine{1484                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{1485             \}}
\DoxyCodeLine{1486 }
\DoxyCodeLine{1487             \textcolor{keywordflow}{case} 0xD2: \textcolor{comment}{// int 32}}
\DoxyCodeLine{1488             \{}
\DoxyCodeLine{1489                 std::int32\_t number\{\};}
\DoxyCodeLine{1490                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{1491             \}}
\DoxyCodeLine{1492 }
\DoxyCodeLine{1493             \textcolor{keywordflow}{case} 0xD3: \textcolor{comment}{// int 64}}
\DoxyCodeLine{1494             \{}
\DoxyCodeLine{1495                 std::int64\_t number\{\};}
\DoxyCodeLine{1496                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{1497             \}}
\DoxyCodeLine{1498 }
\DoxyCodeLine{1499             \textcolor{keywordflow}{case} 0xDC: \textcolor{comment}{// array 16}}
\DoxyCodeLine{1500             \{}
\DoxyCodeLine{1501                 std::uint16\_t len\{\};}
\DoxyCodeLine{1502                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_msgpack\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len));}
\DoxyCodeLine{1503             \}}
\DoxyCodeLine{1504 }
\DoxyCodeLine{1505             \textcolor{keywordflow}{case} 0xDD: \textcolor{comment}{// array 32}}
\DoxyCodeLine{1506             \{}
\DoxyCodeLine{1507                 std::uint32\_t len\{\};}
\DoxyCodeLine{1508                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_msgpack\_array(conditional\_static\_cast<std::size\_t>(len));}
\DoxyCodeLine{1509             \}}
\DoxyCodeLine{1510 }
\DoxyCodeLine{1511             \textcolor{keywordflow}{case} 0xDE: \textcolor{comment}{// map 16}}
\DoxyCodeLine{1512             \{}
\DoxyCodeLine{1513                 std::uint16\_t len\{\};}
\DoxyCodeLine{1514                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_msgpack\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len));}
\DoxyCodeLine{1515             \}}
\DoxyCodeLine{1516 }
\DoxyCodeLine{1517             \textcolor{keywordflow}{case} 0xDF: \textcolor{comment}{// map 32}}
\DoxyCodeLine{1518             \{}
\DoxyCodeLine{1519                 std::uint32\_t len\{\};}
\DoxyCodeLine{1520                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_msgpack\_object(conditional\_static\_cast<std::size\_t>(len));}
\DoxyCodeLine{1521             \}}
\DoxyCodeLine{1522 }
\DoxyCodeLine{1523             \textcolor{comment}{// negative fixint}}
\DoxyCodeLine{1524             \textcolor{keywordflow}{case} 0xE0:}
\DoxyCodeLine{1525             \textcolor{keywordflow}{case} 0xE1:}
\DoxyCodeLine{1526             \textcolor{keywordflow}{case} 0xE2:}
\DoxyCodeLine{1527             \textcolor{keywordflow}{case} 0xE3:}
\DoxyCodeLine{1528             \textcolor{keywordflow}{case} 0xE4:}
\DoxyCodeLine{1529             \textcolor{keywordflow}{case} 0xE5:}
\DoxyCodeLine{1530             \textcolor{keywordflow}{case} 0xE6:}
\DoxyCodeLine{1531             \textcolor{keywordflow}{case} 0xE7:}
\DoxyCodeLine{1532             \textcolor{keywordflow}{case} 0xE8:}
\DoxyCodeLine{1533             \textcolor{keywordflow}{case} 0xE9:}
\DoxyCodeLine{1534             \textcolor{keywordflow}{case} 0xEA:}
\DoxyCodeLine{1535             \textcolor{keywordflow}{case} 0xEB:}
\DoxyCodeLine{1536             \textcolor{keywordflow}{case} 0xEC:}
\DoxyCodeLine{1537             \textcolor{keywordflow}{case} 0xED:}
\DoxyCodeLine{1538             \textcolor{keywordflow}{case} 0xEE:}
\DoxyCodeLine{1539             \textcolor{keywordflow}{case} 0xEF:}
\DoxyCodeLine{1540             \textcolor{keywordflow}{case} 0xF0:}
\DoxyCodeLine{1541             \textcolor{keywordflow}{case} 0xF1:}
\DoxyCodeLine{1542             \textcolor{keywordflow}{case} 0xF2:}
\DoxyCodeLine{1543             \textcolor{keywordflow}{case} 0xF3:}
\DoxyCodeLine{1544             \textcolor{keywordflow}{case} 0xF4:}
\DoxyCodeLine{1545             \textcolor{keywordflow}{case} 0xF5:}
\DoxyCodeLine{1546             \textcolor{keywordflow}{case} 0xF6:}
\DoxyCodeLine{1547             \textcolor{keywordflow}{case} 0xF7:}
\DoxyCodeLine{1548             \textcolor{keywordflow}{case} 0xF8:}
\DoxyCodeLine{1549             \textcolor{keywordflow}{case} 0xF9:}
\DoxyCodeLine{1550             \textcolor{keywordflow}{case} 0xFA:}
\DoxyCodeLine{1551             \textcolor{keywordflow}{case} 0xFB:}
\DoxyCodeLine{1552             \textcolor{keywordflow}{case} 0xFC:}
\DoxyCodeLine{1553             \textcolor{keywordflow}{case} 0xFD:}
\DoxyCodeLine{1554             \textcolor{keywordflow}{case} 0xFE:}
\DoxyCodeLine{1555             \textcolor{keywordflow}{case} 0xFF:}
\DoxyCodeLine{1556                 \textcolor{keywordflow}{return} sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(current));}
\DoxyCodeLine{1557 }
\DoxyCodeLine{1558             \textcolor{keywordflow}{default}: \textcolor{comment}{// anything else}}
\DoxyCodeLine{1559             \{}
\DoxyCodeLine{1560                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{1561                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{1562                                         exception\_message(input\_format\_t::msgpack, concat(\textcolor{stringliteral}{"{}invalid byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{1563             \}}
\DoxyCodeLine{1564         \}}
\DoxyCodeLine{1565     \}}
\DoxyCodeLine{1566 }
\DoxyCodeLine{1577     \textcolor{keywordtype}{bool} get\_msgpack\_string(string\_t\& result)}
\DoxyCodeLine{1578     \{}
\DoxyCodeLine{1579         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::msgpack, \textcolor{stringliteral}{"{}string"{}})))}
\DoxyCodeLine{1580         \{}
\DoxyCodeLine{1581             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1582         \}}
\DoxyCodeLine{1583 }
\DoxyCodeLine{1584         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{1585         \{}
\DoxyCodeLine{1586             \textcolor{comment}{// fixstr}}
\DoxyCodeLine{1587             \textcolor{keywordflow}{case} 0xA0:}
\DoxyCodeLine{1588             \textcolor{keywordflow}{case} 0xA1:}
\DoxyCodeLine{1589             \textcolor{keywordflow}{case} 0xA2:}
\DoxyCodeLine{1590             \textcolor{keywordflow}{case} 0xA3:}
\DoxyCodeLine{1591             \textcolor{keywordflow}{case} 0xA4:}
\DoxyCodeLine{1592             \textcolor{keywordflow}{case} 0xA5:}
\DoxyCodeLine{1593             \textcolor{keywordflow}{case} 0xA6:}
\DoxyCodeLine{1594             \textcolor{keywordflow}{case} 0xA7:}
\DoxyCodeLine{1595             \textcolor{keywordflow}{case} 0xA8:}
\DoxyCodeLine{1596             \textcolor{keywordflow}{case} 0xA9:}
\DoxyCodeLine{1597             \textcolor{keywordflow}{case} 0xAA:}
\DoxyCodeLine{1598             \textcolor{keywordflow}{case} 0xAB:}
\DoxyCodeLine{1599             \textcolor{keywordflow}{case} 0xAC:}
\DoxyCodeLine{1600             \textcolor{keywordflow}{case} 0xAD:}
\DoxyCodeLine{1601             \textcolor{keywordflow}{case} 0xAE:}
\DoxyCodeLine{1602             \textcolor{keywordflow}{case} 0xAF:}
\DoxyCodeLine{1603             \textcolor{keywordflow}{case} 0xB0:}
\DoxyCodeLine{1604             \textcolor{keywordflow}{case} 0xB1:}
\DoxyCodeLine{1605             \textcolor{keywordflow}{case} 0xB2:}
\DoxyCodeLine{1606             \textcolor{keywordflow}{case} 0xB3:}
\DoxyCodeLine{1607             \textcolor{keywordflow}{case} 0xB4:}
\DoxyCodeLine{1608             \textcolor{keywordflow}{case} 0xB5:}
\DoxyCodeLine{1609             \textcolor{keywordflow}{case} 0xB6:}
\DoxyCodeLine{1610             \textcolor{keywordflow}{case} 0xB7:}
\DoxyCodeLine{1611             \textcolor{keywordflow}{case} 0xB8:}
\DoxyCodeLine{1612             \textcolor{keywordflow}{case} 0xB9:}
\DoxyCodeLine{1613             \textcolor{keywordflow}{case} 0xBA:}
\DoxyCodeLine{1614             \textcolor{keywordflow}{case} 0xBB:}
\DoxyCodeLine{1615             \textcolor{keywordflow}{case} 0xBC:}
\DoxyCodeLine{1616             \textcolor{keywordflow}{case} 0xBD:}
\DoxyCodeLine{1617             \textcolor{keywordflow}{case} 0xBE:}
\DoxyCodeLine{1618             \textcolor{keywordflow}{case} 0xBF:}
\DoxyCodeLine{1619             \{}
\DoxyCodeLine{1620                 \textcolor{keywordflow}{return} get\_string(input\_format\_t::msgpack, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu, result);}
\DoxyCodeLine{1621             \}}
\DoxyCodeLine{1622 }
\DoxyCodeLine{1623             \textcolor{keywordflow}{case} 0xD9: \textcolor{comment}{// str 8}}
\DoxyCodeLine{1624             \{}
\DoxyCodeLine{1625                 std::uint8\_t len\{\};}
\DoxyCodeLine{1626                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_string(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{1627             \}}
\DoxyCodeLine{1628 }
\DoxyCodeLine{1629             \textcolor{keywordflow}{case} 0xDA: \textcolor{comment}{// str 16}}
\DoxyCodeLine{1630             \{}
\DoxyCodeLine{1631                 std::uint16\_t len\{\};}
\DoxyCodeLine{1632                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_string(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{1633             \}}
\DoxyCodeLine{1634 }
\DoxyCodeLine{1635             \textcolor{keywordflow}{case} 0xDB: \textcolor{comment}{// str 32}}
\DoxyCodeLine{1636             \{}
\DoxyCodeLine{1637                 std::uint32\_t len\{\};}
\DoxyCodeLine{1638                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_string(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{1639             \}}
\DoxyCodeLine{1640 }
\DoxyCodeLine{1641             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1642             \{}
\DoxyCodeLine{1643                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{1644                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read,}
\DoxyCodeLine{1645                                         exception\_message(input\_format\_t::msgpack, concat(\textcolor{stringliteral}{"{}expected length specification (0xA0-\/0xBF, 0xD9-\/0xDB); last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}string"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{1646             \}}
\DoxyCodeLine{1647         \}}
\DoxyCodeLine{1648     \}}
\DoxyCodeLine{1649 }
\DoxyCodeLine{1660     \textcolor{keywordtype}{bool} get\_msgpack\_binary(binary\_t\& result)}
\DoxyCodeLine{1661     \{}
\DoxyCodeLine{1662         \textcolor{comment}{// helper function to set the subtype}}
\DoxyCodeLine{1663         \textcolor{keyword}{auto} assign\_and\_return\_true = [\&result](std::int8\_t subtype)}
\DoxyCodeLine{1664         \{}
\DoxyCodeLine{1665             result.set\_subtype(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(subtype));}
\DoxyCodeLine{1666             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1667         \};}
\DoxyCodeLine{1668 }
\DoxyCodeLine{1669         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{1670         \{}
\DoxyCodeLine{1671             \textcolor{keywordflow}{case} 0xC4: \textcolor{comment}{// bin 8}}
\DoxyCodeLine{1672             \{}
\DoxyCodeLine{1673                 std::uint8\_t len\{\};}
\DoxyCodeLine{1674                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{1675                        get\_binary(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{1676             \}}
\DoxyCodeLine{1677 }
\DoxyCodeLine{1678             \textcolor{keywordflow}{case} 0xC5: \textcolor{comment}{// bin 16}}
\DoxyCodeLine{1679             \{}
\DoxyCodeLine{1680                 std::uint16\_t len\{\};}
\DoxyCodeLine{1681                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{1682                        get\_binary(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{1683             \}}
\DoxyCodeLine{1684 }
\DoxyCodeLine{1685             \textcolor{keywordflow}{case} 0xC6: \textcolor{comment}{// bin 32}}
\DoxyCodeLine{1686             \{}
\DoxyCodeLine{1687                 std::uint32\_t len\{\};}
\DoxyCodeLine{1688                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{1689                        get\_binary(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{1690             \}}
\DoxyCodeLine{1691 }
\DoxyCodeLine{1692             \textcolor{keywordflow}{case} 0xC7: \textcolor{comment}{// ext 8}}
\DoxyCodeLine{1693             \{}
\DoxyCodeLine{1694                 std::uint8\_t len\{\};}
\DoxyCodeLine{1695                 std::int8\_t subtype\{\};}
\DoxyCodeLine{1696                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{1697                        get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{1698                        get\_binary(input\_format\_t::msgpack, len, result) \&\&}
\DoxyCodeLine{1699                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{1700             \}}
\DoxyCodeLine{1701 }
\DoxyCodeLine{1702             \textcolor{keywordflow}{case} 0xC8: \textcolor{comment}{// ext 16}}
\DoxyCodeLine{1703             \{}
\DoxyCodeLine{1704                 std::uint16\_t len\{\};}
\DoxyCodeLine{1705                 std::int8\_t subtype\{\};}
\DoxyCodeLine{1706                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{1707                        get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{1708                        get\_binary(input\_format\_t::msgpack, len, result) \&\&}
\DoxyCodeLine{1709                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{1710             \}}
\DoxyCodeLine{1711 }
\DoxyCodeLine{1712             \textcolor{keywordflow}{case} 0xC9: \textcolor{comment}{// ext 32}}
\DoxyCodeLine{1713             \{}
\DoxyCodeLine{1714                 std::uint32\_t len\{\};}
\DoxyCodeLine{1715                 std::int8\_t subtype\{\};}
\DoxyCodeLine{1716                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{1717                        get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{1718                        get\_binary(input\_format\_t::msgpack, len, result) \&\&}
\DoxyCodeLine{1719                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{1720             \}}
\DoxyCodeLine{1721 }
\DoxyCodeLine{1722             \textcolor{keywordflow}{case} 0xD4: \textcolor{comment}{// fixext 1}}
\DoxyCodeLine{1723             \{}
\DoxyCodeLine{1724                 std::int8\_t subtype\{\};}
\DoxyCodeLine{1725                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{1726                        get\_binary(input\_format\_t::msgpack, 1, result) \&\&}
\DoxyCodeLine{1727                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{1728             \}}
\DoxyCodeLine{1729 }
\DoxyCodeLine{1730             \textcolor{keywordflow}{case} 0xD5: \textcolor{comment}{// fixext 2}}
\DoxyCodeLine{1731             \{}
\DoxyCodeLine{1732                 std::int8\_t subtype\{\};}
\DoxyCodeLine{1733                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{1734                        get\_binary(input\_format\_t::msgpack, 2, result) \&\&}
\DoxyCodeLine{1735                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{1736             \}}
\DoxyCodeLine{1737 }
\DoxyCodeLine{1738             \textcolor{keywordflow}{case} 0xD6: \textcolor{comment}{// fixext 4}}
\DoxyCodeLine{1739             \{}
\DoxyCodeLine{1740                 std::int8\_t subtype\{\};}
\DoxyCodeLine{1741                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{1742                        get\_binary(input\_format\_t::msgpack, 4, result) \&\&}
\DoxyCodeLine{1743                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{1744             \}}
\DoxyCodeLine{1745 }
\DoxyCodeLine{1746             \textcolor{keywordflow}{case} 0xD7: \textcolor{comment}{// fixext 8}}
\DoxyCodeLine{1747             \{}
\DoxyCodeLine{1748                 std::int8\_t subtype\{\};}
\DoxyCodeLine{1749                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{1750                        get\_binary(input\_format\_t::msgpack, 8, result) \&\&}
\DoxyCodeLine{1751                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{1752             \}}
\DoxyCodeLine{1753 }
\DoxyCodeLine{1754             \textcolor{keywordflow}{case} 0xD8: \textcolor{comment}{// fixext 16}}
\DoxyCodeLine{1755             \{}
\DoxyCodeLine{1756                 std::int8\_t subtype\{\};}
\DoxyCodeLine{1757                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{1758                        get\_binary(input\_format\_t::msgpack, 16, result) \&\&}
\DoxyCodeLine{1759                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{1760             \}}
\DoxyCodeLine{1761 }
\DoxyCodeLine{1762             \textcolor{keywordflow}{default}:           \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{1763                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};  \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{1764         \}}
\DoxyCodeLine{1765     \}}
\DoxyCodeLine{1766 }
\DoxyCodeLine{1771     \textcolor{keywordtype}{bool} get\_msgpack\_array(\textcolor{keyword}{const} std::size\_t len)}
\DoxyCodeLine{1772     \{}
\DoxyCodeLine{1773         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(len)))}
\DoxyCodeLine{1774         \{}
\DoxyCodeLine{1775             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1776         \}}
\DoxyCodeLine{1777 }
\DoxyCodeLine{1778         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < len; ++i)}
\DoxyCodeLine{1779         \{}
\DoxyCodeLine{1780             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_msgpack\_internal()))}
\DoxyCodeLine{1781             \{}
\DoxyCodeLine{1782                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1783             \}}
\DoxyCodeLine{1784         \}}
\DoxyCodeLine{1785 }
\DoxyCodeLine{1786         \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{1787     \}}
\DoxyCodeLine{1788 }
\DoxyCodeLine{1793     \textcolor{keywordtype}{bool} get\_msgpack\_object(\textcolor{keyword}{const} std::size\_t len)}
\DoxyCodeLine{1794     \{}
\DoxyCodeLine{1795         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(len)))}
\DoxyCodeLine{1796         \{}
\DoxyCodeLine{1797             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1798         \}}
\DoxyCodeLine{1799 }
\DoxyCodeLine{1800         string\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}};}
\DoxyCodeLine{1801         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < len; ++i)}
\DoxyCodeLine{1802         \{}
\DoxyCodeLine{1803             get();}
\DoxyCodeLine{1804             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_msgpack\_string(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}) || !sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}})))}
\DoxyCodeLine{1805             \{}
\DoxyCodeLine{1806                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1807             \}}
\DoxyCodeLine{1808 }
\DoxyCodeLine{1809             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_msgpack\_internal()))}
\DoxyCodeLine{1810             \{}
\DoxyCodeLine{1811                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1812             \}}
\DoxyCodeLine{1813             \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}.clear();}
\DoxyCodeLine{1814         \}}
\DoxyCodeLine{1815 }
\DoxyCodeLine{1816         \textcolor{keywordflow}{return} sax-\/>end\_object();}
\DoxyCodeLine{1817     \}}
\DoxyCodeLine{1818 }
\DoxyCodeLine{1820     \textcolor{comment}{// UBJSON //}}
\DoxyCodeLine{1822 \textcolor{comment}{}}
\DoxyCodeLine{1830     \textcolor{keywordtype}{bool} parse\_ubjson\_internal(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} get\_char = \textcolor{keyword}{true})}
\DoxyCodeLine{1831     \{}
\DoxyCodeLine{1832         \textcolor{keywordflow}{return} get\_ubjson\_value(get\_char ? get\_ignore\_noop() : current);}
\DoxyCodeLine{1833     \}}
\DoxyCodeLine{1834 }
\DoxyCodeLine{1849     \textcolor{keywordtype}{bool} get\_ubjson\_string(string\_t\& result, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} get\_char = \textcolor{keyword}{true})}
\DoxyCodeLine{1850     \{}
\DoxyCodeLine{1851         \textcolor{keywordflow}{if} (get\_char)}
\DoxyCodeLine{1852         \{}
\DoxyCodeLine{1853             get();  \textcolor{comment}{// TODO(niels): may we ignore N here?}}
\DoxyCodeLine{1854         \}}
\DoxyCodeLine{1855 }
\DoxyCodeLine{1856         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}value"{}})))}
\DoxyCodeLine{1857         \{}
\DoxyCodeLine{1858             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1859         \}}
\DoxyCodeLine{1860 }
\DoxyCodeLine{1861         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{1862         \{}
\DoxyCodeLine{1863             \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{1864             \{}
\DoxyCodeLine{1865                 std::uint8\_t len\{\};}
\DoxyCodeLine{1866                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{1867             \}}
\DoxyCodeLine{1868 }
\DoxyCodeLine{1869             \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}:}
\DoxyCodeLine{1870             \{}
\DoxyCodeLine{1871                 std::int8\_t len\{\};}
\DoxyCodeLine{1872                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{1873             \}}
\DoxyCodeLine{1874 }
\DoxyCodeLine{1875             \textcolor{keywordflow}{case} \textcolor{charliteral}{'I'}:}
\DoxyCodeLine{1876             \{}
\DoxyCodeLine{1877                 std::int16\_t len\{\};}
\DoxyCodeLine{1878                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{1879             \}}
\DoxyCodeLine{1880 }
\DoxyCodeLine{1881             \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:}
\DoxyCodeLine{1882             \{}
\DoxyCodeLine{1883                 std::int32\_t len\{\};}
\DoxyCodeLine{1884                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{1885             \}}
\DoxyCodeLine{1886 }
\DoxyCodeLine{1887             \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{1888             \{}
\DoxyCodeLine{1889                 std::int64\_t len\{\};}
\DoxyCodeLine{1890                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{1891             \}}
\DoxyCodeLine{1892 }
\DoxyCodeLine{1893             \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{1894             \{}
\DoxyCodeLine{1895                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{1896                 \{}
\DoxyCodeLine{1897                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1898                 \}}
\DoxyCodeLine{1899                 std::uint16\_t len\{\};}
\DoxyCodeLine{1900                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{1901             \}}
\DoxyCodeLine{1902 }
\DoxyCodeLine{1903             \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}:}
\DoxyCodeLine{1904             \{}
\DoxyCodeLine{1905                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{1906                 \{}
\DoxyCodeLine{1907                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1908                 \}}
\DoxyCodeLine{1909                 std::uint32\_t len\{\};}
\DoxyCodeLine{1910                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{1911             \}}
\DoxyCodeLine{1912 }
\DoxyCodeLine{1913             \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:}
\DoxyCodeLine{1914             \{}
\DoxyCodeLine{1915                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{1916                 \{}
\DoxyCodeLine{1917                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1918                 \}}
\DoxyCodeLine{1919                 std::uint64\_t len\{\};}
\DoxyCodeLine{1920                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{1921             \}}
\DoxyCodeLine{1922 }
\DoxyCodeLine{1923             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1924                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{1925         \}}
\DoxyCodeLine{1926         \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{1927         std::string message;}
\DoxyCodeLine{1928 }
\DoxyCodeLine{1929         \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{1930         \{}
\DoxyCodeLine{1931             message = \textcolor{stringliteral}{"{}expected length type specification (U, i, I, l, L); last byte: 0x"{}} + last\_token;}
\DoxyCodeLine{1932         \}}
\DoxyCodeLine{1933         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1934         \{}
\DoxyCodeLine{1935             message = \textcolor{stringliteral}{"{}expected length type specification (U, i, u, I, m, l, M, L); last byte: 0x"{}} + last\_token;}
\DoxyCodeLine{1936         \}}
\DoxyCodeLine{1937         \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read, exception\_message(input\_format, message, \textcolor{stringliteral}{"{}string"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{1938     \}}
\DoxyCodeLine{1939 }
\DoxyCodeLine{1944     \textcolor{keywordtype}{bool} get\_ubjson\_ndarray\_size(std::vector<size\_t>\& dim)}
\DoxyCodeLine{1945     \{}
\DoxyCodeLine{1946         std::pair<std::size\_t, char\_int\_type> size\_and\_type;}
\DoxyCodeLine{1947         \textcolor{keywordtype}{size\_t} dimlen = 0;}
\DoxyCodeLine{1948         \textcolor{keywordtype}{bool} no\_ndarray = \textcolor{keyword}{true};}
\DoxyCodeLine{1949 }
\DoxyCodeLine{1950         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_type(size\_and\_type, no\_ndarray)))}
\DoxyCodeLine{1951         \{}
\DoxyCodeLine{1952             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1953         \}}
\DoxyCodeLine{1954 }
\DoxyCodeLine{1955         \textcolor{keywordflow}{if} (size\_and\_type.first != npos)}
\DoxyCodeLine{1956         \{}
\DoxyCodeLine{1957             \textcolor{keywordflow}{if} (size\_and\_type.second != 0)}
\DoxyCodeLine{1958             \{}
\DoxyCodeLine{1959                 \textcolor{keywordflow}{if} (size\_and\_type.second != \textcolor{charliteral}{'N'})}
\DoxyCodeLine{1960                 \{}
\DoxyCodeLine{1961                     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{1962                     \{}
\DoxyCodeLine{1963                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_value(dimlen, no\_ndarray, size\_and\_type.second)))}
\DoxyCodeLine{1964                         \{}
\DoxyCodeLine{1965                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1966                         \}}
\DoxyCodeLine{1967                         dim.push\_back(dimlen);}
\DoxyCodeLine{1968                     \}}
\DoxyCodeLine{1969                 \}}
\DoxyCodeLine{1970             \}}
\DoxyCodeLine{1971             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1972             \{}
\DoxyCodeLine{1973                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{1974                 \{}
\DoxyCodeLine{1975                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_value(dimlen, no\_ndarray)))}
\DoxyCodeLine{1976                     \{}
\DoxyCodeLine{1977                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1978                     \}}
\DoxyCodeLine{1979                     dim.push\_back(dimlen);}
\DoxyCodeLine{1980                 \}}
\DoxyCodeLine{1981             \}}
\DoxyCodeLine{1982         \}}
\DoxyCodeLine{1983         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1984         \{}
\DoxyCodeLine{1985             \textcolor{keywordflow}{while} (current != \textcolor{charliteral}{']'})}
\DoxyCodeLine{1986             \{}
\DoxyCodeLine{1987                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_value(dimlen, no\_ndarray, current)))}
\DoxyCodeLine{1988                 \{}
\DoxyCodeLine{1989                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1990                 \}}
\DoxyCodeLine{1991                 dim.push\_back(dimlen);}
\DoxyCodeLine{1992                 get\_ignore\_noop();}
\DoxyCodeLine{1993             \}}
\DoxyCodeLine{1994         \}}
\DoxyCodeLine{1995         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1996     \}}
\DoxyCodeLine{1997 }
\DoxyCodeLine{2009     \textcolor{keywordtype}{bool} get\_ubjson\_size\_value(std::size\_t\& result, \textcolor{keywordtype}{bool}\& is\_ndarray, char\_int\_type prefix = 0)}
\DoxyCodeLine{2010     \{}
\DoxyCodeLine{2011         \textcolor{keywordflow}{if} (prefix == 0)}
\DoxyCodeLine{2012         \{}
\DoxyCodeLine{2013             prefix = get\_ignore\_noop();}
\DoxyCodeLine{2014         \}}
\DoxyCodeLine{2015 }
\DoxyCodeLine{2016         \textcolor{keywordflow}{switch} (prefix)}
\DoxyCodeLine{2017         \{}
\DoxyCodeLine{2018             \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{2019             \{}
\DoxyCodeLine{2020                 std::uint8\_t number\{\};}
\DoxyCodeLine{2021                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{2022                 \{}
\DoxyCodeLine{2023                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2024                 \}}
\DoxyCodeLine{2025                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{2026                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2027             \}}
\DoxyCodeLine{2028 }
\DoxyCodeLine{2029             \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}:}
\DoxyCodeLine{2030             \{}
\DoxyCodeLine{2031                 std::int8\_t number\{\};}
\DoxyCodeLine{2032                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{2033                 \{}
\DoxyCodeLine{2034                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2035                 \}}
\DoxyCodeLine{2036                 \textcolor{keywordflow}{if} (number < 0)}
\DoxyCodeLine{2037                 \{}
\DoxyCodeLine{2038                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read,}
\DoxyCodeLine{2039                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}count in an optimized container must be positive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2040                 \}}
\DoxyCodeLine{2041                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number); \textcolor{comment}{// NOLINT(bugprone-\/signed-\/char-\/misuse,cert-\/str34-\/c): number is not a char}}
\DoxyCodeLine{2042                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2043             \}}
\DoxyCodeLine{2044 }
\DoxyCodeLine{2045             \textcolor{keywordflow}{case} \textcolor{charliteral}{'I'}:}
\DoxyCodeLine{2046             \{}
\DoxyCodeLine{2047                 std::int16\_t number\{\};}
\DoxyCodeLine{2048                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{2049                 \{}
\DoxyCodeLine{2050                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2051                 \}}
\DoxyCodeLine{2052                 \textcolor{keywordflow}{if} (number < 0)}
\DoxyCodeLine{2053                 \{}
\DoxyCodeLine{2054                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read,}
\DoxyCodeLine{2055                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}count in an optimized container must be positive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2056                 \}}
\DoxyCodeLine{2057                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{2058                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2059             \}}
\DoxyCodeLine{2060 }
\DoxyCodeLine{2061             \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:}
\DoxyCodeLine{2062             \{}
\DoxyCodeLine{2063                 std::int32\_t number\{\};}
\DoxyCodeLine{2064                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{2065                 \{}
\DoxyCodeLine{2066                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2067                 \}}
\DoxyCodeLine{2068                 \textcolor{keywordflow}{if} (number < 0)}
\DoxyCodeLine{2069                 \{}
\DoxyCodeLine{2070                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read,}
\DoxyCodeLine{2071                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}count in an optimized container must be positive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2072                 \}}
\DoxyCodeLine{2073                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{2074                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2075             \}}
\DoxyCodeLine{2076 }
\DoxyCodeLine{2077             \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{2078             \{}
\DoxyCodeLine{2079                 std::int64\_t number\{\};}
\DoxyCodeLine{2080                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{2081                 \{}
\DoxyCodeLine{2082                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2083                 \}}
\DoxyCodeLine{2084                 \textcolor{keywordflow}{if} (number < 0)}
\DoxyCodeLine{2085                 \{}
\DoxyCodeLine{2086                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read,}
\DoxyCodeLine{2087                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}count in an optimized container must be positive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2088                 \}}
\DoxyCodeLine{2089                 \textcolor{keywordflow}{if} (!value\_in\_range\_of<std::size\_t>(number))}
\DoxyCodeLine{2090                 \{}
\DoxyCodeLine{2091                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), out\_of\_range::create(408,}
\DoxyCodeLine{2092                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}integer value overflow"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2093                 \}}
\DoxyCodeLine{2094                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{2095                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2096             \}}
\DoxyCodeLine{2097 }
\DoxyCodeLine{2098             \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{2099             \{}
\DoxyCodeLine{2100                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2101                 \{}
\DoxyCodeLine{2102                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2103                 \}}
\DoxyCodeLine{2104                 std::uint16\_t number\{\};}
\DoxyCodeLine{2105                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{2106                 \{}
\DoxyCodeLine{2107                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2108                 \}}
\DoxyCodeLine{2109                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{2110                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2111             \}}
\DoxyCodeLine{2112 }
\DoxyCodeLine{2113             \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}:}
\DoxyCodeLine{2114             \{}
\DoxyCodeLine{2115                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2116                 \{}
\DoxyCodeLine{2117                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2118                 \}}
\DoxyCodeLine{2119                 std::uint32\_t number\{\};}
\DoxyCodeLine{2120                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{2121                 \{}
\DoxyCodeLine{2122                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2123                 \}}
\DoxyCodeLine{2124                 result = conditional\_static\_cast<std::size\_t>(number);}
\DoxyCodeLine{2125                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2126             \}}
\DoxyCodeLine{2127 }
\DoxyCodeLine{2128             \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:}
\DoxyCodeLine{2129             \{}
\DoxyCodeLine{2130                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2131                 \{}
\DoxyCodeLine{2132                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2133                 \}}
\DoxyCodeLine{2134                 std::uint64\_t number\{\};}
\DoxyCodeLine{2135                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{2136                 \{}
\DoxyCodeLine{2137                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2138                 \}}
\DoxyCodeLine{2139                 \textcolor{keywordflow}{if} (!value\_in\_range\_of<std::size\_t>(number))}
\DoxyCodeLine{2140                 \{}
\DoxyCodeLine{2141                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), out\_of\_range::create(408,}
\DoxyCodeLine{2142                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}integer value overflow"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2143                 \}}
\DoxyCodeLine{2144                 result = detail::conditional\_static\_cast<std::size\_t>(number);}
\DoxyCodeLine{2145                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2146             \}}
\DoxyCodeLine{2147 }
\DoxyCodeLine{2148             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{2149             \{}
\DoxyCodeLine{2150                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2151                 \{}
\DoxyCodeLine{2152                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2153                 \}}
\DoxyCodeLine{2154                 \textcolor{keywordflow}{if} (is\_ndarray) \textcolor{comment}{// ndarray dimensional vector can only contain integers, and can not embed another array}}
\DoxyCodeLine{2155                 \{}
\DoxyCodeLine{2156                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read, exception\_message(input\_format, \textcolor{stringliteral}{"{}ndarray dimentional vector is not allowed"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2157                 \}}
\DoxyCodeLine{2158                 std::vector<size\_t> dim;}
\DoxyCodeLine{2159                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_ndarray\_size(dim)))}
\DoxyCodeLine{2160                 \{}
\DoxyCodeLine{2161                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2162                 \}}
\DoxyCodeLine{2163                 \textcolor{keywordflow}{if} (dim.size() == 1 || (dim.size() == 2 \&\& dim.at(0) == 1)) \textcolor{comment}{// return normal array size if 1D row vector}}
\DoxyCodeLine{2164                 \{}
\DoxyCodeLine{2165                     result = dim.at(dim.size() -\/ 1);}
\DoxyCodeLine{2166                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2167                 \}}
\DoxyCodeLine{2168                 \textcolor{keywordflow}{if} (!dim.empty())  \textcolor{comment}{// if ndarray, convert to an object in JData annotated array format}}
\DoxyCodeLine{2169                 \{}
\DoxyCodeLine{2170                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i : dim) \textcolor{comment}{// test if any dimension in an ndarray is 0, if so, return a 1D empty container}}
\DoxyCodeLine{2171                     \{}
\DoxyCodeLine{2172                         \textcolor{keywordflow}{if} ( i == 0 )}
\DoxyCodeLine{2173                         \{}
\DoxyCodeLine{2174                             result = 0;}
\DoxyCodeLine{2175                             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2176                         \}}
\DoxyCodeLine{2177                     \}}
\DoxyCodeLine{2178 }
\DoxyCodeLine{2179                     string\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}} = \textcolor{stringliteral}{"{}\_ArraySize\_"{}};}
\DoxyCodeLine{2180                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(3) || !sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}) || !sax-\/>start\_array(dim.size())))}
\DoxyCodeLine{2181                     \{}
\DoxyCodeLine{2182                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2183                     \}}
\DoxyCodeLine{2184                     result = 1;}
\DoxyCodeLine{2185                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i : dim)}
\DoxyCodeLine{2186                     \{}
\DoxyCodeLine{2187                         result *= i;}
\DoxyCodeLine{2188                         \textcolor{keywordflow}{if} (result == 0 || result == npos) \textcolor{comment}{// because dim elements shall not have zeros, result = 0 means overflow happened; it also can't be npos as it is used to initialize size in get\_ubjson\_size\_type()}}
\DoxyCodeLine{2189                         \{}
\DoxyCodeLine{2190                             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), out\_of\_range::create(408, exception\_message(input\_format, \textcolor{stringliteral}{"{}excessive ndarray size caused overflow"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2191                         \}}
\DoxyCodeLine{2192                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>number\_unsigned(\textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(i))))}
\DoxyCodeLine{2193                         \{}
\DoxyCodeLine{2194                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2195                         \}}
\DoxyCodeLine{2196                     \}}
\DoxyCodeLine{2197                     is\_ndarray = \textcolor{keyword}{true};}
\DoxyCodeLine{2198                     \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{2199                 \}}
\DoxyCodeLine{2200                 result = 0;}
\DoxyCodeLine{2201                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2202             \}}
\DoxyCodeLine{2203 }
\DoxyCodeLine{2204             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2205                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2206         \}}
\DoxyCodeLine{2207         \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{2208         std::string message;}
\DoxyCodeLine{2209 }
\DoxyCodeLine{2210         \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2211         \{}
\DoxyCodeLine{2212             message = \textcolor{stringliteral}{"{}expected length type specification (U, i, I, l, L) after '\#'; last byte: 0x"{}} + last\_token;}
\DoxyCodeLine{2213         \}}
\DoxyCodeLine{2214         \textcolor{keywordflow}{else}}
\DoxyCodeLine{2215         \{}
\DoxyCodeLine{2216             message = \textcolor{stringliteral}{"{}expected length type specification (U, i, u, I, m, l, M, L) after '\#'; last byte: 0x"{}} + last\_token;}
\DoxyCodeLine{2217         \}}
\DoxyCodeLine{2218         \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read, exception\_message(input\_format, message, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2219     \}}
\DoxyCodeLine{2220 }
\DoxyCodeLine{2232     \textcolor{keywordtype}{bool} get\_ubjson\_size\_type(std::pair<std::size\_t, char\_int\_type>\& result, \textcolor{keywordtype}{bool} inside\_ndarray = \textcolor{keyword}{false})}
\DoxyCodeLine{2233     \{}
\DoxyCodeLine{2234         result.first = npos; \textcolor{comment}{// size}}
\DoxyCodeLine{2235         result.second = 0; \textcolor{comment}{// type}}
\DoxyCodeLine{2236         \textcolor{keywordtype}{bool} is\_ndarray = \textcolor{keyword}{false};}
\DoxyCodeLine{2237 }
\DoxyCodeLine{2238         get\_ignore\_noop();}
\DoxyCodeLine{2239 }
\DoxyCodeLine{2240         \textcolor{keywordflow}{if} (current == \textcolor{charliteral}{'\$'})}
\DoxyCodeLine{2241         \{}
\DoxyCodeLine{2242             result.second = get();  \textcolor{comment}{// must not ignore 'N', because 'N' maybe the type}}
\DoxyCodeLine{2243             \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata}
\DoxyCodeLine{2244                     \&\& JSON\_HEDLEY\_UNLIKELY(std::binary\_search(bjd\_optimized\_type\_markers.begin(), bjd\_optimized\_type\_markers.end(), result.second)))}
\DoxyCodeLine{2245             \{}
\DoxyCodeLine{2246                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{2247                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{2248                                         exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}marker 0x"{}}, last\_token, \textcolor{stringliteral}{"{} is not a permitted optimized array type"{}}), \textcolor{stringliteral}{"{}type"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2249             \}}
\DoxyCodeLine{2250 }
\DoxyCodeLine{2251             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}type"{}})))}
\DoxyCodeLine{2252             \{}
\DoxyCodeLine{2253                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2254             \}}
\DoxyCodeLine{2255 }
\DoxyCodeLine{2256             get\_ignore\_noop();}
\DoxyCodeLine{2257             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(current != \textcolor{charliteral}{'\#'}))}
\DoxyCodeLine{2258             \{}
\DoxyCodeLine{2259                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}value"{}})))}
\DoxyCodeLine{2260                 \{}
\DoxyCodeLine{2261                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2262                 \}}
\DoxyCodeLine{2263                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{2264                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{2265                                         exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}expected '\#' after type information; last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2266             \}}
\DoxyCodeLine{2267 }
\DoxyCodeLine{2268             \textcolor{keywordtype}{bool} is\_error = get\_ubjson\_size\_value(result.first, is\_ndarray);}
\DoxyCodeLine{2269             \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata \&\& is\_ndarray)}
\DoxyCodeLine{2270             \{}
\DoxyCodeLine{2271                 \textcolor{keywordflow}{if} (inside\_ndarray)}
\DoxyCodeLine{2272                 \{}
\DoxyCodeLine{2273                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{2274                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}ndarray can not be recursive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2275                 \}}
\DoxyCodeLine{2276                 result.second |= (1 << 8); \textcolor{comment}{// use bit 8 to indicate ndarray, all UBJSON and BJData markers should be ASCII letters}}
\DoxyCodeLine{2277             \}}
\DoxyCodeLine{2278             \textcolor{keywordflow}{return} is\_error;}
\DoxyCodeLine{2279         \}}
\DoxyCodeLine{2280 }
\DoxyCodeLine{2281         \textcolor{keywordflow}{if} (current == \textcolor{charliteral}{'\#'})}
\DoxyCodeLine{2282         \{}
\DoxyCodeLine{2283             \textcolor{keywordtype}{bool} is\_error = get\_ubjson\_size\_value(result.first, is\_ndarray);}
\DoxyCodeLine{2284             \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata \&\& is\_ndarray)}
\DoxyCodeLine{2285             \{}
\DoxyCodeLine{2286                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{2287                                         exception\_message(input\_format, \textcolor{stringliteral}{"{}ndarray requires both type and size"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2288             \}}
\DoxyCodeLine{2289             \textcolor{keywordflow}{return} is\_error;}
\DoxyCodeLine{2290         \}}
\DoxyCodeLine{2291 }
\DoxyCodeLine{2292         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2293     \}}
\DoxyCodeLine{2294 }
\DoxyCodeLine{2299     \textcolor{keywordtype}{bool} get\_ubjson\_value(\textcolor{keyword}{const} char\_int\_type prefix)}
\DoxyCodeLine{2300     \{}
\DoxyCodeLine{2301         \textcolor{keywordflow}{switch} (prefix)}
\DoxyCodeLine{2302         \{}
\DoxyCodeLine{2303             \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():  \textcolor{comment}{// EOF}}
\DoxyCodeLine{2304                 return unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}value"{}});}
\DoxyCodeLine{2305 }
\DoxyCodeLine{2306             \textcolor{keywordflow}{case} \textcolor{charliteral}{'T'}:  \textcolor{comment}{// true}}
\DoxyCodeLine{2307                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{true});}
\DoxyCodeLine{2308             \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}:  \textcolor{comment}{// false}}
\DoxyCodeLine{2309                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{false});}
\DoxyCodeLine{2310 }
\DoxyCodeLine{2311             \textcolor{keywordflow}{case} \textcolor{charliteral}{'Z'}:  \textcolor{comment}{// null}}
\DoxyCodeLine{2312                 \textcolor{keywordflow}{return} sax-\/>null();}
\DoxyCodeLine{2313 }
\DoxyCodeLine{2314             \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{2315             \{}
\DoxyCodeLine{2316                 std::uint8\_t number\{\};}
\DoxyCodeLine{2317                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{2318             \}}
\DoxyCodeLine{2319 }
\DoxyCodeLine{2320             \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}:}
\DoxyCodeLine{2321             \{}
\DoxyCodeLine{2322                 std::int8\_t number\{\};}
\DoxyCodeLine{2323                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{2324             \}}
\DoxyCodeLine{2325 }
\DoxyCodeLine{2326             \textcolor{keywordflow}{case} \textcolor{charliteral}{'I'}:}
\DoxyCodeLine{2327             \{}
\DoxyCodeLine{2328                 std::int16\_t number\{\};}
\DoxyCodeLine{2329                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{2330             \}}
\DoxyCodeLine{2331 }
\DoxyCodeLine{2332             \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:}
\DoxyCodeLine{2333             \{}
\DoxyCodeLine{2334                 std::int32\_t number\{\};}
\DoxyCodeLine{2335                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{2336             \}}
\DoxyCodeLine{2337 }
\DoxyCodeLine{2338             \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{2339             \{}
\DoxyCodeLine{2340                 std::int64\_t number\{\};}
\DoxyCodeLine{2341                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{2342             \}}
\DoxyCodeLine{2343 }
\DoxyCodeLine{2344             \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{2345             \{}
\DoxyCodeLine{2346                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2347                 \{}
\DoxyCodeLine{2348                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2349                 \}}
\DoxyCodeLine{2350                 std::uint16\_t number\{\};}
\DoxyCodeLine{2351                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{2352             \}}
\DoxyCodeLine{2353 }
\DoxyCodeLine{2354             \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}:}
\DoxyCodeLine{2355             \{}
\DoxyCodeLine{2356                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2357                 \{}
\DoxyCodeLine{2358                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2359                 \}}
\DoxyCodeLine{2360                 std::uint32\_t number\{\};}
\DoxyCodeLine{2361                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{2362             \}}
\DoxyCodeLine{2363 }
\DoxyCodeLine{2364             \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:}
\DoxyCodeLine{2365             \{}
\DoxyCodeLine{2366                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2367                 \{}
\DoxyCodeLine{2368                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2369                 \}}
\DoxyCodeLine{2370                 std::uint64\_t number\{\};}
\DoxyCodeLine{2371                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{2372             \}}
\DoxyCodeLine{2373 }
\DoxyCodeLine{2374             \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}:}
\DoxyCodeLine{2375             \{}
\DoxyCodeLine{2376                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{2377                 \{}
\DoxyCodeLine{2378                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2379                 \}}
\DoxyCodeLine{2380                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte1\_raw = get();}
\DoxyCodeLine{2381                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{2382                 \{}
\DoxyCodeLine{2383                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2384                 \}}
\DoxyCodeLine{2385                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte2\_raw = get();}
\DoxyCodeLine{2386                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{2387                 \{}
\DoxyCodeLine{2388                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2389                 \}}
\DoxyCodeLine{2390 }
\DoxyCodeLine{2391                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte1 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(byte1\_raw);}
\DoxyCodeLine{2392                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(byte2\_raw);}
\DoxyCodeLine{2393 }
\DoxyCodeLine{2394                 \textcolor{comment}{// code from RFC 7049, Appendix D, Figure 3:}}
\DoxyCodeLine{2395                 \textcolor{comment}{// As half-\/precision floating-\/point numbers were only added}}
\DoxyCodeLine{2396                 \textcolor{comment}{// to IEEE 754 in 2008, today's programming platforms often}}
\DoxyCodeLine{2397                 \textcolor{comment}{// still only have limited support for them. It is very}}
\DoxyCodeLine{2398                 \textcolor{comment}{// easy to include at least decoding support for them even}}
\DoxyCodeLine{2399                 \textcolor{comment}{// without such support. An example of a small decoder for}}
\DoxyCodeLine{2400                 \textcolor{comment}{// half-\/precision floating-\/point numbers in the C language}}
\DoxyCodeLine{2401                 \textcolor{comment}{// is shown in Fig. 3.}}
\DoxyCodeLine{2402                 \textcolor{keyword}{const} \textcolor{keyword}{auto} half = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}((byte2 << 8u) + byte1);}
\DoxyCodeLine{2403                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} val = [\&half]}
\DoxyCodeLine{2404                 \{}
\DoxyCodeLine{2405                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} exp = (half >> 10u) \& 0x1Fu;}
\DoxyCodeLine{2406                     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mant = half \& 0x3FFu;}
\DoxyCodeLine{2407                     JSON\_ASSERT(0 <= exp\&\& exp <= 32);}
\DoxyCodeLine{2408                     JSON\_ASSERT(mant <= 1024);}
\DoxyCodeLine{2409                     \textcolor{keywordflow}{switch} (exp)}
\DoxyCodeLine{2410                     \{}
\DoxyCodeLine{2411                         \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{2412                             \textcolor{keywordflow}{return} std::ldexp(mant, -\/24);}
\DoxyCodeLine{2413                         \textcolor{keywordflow}{case} 31:}
\DoxyCodeLine{2414                             \textcolor{keywordflow}{return} (mant == 0)}
\DoxyCodeLine{2415                             ? std::numeric\_limits<double>::infinity()}
\DoxyCodeLine{2416                             : std::numeric\_limits<double>::quiet\_NaN();}
\DoxyCodeLine{2417                         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2418                             \textcolor{keywordflow}{return} std::ldexp(mant + 1024, exp -\/ 25);}
\DoxyCodeLine{2419                     \}}
\DoxyCodeLine{2420                 \}();}
\DoxyCodeLine{2421                 \textcolor{keywordflow}{return} sax-\/>number\_float((half \& 0x8000u) != 0}
\DoxyCodeLine{2422                                          ? \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(-\/val)}
\DoxyCodeLine{2423                                          : \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(val), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2424             \}}
\DoxyCodeLine{2425 }
\DoxyCodeLine{2426             \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}:}
\DoxyCodeLine{2427             \{}
\DoxyCodeLine{2428                 \textcolor{keywordtype}{float} number\{\};}
\DoxyCodeLine{2429                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2430             \}}
\DoxyCodeLine{2431 }
\DoxyCodeLine{2432             \textcolor{keywordflow}{case} \textcolor{charliteral}{'D'}:}
\DoxyCodeLine{2433             \{}
\DoxyCodeLine{2434                 \textcolor{keywordtype}{double} number\{\};}
\DoxyCodeLine{2435                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2436             \}}
\DoxyCodeLine{2437 }
\DoxyCodeLine{2438             \textcolor{keywordflow}{case} \textcolor{charliteral}{'H'}:}
\DoxyCodeLine{2439             \{}
\DoxyCodeLine{2440                 \textcolor{keywordflow}{return} get\_ubjson\_high\_precision\_number();}
\DoxyCodeLine{2441             \}}
\DoxyCodeLine{2442 }
\DoxyCodeLine{2443             \textcolor{keywordflow}{case} \textcolor{charliteral}{'C'}:  \textcolor{comment}{// char}}
\DoxyCodeLine{2444             \{}
\DoxyCodeLine{2445                 get();}
\DoxyCodeLine{2446                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}char"{}})))}
\DoxyCodeLine{2447                 \{}
\DoxyCodeLine{2448                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2449                 \}}
\DoxyCodeLine{2450                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(current > 127))}
\DoxyCodeLine{2451                 \{}
\DoxyCodeLine{2452                     \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{2453                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(113, chars\_read,}
\DoxyCodeLine{2454                                             exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}byte after 'C' must be in range 0x00..0x7F; last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}char"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2455                 \}}
\DoxyCodeLine{2456                 string\_t s(1, \textcolor{keyword}{static\_cast<}typename string\_t::value\_type\textcolor{keyword}{>}(current));}
\DoxyCodeLine{2457                 \textcolor{keywordflow}{return} sax-\/>string(s);}
\DoxyCodeLine{2458             \}}
\DoxyCodeLine{2459 }
\DoxyCodeLine{2460             \textcolor{keywordflow}{case} \textcolor{charliteral}{'S'}:  \textcolor{comment}{// string}}
\DoxyCodeLine{2461             \{}
\DoxyCodeLine{2462                 string\_t s;}
\DoxyCodeLine{2463                 \textcolor{keywordflow}{return} get\_ubjson\_string(s) \&\& sax-\/>string(s);}
\DoxyCodeLine{2464             \}}
\DoxyCodeLine{2465 }
\DoxyCodeLine{2466             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:  \textcolor{comment}{// array}}
\DoxyCodeLine{2467                 \textcolor{keywordflow}{return} get\_ubjson\_array();}
\DoxyCodeLine{2468 }
\DoxyCodeLine{2469             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}:  \textcolor{comment}{// object}}
\DoxyCodeLine{2470                 \textcolor{keywordflow}{return} get\_ubjson\_object();}
\DoxyCodeLine{2471 }
\DoxyCodeLine{2472             \textcolor{keywordflow}{default}: \textcolor{comment}{// anything else}}
\DoxyCodeLine{2473                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2474         \}}
\DoxyCodeLine{2475         \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{2476         \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read, exception\_message(input\_format, \textcolor{stringliteral}{"{}invalid byte: 0x"{}} + last\_token, \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2477     \}}
\DoxyCodeLine{2478 }
\DoxyCodeLine{2482     \textcolor{keywordtype}{bool} get\_ubjson\_array()}
\DoxyCodeLine{2483     \{}
\DoxyCodeLine{2484         std::pair<std::size\_t, char\_int\_type> size\_and\_type;}
\DoxyCodeLine{2485         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_type(size\_and\_type)))}
\DoxyCodeLine{2486         \{}
\DoxyCodeLine{2487             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2488         \}}
\DoxyCodeLine{2489 }
\DoxyCodeLine{2490         \textcolor{comment}{// if bit-\/8 of size\_and\_type.second is set to 1, encode bjdata ndarray as an object in JData annotated array format (https://github.com/NeuroJSON/jdata):}}
\DoxyCodeLine{2491         \textcolor{comment}{// \{"{}\_ArrayType\_"{} : "{}typeid"{}, "{}\_ArraySize\_"{} : [n1, n2, ...], "{}\_ArrayData\_"{} : [v1, v2, ...]\}}}
\DoxyCodeLine{2492 }
\DoxyCodeLine{2493         \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata \&\& size\_and\_type.first != npos \&\& (size\_and\_type.second \& (1 << 8)) != 0)}
\DoxyCodeLine{2494         \{}
\DoxyCodeLine{2495             size\_and\_type.second \&= \string~(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(1) << 8);  \textcolor{comment}{// use bit 8 to indicate ndarray, here we remove the bit to restore the type marker}}
\DoxyCodeLine{2496             \textcolor{keyword}{auto} it = std::lower\_bound(bjd\_types\_map.begin(), bjd\_types\_map.end(), size\_and\_type.second, [](\textcolor{keyword}{const} bjd\_type \& p, char\_int\_type t)}
\DoxyCodeLine{2497             \{}
\DoxyCodeLine{2498                 return p.first < t;}
\DoxyCodeLine{2499             \});}
\DoxyCodeLine{2500             string\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}} = \textcolor{stringliteral}{"{}\_ArrayType\_"{}};}
\DoxyCodeLine{2501             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(it == bjd\_types\_map.end() || it-\/>first != size\_and\_type.second))}
\DoxyCodeLine{2502             \{}
\DoxyCodeLine{2503                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{2504                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{2505                                         exception\_message(input\_format, \textcolor{stringliteral}{"{}invalid byte: 0x"{}} + last\_token, \textcolor{stringliteral}{"{}type"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2506             \}}
\DoxyCodeLine{2507 }
\DoxyCodeLine{2508             string\_t type = it-\/>second; \textcolor{comment}{// sax-\/>string() takes a reference}}
\DoxyCodeLine{2509             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}) || !sax-\/>string(type)))}
\DoxyCodeLine{2510             \{}
\DoxyCodeLine{2511                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2512             \}}
\DoxyCodeLine{2513 }
\DoxyCodeLine{2514             \textcolor{keywordflow}{if} (size\_and\_type.second == \textcolor{charliteral}{'C'})}
\DoxyCodeLine{2515             \{}
\DoxyCodeLine{2516                 size\_and\_type.second = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{2517             \}}
\DoxyCodeLine{2518 }
\DoxyCodeLine{2519             \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}} = \textcolor{stringliteral}{"{}\_ArrayData\_"{}};}
\DoxyCodeLine{2520             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}) || !sax-\/>start\_array(size\_and\_type.first) ))}
\DoxyCodeLine{2521             \{}
\DoxyCodeLine{2522                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2523             \}}
\DoxyCodeLine{2524 }
\DoxyCodeLine{2525             \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{2526             \{}
\DoxyCodeLine{2527                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_value(size\_and\_type.second)))}
\DoxyCodeLine{2528                 \{}
\DoxyCodeLine{2529                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2530                 \}}
\DoxyCodeLine{2531             \}}
\DoxyCodeLine{2532 }
\DoxyCodeLine{2533             \textcolor{keywordflow}{return} (sax-\/>end\_array() \&\& sax-\/>end\_object());}
\DoxyCodeLine{2534         \}}
\DoxyCodeLine{2535 }
\DoxyCodeLine{2536         \textcolor{keywordflow}{if} (size\_and\_type.first != npos)}
\DoxyCodeLine{2537         \{}
\DoxyCodeLine{2538             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(size\_and\_type.first)))}
\DoxyCodeLine{2539             \{}
\DoxyCodeLine{2540                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2541             \}}
\DoxyCodeLine{2542 }
\DoxyCodeLine{2543             \textcolor{keywordflow}{if} (size\_and\_type.second != 0)}
\DoxyCodeLine{2544             \{}
\DoxyCodeLine{2545                 \textcolor{keywordflow}{if} (size\_and\_type.second != \textcolor{charliteral}{'N'})}
\DoxyCodeLine{2546                 \{}
\DoxyCodeLine{2547                     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{2548                     \{}
\DoxyCodeLine{2549                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_value(size\_and\_type.second)))}
\DoxyCodeLine{2550                         \{}
\DoxyCodeLine{2551                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2552                         \}}
\DoxyCodeLine{2553                     \}}
\DoxyCodeLine{2554                 \}}
\DoxyCodeLine{2555             \}}
\DoxyCodeLine{2556             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2557             \{}
\DoxyCodeLine{2558                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{2559                 \{}
\DoxyCodeLine{2560                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_ubjson\_internal()))}
\DoxyCodeLine{2561                     \{}
\DoxyCodeLine{2562                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2563                     \}}
\DoxyCodeLine{2564                 \}}
\DoxyCodeLine{2565             \}}
\DoxyCodeLine{2566         \}}
\DoxyCodeLine{2567         \textcolor{keywordflow}{else}}
\DoxyCodeLine{2568         \{}
\DoxyCodeLine{2569             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{2570             \{}
\DoxyCodeLine{2571                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2572             \}}
\DoxyCodeLine{2573 }
\DoxyCodeLine{2574             \textcolor{keywordflow}{while} (current != \textcolor{charliteral}{']'})}
\DoxyCodeLine{2575             \{}
\DoxyCodeLine{2576                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_ubjson\_internal(\textcolor{keyword}{false})))}
\DoxyCodeLine{2577                 \{}
\DoxyCodeLine{2578                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2579                 \}}
\DoxyCodeLine{2580                 get\_ignore\_noop();}
\DoxyCodeLine{2581             \}}
\DoxyCodeLine{2582         \}}
\DoxyCodeLine{2583 }
\DoxyCodeLine{2584         \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{2585     \}}
\DoxyCodeLine{2586 }
\DoxyCodeLine{2590     \textcolor{keywordtype}{bool} get\_ubjson\_object()}
\DoxyCodeLine{2591     \{}
\DoxyCodeLine{2592         std::pair<std::size\_t, char\_int\_type> size\_and\_type;}
\DoxyCodeLine{2593         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_type(size\_and\_type)))}
\DoxyCodeLine{2594         \{}
\DoxyCodeLine{2595             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2596         \}}
\DoxyCodeLine{2597 }
\DoxyCodeLine{2598         \textcolor{comment}{// do not accept ND-\/array size in objects in BJData}}
\DoxyCodeLine{2599         \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata \&\& size\_and\_type.first != npos \&\& (size\_and\_type.second \& (1 << 8)) != 0)}
\DoxyCodeLine{2600         \{}
\DoxyCodeLine{2601             \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{2602             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(112, chars\_read,}
\DoxyCodeLine{2603                                     exception\_message(input\_format, \textcolor{stringliteral}{"{}BJData object does not support ND-\/array size in optimized format"{}}, \textcolor{stringliteral}{"{}object"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2604         \}}
\DoxyCodeLine{2605 }
\DoxyCodeLine{2606         string\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}};}
\DoxyCodeLine{2607         \textcolor{keywordflow}{if} (size\_and\_type.first != npos)}
\DoxyCodeLine{2608         \{}
\DoxyCodeLine{2609             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(size\_and\_type.first)))}
\DoxyCodeLine{2610             \{}
\DoxyCodeLine{2611                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2612             \}}
\DoxyCodeLine{2613 }
\DoxyCodeLine{2614             \textcolor{keywordflow}{if} (size\_and\_type.second != 0)}
\DoxyCodeLine{2615             \{}
\DoxyCodeLine{2616                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{2617                 \{}
\DoxyCodeLine{2618                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_string(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}) || !sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}})))}
\DoxyCodeLine{2619                     \{}
\DoxyCodeLine{2620                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2621                     \}}
\DoxyCodeLine{2622                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_value(size\_and\_type.second)))}
\DoxyCodeLine{2623                     \{}
\DoxyCodeLine{2624                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2625                     \}}
\DoxyCodeLine{2626                     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}.clear();}
\DoxyCodeLine{2627                 \}}
\DoxyCodeLine{2628             \}}
\DoxyCodeLine{2629             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2630             \{}
\DoxyCodeLine{2631                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{2632                 \{}
\DoxyCodeLine{2633                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_string(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}) || !sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}})))}
\DoxyCodeLine{2634                     \{}
\DoxyCodeLine{2635                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2636                     \}}
\DoxyCodeLine{2637                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_ubjson\_internal()))}
\DoxyCodeLine{2638                     \{}
\DoxyCodeLine{2639                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2640                     \}}
\DoxyCodeLine{2641                     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}.clear();}
\DoxyCodeLine{2642                 \}}
\DoxyCodeLine{2643             \}}
\DoxyCodeLine{2644         \}}
\DoxyCodeLine{2645         \textcolor{keywordflow}{else}}
\DoxyCodeLine{2646         \{}
\DoxyCodeLine{2647             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{2648             \{}
\DoxyCodeLine{2649                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2650             \}}
\DoxyCodeLine{2651 }
\DoxyCodeLine{2652             \textcolor{keywordflow}{while} (current != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2653             \{}
\DoxyCodeLine{2654                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_string(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}, \textcolor{keyword}{false}) || !sax-\/>key(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}})))}
\DoxyCodeLine{2655                 \{}
\DoxyCodeLine{2656                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2657                 \}}
\DoxyCodeLine{2658                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_ubjson\_internal()))}
\DoxyCodeLine{2659                 \{}
\DoxyCodeLine{2660                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2661                 \}}
\DoxyCodeLine{2662                 get\_ignore\_noop();}
\DoxyCodeLine{2663                 \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa3c6e0b8a9c15224a8228b9a98ca1531d}{key}}.clear();}
\DoxyCodeLine{2664             \}}
\DoxyCodeLine{2665         \}}
\DoxyCodeLine{2666 }
\DoxyCodeLine{2667         \textcolor{keywordflow}{return} sax-\/>end\_object();}
\DoxyCodeLine{2668     \}}
\DoxyCodeLine{2669 }
\DoxyCodeLine{2670     \textcolor{comment}{// Note, no reader for UBJSON binary types is implemented because they do}}
\DoxyCodeLine{2671     \textcolor{comment}{// not exist}}
\DoxyCodeLine{2672 }
\DoxyCodeLine{2673     \textcolor{keywordtype}{bool} get\_ubjson\_high\_precision\_number()}
\DoxyCodeLine{2674     \{}
\DoxyCodeLine{2675         \textcolor{comment}{// get size of following number string}}
\DoxyCodeLine{2676         std::size\_t size\{\};}
\DoxyCodeLine{2677         \textcolor{keywordtype}{bool} no\_ndarray = \textcolor{keyword}{true};}
\DoxyCodeLine{2678         \textcolor{keyword}{auto} res = get\_ubjson\_size\_value(size, no\_ndarray);}
\DoxyCodeLine{2679         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!res))}
\DoxyCodeLine{2680         \{}
\DoxyCodeLine{2681             \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{2682         \}}
\DoxyCodeLine{2683 }
\DoxyCodeLine{2684         \textcolor{comment}{// get number string}}
\DoxyCodeLine{2685         std::vector<char> number\_vector;}
\DoxyCodeLine{2686         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size; ++i)}
\DoxyCodeLine{2687         \{}
\DoxyCodeLine{2688             get();}
\DoxyCodeLine{2689             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{2690             \{}
\DoxyCodeLine{2691                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2692             \}}
\DoxyCodeLine{2693             number\_vector.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(current));}
\DoxyCodeLine{2694         \}}
\DoxyCodeLine{2695 }
\DoxyCodeLine{2696         \textcolor{comment}{// parse number string}}
\DoxyCodeLine{2697         \textcolor{keyword}{using }ia\_type = \textcolor{keyword}{decltype}(detail::input\_adapter(number\_vector));}
\DoxyCodeLine{2698         \textcolor{keyword}{auto} number\_lexer = \mbox{\hyperlink{classdetail_1_1lexer}{detail::lexer<BasicJsonType, ia\_type>}}(detail::input\_adapter(number\_vector), \textcolor{keyword}{false});}
\DoxyCodeLine{2699         \textcolor{keyword}{const} \textcolor{keyword}{auto} result\_number = number\_lexer.scan();}
\DoxyCodeLine{2700         \textcolor{keyword}{const} \textcolor{keyword}{auto} number\_string = number\_lexer.get\_token\_string();}
\DoxyCodeLine{2701         \textcolor{keyword}{const} \textcolor{keyword}{auto} result\_remainder = number\_lexer.scan();}
\DoxyCodeLine{2702 }
\DoxyCodeLine{2703         \textcolor{keyword}{using }token\_type = \textcolor{keyword}{typename} \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{detail::lexer\_base<BasicJsonType>::token\_type}};}
\DoxyCodeLine{2704 }
\DoxyCodeLine{2705         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(result\_remainder != token\_type::end\_of\_input))}
\DoxyCodeLine{2706         \{}
\DoxyCodeLine{2707             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, number\_string, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(115, chars\_read,}
\DoxyCodeLine{2708                                     exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}invalid number text: "{}}, number\_lexer.get\_token\_string()), \textcolor{stringliteral}{"{}high-\/precision number"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2709         \}}
\DoxyCodeLine{2710 }
\DoxyCodeLine{2711         \textcolor{keywordflow}{switch} (result\_number)}
\DoxyCodeLine{2712         \{}
\DoxyCodeLine{2713             \textcolor{keywordflow}{case} token\_type::value\_integer:}
\DoxyCodeLine{2714                 \textcolor{keywordflow}{return} sax-\/>number\_integer(number\_lexer.get\_number\_integer());}
\DoxyCodeLine{2715             \textcolor{keywordflow}{case} token\_type::value\_unsigned:}
\DoxyCodeLine{2716                 \textcolor{keywordflow}{return} sax-\/>number\_unsigned(number\_lexer.get\_number\_unsigned());}
\DoxyCodeLine{2717             \textcolor{keywordflow}{case} token\_type::value\_float:}
\DoxyCodeLine{2718                 \textcolor{keywordflow}{return} sax-\/>number\_float(number\_lexer.get\_number\_float(), std::move(number\_string));}
\DoxyCodeLine{2719             \textcolor{keywordflow}{case} token\_type::uninitialized:}
\DoxyCodeLine{2720             \textcolor{keywordflow}{case} token\_type::literal\_true:}
\DoxyCodeLine{2721             \textcolor{keywordflow}{case} token\_type::literal\_false:}
\DoxyCodeLine{2722             \textcolor{keywordflow}{case} token\_type::literal\_null:}
\DoxyCodeLine{2723             \textcolor{keywordflow}{case} token\_type::value\_string:}
\DoxyCodeLine{2724             \textcolor{keywordflow}{case} token\_type::begin\_array:}
\DoxyCodeLine{2725             \textcolor{keywordflow}{case} token\_type::begin\_object:}
\DoxyCodeLine{2726             \textcolor{keywordflow}{case} token\_type::end\_array:}
\DoxyCodeLine{2727             \textcolor{keywordflow}{case} token\_type::end\_object:}
\DoxyCodeLine{2728             \textcolor{keywordflow}{case} token\_type::name\_separator:}
\DoxyCodeLine{2729             \textcolor{keywordflow}{case} token\_type::value\_separator:}
\DoxyCodeLine{2730             \textcolor{keywordflow}{case} token\_type::parse\_error:}
\DoxyCodeLine{2731             \textcolor{keywordflow}{case} token\_type::end\_of\_input:}
\DoxyCodeLine{2732             \textcolor{keywordflow}{case} token\_type::literal\_or\_value:}
\DoxyCodeLine{2733             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2734                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, number\_string, \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(115, chars\_read,}
\DoxyCodeLine{2735                                         exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}invalid number text: "{}}, number\_lexer.get\_token\_string()), \textcolor{stringliteral}{"{}high-\/precision number"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2736         \}}
\DoxyCodeLine{2737     \}}
\DoxyCodeLine{2738 }
\DoxyCodeLine{2740     \textcolor{comment}{// Utility functions //}}
\DoxyCodeLine{2742 \textcolor{comment}{}}
\DoxyCodeLine{2752     char\_int\_type get()}
\DoxyCodeLine{2753     \{}
\DoxyCodeLine{2754         ++chars\_read;}
\DoxyCodeLine{2755         \textcolor{keywordflow}{return} current = ia.get\_character();}
\DoxyCodeLine{2756     \}}
\DoxyCodeLine{2757 }
\DoxyCodeLine{2761     char\_int\_type get\_ignore\_noop()}
\DoxyCodeLine{2762     \{}
\DoxyCodeLine{2763         \textcolor{keywordflow}{do}}
\DoxyCodeLine{2764         \{}
\DoxyCodeLine{2765             get();}
\DoxyCodeLine{2766         \}}
\DoxyCodeLine{2767         \textcolor{keywordflow}{while} (current == \textcolor{charliteral}{'N'});}
\DoxyCodeLine{2768 }
\DoxyCodeLine{2769         \textcolor{keywordflow}{return} current;}
\DoxyCodeLine{2770     \}}
\DoxyCodeLine{2771 }
\DoxyCodeLine{2772     \textcolor{comment}{/*}}
\DoxyCodeLine{2773 \textcolor{comment}{    @brief read a number from the input}}
\DoxyCodeLine{2774 \textcolor{comment}{}}
\DoxyCodeLine{2775 \textcolor{comment}{    @tparam NumberType the type of the number}}
\DoxyCodeLine{2776 \textcolor{comment}{    @param[in] format   the current format (for diagnostics)}}
\DoxyCodeLine{2777 \textcolor{comment}{    @param[out] result  number of type @a NumberType}}
\DoxyCodeLine{2778 \textcolor{comment}{}}
\DoxyCodeLine{2779 \textcolor{comment}{    @return whether conversion completed}}
\DoxyCodeLine{2780 \textcolor{comment}{}}
\DoxyCodeLine{2781 \textcolor{comment}{    @note This function needs to respect the system's endianness, because}}
\DoxyCodeLine{2782 \textcolor{comment}{          bytes in CBOR, MessagePack, and UBJSON are stored in network order}}
\DoxyCodeLine{2783 \textcolor{comment}{          (big endian) and therefore need reordering on little endian systems.}}
\DoxyCodeLine{2784 \textcolor{comment}{          On the other hand, BSON and BJData use little endian and should reorder}}
\DoxyCodeLine{2785 \textcolor{comment}{          on big endian systems.}}
\DoxyCodeLine{2786 \textcolor{comment}{    */}}
\DoxyCodeLine{2787     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType, \textcolor{keywordtype}{bool} InputIsLittleEndian = false>}
\DoxyCodeLine{2788     \textcolor{keywordtype}{bool} get\_number(\textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format, NumberType\& result)}
\DoxyCodeLine{2789     \{}
\DoxyCodeLine{2790         \textcolor{comment}{// step 1: read input into array with system's byte order}}
\DoxyCodeLine{2791         std::array<std::uint8\_t, \textcolor{keyword}{sizeof}(NumberType)> vec\{\};}
\DoxyCodeLine{2792         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(NumberType); ++i)}
\DoxyCodeLine{2793         \{}
\DoxyCodeLine{2794             get();}
\DoxyCodeLine{2795             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(format, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{2796             \{}
\DoxyCodeLine{2797                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2798             \}}
\DoxyCodeLine{2799 }
\DoxyCodeLine{2800             \textcolor{comment}{// reverse byte order prior to conversion if necessary}}
\DoxyCodeLine{2801             \textcolor{keywordflow}{if} (is\_little\_endian != (InputIsLittleEndian || format == input\_format\_t::bjdata))}
\DoxyCodeLine{2802             \{}
\DoxyCodeLine{2803                 vec[\textcolor{keyword}{sizeof}(NumberType) -\/ i -\/ 1] = \textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(current);}
\DoxyCodeLine{2804             \}}
\DoxyCodeLine{2805             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2806             \{}
\DoxyCodeLine{2807                 vec[i] = \textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(current); \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{2808             \}}
\DoxyCodeLine{2809         \}}
\DoxyCodeLine{2810 }
\DoxyCodeLine{2811         \textcolor{comment}{// step 2: convert array into number of type T and return}}
\DoxyCodeLine{2812         std::memcpy(\&result, vec.data(), \textcolor{keyword}{sizeof}(NumberType));}
\DoxyCodeLine{2813         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2814     \}}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2830     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{2831     \textcolor{keywordtype}{bool} get\_string(\textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format,}
\DoxyCodeLine{2832                     \textcolor{keyword}{const} NumberType len,}
\DoxyCodeLine{2833                     string\_t\& result)}
\DoxyCodeLine{2834     \{}
\DoxyCodeLine{2835         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{true};}
\DoxyCodeLine{2836         \textcolor{keywordflow}{for} (NumberType i = 0; i < len; i++)}
\DoxyCodeLine{2837         \{}
\DoxyCodeLine{2838             get();}
\DoxyCodeLine{2839             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(format, \textcolor{stringliteral}{"{}string"{}})))}
\DoxyCodeLine{2840             \{}
\DoxyCodeLine{2841                 success = \textcolor{keyword}{false};}
\DoxyCodeLine{2842                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2843             \}}
\DoxyCodeLine{2844             result.push\_back(\textcolor{keyword}{static\_cast<}typename string\_t::value\_type\textcolor{keyword}{>}(current));}
\DoxyCodeLine{2845         \}}
\DoxyCodeLine{2846         \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{2847     \}}
\DoxyCodeLine{2848 }
\DoxyCodeLine{2863     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{2864     \textcolor{keywordtype}{bool} get\_binary(\textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format,}
\DoxyCodeLine{2865                     \textcolor{keyword}{const} NumberType len,}
\DoxyCodeLine{2866                     binary\_t\& result)}
\DoxyCodeLine{2867     \{}
\DoxyCodeLine{2868         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{true};}
\DoxyCodeLine{2869         \textcolor{keywordflow}{for} (NumberType i = 0; i < len; i++)}
\DoxyCodeLine{2870         \{}
\DoxyCodeLine{2871             get();}
\DoxyCodeLine{2872             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(format, \textcolor{stringliteral}{"{}binary"{}})))}
\DoxyCodeLine{2873             \{}
\DoxyCodeLine{2874                 success = \textcolor{keyword}{false};}
\DoxyCodeLine{2875                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2876             \}}
\DoxyCodeLine{2877             result.push\_back(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(current));}
\DoxyCodeLine{2878         \}}
\DoxyCodeLine{2879         \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{2880     \}}
\DoxyCodeLine{2881 }
\DoxyCodeLine{2887     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{2888     bool unexpect\_eof(const \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format, const \textcolor{keywordtype}{char}* context)\textcolor{keyword}{ const}}
\DoxyCodeLine{2889 \textcolor{keyword}{    }\{}
\DoxyCodeLine{2890         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(current == std::char\_traits<char\_type>::eof()))}
\DoxyCodeLine{2891         \{}
\DoxyCodeLine{2892             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, \textcolor{stringliteral}{"{}<end of file>"{}},}
\DoxyCodeLine{2893                                     \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{parse\_error::create}}(110, chars\_read, exception\_message(format, \textcolor{stringliteral}{"{}unexpected end of input"{}}, context), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{2894         \}}
\DoxyCodeLine{2895         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2896     \}}
\DoxyCodeLine{2897 }
\DoxyCodeLine{2901     std::string get\_token\_string()\textcolor{keyword}{ const}}
\DoxyCodeLine{2902 \textcolor{keyword}{    }\{}
\DoxyCodeLine{2903         std::array<char, 3> cr\{\{\}\};}
\DoxyCodeLine{2904         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((std::snprintf)(cr.data(), cr.size(), \textcolor{stringliteral}{"{}\%.2hhX"{}}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(current))); \textcolor{comment}{// NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{2905         \textcolor{keywordflow}{return} std::string\{cr.data()\};}
\DoxyCodeLine{2906     \}}
\DoxyCodeLine{2907 }
\DoxyCodeLine{2914     std::string exception\_message(\textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format,}
\DoxyCodeLine{2915                                   \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{namespacedetail}{detail}},}
\DoxyCodeLine{2916                                   \textcolor{keyword}{const} std::string\& context)\textcolor{keyword}{ const}}
\DoxyCodeLine{2917 \textcolor{keyword}{    }\{}
\DoxyCodeLine{2918         std::string error\_msg = \textcolor{stringliteral}{"{}syntax error while parsing "{}};}
\DoxyCodeLine{2919 }
\DoxyCodeLine{2920         \textcolor{keywordflow}{switch} (format)}
\DoxyCodeLine{2921         \{}
\DoxyCodeLine{2922             \textcolor{keywordflow}{case} input\_format\_t::cbor:}
\DoxyCodeLine{2923                 error\_msg += \textcolor{stringliteral}{"{}CBOR"{}};}
\DoxyCodeLine{2924                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2925 }
\DoxyCodeLine{2926             \textcolor{keywordflow}{case} input\_format\_t::msgpack:}
\DoxyCodeLine{2927                 error\_msg += \textcolor{stringliteral}{"{}MessagePack"{}};}
\DoxyCodeLine{2928                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2929 }
\DoxyCodeLine{2930             \textcolor{keywordflow}{case} input\_format\_t::ubjson:}
\DoxyCodeLine{2931                 error\_msg += \textcolor{stringliteral}{"{}UBJSON"{}};}
\DoxyCodeLine{2932                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2933 }
\DoxyCodeLine{2934             \textcolor{keywordflow}{case} input\_format\_t::bson:}
\DoxyCodeLine{2935                 error\_msg += \textcolor{stringliteral}{"{}BSON"{}};}
\DoxyCodeLine{2936                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2937 }
\DoxyCodeLine{2938             \textcolor{keywordflow}{case} input\_format\_t::bjdata:}
\DoxyCodeLine{2939                 error\_msg += \textcolor{stringliteral}{"{}BJData"{}};}
\DoxyCodeLine{2940                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{2941 }
\DoxyCodeLine{2942             \textcolor{keywordflow}{case} input\_format\_t::json: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{2943             \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{2944                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{2945         \}}
\DoxyCodeLine{2946 }
\DoxyCodeLine{2947         \textcolor{keywordflow}{return} concat(error\_msg, \textcolor{charliteral}{' '}, context, \textcolor{stringliteral}{"{}: "{}}, \mbox{\hyperlink{namespacedetail}{detail}});}
\DoxyCodeLine{2948     \}}
\DoxyCodeLine{2949 }
\DoxyCodeLine{2950   \textcolor{keyword}{private}:}
\DoxyCodeLine{2951     \textcolor{keyword}{static} JSON\_INLINE\_VARIABLE \textcolor{keyword}{constexpr} std::size\_t npos = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{2952 }
\DoxyCodeLine{2954     InputAdapterType ia;}
\DoxyCodeLine{2955 }
\DoxyCodeLine{2957     char\_int\_type current = std::char\_traits<char\_type>::eof();}
\DoxyCodeLine{2958 }
\DoxyCodeLine{2960     std::size\_t chars\_read = 0;}
\DoxyCodeLine{2961 }
\DoxyCodeLine{2963     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_little\_endian = little\_endianness();}
\DoxyCodeLine{2964 }
\DoxyCodeLine{2966     \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} input\_format = input\_format\_t::json;}
\DoxyCodeLine{2967 }
\DoxyCodeLine{2969     json\_sax\_t* sax = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2970 }
\DoxyCodeLine{2971     \textcolor{comment}{// excluded markers in bjdata optimized type}}
\DoxyCodeLine{2972 \textcolor{preprocessor}{\#define JSON\_BINARY\_READER\_MAKE\_BJD\_OPTIMIZED\_TYPE\_MARKERS\_ \(\backslash\)}}
\DoxyCodeLine{2973 \textcolor{preprocessor}{    make\_array<char\_int\_type>('F', 'H', 'N', 'S', 'T', 'Z', '[', '\{')}}
\DoxyCodeLine{2974 }
\DoxyCodeLine{2975 \textcolor{preprocessor}{\#define JSON\_BINARY\_READER\_MAKE\_BJD\_TYPES\_MAP\_ \(\backslash\)}}
\DoxyCodeLine{2976 \textcolor{preprocessor}{    make\_array<bjd\_type>(                      \(\backslash\)}}
\DoxyCodeLine{2977 \textcolor{preprocessor}{    bjd\_type\{'C', "{}char"{}}\},                     \(\backslash\)}
\DoxyCodeLine{2978     bjd\_type\{'D', "{}double"{}\},                   \(\backslash\)}
\DoxyCodeLine{2979     bjd\_type\{'I', "{}int16"{}\},                    \(\backslash\)}
\DoxyCodeLine{2980     bjd\_type\{'L', "{}int64"{}\},                    \(\backslash\)}
\DoxyCodeLine{2981     bjd\_type\{'M', "{}uint64"{}\},                   \(\backslash\)}
\DoxyCodeLine{2982     bjd\_type\{'U', "{}uint8"{}\},                    \(\backslash\)}
\DoxyCodeLine{2983     bjd\_type\{'d', "{}single"{}\},                   \(\backslash\)}
\DoxyCodeLine{2984     bjd\_type\{'i', "{}int8"{}\},                     \(\backslash\)}
\DoxyCodeLine{2985     bjd\_type\{'l', "{}int32"{}\},                    \(\backslash\)}
\DoxyCodeLine{2986     bjd\_type\{'m', "{}uint32"{}\},                   \(\backslash\)}
\DoxyCodeLine{2987     bjd\_type\{'u', "{}uint16"{}\})}
\DoxyCodeLine{2988 }
\DoxyCodeLine{2989   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{2990     \textcolor{comment}{// lookup tables}}
\DoxyCodeLine{2991     \textcolor{comment}{// NOLINTNEXTLINE(cppcoreguidelines-\/non-\/private-\/member-\/variables-\/in-\/classes)}}
\DoxyCodeLine{2992     \textcolor{keyword}{const} \textcolor{keyword}{decltype}(JSON\_BINARY\_READER\_MAKE\_BJD\_OPTIMIZED\_TYPE\_MARKERS\_) bjd\_optimized\_type\_markers =}
\DoxyCodeLine{2993         JSON\_BINARY\_READER\_MAKE\_BJD\_OPTIMIZED\_TYPE\_MARKERS\_;}
\DoxyCodeLine{2994 }
\DoxyCodeLine{2995     \textcolor{keyword}{using }bjd\_type = std::pair<char\_int\_type, string\_t>;}
\DoxyCodeLine{2996     \textcolor{comment}{// NOLINTNEXTLINE(cppcoreguidelines-\/non-\/private-\/member-\/variables-\/in-\/classes)}}
\DoxyCodeLine{2997     \textcolor{keyword}{const} \textcolor{keyword}{decltype}(JSON\_BINARY\_READER\_MAKE\_BJD\_TYPES\_MAP\_) bjd\_types\_map =}
\DoxyCodeLine{2998         JSON\_BINARY\_READER\_MAKE\_BJD\_TYPES\_MAP\_;}
\DoxyCodeLine{2999 }
\DoxyCodeLine{3000 \textcolor{preprocessor}{\#undef JSON\_BINARY\_READER\_MAKE\_BJD\_OPTIMIZED\_TYPE\_MARKERS\_}}
\DoxyCodeLine{3001 \textcolor{preprocessor}{\#undef JSON\_BINARY\_READER\_MAKE\_BJD\_TYPES\_MAP\_}}
\DoxyCodeLine{3002 \};}
\DoxyCodeLine{3003 }
\DoxyCodeLine{3004 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{3005     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} InputAdapterType, \textcolor{keyword}{typename} SAX>}
\DoxyCodeLine{3006     \textcolor{keyword}{constexpr} std::size\_t binary\_reader<BasicJsonType, InputAdapterType, SAX>::npos;}
\DoxyCodeLine{3007 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3008 }
\DoxyCodeLine{3009 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{3010 NLOHMANN\_JSON\_NAMESPACE\_END}

\end{DoxyCode}
