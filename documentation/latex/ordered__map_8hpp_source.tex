\hypertarget{ordered__map_8hpp_source}{}\doxysection{ordered\+\_\+map.\+hpp}
\label{ordered__map_8hpp_source}\index{build/\_deps/json-\/src/include/nlohmann/ordered\_map.hpp@{build/\_deps/json-\/src/include/nlohmann/ordered\_map.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{2 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{7 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <functional>} \textcolor{comment}{// equal\_to, less}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <initializer\_list>} \textcolor{comment}{// initializer\_list}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// input\_iterator\_tag, iterator\_traits}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <memory>} \textcolor{comment}{// allocator}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <stdexcept>} \textcolor{comment}{// for out\_of\_range}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// enable\_if, is\_convertible}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// pair}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{24 }
\DoxyCodeLine{27 \textcolor{keyword}{template} <\textcolor{keyword}{class} Key, \textcolor{keyword}{class} T, \textcolor{keyword}{class} IgnoredLess = std::less<Key>,}
\DoxyCodeLine{28           \textcolor{keyword}{class} Allocator = std::allocator<std::pair<const Key, T>>>}
\DoxyCodeLine{29                   \textcolor{keyword}{struct }\mbox{\hyperlink{structordered__map}{ordered\_map}} : std::vector<std::pair<const Key, T>, Allocator>}
\DoxyCodeLine{30 \{}
\DoxyCodeLine{31     \textcolor{keyword}{using }key\_type = Key;}
\DoxyCodeLine{32     \textcolor{keyword}{using }mapped\_type = T;}
\DoxyCodeLine{33     \textcolor{keyword}{using }Container = std::vector<std::pair<const Key, T>, Allocator>;}
\DoxyCodeLine{34     \textcolor{keyword}{using }iterator = \textcolor{keyword}{typename} Container::iterator;}
\DoxyCodeLine{35     \textcolor{keyword}{using }const\_iterator = \textcolor{keyword}{typename} Container::const\_iterator;}
\DoxyCodeLine{36     \textcolor{keyword}{using }size\_type = \textcolor{keyword}{typename} Container::size\_type;}
\DoxyCodeLine{37     \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} Container::value\_type;}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#ifdef JSON\_HAS\_CPP\_14}}
\DoxyCodeLine{39     \textcolor{keyword}{using }key\_compare = std::equal\_to<>;}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{41     \textcolor{keyword}{using }key\_compare = std::equal\_to<Key>;}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44     \textcolor{comment}{// Explicit constructors instead of `using Container::Container`}}
\DoxyCodeLine{45     \textcolor{comment}{// otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)}}
\DoxyCodeLine{46     \mbox{\hyperlink{structordered__map}{ordered\_map}}() noexcept(noexcept(Container())) : Container\{\} \{\}}
\DoxyCodeLine{47     \textcolor{keyword}{explicit} \mbox{\hyperlink{structordered__map}{ordered\_map}}(\textcolor{keyword}{const} Allocator\& alloc) \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(Container(alloc))) : Container\{alloc\} \{\}}
\DoxyCodeLine{48     \textcolor{keyword}{template} <\textcolor{keyword}{class} It>}
\DoxyCodeLine{49     \mbox{\hyperlink{structordered__map}{ordered\_map}}(It first, It last, \textcolor{keyword}{const} Allocator\& alloc = Allocator())}
\DoxyCodeLine{50         : Container\{first, last, alloc\} \{\}}
\DoxyCodeLine{51     \mbox{\hyperlink{structordered__map}{ordered\_map}}(std::initializer\_list<value\_type> init, \textcolor{keyword}{const} Allocator\& alloc = Allocator() )}
\DoxyCodeLine{52         : Container\{init, alloc\} \{\}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54     std::pair<iterator, bool> emplace(\textcolor{keyword}{const} key\_type\& key, T\&\& t)}
\DoxyCodeLine{55     \{}
\DoxyCodeLine{56         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{57         \{}
\DoxyCodeLine{58             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{59             \{}
\DoxyCodeLine{60                 \textcolor{keywordflow}{return} \{it, \textcolor{keyword}{false}\};}
\DoxyCodeLine{61             \}}
\DoxyCodeLine{62         \}}
\DoxyCodeLine{63         Container::emplace\_back(key, std::forward<T>(t));}
\DoxyCodeLine{64         \textcolor{keywordflow}{return} \{std::prev(this-\/>end()), \textcolor{keyword}{true}\};}
\DoxyCodeLine{65     \}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{68                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{69     std::pair<iterator, bool> emplace(KeyType \&\& key, T \&\& t)}
\DoxyCodeLine{70     \{}
\DoxyCodeLine{71         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{72         \{}
\DoxyCodeLine{73             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{74             \{}
\DoxyCodeLine{75                 \textcolor{keywordflow}{return} \{it, \textcolor{keyword}{false}\};}
\DoxyCodeLine{76             \}}
\DoxyCodeLine{77         \}}
\DoxyCodeLine{78         Container::emplace\_back(std::forward<KeyType>(key), std::forward<T>(t));}
\DoxyCodeLine{79         \textcolor{keywordflow}{return} \{std::prev(this-\/>end()), \textcolor{keyword}{true}\};}
\DoxyCodeLine{80     \}}
\DoxyCodeLine{81 }
\DoxyCodeLine{82     T\& operator[](\textcolor{keyword}{const} key\_type\& key)}
\DoxyCodeLine{83     \{}
\DoxyCodeLine{84         \textcolor{keywordflow}{return} emplace(key, T\{\}).first-\/>second;}
\DoxyCodeLine{85     \}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{88                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{89     T \& operator[](KeyType \&\& key)}
\DoxyCodeLine{90     \{}
\DoxyCodeLine{91         \textcolor{keywordflow}{return} emplace(std::forward<KeyType>(key), T\{\}).first-\/>second;}
\DoxyCodeLine{92     \}}
\DoxyCodeLine{93 }
\DoxyCodeLine{94     \textcolor{keyword}{const} T\& operator[](\textcolor{keyword}{const} key\_type\& key)\textcolor{keyword}{ const}}
\DoxyCodeLine{95 \textcolor{keyword}{    }\{}
\DoxyCodeLine{96         \textcolor{keywordflow}{return} at(key);}
\DoxyCodeLine{97     \}}
\DoxyCodeLine{98 }
\DoxyCodeLine{99     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{100                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{101     \textcolor{keyword}{const} T \& operator[](KeyType \&\& key)\textcolor{keyword}{ const}}
\DoxyCodeLine{102 \textcolor{keyword}{    }\{}
\DoxyCodeLine{103         \textcolor{keywordflow}{return} at(std::forward<KeyType>(key));}
\DoxyCodeLine{104     \}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106     T\& at(\textcolor{keyword}{const} key\_type\& key)}
\DoxyCodeLine{107     \{}
\DoxyCodeLine{108         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{109         \{}
\DoxyCodeLine{110             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{111             \{}
\DoxyCodeLine{112                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{113             \}}
\DoxyCodeLine{114         \}}
\DoxyCodeLine{115 }
\DoxyCodeLine{116         JSON\_THROW(std::out\_of\_range(\textcolor{stringliteral}{"{}key not found"{}}));}
\DoxyCodeLine{117     \}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{120                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{121     T \& at(KeyType \&\& key)}
\DoxyCodeLine{122     \{}
\DoxyCodeLine{123         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{124         \{}
\DoxyCodeLine{125             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{126             \{}
\DoxyCodeLine{127                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{128             \}}
\DoxyCodeLine{129         \}}
\DoxyCodeLine{130 }
\DoxyCodeLine{131         JSON\_THROW(std::out\_of\_range(\textcolor{stringliteral}{"{}key not found"{}}));}
\DoxyCodeLine{132     \}}
\DoxyCodeLine{133 }
\DoxyCodeLine{134     \textcolor{keyword}{const} T\& at(\textcolor{keyword}{const} key\_type\& key)\textcolor{keyword}{ const}}
\DoxyCodeLine{135 \textcolor{keyword}{    }\{}
\DoxyCodeLine{136         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{137         \{}
\DoxyCodeLine{138             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{139             \{}
\DoxyCodeLine{140                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{141             \}}
\DoxyCodeLine{142         \}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144         JSON\_THROW(std::out\_of\_range(\textcolor{stringliteral}{"{}key not found"{}}));}
\DoxyCodeLine{145     \}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{148                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{149     \textcolor{keyword}{const} T \& at(KeyType \&\& key)\textcolor{keyword}{ const}}
\DoxyCodeLine{150 \textcolor{keyword}{    }\{}
\DoxyCodeLine{151         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{152         \{}
\DoxyCodeLine{153             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{154             \{}
\DoxyCodeLine{155                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{156             \}}
\DoxyCodeLine{157         \}}
\DoxyCodeLine{158 }
\DoxyCodeLine{159         JSON\_THROW(std::out\_of\_range(\textcolor{stringliteral}{"{}key not found"{}}));}
\DoxyCodeLine{160     \}}
\DoxyCodeLine{161 }
\DoxyCodeLine{162     size\_type erase(\textcolor{keyword}{const} key\_type\& key)}
\DoxyCodeLine{163     \{}
\DoxyCodeLine{164         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{165         \{}
\DoxyCodeLine{166             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{167             \{}
\DoxyCodeLine{168                 \textcolor{comment}{// Since we cannot move const Keys, re-\/construct them in place}}
\DoxyCodeLine{169                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} next = it; ++next != this-\/>end(); ++it)}
\DoxyCodeLine{170                 \{}
\DoxyCodeLine{171                     it-\/>\string~value\_type(); \textcolor{comment}{// Destroy but keep allocation}}
\DoxyCodeLine{172                     \textcolor{keyword}{new} (\&*it) value\_type\{std::move(*next)\};}
\DoxyCodeLine{173                 \}}
\DoxyCodeLine{174                 Container::pop\_back();}
\DoxyCodeLine{175                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{176             \}}
\DoxyCodeLine{177         \}}
\DoxyCodeLine{178         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{179     \}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{182                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{183     size\_type erase(KeyType \&\& key)}
\DoxyCodeLine{184     \{}
\DoxyCodeLine{185         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{186         \{}
\DoxyCodeLine{187             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{188             \{}
\DoxyCodeLine{189                 \textcolor{comment}{// Since we cannot move const Keys, re-\/construct them in place}}
\DoxyCodeLine{190                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} next = it; ++next != this-\/>end(); ++it)}
\DoxyCodeLine{191                 \{}
\DoxyCodeLine{192                     it-\/>\string~value\_type(); \textcolor{comment}{// Destroy but keep allocation}}
\DoxyCodeLine{193                     \textcolor{keyword}{new} (\&*it) value\_type\{std::move(*next)\};}
\DoxyCodeLine{194                 \}}
\DoxyCodeLine{195                 Container::pop\_back();}
\DoxyCodeLine{196                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{197             \}}
\DoxyCodeLine{198         \}}
\DoxyCodeLine{199         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{200     \}}
\DoxyCodeLine{201 }
\DoxyCodeLine{202     iterator erase(iterator pos)}
\DoxyCodeLine{203     \{}
\DoxyCodeLine{204         \textcolor{keywordflow}{return} erase(pos, std::next(pos));}
\DoxyCodeLine{205     \}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207     iterator erase(iterator first, iterator last)}
\DoxyCodeLine{208     \{}
\DoxyCodeLine{209         \textcolor{keywordflow}{if} (first == last)}
\DoxyCodeLine{210         \{}
\DoxyCodeLine{211             \textcolor{keywordflow}{return} first;}
\DoxyCodeLine{212         \}}
\DoxyCodeLine{213 }
\DoxyCodeLine{214         \textcolor{keyword}{const} \textcolor{keyword}{auto} elements\_affected = std::distance(first, last);}
\DoxyCodeLine{215         \textcolor{keyword}{const} \textcolor{keyword}{auto} offset = std::distance(Container::begin(), first);}
\DoxyCodeLine{216 }
\DoxyCodeLine{217         \textcolor{comment}{// This is the start situation. We need to delete elements\_affected}}
\DoxyCodeLine{218         \textcolor{comment}{// elements (3 in this example: e, f, g), and need to return an}}
\DoxyCodeLine{219         \textcolor{comment}{// iterator past the last deleted element (h in this example).}}
\DoxyCodeLine{220         \textcolor{comment}{// Note that offset is the distance from the start of the vector}}
\DoxyCodeLine{221         \textcolor{comment}{// to first. We will need this later.}}
\DoxyCodeLine{222 }
\DoxyCodeLine{223         \textcolor{comment}{// [ a, b, c, d, e, f, g, h, i, j ]}}
\DoxyCodeLine{224         \textcolor{comment}{//               \string^        \string^}}
\DoxyCodeLine{225         \textcolor{comment}{//             first    last}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227         \textcolor{comment}{// Since we cannot move const Keys, we re-\/construct them in place.}}
\DoxyCodeLine{228         \textcolor{comment}{// We start at first and re-\/construct (viz. copy) the elements from}}
\DoxyCodeLine{229         \textcolor{comment}{// the back of the vector. Example for first iteration:}}
\DoxyCodeLine{230 }
\DoxyCodeLine{231         \textcolor{comment}{//               ,-\/-\/-\/-\/-\/-\/-\/-\/.}}
\DoxyCodeLine{232         \textcolor{comment}{//               v        |   destroy e and re-\/construct with h}}
\DoxyCodeLine{233         \textcolor{comment}{// [ a, b, c, d, e, f, g, h, i, j ]}}
\DoxyCodeLine{234         \textcolor{comment}{//               \string^        \string^}}
\DoxyCodeLine{235         \textcolor{comment}{//               it       it + elements\_affected}}
\DoxyCodeLine{236 }
\DoxyCodeLine{237         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; std::next(it, elements\_affected) != Container::end(); ++it)}
\DoxyCodeLine{238         \{}
\DoxyCodeLine{239             it-\/>\string~value\_type(); \textcolor{comment}{// destroy but keep allocation}}
\DoxyCodeLine{240             \textcolor{keyword}{new} (\&*it) value\_type\{std::move(*std::next(it, elements\_affected))\}; \textcolor{comment}{// "{}move"{} next element to it}}
\DoxyCodeLine{241         \}}
\DoxyCodeLine{242 }
\DoxyCodeLine{243         \textcolor{comment}{// [ a, b, c, d, h, i, j, h, i, j ]}}
\DoxyCodeLine{244         \textcolor{comment}{//               \string^        \string^}}
\DoxyCodeLine{245         \textcolor{comment}{//             first    last}}
\DoxyCodeLine{246 }
\DoxyCodeLine{247         \textcolor{comment}{// remove the unneeded elements at the end of the vector}}
\DoxyCodeLine{248         Container::resize(this-\/>size() -\/ \textcolor{keyword}{static\_cast<}size\_type\textcolor{keyword}{>}(elements\_affected));}
\DoxyCodeLine{249 }
\DoxyCodeLine{250         \textcolor{comment}{// [ a, b, c, d, h, i, j ]}}
\DoxyCodeLine{251         \textcolor{comment}{//               \string^        \string^}}
\DoxyCodeLine{252         \textcolor{comment}{//             first    last}}
\DoxyCodeLine{253 }
\DoxyCodeLine{254         \textcolor{comment}{// first is now pointing past the last deleted element, but we cannot}}
\DoxyCodeLine{255         \textcolor{comment}{// use this iterator, because it may have been invalidated by the}}
\DoxyCodeLine{256         \textcolor{comment}{// resize call. Instead, we can return begin() + offset.}}
\DoxyCodeLine{257         \textcolor{keywordflow}{return} Container::begin() + offset;}
\DoxyCodeLine{258     \}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260     size\_type count(\textcolor{keyword}{const} key\_type\& key)\textcolor{keyword}{ const}}
\DoxyCodeLine{261 \textcolor{keyword}{    }\{}
\DoxyCodeLine{262         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{263         \{}
\DoxyCodeLine{264             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{265             \{}
\DoxyCodeLine{266                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{267             \}}
\DoxyCodeLine{268         \}}
\DoxyCodeLine{269         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{270     \}}
\DoxyCodeLine{271 }
\DoxyCodeLine{272     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{273                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{274     size\_type count(KeyType \&\& key)\textcolor{keyword}{ const}}
\DoxyCodeLine{275 \textcolor{keyword}{    }\{}
\DoxyCodeLine{276         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{277         \{}
\DoxyCodeLine{278             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{279             \{}
\DoxyCodeLine{280                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{281             \}}
\DoxyCodeLine{282         \}}
\DoxyCodeLine{283         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{284     \}}
\DoxyCodeLine{285 }
\DoxyCodeLine{286     iterator find(\textcolor{keyword}{const} key\_type\& key)}
\DoxyCodeLine{287     \{}
\DoxyCodeLine{288         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{289         \{}
\DoxyCodeLine{290             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{291             \{}
\DoxyCodeLine{292                 \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{293             \}}
\DoxyCodeLine{294         \}}
\DoxyCodeLine{295         \textcolor{keywordflow}{return} Container::end();}
\DoxyCodeLine{296     \}}
\DoxyCodeLine{297 }
\DoxyCodeLine{298     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{299                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{300     iterator find(KeyType \&\& key)}
\DoxyCodeLine{301     \{}
\DoxyCodeLine{302         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{303         \{}
\DoxyCodeLine{304             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{305             \{}
\DoxyCodeLine{306                 \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{307             \}}
\DoxyCodeLine{308         \}}
\DoxyCodeLine{309         \textcolor{keywordflow}{return} Container::end();}
\DoxyCodeLine{310     \}}
\DoxyCodeLine{311 }
\DoxyCodeLine{312     const\_iterator find(\textcolor{keyword}{const} key\_type\& key)\textcolor{keyword}{ const}}
\DoxyCodeLine{313 \textcolor{keyword}{    }\{}
\DoxyCodeLine{314         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{315         \{}
\DoxyCodeLine{316             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, key))}
\DoxyCodeLine{317             \{}
\DoxyCodeLine{318                 \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{319             \}}
\DoxyCodeLine{320         \}}
\DoxyCodeLine{321         \textcolor{keywordflow}{return} Container::end();}
\DoxyCodeLine{322     \}}
\DoxyCodeLine{323 }
\DoxyCodeLine{324     std::pair<iterator, bool> insert( value\_type\&\& value )}
\DoxyCodeLine{325     \{}
\DoxyCodeLine{326         \textcolor{keywordflow}{return} emplace(value.first, std::move(value.second));}
\DoxyCodeLine{327     \}}
\DoxyCodeLine{328 }
\DoxyCodeLine{329     std::pair<iterator, bool> insert( \textcolor{keyword}{const} value\_type\& value )}
\DoxyCodeLine{330     \{}
\DoxyCodeLine{331         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{332         \{}
\DoxyCodeLine{333             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, value.first))}
\DoxyCodeLine{334             \{}
\DoxyCodeLine{335                 \textcolor{keywordflow}{return} \{it, \textcolor{keyword}{false}\};}
\DoxyCodeLine{336             \}}
\DoxyCodeLine{337         \}}
\DoxyCodeLine{338         Container::push\_back(value);}
\DoxyCodeLine{339         \textcolor{keywordflow}{return} \{-\/-\/this-\/>end(), \textcolor{keyword}{true}\};}
\DoxyCodeLine{340     \}}
\DoxyCodeLine{341 }
\DoxyCodeLine{342     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIt>}
\DoxyCodeLine{343     \textcolor{keyword}{using }require\_input\_iter = \textcolor{keyword}{typename} std::enable\_if<std::is\_convertible<typename std::iterator\_traits<InputIt>::iterator\_category,}
\DoxyCodeLine{344             std::input\_iterator\_tag>::value>::type;}
\DoxyCodeLine{345 }
\DoxyCodeLine{346     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIt, \textcolor{keyword}{typename} = require\_input\_iter<InputIt>>}
\DoxyCodeLine{347     \textcolor{keywordtype}{void} insert(InputIt first, InputIt last)}
\DoxyCodeLine{348     \{}
\DoxyCodeLine{349         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it != last; ++it)}
\DoxyCodeLine{350         \{}
\DoxyCodeLine{351             insert(*it);}
\DoxyCodeLine{352         \}}
\DoxyCodeLine{353     \}}
\DoxyCodeLine{354 }
\DoxyCodeLine{355 \textcolor{keyword}{private}:}
\DoxyCodeLine{356     JSON\_NO\_UNIQUE\_ADDRESS key\_compare m\_compare = key\_compare();}
\DoxyCodeLine{357 \};}
\DoxyCodeLine{358 }
\DoxyCodeLine{359 NLOHMANN\_JSON\_NAMESPACE\_END}

\end{DoxyCode}
