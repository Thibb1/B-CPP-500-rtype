\hypertarget{to__chars_8hpp_source}{}\doxysection{to\+\_\+chars.\+hpp}
\label{to__chars_8hpp_source}\index{build/\_deps/json-\/src/include/nlohmann/detail/conversions/to\_chars.hpp@{build/\_deps/json-\/src/include/nlohmann/detail/conversions/to\_chars.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{2 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2009 Florian Loitsch <https://florian.loitsch.com/>}}
\DoxyCodeLine{7 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{8 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{9 }
\DoxyCodeLine{10 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <cmath>}   \textcolor{comment}{// signbit, isfinite}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// intN\_t, uintN\_t}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <cstring>} \textcolor{comment}{// memcpy, memmove}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <limits>} \textcolor{comment}{// numeric\_limits}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// conditional}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{22 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{23 \{}
\DoxyCodeLine{24 }
\DoxyCodeLine{44 \textcolor{keyword}{namespace }dtoa\_impl}
\DoxyCodeLine{45 \{}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Target, \textcolor{keyword}{typename} Source>}
\DoxyCodeLine{48 Target reinterpret\_bits(\textcolor{keyword}{const} Source source)}
\DoxyCodeLine{49 \{}
\DoxyCodeLine{50     \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(Target) == \textcolor{keyword}{sizeof}(Source), \textcolor{stringliteral}{"{}size mismatch"{}});}
\DoxyCodeLine{51 }
\DoxyCodeLine{52     Target target;}
\DoxyCodeLine{53     std::memcpy(\&target, \&source, \textcolor{keyword}{sizeof}(Source));}
\DoxyCodeLine{54     \textcolor{keywordflow}{return} target;}
\DoxyCodeLine{55 \}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \textcolor{comment}{// f * 2\string^e}}
\DoxyCodeLine{58 \{}
\DoxyCodeLine{59     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kPrecision = 64; \textcolor{comment}{// = q}}
\DoxyCodeLine{60 }
\DoxyCodeLine{61     std::uint64\_t f = 0;}
\DoxyCodeLine{62     \textcolor{keywordtype}{int} e = 0;}
\DoxyCodeLine{63 }
\DoxyCodeLine{64     \textcolor{keyword}{constexpr} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(std::uint64\_t f\_, \textcolor{keywordtype}{int} e\_) noexcept : f(f\_), e(e\_) \{\}}
\DoxyCodeLine{65 }
\DoxyCodeLine{70     \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a75142bace0b78b1e1433b1d35a7ff252}{sub}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& x, \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& y) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{71     \{}
\DoxyCodeLine{72         JSON\_ASSERT(x.e == y.e);}
\DoxyCodeLine{73         JSON\_ASSERT(x.f >= y.f);}
\DoxyCodeLine{74 }
\DoxyCodeLine{75         \textcolor{keywordflow}{return} \{x.f -\/ y.f, x.e\};}
\DoxyCodeLine{76     \}}
\DoxyCodeLine{77 }
\DoxyCodeLine{82     \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a046c61f2c13411677eedfb5b9b7a8226}{mul}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& x, \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& y) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{83     \{}
\DoxyCodeLine{84         \textcolor{keyword}{static\_assert}(kPrecision == 64, \textcolor{stringliteral}{"{}internal error"{}});}
\DoxyCodeLine{85 }
\DoxyCodeLine{86         \textcolor{comment}{// Computes:}}
\DoxyCodeLine{87         \textcolor{comment}{//  f = round((x.f * y.f) / 2\string^q)}}
\DoxyCodeLine{88         \textcolor{comment}{//  e = x.e + y.e + q}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90         \textcolor{comment}{// Emulate the 64-\/bit * 64-\/bit multiplication:}}
\DoxyCodeLine{91         \textcolor{comment}{//}}
\DoxyCodeLine{92         \textcolor{comment}{// p = u * v}}
\DoxyCodeLine{93         \textcolor{comment}{//   = (u\_lo + 2\string^32 u\_hi) (v\_lo + 2\string^32 v\_hi)}}
\DoxyCodeLine{94         \textcolor{comment}{//   = (u\_lo v\_lo         ) + 2\string^32 ((u\_lo v\_hi         ) + (u\_hi v\_lo         )) + 2\string^64 (u\_hi v\_hi         )}}
\DoxyCodeLine{95         \textcolor{comment}{//   = (p0                ) + 2\string^32 ((p1                ) + (p2                )) + 2\string^64 (p3                )}}
\DoxyCodeLine{96         \textcolor{comment}{//   = (p0\_lo + 2\string^32 p0\_hi) + 2\string^32 ((p1\_lo + 2\string^32 p1\_hi) + (p2\_lo + 2\string^32 p2\_hi)) + 2\string^64 (p3                )}}
\DoxyCodeLine{97         \textcolor{comment}{//   = (p0\_lo             ) + 2\string^32 (p0\_hi + p1\_lo + p2\_lo                      ) + 2\string^64 (p1\_hi + p2\_hi + p3)}}
\DoxyCodeLine{98         \textcolor{comment}{//   = (p0\_lo             ) + 2\string^32 (Q                                          ) + 2\string^64 (H                 )}}
\DoxyCodeLine{99         \textcolor{comment}{//   = (p0\_lo             ) + 2\string^32 (Q\_lo + 2\string^32 Q\_hi                           ) + 2\string^64 (H                 )}}
\DoxyCodeLine{100         \textcolor{comment}{//}}
\DoxyCodeLine{101         \textcolor{comment}{// (Since Q might be larger than 2\string^32 -\/ 1)}}
\DoxyCodeLine{102         \textcolor{comment}{//}}
\DoxyCodeLine{103         \textcolor{comment}{//   = (p0\_lo + 2\string^32 Q\_lo) + 2\string^64 (Q\_hi + H)}}
\DoxyCodeLine{104         \textcolor{comment}{//}}
\DoxyCodeLine{105         \textcolor{comment}{// (Q\_hi + H does not overflow a 64-\/bit int)}}
\DoxyCodeLine{106         \textcolor{comment}{//}}
\DoxyCodeLine{107         \textcolor{comment}{//   = p\_lo + 2\string^64 p\_hi}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109         \textcolor{keyword}{const} std::uint64\_t u\_lo = x.f \& 0xFFFFFFFFu;}
\DoxyCodeLine{110         \textcolor{keyword}{const} std::uint64\_t u\_hi = x.f >> 32u;}
\DoxyCodeLine{111         \textcolor{keyword}{const} std::uint64\_t v\_lo = y.f \& 0xFFFFFFFFu;}
\DoxyCodeLine{112         \textcolor{keyword}{const} std::uint64\_t v\_hi = y.f >> 32u;}
\DoxyCodeLine{113 }
\DoxyCodeLine{114         \textcolor{keyword}{const} std::uint64\_t p0 = u\_lo * v\_lo;}
\DoxyCodeLine{115         \textcolor{keyword}{const} std::uint64\_t p1 = u\_lo * v\_hi;}
\DoxyCodeLine{116         \textcolor{keyword}{const} std::uint64\_t p2 = u\_hi * v\_lo;}
\DoxyCodeLine{117         \textcolor{keyword}{const} std::uint64\_t p3 = u\_hi * v\_hi;}
\DoxyCodeLine{118 }
\DoxyCodeLine{119         \textcolor{keyword}{const} std::uint64\_t p0\_hi = p0 >> 32u;}
\DoxyCodeLine{120         \textcolor{keyword}{const} std::uint64\_t p1\_lo = p1 \& 0xFFFFFFFFu;}
\DoxyCodeLine{121         \textcolor{keyword}{const} std::uint64\_t p1\_hi = p1 >> 32u;}
\DoxyCodeLine{122         \textcolor{keyword}{const} std::uint64\_t p2\_lo = p2 \& 0xFFFFFFFFu;}
\DoxyCodeLine{123         \textcolor{keyword}{const} std::uint64\_t p2\_hi = p2 >> 32u;}
\DoxyCodeLine{124 }
\DoxyCodeLine{125         std::uint64\_t Q = p0\_hi + p1\_lo + p2\_lo;}
\DoxyCodeLine{126 }
\DoxyCodeLine{127         \textcolor{comment}{// The full product might now be computed as}}
\DoxyCodeLine{128         \textcolor{comment}{//}}
\DoxyCodeLine{129         \textcolor{comment}{// p\_hi = p3 + p2\_hi + p1\_hi + (Q >> 32)}}
\DoxyCodeLine{130         \textcolor{comment}{// p\_lo = p0\_lo + (Q << 32)}}
\DoxyCodeLine{131         \textcolor{comment}{//}}
\DoxyCodeLine{132         \textcolor{comment}{// But in this particular case here, the full p\_lo is not required.}}
\DoxyCodeLine{133         \textcolor{comment}{// Effectively we only need to add the highest bit in p\_lo to p\_hi (and}}
\DoxyCodeLine{134         \textcolor{comment}{// Q\_hi + 1 does not overflow).}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136         Q += std::uint64\_t\{1\} << (64u -\/ 32u -\/ 1u); \textcolor{comment}{// round, ties up}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138         \textcolor{keyword}{const} std::uint64\_t h = p3 + p2\_hi + p1\_hi + (Q >> 32u);}
\DoxyCodeLine{139 }
\DoxyCodeLine{140         \textcolor{keywordflow}{return} \{h, x.e + y.e + 64\};}
\DoxyCodeLine{141     \}}
\DoxyCodeLine{142 }
\DoxyCodeLine{147     \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a5bad735c2cb50b194938a8a89b82f6ed}{normalize}}(\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} x) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{148     \{}
\DoxyCodeLine{149         JSON\_ASSERT(x.f != 0);}
\DoxyCodeLine{150 }
\DoxyCodeLine{151         \textcolor{keywordflow}{while} ((x.f >> 63u) == 0)}
\DoxyCodeLine{152         \{}
\DoxyCodeLine{153             x.f <<= 1u;}
\DoxyCodeLine{154             x.e-\/-\/;}
\DoxyCodeLine{155         \}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157         \textcolor{keywordflow}{return} x;}
\DoxyCodeLine{158     \}}
\DoxyCodeLine{159 }
\DoxyCodeLine{164     \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a5a9ce83c6c1663c9aaac7ffd9009b971}{normalize\_to}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& x, \textcolor{keyword}{const} \textcolor{keywordtype}{int} target\_exponent) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{165     \{}
\DoxyCodeLine{166         \textcolor{keyword}{const} \textcolor{keywordtype}{int} delta = x.e -\/ target\_exponent;}
\DoxyCodeLine{167 }
\DoxyCodeLine{168         JSON\_ASSERT(delta >= 0);}
\DoxyCodeLine{169         JSON\_ASSERT(((x.f << delta) >> delta) == x.f);}
\DoxyCodeLine{170 }
\DoxyCodeLine{171         \textcolor{keywordflow}{return} \{x.f << delta, target\_exponent\};}
\DoxyCodeLine{172     \}}
\DoxyCodeLine{173 \};}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1boundaries}{boundaries}}}
\DoxyCodeLine{176 \{}
\DoxyCodeLine{177     \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w;}
\DoxyCodeLine{178     \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} minus;}
\DoxyCodeLine{179     \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} plus;}
\DoxyCodeLine{180 \};}
\DoxyCodeLine{181 }
\DoxyCodeLine{188 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{189 \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1boundaries}{boundaries}} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a6a5ccf11847aab7a0f42f587b33935df}{compute\_boundaries}}(FloatType value)}
\DoxyCodeLine{190 \{}
\DoxyCodeLine{191     JSON\_ASSERT(std::isfinite(value));}
\DoxyCodeLine{192     JSON\_ASSERT(value > 0);}
\DoxyCodeLine{193 }
\DoxyCodeLine{194     \textcolor{comment}{// Convert the IEEE representation into a diyfp.}}
\DoxyCodeLine{195     \textcolor{comment}{//}}
\DoxyCodeLine{196     \textcolor{comment}{// If v is denormal:}}
\DoxyCodeLine{197     \textcolor{comment}{//      value = 0.F * 2\string^(1 -\/ bias) = (          F) * 2\string^(1 -\/ bias -\/ (p-\/1))}}
\DoxyCodeLine{198     \textcolor{comment}{// If v is normalized:}}
\DoxyCodeLine{199     \textcolor{comment}{//      value = 1.F * 2\string^(E -\/ bias) = (2\string^(p-\/1) + F) * 2\string^(E -\/ bias -\/ (p-\/1))}}
\DoxyCodeLine{200 }
\DoxyCodeLine{201     \textcolor{keyword}{static\_assert}(std::numeric\_limits<FloatType>::is\_iec559,}
\DoxyCodeLine{202                   \textcolor{stringliteral}{"{}internal error: dtoa\_short requires an IEEE-\/754 floating-\/point implementation"{}});}
\DoxyCodeLine{203 }
\DoxyCodeLine{204     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int}      kPrecision = std::numeric\_limits<FloatType>::digits; \textcolor{comment}{// = p (includes the hidden bit)}}
\DoxyCodeLine{205     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int}      kBias      = std::numeric\_limits<FloatType>::max\_exponent -\/ 1 + (kPrecision -\/ 1);}
\DoxyCodeLine{206     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int}      kMinExp    = 1 -\/ kBias;}
\DoxyCodeLine{207     \textcolor{keyword}{constexpr} std::uint64\_t kHiddenBit = std::uint64\_t\{1\} << (kPrecision -\/ 1); \textcolor{comment}{// = 2\string^(p-\/1)}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209     \textcolor{keyword}{using }bits\_type = \textcolor{keyword}{typename} std::conditional<kPrecision == 24, std::uint32\_t, std::uint64\_t >::type;}
\DoxyCodeLine{210 }
\DoxyCodeLine{211     \textcolor{keyword}{const} \textcolor{keyword}{auto} bits = \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(reinterpret\_bits<bits\_type>(value));}
\DoxyCodeLine{212     \textcolor{keyword}{const} std::uint64\_t E = bits >> (kPrecision -\/ 1);}
\DoxyCodeLine{213     \textcolor{keyword}{const} std::uint64\_t F = bits \& (kHiddenBit -\/ 1);}
\DoxyCodeLine{214 }
\DoxyCodeLine{215     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_denormal = E == 0;}
\DoxyCodeLine{216     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} v = is\_denormal}
\DoxyCodeLine{217                     ? \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(F, kMinExp)}
\DoxyCodeLine{218                     : \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(F + kHiddenBit, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(E) -\/ kBias);}
\DoxyCodeLine{219 }
\DoxyCodeLine{220     \textcolor{comment}{// Compute the boundaries m-\/ and m+ of the floating-\/point value}}
\DoxyCodeLine{221     \textcolor{comment}{// v = f * 2\string^e.}}
\DoxyCodeLine{222     \textcolor{comment}{//}}
\DoxyCodeLine{223     \textcolor{comment}{// Determine v-\/ and v+, the floating-\/point predecessor and successor if v,}}
\DoxyCodeLine{224     \textcolor{comment}{// respectively.}}
\DoxyCodeLine{225     \textcolor{comment}{//}}
\DoxyCodeLine{226     \textcolor{comment}{//      v-\/ = v -\/ 2\string^e        if f != 2\string^(p-\/1) or e == e\_min                (A)}}
\DoxyCodeLine{227     \textcolor{comment}{//         = v -\/ 2\string^(e-\/1)    if f == 2\string^(p-\/1) and e > e\_min                (B)}}
\DoxyCodeLine{228     \textcolor{comment}{//}}
\DoxyCodeLine{229     \textcolor{comment}{//      v+ = v + 2\string^e}}
\DoxyCodeLine{230     \textcolor{comment}{//}}
\DoxyCodeLine{231     \textcolor{comment}{// Let m-\/ = (v-\/ + v) / 2 and m+ = (v + v+) / 2. All real numbers \_strictly\_}}
\DoxyCodeLine{232     \textcolor{comment}{// between m-\/ and m+ round to v, regardless of how the input rounding}}
\DoxyCodeLine{233     \textcolor{comment}{// algorithm breaks ties.}}
\DoxyCodeLine{234     \textcolor{comment}{//}}
\DoxyCodeLine{235     \textcolor{comment}{//      -\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/  (A)}}
\DoxyCodeLine{236     \textcolor{comment}{//         v-\/            m-\/            v             m+            v+}}
\DoxyCodeLine{237     \textcolor{comment}{//}}
\DoxyCodeLine{238     \textcolor{comment}{//      -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/  (B)}}
\DoxyCodeLine{239     \textcolor{comment}{//                       v-\/     m-\/     v             m+            v+}}
\DoxyCodeLine{240 }
\DoxyCodeLine{241     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} lower\_boundary\_is\_closer = F == 0 \&\& E > 1;}
\DoxyCodeLine{242     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\_plus = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(2 * v.f + 1, v.e -\/ 1);}
\DoxyCodeLine{243     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\_minus = lower\_boundary\_is\_closer}
\DoxyCodeLine{244                           ? \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(4 * v.f -\/ 1, v.e -\/ 2)  \textcolor{comment}{// (B)}}
\DoxyCodeLine{245                           : \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(2 * v.f -\/ 1, v.e -\/ 1); \textcolor{comment}{// (A)}}
\DoxyCodeLine{246 }
\DoxyCodeLine{247     \textcolor{comment}{// Determine the normalized w+ = m+.}}
\DoxyCodeLine{248     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_plus = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a5bad735c2cb50b194938a8a89b82f6ed}{diyfp::normalize}}(m\_plus);}
\DoxyCodeLine{249 }
\DoxyCodeLine{250     \textcolor{comment}{// Determine w-\/ = m-\/ such that e\_(w-\/) = e\_(w+).}}
\DoxyCodeLine{251     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_minus = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a5a9ce83c6c1663c9aaac7ffd9009b971}{diyfp::normalize\_to}}(m\_minus, w\_plus.e);}
\DoxyCodeLine{252 }
\DoxyCodeLine{253     \textcolor{keywordflow}{return} \{\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a5bad735c2cb50b194938a8a89b82f6ed}{diyfp::normalize}}(v), w\_minus, w\_plus\};}
\DoxyCodeLine{254 \}}
\DoxyCodeLine{255 }
\DoxyCodeLine{256 \textcolor{comment}{// Given normalized diyfp w, Grisu needs to find a (normalized) cached}}
\DoxyCodeLine{257 \textcolor{comment}{// power-\/of-\/ten c, such that the exponent of the product c * w = f * 2\string^e lies}}
\DoxyCodeLine{258 \textcolor{comment}{// within a certain range [alpha, gamma] (Definition 3.2 from [1])}}
\DoxyCodeLine{259 \textcolor{comment}{//}}
\DoxyCodeLine{260 \textcolor{comment}{//      alpha <= e = e\_c + e\_w + q <= gamma}}
\DoxyCodeLine{261 \textcolor{comment}{//}}
\DoxyCodeLine{262 \textcolor{comment}{// or}}
\DoxyCodeLine{263 \textcolor{comment}{//}}
\DoxyCodeLine{264 \textcolor{comment}{//      f\_c * f\_w * 2\string^alpha <= f\_c 2\string^(e\_c) * f\_w 2\string^(e\_w) * 2\string^q}}
\DoxyCodeLine{265 \textcolor{comment}{//                          <= f\_c * f\_w * 2\string^gamma}}
\DoxyCodeLine{266 \textcolor{comment}{//}}
\DoxyCodeLine{267 \textcolor{comment}{// Since c and w are normalized, i.e. 2\string^(q-\/1) <= f < 2\string^q, this implies}}
\DoxyCodeLine{268 \textcolor{comment}{//}}
\DoxyCodeLine{269 \textcolor{comment}{//      2\string^(q-\/1) * 2\string^(q-\/1) * 2\string^alpha <= c * w * 2\string^q < 2\string^q * 2\string^q * 2\string^gamma}}
\DoxyCodeLine{270 \textcolor{comment}{//}}
\DoxyCodeLine{271 \textcolor{comment}{// or}}
\DoxyCodeLine{272 \textcolor{comment}{//}}
\DoxyCodeLine{273 \textcolor{comment}{//      2\string^(q -\/ 2 + alpha) <= c * w < 2\string^(q + gamma)}}
\DoxyCodeLine{274 \textcolor{comment}{//}}
\DoxyCodeLine{275 \textcolor{comment}{// The choice of (alpha,gamma) determines the size of the table and the form of}}
\DoxyCodeLine{276 \textcolor{comment}{// the digit generation procedure. Using (alpha,gamma)=(-\/60,-\/32) works out well}}
\DoxyCodeLine{277 \textcolor{comment}{// in practice:}}
\DoxyCodeLine{278 \textcolor{comment}{//}}
\DoxyCodeLine{279 \textcolor{comment}{// The idea is to cut the number c * w = f * 2\string^e into two parts, which can be}}
\DoxyCodeLine{280 \textcolor{comment}{// processed independently: An integral part p1, and a fractional part p2:}}
\DoxyCodeLine{281 \textcolor{comment}{//}}
\DoxyCodeLine{282 \textcolor{comment}{//      f * 2\string^e = ( (f div 2\string^-\/e) * 2\string^-\/e + (f mod 2\string^-\/e) ) * 2\string^e}}
\DoxyCodeLine{283 \textcolor{comment}{//              = (f div 2\string^-\/e) + (f mod 2\string^-\/e) * 2\string^e}}
\DoxyCodeLine{284 \textcolor{comment}{//              = p1 + p2 * 2\string^e}}
\DoxyCodeLine{285 \textcolor{comment}{//}}
\DoxyCodeLine{286 \textcolor{comment}{// The conversion of p1 into decimal form requires a series of divisions and}}
\DoxyCodeLine{287 \textcolor{comment}{// modulos by (a power of) 10. These operations are faster for 32-\/bit than for}}
\DoxyCodeLine{288 \textcolor{comment}{// 64-\/bit integers, so p1 should ideally fit into a 32-\/bit integer. This can be}}
\DoxyCodeLine{289 \textcolor{comment}{// achieved by choosing}}
\DoxyCodeLine{290 \textcolor{comment}{//}}
\DoxyCodeLine{291 \textcolor{comment}{//      -\/e >= 32   or   e <= -\/32 := gamma}}
\DoxyCodeLine{292 \textcolor{comment}{//}}
\DoxyCodeLine{293 \textcolor{comment}{// In order to convert the fractional part}}
\DoxyCodeLine{294 \textcolor{comment}{//}}
\DoxyCodeLine{295 \textcolor{comment}{//      p2 * 2\string^e = p2 / 2\string^-\/e = d[-\/1] / 10\string^1 + d[-\/2] / 10\string^2 + ...}}
\DoxyCodeLine{296 \textcolor{comment}{//}}
\DoxyCodeLine{297 \textcolor{comment}{// into decimal form, the fraction is repeatedly multiplied by 10 and the digits}}
\DoxyCodeLine{298 \textcolor{comment}{// d[-\/i] are extracted in order:}}
\DoxyCodeLine{299 \textcolor{comment}{//}}
\DoxyCodeLine{300 \textcolor{comment}{//      (10 * p2) div 2\string^-\/e = d[-\/1]}}
\DoxyCodeLine{301 \textcolor{comment}{//      (10 * p2) mod 2\string^-\/e = d[-\/2] / 10\string^1 + ...}}
\DoxyCodeLine{302 \textcolor{comment}{//}}
\DoxyCodeLine{303 \textcolor{comment}{// The multiplication by 10 must not overflow. It is sufficient to choose}}
\DoxyCodeLine{304 \textcolor{comment}{//}}
\DoxyCodeLine{305 \textcolor{comment}{//      10 * p2 < 16 * p2 = 2\string^4 * p2 <= 2\string^64.}}
\DoxyCodeLine{306 \textcolor{comment}{//}}
\DoxyCodeLine{307 \textcolor{comment}{// Since p2 = f mod 2\string^-\/e < 2\string^-\/e,}}
\DoxyCodeLine{308 \textcolor{comment}{//}}
\DoxyCodeLine{309 \textcolor{comment}{//      -\/e <= 60   or   e >= -\/60 := alpha}}
\DoxyCodeLine{310 }
\DoxyCodeLine{311 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kAlpha = -\/60;}
\DoxyCodeLine{312 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kGamma = -\/32;}
\DoxyCodeLine{313 }
\DoxyCodeLine{314 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1cached__power}{cached\_power}} \textcolor{comment}{// c = f * 2\string^e \string~= 10\string^k}}
\DoxyCodeLine{315 \{}
\DoxyCodeLine{316     std::uint64\_t f;}
\DoxyCodeLine{317     \textcolor{keywordtype}{int} e;}
\DoxyCodeLine{318     \textcolor{keywordtype}{int} k;}
\DoxyCodeLine{319 \};}
\DoxyCodeLine{320 }
\DoxyCodeLine{328 \textcolor{keyword}{inline} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1cached__power}{cached\_power}} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a29ae6574f6be09a5c8ab08da9a3f71b4}{get\_cached\_power\_for\_binary\_exponent}}(\textcolor{keywordtype}{int} e)}
\DoxyCodeLine{329 \{}
\DoxyCodeLine{330     \textcolor{comment}{// Now}}
\DoxyCodeLine{331     \textcolor{comment}{//}}
\DoxyCodeLine{332     \textcolor{comment}{//      alpha <= e\_c + e + q <= gamma                                    (1)}}
\DoxyCodeLine{333     \textcolor{comment}{//      ==> f\_c * 2\string^alpha <= c * 2\string^e * 2\string^q}}
\DoxyCodeLine{334     \textcolor{comment}{//}}
\DoxyCodeLine{335     \textcolor{comment}{// and since the c's are normalized, 2\string^(q-\/1) <= f\_c,}}
\DoxyCodeLine{336     \textcolor{comment}{//}}
\DoxyCodeLine{337     \textcolor{comment}{//      ==> 2\string^(q -\/ 1 + alpha) <= c * 2\string^(e + q)}}
\DoxyCodeLine{338     \textcolor{comment}{//      ==> 2\string^(alpha -\/ e -\/ 1) <= c}}
\DoxyCodeLine{339     \textcolor{comment}{//}}
\DoxyCodeLine{340     \textcolor{comment}{// If c were an exact power of ten, i.e. c = 10\string^k, one may determine k as}}
\DoxyCodeLine{341     \textcolor{comment}{//}}
\DoxyCodeLine{342     \textcolor{comment}{//      k = ceil( log\_10( 2\string^(alpha -\/ e -\/ 1) ) )}}
\DoxyCodeLine{343     \textcolor{comment}{//        = ceil( (alpha -\/ e -\/ 1) * log\_10(2) )}}
\DoxyCodeLine{344     \textcolor{comment}{//}}
\DoxyCodeLine{345     \textcolor{comment}{// From the paper:}}
\DoxyCodeLine{346     \textcolor{comment}{// "{}In theory the result of the procedure could be wrong since c is rounded,}}
\DoxyCodeLine{347     \textcolor{comment}{//  and the computation itself is approximated [...]. In practice, however,}}
\DoxyCodeLine{348     \textcolor{comment}{//  this simple function is sufficient."{}}}
\DoxyCodeLine{349     \textcolor{comment}{//}}
\DoxyCodeLine{350     \textcolor{comment}{// For IEEE double precision floating-\/point numbers converted into}}
\DoxyCodeLine{351     \textcolor{comment}{// normalized diyfp's w = f * 2\string^e, with q = 64,}}
\DoxyCodeLine{352     \textcolor{comment}{//}}
\DoxyCodeLine{353     \textcolor{comment}{//      e >= -\/1022      (min IEEE exponent)}}
\DoxyCodeLine{354     \textcolor{comment}{//           -\/52        (p -\/ 1)}}
\DoxyCodeLine{355     \textcolor{comment}{//           -\/52        (p -\/ 1, possibly normalize denormal IEEE numbers)}}
\DoxyCodeLine{356     \textcolor{comment}{//           -\/11        (normalize the diyfp)}}
\DoxyCodeLine{357     \textcolor{comment}{//         = -\/1137}}
\DoxyCodeLine{358     \textcolor{comment}{//}}
\DoxyCodeLine{359     \textcolor{comment}{// and}}
\DoxyCodeLine{360     \textcolor{comment}{//}}
\DoxyCodeLine{361     \textcolor{comment}{//      e <= +1023      (max IEEE exponent)}}
\DoxyCodeLine{362     \textcolor{comment}{//           -\/52        (p -\/ 1)}}
\DoxyCodeLine{363     \textcolor{comment}{//           -\/11        (normalize the diyfp)}}
\DoxyCodeLine{364     \textcolor{comment}{//         = 960}}
\DoxyCodeLine{365     \textcolor{comment}{//}}
\DoxyCodeLine{366     \textcolor{comment}{// This binary exponent range [-\/1137,960] results in a decimal exponent}}
\DoxyCodeLine{367     \textcolor{comment}{// range [-\/307,324]. One does not need to store a cached power for each}}
\DoxyCodeLine{368     \textcolor{comment}{// k in this range. For each such k it suffices to find a cached power}}
\DoxyCodeLine{369     \textcolor{comment}{// such that the exponent of the product lies in [alpha,gamma].}}
\DoxyCodeLine{370     \textcolor{comment}{// This implies that the difference of the decimal exponents of adjacent}}
\DoxyCodeLine{371     \textcolor{comment}{// table entries must be less than or equal to}}
\DoxyCodeLine{372     \textcolor{comment}{//}}
\DoxyCodeLine{373     \textcolor{comment}{//      floor( (gamma -\/ alpha) * log\_10(2) ) = 8.}}
\DoxyCodeLine{374     \textcolor{comment}{//}}
\DoxyCodeLine{375     \textcolor{comment}{// (A smaller distance gamma-\/alpha would require a larger table.)}}
\DoxyCodeLine{376 }
\DoxyCodeLine{377     \textcolor{comment}{// NB:}}
\DoxyCodeLine{378     \textcolor{comment}{// Actually this function returns c, such that -\/60 <= e\_c + e + 64 <= -\/34.}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kCachedPowersMinDecExp = -\/300;}
\DoxyCodeLine{381     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kCachedPowersDecStep = 8;}
\DoxyCodeLine{382 }
\DoxyCodeLine{383     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::array<cached\_power, 79> kCachedPowers =}
\DoxyCodeLine{384     \{}
\DoxyCodeLine{385         \{}
\DoxyCodeLine{386             \{ 0xAB70FE17C79AC6CA, -\/1060, -\/300 \},}
\DoxyCodeLine{387             \{ 0xFF77B1FCBEBCDC4F, -\/1034, -\/292 \},}
\DoxyCodeLine{388             \{ 0xBE5691EF416BD60C, -\/1007, -\/284 \},}
\DoxyCodeLine{389             \{ 0x8DD01FAD907FFC3C,  -\/980, -\/276 \},}
\DoxyCodeLine{390             \{ 0xD3515C2831559A83,  -\/954, -\/268 \},}
\DoxyCodeLine{391             \{ 0x9D71AC8FADA6C9B5,  -\/927, -\/260 \},}
\DoxyCodeLine{392             \{ 0xEA9C227723EE8BCB,  -\/901, -\/252 \},}
\DoxyCodeLine{393             \{ 0xAECC49914078536D,  -\/874, -\/244 \},}
\DoxyCodeLine{394             \{ 0x823C12795DB6CE57,  -\/847, -\/236 \},}
\DoxyCodeLine{395             \{ 0xC21094364DFB5637,  -\/821, -\/228 \},}
\DoxyCodeLine{396             \{ 0x9096EA6F3848984F,  -\/794, -\/220 \},}
\DoxyCodeLine{397             \{ 0xD77485CB25823AC7,  -\/768, -\/212 \},}
\DoxyCodeLine{398             \{ 0xA086CFCD97BF97F4,  -\/741, -\/204 \},}
\DoxyCodeLine{399             \{ 0xEF340A98172AACE5,  -\/715, -\/196 \},}
\DoxyCodeLine{400             \{ 0xB23867FB2A35B28E,  -\/688, -\/188 \},}
\DoxyCodeLine{401             \{ 0x84C8D4DFD2C63F3B,  -\/661, -\/180 \},}
\DoxyCodeLine{402             \{ 0xC5DD44271AD3CDBA,  -\/635, -\/172 \},}
\DoxyCodeLine{403             \{ 0x936B9FCEBB25C996,  -\/608, -\/164 \},}
\DoxyCodeLine{404             \{ 0xDBAC6C247D62A584,  -\/582, -\/156 \},}
\DoxyCodeLine{405             \{ 0xA3AB66580D5FDAF6,  -\/555, -\/148 \},}
\DoxyCodeLine{406             \{ 0xF3E2F893DEC3F126,  -\/529, -\/140 \},}
\DoxyCodeLine{407             \{ 0xB5B5ADA8AAFF80B8,  -\/502, -\/132 \},}
\DoxyCodeLine{408             \{ 0x87625F056C7C4A8B,  -\/475, -\/124 \},}
\DoxyCodeLine{409             \{ 0xC9BCFF6034C13053,  -\/449, -\/116 \},}
\DoxyCodeLine{410             \{ 0x964E858C91BA2655,  -\/422, -\/108 \},}
\DoxyCodeLine{411             \{ 0xDFF9772470297EBD,  -\/396, -\/100 \},}
\DoxyCodeLine{412             \{ 0xA6DFBD9FB8E5B88F,  -\/369,  -\/92 \},}
\DoxyCodeLine{413             \{ 0xF8A95FCF88747D94,  -\/343,  -\/84 \},}
\DoxyCodeLine{414             \{ 0xB94470938FA89BCF,  -\/316,  -\/76 \},}
\DoxyCodeLine{415             \{ 0x8A08F0F8BF0F156B,  -\/289,  -\/68 \},}
\DoxyCodeLine{416             \{ 0xCDB02555653131B6,  -\/263,  -\/60 \},}
\DoxyCodeLine{417             \{ 0x993FE2C6D07B7FAC,  -\/236,  -\/52 \},}
\DoxyCodeLine{418             \{ 0xE45C10C42A2B3B06,  -\/210,  -\/44 \},}
\DoxyCodeLine{419             \{ 0xAA242499697392D3,  -\/183,  -\/36 \},}
\DoxyCodeLine{420             \{ 0xFD87B5F28300CA0E,  -\/157,  -\/28 \},}
\DoxyCodeLine{421             \{ 0xBCE5086492111AEB,  -\/130,  -\/20 \},}
\DoxyCodeLine{422             \{ 0x8CBCCC096F5088CC,  -\/103,  -\/12 \},}
\DoxyCodeLine{423             \{ 0xD1B71758E219652C,   -\/77,   -\/4 \},}
\DoxyCodeLine{424             \{ 0x9C40000000000000,   -\/50,    4 \},}
\DoxyCodeLine{425             \{ 0xE8D4A51000000000,   -\/24,   12 \},}
\DoxyCodeLine{426             \{ 0xAD78EBC5AC620000,     3,   20 \},}
\DoxyCodeLine{427             \{ 0x813F3978F8940984,    30,   28 \},}
\DoxyCodeLine{428             \{ 0xC097CE7BC90715B3,    56,   36 \},}
\DoxyCodeLine{429             \{ 0x8F7E32CE7BEA5C70,    83,   44 \},}
\DoxyCodeLine{430             \{ 0xD5D238A4ABE98068,   109,   52 \},}
\DoxyCodeLine{431             \{ 0x9F4F2726179A2245,   136,   60 \},}
\DoxyCodeLine{432             \{ 0xED63A231D4C4FB27,   162,   68 \},}
\DoxyCodeLine{433             \{ 0xB0DE65388CC8ADA8,   189,   76 \},}
\DoxyCodeLine{434             \{ 0x83C7088E1AAB65DB,   216,   84 \},}
\DoxyCodeLine{435             \{ 0xC45D1DF942711D9A,   242,   92 \},}
\DoxyCodeLine{436             \{ 0x924D692CA61BE758,   269,  100 \},}
\DoxyCodeLine{437             \{ 0xDA01EE641A708DEA,   295,  108 \},}
\DoxyCodeLine{438             \{ 0xA26DA3999AEF774A,   322,  116 \},}
\DoxyCodeLine{439             \{ 0xF209787BB47D6B85,   348,  124 \},}
\DoxyCodeLine{440             \{ 0xB454E4A179DD1877,   375,  132 \},}
\DoxyCodeLine{441             \{ 0x865B86925B9BC5C2,   402,  140 \},}
\DoxyCodeLine{442             \{ 0xC83553C5C8965D3D,   428,  148 \},}
\DoxyCodeLine{443             \{ 0x952AB45CFA97A0B3,   455,  156 \},}
\DoxyCodeLine{444             \{ 0xDE469FBD99A05FE3,   481,  164 \},}
\DoxyCodeLine{445             \{ 0xA59BC234DB398C25,   508,  172 \},}
\DoxyCodeLine{446             \{ 0xF6C69A72A3989F5C,   534,  180 \},}
\DoxyCodeLine{447             \{ 0xB7DCBF5354E9BECE,   561,  188 \},}
\DoxyCodeLine{448             \{ 0x88FCF317F22241E2,   588,  196 \},}
\DoxyCodeLine{449             \{ 0xCC20CE9BD35C78A5,   614,  204 \},}
\DoxyCodeLine{450             \{ 0x98165AF37B2153DF,   641,  212 \},}
\DoxyCodeLine{451             \{ 0xE2A0B5DC971F303A,   667,  220 \},}
\DoxyCodeLine{452             \{ 0xA8D9D1535CE3B396,   694,  228 \},}
\DoxyCodeLine{453             \{ 0xFB9B7CD9A4A7443C,   720,  236 \},}
\DoxyCodeLine{454             \{ 0xBB764C4CA7A44410,   747,  244 \},}
\DoxyCodeLine{455             \{ 0x8BAB8EEFB6409C1A,   774,  252 \},}
\DoxyCodeLine{456             \{ 0xD01FEF10A657842C,   800,  260 \},}
\DoxyCodeLine{457             \{ 0x9B10A4E5E9913129,   827,  268 \},}
\DoxyCodeLine{458             \{ 0xE7109BFBA19C0C9D,   853,  276 \},}
\DoxyCodeLine{459             \{ 0xAC2820D9623BF429,   880,  284 \},}
\DoxyCodeLine{460             \{ 0x80444B5E7AA7CF85,   907,  292 \},}
\DoxyCodeLine{461             \{ 0xBF21E44003ACDD2D,   933,  300 \},}
\DoxyCodeLine{462             \{ 0x8E679C2F5E44FF8F,   960,  308 \},}
\DoxyCodeLine{463             \{ 0xD433179D9C8CB841,   986,  316 \},}
\DoxyCodeLine{464             \{ 0x9E19DB92B4E31BA9,  1013,  324 \},}
\DoxyCodeLine{465         \}}
\DoxyCodeLine{466     \};}
\DoxyCodeLine{467 }
\DoxyCodeLine{468     \textcolor{comment}{// This computation gives exactly the same results for k as}}
\DoxyCodeLine{469     \textcolor{comment}{//      k = ceil((kAlpha -\/ e -\/ 1) * 0.30102999566398114)}}
\DoxyCodeLine{470     \textcolor{comment}{// for |e| <= 1500, but doesn't require floating-\/point operations.}}
\DoxyCodeLine{471     \textcolor{comment}{// NB: log\_10(2) \string~= 78913 / 2\string^18}}
\DoxyCodeLine{472     JSON\_ASSERT(e >= -\/1500);}
\DoxyCodeLine{473     JSON\_ASSERT(e <=  1500);}
\DoxyCodeLine{474     \textcolor{keyword}{const} \textcolor{keywordtype}{int} f = kAlpha -\/ e -\/ 1;}
\DoxyCodeLine{475     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = (f * 78913) / (1 << 18) + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(f > 0);}
\DoxyCodeLine{476 }
\DoxyCodeLine{477     \textcolor{keyword}{const} \textcolor{keywordtype}{int} index = (-\/kCachedPowersMinDecExp + k + (kCachedPowersDecStep -\/ 1)) / kCachedPowersDecStep;}
\DoxyCodeLine{478     JSON\_ASSERT(index >= 0);}
\DoxyCodeLine{479     JSON\_ASSERT(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(index) < kCachedPowers.size());}
\DoxyCodeLine{480 }
\DoxyCodeLine{481     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1cached__power}{cached\_power}} cached = kCachedPowers[\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(index)];}
\DoxyCodeLine{482     JSON\_ASSERT(kAlpha <= cached.e + e + 64);}
\DoxyCodeLine{483     JSON\_ASSERT(kGamma >= cached.e + e + 64);}
\DoxyCodeLine{484 }
\DoxyCodeLine{485     \textcolor{keywordflow}{return} cached;}
\DoxyCodeLine{486 \}}
\DoxyCodeLine{487 }
\DoxyCodeLine{492 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a04eb234a28617519974fc962cd4da666}{find\_largest\_pow10}}(\textcolor{keyword}{const} std::uint32\_t n, std::uint32\_t\& pow10)}
\DoxyCodeLine{493 \{}
\DoxyCodeLine{494     \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{495     \textcolor{keywordflow}{if} (n >= 1000000000)}
\DoxyCodeLine{496     \{}
\DoxyCodeLine{497         pow10 = 1000000000;}
\DoxyCodeLine{498         \textcolor{keywordflow}{return} 10;}
\DoxyCodeLine{499     \}}
\DoxyCodeLine{500     \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{501     \textcolor{keywordflow}{if} (n >= 100000000)}
\DoxyCodeLine{502     \{}
\DoxyCodeLine{503         pow10 = 100000000;}
\DoxyCodeLine{504         \textcolor{keywordflow}{return}  9;}
\DoxyCodeLine{505     \}}
\DoxyCodeLine{506     \textcolor{keywordflow}{if} (n >= 10000000)}
\DoxyCodeLine{507     \{}
\DoxyCodeLine{508         pow10 = 10000000;}
\DoxyCodeLine{509         \textcolor{keywordflow}{return}  8;}
\DoxyCodeLine{510     \}}
\DoxyCodeLine{511     \textcolor{keywordflow}{if} (n >= 1000000)}
\DoxyCodeLine{512     \{}
\DoxyCodeLine{513         pow10 = 1000000;}
\DoxyCodeLine{514         \textcolor{keywordflow}{return}  7;}
\DoxyCodeLine{515     \}}
\DoxyCodeLine{516     \textcolor{keywordflow}{if} (n >= 100000)}
\DoxyCodeLine{517     \{}
\DoxyCodeLine{518         pow10 = 100000;}
\DoxyCodeLine{519         \textcolor{keywordflow}{return}  6;}
\DoxyCodeLine{520     \}}
\DoxyCodeLine{521     \textcolor{keywordflow}{if} (n >= 10000)}
\DoxyCodeLine{522     \{}
\DoxyCodeLine{523         pow10 = 10000;}
\DoxyCodeLine{524         \textcolor{keywordflow}{return}  5;}
\DoxyCodeLine{525     \}}
\DoxyCodeLine{526     \textcolor{keywordflow}{if} (n >= 1000)}
\DoxyCodeLine{527     \{}
\DoxyCodeLine{528         pow10 = 1000;}
\DoxyCodeLine{529         \textcolor{keywordflow}{return}  4;}
\DoxyCodeLine{530     \}}
\DoxyCodeLine{531     \textcolor{keywordflow}{if} (n >= 100)}
\DoxyCodeLine{532     \{}
\DoxyCodeLine{533         pow10 = 100;}
\DoxyCodeLine{534         \textcolor{keywordflow}{return}  3;}
\DoxyCodeLine{535     \}}
\DoxyCodeLine{536     \textcolor{keywordflow}{if} (n >= 10)}
\DoxyCodeLine{537     \{}
\DoxyCodeLine{538         pow10 = 10;}
\DoxyCodeLine{539         \textcolor{keywordflow}{return}  2;}
\DoxyCodeLine{540     \}}
\DoxyCodeLine{541 }
\DoxyCodeLine{542     pow10 = 1;}
\DoxyCodeLine{543     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{544 \}}
\DoxyCodeLine{545 }
\DoxyCodeLine{546 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} grisu2\_round(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int} len, std::uint64\_t dist, std::uint64\_t delta,}
\DoxyCodeLine{547                          std::uint64\_t rest, std::uint64\_t ten\_k)}
\DoxyCodeLine{548 \{}
\DoxyCodeLine{549     JSON\_ASSERT(len >= 1);}
\DoxyCodeLine{550     JSON\_ASSERT(dist <= delta);}
\DoxyCodeLine{551     JSON\_ASSERT(rest <= delta);}
\DoxyCodeLine{552     JSON\_ASSERT(ten\_k > 0);}
\DoxyCodeLine{553 }
\DoxyCodeLine{554     \textcolor{comment}{//               <-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ delta -\/-\/-\/-\/>}}
\DoxyCodeLine{555     \textcolor{comment}{//                                  <-\/-\/-\/-\/ dist -\/-\/-\/-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{556     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{557     \textcolor{comment}{//               M-\/                 w                   M+}}
\DoxyCodeLine{558     \textcolor{comment}{//}}
\DoxyCodeLine{559     \textcolor{comment}{//                                  ten\_k}}
\DoxyCodeLine{560     \textcolor{comment}{//                                <-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{561     \textcolor{comment}{//                                       <-\/-\/-\/-\/ rest -\/-\/-\/-\/>}}
\DoxyCodeLine{562     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{563     \textcolor{comment}{//                                  w    V}}
\DoxyCodeLine{564     \textcolor{comment}{//                                       = buf * 10\string^k}}
\DoxyCodeLine{565     \textcolor{comment}{//}}
\DoxyCodeLine{566     \textcolor{comment}{// ten\_k represents a unit-\/in-\/the-\/last-\/place in the decimal representation}}
\DoxyCodeLine{567     \textcolor{comment}{// stored in buf.}}
\DoxyCodeLine{568     \textcolor{comment}{// Decrement buf by ten\_k while this takes buf closer to w.}}
\DoxyCodeLine{569 }
\DoxyCodeLine{570     \textcolor{comment}{// The tests are written in this order to avoid overflow in unsigned}}
\DoxyCodeLine{571     \textcolor{comment}{// integer arithmetic.}}
\DoxyCodeLine{572 }
\DoxyCodeLine{573     \textcolor{keywordflow}{while} (rest < dist}
\DoxyCodeLine{574             \&\& delta -\/ rest >= ten\_k}
\DoxyCodeLine{575             \&\& (rest + ten\_k < dist || dist -\/ rest > rest + ten\_k -\/ dist))}
\DoxyCodeLine{576     \{}
\DoxyCodeLine{577         JSON\_ASSERT(buf[len -\/ 1] != \textcolor{charliteral}{'0'});}
\DoxyCodeLine{578         buf[len -\/ 1]-\/-\/;}
\DoxyCodeLine{579         rest += ten\_k;}
\DoxyCodeLine{580     \}}
\DoxyCodeLine{581 \}}
\DoxyCodeLine{582 }
\DoxyCodeLine{587 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ae877aa13ab872c99a1c614e5e1524807}{grisu2\_digit\_gen}}(\textcolor{keywordtype}{char}* buffer, \textcolor{keywordtype}{int}\& length, \textcolor{keywordtype}{int}\& decimal\_exponent,}
\DoxyCodeLine{588                              \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_minus, \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w, \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_plus)}
\DoxyCodeLine{589 \{}
\DoxyCodeLine{590     \textcolor{keyword}{static\_assert}(kAlpha >= -\/60, \textcolor{stringliteral}{"{}internal error"{}});}
\DoxyCodeLine{591     \textcolor{keyword}{static\_assert}(kGamma <= -\/32, \textcolor{stringliteral}{"{}internal error"{}});}
\DoxyCodeLine{592 }
\DoxyCodeLine{593     \textcolor{comment}{// Generates the digits (and the exponent) of a decimal floating-\/point}}
\DoxyCodeLine{594     \textcolor{comment}{// number V = buffer * 10\string^decimal\_exponent in the range [M-\/, M+]. The diyfp's}}
\DoxyCodeLine{595     \textcolor{comment}{// w, M-\/ and M+ share the same exponent e, which satisfies alpha <= e <= gamma.}}
\DoxyCodeLine{596     \textcolor{comment}{//}}
\DoxyCodeLine{597     \textcolor{comment}{//               <-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ delta -\/-\/-\/-\/>}}
\DoxyCodeLine{598     \textcolor{comment}{//                                  <-\/-\/-\/-\/ dist -\/-\/-\/-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{599     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{600     \textcolor{comment}{//               M-\/                 w                   M+}}
\DoxyCodeLine{601     \textcolor{comment}{//}}
\DoxyCodeLine{602     \textcolor{comment}{// Grisu2 generates the digits of M+ from left to right and stops as soon as}}
\DoxyCodeLine{603     \textcolor{comment}{// V is in [M-\/,M+].}}
\DoxyCodeLine{604 }
\DoxyCodeLine{605     JSON\_ASSERT(M\_plus.e >= kAlpha);}
\DoxyCodeLine{606     JSON\_ASSERT(M\_plus.e <= kGamma);}
\DoxyCodeLine{607 }
\DoxyCodeLine{608     std::uint64\_t delta = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a75142bace0b78b1e1433b1d35a7ff252}{diyfp::sub}}(M\_plus, M\_minus).f; \textcolor{comment}{// (significand of (M+ -\/ M-\/), implicit exponent is e)}}
\DoxyCodeLine{609     std::uint64\_t dist  = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a75142bace0b78b1e1433b1d35a7ff252}{diyfp::sub}}(M\_plus, w      ).f; \textcolor{comment}{// (significand of (M+ -\/ w ), implicit exponent is e)}}
\DoxyCodeLine{610 }
\DoxyCodeLine{611     \textcolor{comment}{// Split M+ = f * 2\string^e into two parts p1 and p2 (note: e < 0):}}
\DoxyCodeLine{612     \textcolor{comment}{//}}
\DoxyCodeLine{613     \textcolor{comment}{//      M+ = f * 2\string^e}}
\DoxyCodeLine{614     \textcolor{comment}{//         = ((f div 2\string^-\/e) * 2\string^-\/e + (f mod 2\string^-\/e)) * 2\string^e}}
\DoxyCodeLine{615     \textcolor{comment}{//         = ((p1        ) * 2\string^-\/e + (p2        )) * 2\string^e}}
\DoxyCodeLine{616     \textcolor{comment}{//         = p1 + p2 * 2\string^e}}
\DoxyCodeLine{617 }
\DoxyCodeLine{618     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} one(std::uint64\_t\{1\} << -\/M\_plus.e, M\_plus.e);}
\DoxyCodeLine{619 }
\DoxyCodeLine{620     \textcolor{keyword}{auto} p1 = \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(M\_plus.f >> -\/one.e); \textcolor{comment}{// p1 = f div 2\string^-\/e (Since -\/e >= 32, p1 fits into a 32-\/bit int.)}}
\DoxyCodeLine{621     std::uint64\_t p2 = M\_plus.f \& (one.f -\/ 1);                    \textcolor{comment}{// p2 = f mod 2\string^-\/e}}
\DoxyCodeLine{622 }
\DoxyCodeLine{623     \textcolor{comment}{// 1)}}
\DoxyCodeLine{624     \textcolor{comment}{//}}
\DoxyCodeLine{625     \textcolor{comment}{// Generate the digits of the integral part p1 = d[n-\/1]...d[1]d[0]}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627     JSON\_ASSERT(p1 > 0);}
\DoxyCodeLine{628 }
\DoxyCodeLine{629     std::uint32\_t pow10\{\};}
\DoxyCodeLine{630     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a04eb234a28617519974fc962cd4da666}{find\_largest\_pow10}}(p1, pow10);}
\DoxyCodeLine{631 }
\DoxyCodeLine{632     \textcolor{comment}{//      10\string^(k-\/1) <= p1 < 10\string^k, pow10 = 10\string^(k-\/1)}}
\DoxyCodeLine{633     \textcolor{comment}{//}}
\DoxyCodeLine{634     \textcolor{comment}{//      p1 = (p1 div 10\string^(k-\/1)) * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))}}
\DoxyCodeLine{635     \textcolor{comment}{//         = (d[k-\/1]         ) * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))}}
\DoxyCodeLine{636     \textcolor{comment}{//}}
\DoxyCodeLine{637     \textcolor{comment}{//      M+ = p1                                             + p2 * 2\string^e}}
\DoxyCodeLine{638     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))          + p2 * 2\string^e}}
\DoxyCodeLine{639     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + ((p1 mod 10\string^(k-\/1)) * 2\string^-\/e + p2) * 2\string^e}}
\DoxyCodeLine{640     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + (                         rest) * 2\string^e}}
\DoxyCodeLine{641     \textcolor{comment}{//}}
\DoxyCodeLine{642     \textcolor{comment}{// Now generate the digits d[n] of p1 from left to right (n = k-\/1,...,0)}}
\DoxyCodeLine{643     \textcolor{comment}{//}}
\DoxyCodeLine{644     \textcolor{comment}{//      p1 = d[k-\/1]...d[n] * 10\string^n + d[n-\/1]...d[0]}}
\DoxyCodeLine{645     \textcolor{comment}{//}}
\DoxyCodeLine{646     \textcolor{comment}{// but stop as soon as}}
\DoxyCodeLine{647     \textcolor{comment}{//}}
\DoxyCodeLine{648     \textcolor{comment}{//      rest * 2\string^e = (d[n-\/1]...d[0] * 2\string^-\/e + p2) * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{649 }
\DoxyCodeLine{650     \textcolor{keywordtype}{int} n = k;}
\DoxyCodeLine{651     \textcolor{keywordflow}{while} (n > 0)}
\DoxyCodeLine{652     \{}
\DoxyCodeLine{653         \textcolor{comment}{// Invariants:}}
\DoxyCodeLine{654         \textcolor{comment}{//      M+ = buffer * 10\string^n + (p1 + p2 * 2\string^e)    (buffer = 0 for n = k)}}
\DoxyCodeLine{655         \textcolor{comment}{//      pow10 = 10\string^(n-\/1) <= p1 < 10\string^n}}
\DoxyCodeLine{656         \textcolor{comment}{//}}
\DoxyCodeLine{657         \textcolor{keyword}{const} std::uint32\_t d = p1 / pow10;  \textcolor{comment}{// d = p1 div 10\string^(n-\/1)}}
\DoxyCodeLine{658         \textcolor{keyword}{const} std::uint32\_t r = p1 \% pow10;  \textcolor{comment}{// r = p1 mod 10\string^(n-\/1)}}
\DoxyCodeLine{659         \textcolor{comment}{//}}
\DoxyCodeLine{660         \textcolor{comment}{//      M+ = buffer * 10\string^n + (d * 10\string^(n-\/1) + r) + p2 * 2\string^e}}
\DoxyCodeLine{661         \textcolor{comment}{//         = (buffer * 10 + d) * 10\string^(n-\/1) + (r + p2 * 2\string^e)}}
\DoxyCodeLine{662         \textcolor{comment}{//}}
\DoxyCodeLine{663         JSON\_ASSERT(d <= 9);}
\DoxyCodeLine{664         buffer[length++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + d); \textcolor{comment}{// buffer := buffer * 10 + d}}
\DoxyCodeLine{665         \textcolor{comment}{//}}
\DoxyCodeLine{666         \textcolor{comment}{//      M+ = buffer * 10\string^(n-\/1) + (r + p2 * 2\string^e)}}
\DoxyCodeLine{667         \textcolor{comment}{//}}
\DoxyCodeLine{668         p1 = r;}
\DoxyCodeLine{669         n-\/-\/;}
\DoxyCodeLine{670         \textcolor{comment}{//}}
\DoxyCodeLine{671         \textcolor{comment}{//      M+ = buffer * 10\string^n + (p1 + p2 * 2\string^e)}}
\DoxyCodeLine{672         \textcolor{comment}{//      pow10 = 10\string^n}}
\DoxyCodeLine{673         \textcolor{comment}{//}}
\DoxyCodeLine{674 }
\DoxyCodeLine{675         \textcolor{comment}{// Now check if enough digits have been generated.}}
\DoxyCodeLine{676         \textcolor{comment}{// Compute}}
\DoxyCodeLine{677         \textcolor{comment}{//}}
\DoxyCodeLine{678         \textcolor{comment}{//      p1 + p2 * 2\string^e = (p1 * 2\string^-\/e + p2) * 2\string^e = rest * 2\string^e}}
\DoxyCodeLine{679         \textcolor{comment}{//}}
\DoxyCodeLine{680         \textcolor{comment}{// Note:}}
\DoxyCodeLine{681         \textcolor{comment}{// Since rest and delta share the same exponent e, it suffices to}}
\DoxyCodeLine{682         \textcolor{comment}{// compare the significands.}}
\DoxyCodeLine{683         \textcolor{keyword}{const} std::uint64\_t rest = (std::uint64\_t\{p1\} << -\/one.e) + p2;}
\DoxyCodeLine{684         \textcolor{keywordflow}{if} (rest <= delta)}
\DoxyCodeLine{685         \{}
\DoxyCodeLine{686             \textcolor{comment}{// V = buffer * 10\string^n, with M-\/ <= V <= M+.}}
\DoxyCodeLine{687 }
\DoxyCodeLine{688             decimal\_exponent += n;}
\DoxyCodeLine{689 }
\DoxyCodeLine{690             \textcolor{comment}{// We may now just stop. But instead look if the buffer could be}}
\DoxyCodeLine{691             \textcolor{comment}{// decremented to bring V closer to w.}}
\DoxyCodeLine{692             \textcolor{comment}{//}}
\DoxyCodeLine{693             \textcolor{comment}{// pow10 = 10\string^n is now 1 ulp in the decimal representation V.}}
\DoxyCodeLine{694             \textcolor{comment}{// The rounding procedure works with diyfp's with an implicit}}
\DoxyCodeLine{695             \textcolor{comment}{// exponent of e.}}
\DoxyCodeLine{696             \textcolor{comment}{//}}
\DoxyCodeLine{697             \textcolor{comment}{//      10\string^n = (10\string^n * 2\string^-\/e) * 2\string^e = ulp * 2\string^e}}
\DoxyCodeLine{698             \textcolor{comment}{//}}
\DoxyCodeLine{699             \textcolor{keyword}{const} std::uint64\_t ten\_n = std::uint64\_t\{pow10\} << -\/one.e;}
\DoxyCodeLine{700             grisu2\_round(buffer, length, dist, delta, rest, ten\_n);}
\DoxyCodeLine{701 }
\DoxyCodeLine{702             \textcolor{keywordflow}{return};}
\DoxyCodeLine{703         \}}
\DoxyCodeLine{704 }
\DoxyCodeLine{705         pow10 /= 10;}
\DoxyCodeLine{706         \textcolor{comment}{//}}
\DoxyCodeLine{707         \textcolor{comment}{//      pow10 = 10\string^(n-\/1) <= p1 < 10\string^n}}
\DoxyCodeLine{708         \textcolor{comment}{// Invariants restored.}}
\DoxyCodeLine{709     \}}
\DoxyCodeLine{710 }
\DoxyCodeLine{711     \textcolor{comment}{// 2)}}
\DoxyCodeLine{712     \textcolor{comment}{//}}
\DoxyCodeLine{713     \textcolor{comment}{// The digits of the integral part have been generated:}}
\DoxyCodeLine{714     \textcolor{comment}{//}}
\DoxyCodeLine{715     \textcolor{comment}{//      M+ = d[k-\/1]...d[1]d[0] + p2 * 2\string^e}}
\DoxyCodeLine{716     \textcolor{comment}{//         = buffer            + p2 * 2\string^e}}
\DoxyCodeLine{717     \textcolor{comment}{//}}
\DoxyCodeLine{718     \textcolor{comment}{// Now generate the digits of the fractional part p2 * 2\string^e.}}
\DoxyCodeLine{719     \textcolor{comment}{//}}
\DoxyCodeLine{720     \textcolor{comment}{// Note:}}
\DoxyCodeLine{721     \textcolor{comment}{// No decimal point is generated: the exponent is adjusted instead.}}
\DoxyCodeLine{722     \textcolor{comment}{//}}
\DoxyCodeLine{723     \textcolor{comment}{// p2 actually represents the fraction}}
\DoxyCodeLine{724     \textcolor{comment}{//}}
\DoxyCodeLine{725     \textcolor{comment}{//      p2 * 2\string^e}}
\DoxyCodeLine{726     \textcolor{comment}{//          = p2 / 2\string^-\/e}}
\DoxyCodeLine{727     \textcolor{comment}{//          = d[-\/1] / 10\string^1 + d[-\/2] / 10\string^2 + ...}}
\DoxyCodeLine{728     \textcolor{comment}{//}}
\DoxyCodeLine{729     \textcolor{comment}{// Now generate the digits d[-\/m] of p1 from left to right (m = 1,2,...)}}
\DoxyCodeLine{730     \textcolor{comment}{//}}
\DoxyCodeLine{731     \textcolor{comment}{//      p2 * 2\string^e = d[-\/1]d[-\/2]...d[-\/m] * 10\string^-\/m}}
\DoxyCodeLine{732     \textcolor{comment}{//                      + 10\string^-\/m * (d[-\/m-\/1] / 10\string^1 + d[-\/m-\/2] / 10\string^2 + ...)}}
\DoxyCodeLine{733     \textcolor{comment}{//}}
\DoxyCodeLine{734     \textcolor{comment}{// using}}
\DoxyCodeLine{735     \textcolor{comment}{//}}
\DoxyCodeLine{736     \textcolor{comment}{//      10\string^m * p2 = ((10\string^m * p2) div 2\string^-\/e) * 2\string^-\/e + ((10\string^m * p2) mod 2\string^-\/e)}}
\DoxyCodeLine{737     \textcolor{comment}{//                = (                   d) * 2\string^-\/e + (                   r)}}
\DoxyCodeLine{738     \textcolor{comment}{//}}
\DoxyCodeLine{739     \textcolor{comment}{// or}}
\DoxyCodeLine{740     \textcolor{comment}{//      10\string^m * p2 * 2\string^e = d + r * 2\string^e}}
\DoxyCodeLine{741     \textcolor{comment}{//}}
\DoxyCodeLine{742     \textcolor{comment}{// i.e.}}
\DoxyCodeLine{743     \textcolor{comment}{//}}
\DoxyCodeLine{744     \textcolor{comment}{//      M+ = buffer + p2 * 2\string^e}}
\DoxyCodeLine{745     \textcolor{comment}{//         = buffer + 10\string^-\/m * (d + r * 2\string^e)}}
\DoxyCodeLine{746     \textcolor{comment}{//         = (buffer * 10\string^m + d) * 10\string^-\/m + 10\string^-\/m * r * 2\string^e}}
\DoxyCodeLine{747     \textcolor{comment}{//}}
\DoxyCodeLine{748     \textcolor{comment}{// and stop as soon as 10\string^-\/m * r * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{749 }
\DoxyCodeLine{750     JSON\_ASSERT(p2 > delta);}
\DoxyCodeLine{751 }
\DoxyCodeLine{752     \textcolor{keywordtype}{int} m = 0;}
\DoxyCodeLine{753     \textcolor{keywordflow}{for} (;;)}
\DoxyCodeLine{754     \{}
\DoxyCodeLine{755         \textcolor{comment}{// Invariant:}}
\DoxyCodeLine{756         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * (d[-\/m-\/1] / 10 + d[-\/m-\/2] / 10\string^2 + ...) * 2\string^e}}
\DoxyCodeLine{757         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (p2                                 ) * 2\string^e}}
\DoxyCodeLine{758         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (10 * p2)                   ) * 2\string^e}}
\DoxyCodeLine{759         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * ((10*p2 div 2\string^-\/e) * 2\string^-\/e + (10*p2 mod 2\string^-\/e)) * 2\string^e}}
\DoxyCodeLine{760         \textcolor{comment}{//}}
\DoxyCodeLine{761         JSON\_ASSERT(p2 <= (std::numeric\_limits<std::uint64\_t>::max)() / 10);}
\DoxyCodeLine{762         p2 *= 10;}
\DoxyCodeLine{763         \textcolor{keyword}{const} std::uint64\_t d = p2 >> -\/one.e;     \textcolor{comment}{// d = (10 * p2) div 2\string^-\/e}}
\DoxyCodeLine{764         \textcolor{keyword}{const} std::uint64\_t r = p2 \& (one.f -\/ 1); \textcolor{comment}{// r = (10 * p2) mod 2\string^-\/e}}
\DoxyCodeLine{765         \textcolor{comment}{//}}
\DoxyCodeLine{766         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (d * 2\string^-\/e + r) * 2\string^e}}
\DoxyCodeLine{767         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (d + r * 2\string^e))}}
\DoxyCodeLine{768         \textcolor{comment}{//         = (buffer * 10 + d) * 10\string^(-\/m-\/1) + 10\string^(-\/m-\/1) * r * 2\string^e}}
\DoxyCodeLine{769         \textcolor{comment}{//}}
\DoxyCodeLine{770         JSON\_ASSERT(d <= 9);}
\DoxyCodeLine{771         buffer[length++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + d); \textcolor{comment}{// buffer := buffer * 10 + d}}
\DoxyCodeLine{772         \textcolor{comment}{//}}
\DoxyCodeLine{773         \textcolor{comment}{//      M+ = buffer * 10\string^(-\/m-\/1) + 10\string^(-\/m-\/1) * r * 2\string^e}}
\DoxyCodeLine{774         \textcolor{comment}{//}}
\DoxyCodeLine{775         p2 = r;}
\DoxyCodeLine{776         m++;}
\DoxyCodeLine{777         \textcolor{comment}{//}}
\DoxyCodeLine{778         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * p2 * 2\string^e}}
\DoxyCodeLine{779         \textcolor{comment}{// Invariant restored.}}
\DoxyCodeLine{780 }
\DoxyCodeLine{781         \textcolor{comment}{// Check if enough digits have been generated.}}
\DoxyCodeLine{782         \textcolor{comment}{//}}
\DoxyCodeLine{783         \textcolor{comment}{//      10\string^-\/m * p2 * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{784         \textcolor{comment}{//              p2 * 2\string^e <= 10\string^m * delta * 2\string^e}}
\DoxyCodeLine{785         \textcolor{comment}{//                    p2 <= 10\string^m * delta}}
\DoxyCodeLine{786         delta *= 10;}
\DoxyCodeLine{787         dist  *= 10;}
\DoxyCodeLine{788         \textcolor{keywordflow}{if} (p2 <= delta)}
\DoxyCodeLine{789         \{}
\DoxyCodeLine{790             \textcolor{keywordflow}{break};}
\DoxyCodeLine{791         \}}
\DoxyCodeLine{792     \}}
\DoxyCodeLine{793 }
\DoxyCodeLine{794     \textcolor{comment}{// V = buffer * 10\string^-\/m, with M-\/ <= V <= M+.}}
\DoxyCodeLine{795 }
\DoxyCodeLine{796     decimal\_exponent -\/= m;}
\DoxyCodeLine{797 }
\DoxyCodeLine{798     \textcolor{comment}{// 1 ulp in the decimal representation is now 10\string^-\/m.}}
\DoxyCodeLine{799     \textcolor{comment}{// Since delta and dist are now scaled by 10\string^m, we need to do the}}
\DoxyCodeLine{800     \textcolor{comment}{// same with ulp in order to keep the units in sync.}}
\DoxyCodeLine{801     \textcolor{comment}{//}}
\DoxyCodeLine{802     \textcolor{comment}{//      10\string^m * 10\string^-\/m = 1 = 2\string^-\/e * 2\string^e = ten\_m * 2\string^e}}
\DoxyCodeLine{803     \textcolor{comment}{//}}
\DoxyCodeLine{804     \textcolor{keyword}{const} std::uint64\_t ten\_m = one.f;}
\DoxyCodeLine{805     grisu2\_round(buffer, length, dist, delta, p2, ten\_m);}
\DoxyCodeLine{806 }
\DoxyCodeLine{807     \textcolor{comment}{// By construction this algorithm generates the shortest possible decimal}}
\DoxyCodeLine{808     \textcolor{comment}{// number (Loitsch, Theorem 6.2) which rounds back to w.}}
\DoxyCodeLine{809     \textcolor{comment}{// For an input number of precision p, at least}}
\DoxyCodeLine{810     \textcolor{comment}{//}}
\DoxyCodeLine{811     \textcolor{comment}{//      N = 1 + ceil(p * log\_10(2))}}
\DoxyCodeLine{812     \textcolor{comment}{//}}
\DoxyCodeLine{813     \textcolor{comment}{// decimal digits are sufficient to identify all binary floating-\/point}}
\DoxyCodeLine{814     \textcolor{comment}{// numbers (Matula, "{}In-\/and-\/Out conversions"{}).}}
\DoxyCodeLine{815     \textcolor{comment}{// This implies that the algorithm does not produce more than N decimal}}
\DoxyCodeLine{816     \textcolor{comment}{// digits.}}
\DoxyCodeLine{817     \textcolor{comment}{//}}
\DoxyCodeLine{818     \textcolor{comment}{//      N = 17 for p = 53 (IEEE double precision)}}
\DoxyCodeLine{819     \textcolor{comment}{//      N = 9  for p = 24 (IEEE single precision)}}
\DoxyCodeLine{820 \}}
\DoxyCodeLine{821 }
\DoxyCodeLine{827 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{828 inline \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ad549352ed1a9676a092d143a2daa3dee}{grisu2}}(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int}\& len, \textcolor{keywordtype}{int}\& decimal\_exponent,}
\DoxyCodeLine{829                    \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\_minus, \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} v, \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\_plus)}
\DoxyCodeLine{830 \{}
\DoxyCodeLine{831     JSON\_ASSERT(m\_plus.e == m\_minus.e);}
\DoxyCodeLine{832     JSON\_ASSERT(m\_plus.e == v.e);}
\DoxyCodeLine{833 }
\DoxyCodeLine{834     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/    (A)}}
\DoxyCodeLine{835     \textcolor{comment}{//          m-\/                      v                       m+}}
\DoxyCodeLine{836     \textcolor{comment}{//}}
\DoxyCodeLine{837     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/    (B)}}
\DoxyCodeLine{838     \textcolor{comment}{//                      m-\/          v                       m+}}
\DoxyCodeLine{839     \textcolor{comment}{//}}
\DoxyCodeLine{840     \textcolor{comment}{// First scale v (and m-\/ and m+) such that the exponent is in the range}}
\DoxyCodeLine{841     \textcolor{comment}{// [alpha, gamma].}}
\DoxyCodeLine{842 }
\DoxyCodeLine{843     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1cached__power}{cached\_power}} cached = \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a29ae6574f6be09a5c8ab08da9a3f71b4}{get\_cached\_power\_for\_binary\_exponent}}(m\_plus.e);}
\DoxyCodeLine{844 }
\DoxyCodeLine{845     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} c\_minus\_k(cached.f, cached.e); \textcolor{comment}{// = c \string~= 10\string^-\/k}}
\DoxyCodeLine{846 }
\DoxyCodeLine{847     \textcolor{comment}{// The exponent of the products is = v.e + c\_minus\_k.e + q and is in the range [alpha,gamma]}}
\DoxyCodeLine{848     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w       = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a046c61f2c13411677eedfb5b9b7a8226}{diyfp::mul}}(v,       c\_minus\_k);}
\DoxyCodeLine{849     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_minus = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a046c61f2c13411677eedfb5b9b7a8226}{diyfp::mul}}(m\_minus, c\_minus\_k);}
\DoxyCodeLine{850     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_plus  = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a046c61f2c13411677eedfb5b9b7a8226}{diyfp::mul}}(m\_plus,  c\_minus\_k);}
\DoxyCodeLine{851 }
\DoxyCodeLine{852     \textcolor{comment}{//  -\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/}}
\DoxyCodeLine{853     \textcolor{comment}{//          w-\/                      w                       w+}}
\DoxyCodeLine{854     \textcolor{comment}{//          = c*m-\/                  = c*v                   = c*m+}}
\DoxyCodeLine{855     \textcolor{comment}{//}}
\DoxyCodeLine{856     \textcolor{comment}{// diyfp::mul rounds its result and c\_minus\_k is approximated too. w, w-\/ and}}
\DoxyCodeLine{857     \textcolor{comment}{// w+ are now off by a small amount.}}
\DoxyCodeLine{858     \textcolor{comment}{// In fact:}}
\DoxyCodeLine{859     \textcolor{comment}{//}}
\DoxyCodeLine{860     \textcolor{comment}{//      w -\/ v * 10\string^k < 1 ulp}}
\DoxyCodeLine{861     \textcolor{comment}{//}}
\DoxyCodeLine{862     \textcolor{comment}{// To account for this inaccuracy, add resp. subtract 1 ulp.}}
\DoxyCodeLine{863     \textcolor{comment}{//}}
\DoxyCodeLine{864     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{865     \textcolor{comment}{//          w-\/  M-\/                  w                   M+  w+}}
\DoxyCodeLine{866     \textcolor{comment}{//}}
\DoxyCodeLine{867     \textcolor{comment}{// Now any number in [M-\/, M+] (bounds included) will round to w when input,}}
\DoxyCodeLine{868     \textcolor{comment}{// regardless of how the input rounding algorithm breaks ties.}}
\DoxyCodeLine{869     \textcolor{comment}{//}}
\DoxyCodeLine{870     \textcolor{comment}{// And digit\_gen generates the shortest possible such number in [M-\/, M+].}}
\DoxyCodeLine{871     \textcolor{comment}{// Note that this does not mean that Grisu2 always generates the shortest}}
\DoxyCodeLine{872     \textcolor{comment}{// possible number in the interval (m-\/, m+).}}
\DoxyCodeLine{873     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_minus(w\_minus.f + 1, w\_minus.e);}
\DoxyCodeLine{874     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_plus (w\_plus.f  -\/ 1, w\_plus.e );}
\DoxyCodeLine{875 }
\DoxyCodeLine{876     decimal\_exponent = -\/cached.k; \textcolor{comment}{// = -\/(-\/k) = k}}
\DoxyCodeLine{877 }
\DoxyCodeLine{878     \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ae877aa13ab872c99a1c614e5e1524807}{grisu2\_digit\_gen}}(buf, len, decimal\_exponent, M\_minus, w, M\_plus);}
\DoxyCodeLine{879 \}}
\DoxyCodeLine{880 }
\DoxyCodeLine{886 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{887 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{888 void \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ad549352ed1a9676a092d143a2daa3dee}{grisu2}}(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int}\& len, \textcolor{keywordtype}{int}\& decimal\_exponent, FloatType value)}
\DoxyCodeLine{889 \{}
\DoxyCodeLine{890     \textcolor{keyword}{static\_assert}(diyfp::kPrecision >= std::numeric\_limits<FloatType>::digits + 3,}
\DoxyCodeLine{891                   \textcolor{stringliteral}{"{}internal error: not enough precision"{}});}
\DoxyCodeLine{892 }
\DoxyCodeLine{893     JSON\_ASSERT(std::isfinite(value));}
\DoxyCodeLine{894     JSON\_ASSERT(value > 0);}
\DoxyCodeLine{895 }
\DoxyCodeLine{896     \textcolor{comment}{// If the neighbors (and boundaries) of 'value' are always computed for double-\/precision}}
\DoxyCodeLine{897     \textcolor{comment}{// numbers, all float's can be recovered using strtod (and strtof). However, the resulting}}
\DoxyCodeLine{898     \textcolor{comment}{// decimal representations are not exactly "{}short"{}.}}
\DoxyCodeLine{899     \textcolor{comment}{//}}
\DoxyCodeLine{900     \textcolor{comment}{// The documentation for 'std::to\_chars' (https://en.cppreference.com/w/cpp/utility/to\_chars)}}
\DoxyCodeLine{901     \textcolor{comment}{// says "{}value is converted to a string as if by std::sprintf in the default ("{}C"{}) locale"{}}}
\DoxyCodeLine{902     \textcolor{comment}{// and since sprintf promotes floats to doubles, I think this is exactly what 'std::to\_chars'}}
\DoxyCodeLine{903     \textcolor{comment}{// does.}}
\DoxyCodeLine{904     \textcolor{comment}{// On the other hand, the documentation for 'std::to\_chars' requires that "{}parsing the}}
\DoxyCodeLine{905     \textcolor{comment}{// representation using the corresponding std::from\_chars function recovers value exactly"{}. That}}
\DoxyCodeLine{906     \textcolor{comment}{// indicates that single precision floating-\/point numbers should be recovered using}}
\DoxyCodeLine{907     \textcolor{comment}{// 'std::strtof'.}}
\DoxyCodeLine{908     \textcolor{comment}{//}}
\DoxyCodeLine{909     \textcolor{comment}{// NB: If the neighbors are computed for single-\/precision numbers, there is a single float}}
\DoxyCodeLine{910     \textcolor{comment}{//     (7.0385307e-\/26f) which can't be recovered using strtod. The resulting double precision}}
\DoxyCodeLine{911     \textcolor{comment}{//     value is off by 1 ulp.}}
\DoxyCodeLine{912 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{913     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1boundaries}{boundaries}} w = \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a6a5ccf11847aab7a0f42f587b33935df}{compute\_boundaries}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{914 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{915     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1boundaries}{boundaries}} w = \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a6a5ccf11847aab7a0f42f587b33935df}{compute\_boundaries}}(value);}
\DoxyCodeLine{916 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{917 }
\DoxyCodeLine{918     \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ad549352ed1a9676a092d143a2daa3dee}{grisu2}}(buf, len, decimal\_exponent, w.minus, w.w, w.plus);}
\DoxyCodeLine{919 \}}
\DoxyCodeLine{920 }
\DoxyCodeLine{926 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{927 JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{928 inline \textcolor{keywordtype}{char}* \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_aec9f6655c3b629aeb0e8c887aea5da87}{append\_exponent}}(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int} e)}
\DoxyCodeLine{929 \{}
\DoxyCodeLine{930     JSON\_ASSERT(e > -\/1000);}
\DoxyCodeLine{931     JSON\_ASSERT(e <  1000);}
\DoxyCodeLine{932 }
\DoxyCodeLine{933     \textcolor{keywordflow}{if} (e < 0)}
\DoxyCodeLine{934     \{}
\DoxyCodeLine{935         e = -\/e;}
\DoxyCodeLine{936         *buf++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{937     \}}
\DoxyCodeLine{938     \textcolor{keywordflow}{else}}
\DoxyCodeLine{939     \{}
\DoxyCodeLine{940         *buf++ = \textcolor{charliteral}{'+'};}
\DoxyCodeLine{941     \}}
\DoxyCodeLine{942 }
\DoxyCodeLine{943     \textcolor{keyword}{auto} k = \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(e);}
\DoxyCodeLine{944     \textcolor{keywordflow}{if} (k < 10)}
\DoxyCodeLine{945     \{}
\DoxyCodeLine{946         \textcolor{comment}{// Always print at least two digits in the exponent.}}
\DoxyCodeLine{947         \textcolor{comment}{// This is for compatibility with printf("{}\%g"{}).}}
\DoxyCodeLine{948         *buf++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{949         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{950     \}}
\DoxyCodeLine{951     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (k < 100)}
\DoxyCodeLine{952     \{}
\DoxyCodeLine{953         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 10);}
\DoxyCodeLine{954         k \%= 10;}
\DoxyCodeLine{955         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{956     \}}
\DoxyCodeLine{957     \textcolor{keywordflow}{else}}
\DoxyCodeLine{958     \{}
\DoxyCodeLine{959         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 100);}
\DoxyCodeLine{960         k \%= 100;}
\DoxyCodeLine{961         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 10);}
\DoxyCodeLine{962         k \%= 10;}
\DoxyCodeLine{963         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{964     \}}
\DoxyCodeLine{965 }
\DoxyCodeLine{966     \textcolor{keywordflow}{return} buf;}
\DoxyCodeLine{967 \}}
\DoxyCodeLine{968 }
\DoxyCodeLine{978 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{979 JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{980 inline \textcolor{keywordtype}{char}* \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_afab91abfdd1cdf43cc2fcd5b9c4a7456}{format\_buffer}}(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} decimal\_exponent,}
\DoxyCodeLine{981                            \textcolor{keywordtype}{int} min\_exp, \textcolor{keywordtype}{int} max\_exp)}
\DoxyCodeLine{982 \{}
\DoxyCodeLine{983     JSON\_ASSERT(min\_exp < 0);}
\DoxyCodeLine{984     JSON\_ASSERT(max\_exp > 0);}
\DoxyCodeLine{985 }
\DoxyCodeLine{986     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = len;}
\DoxyCodeLine{987     \textcolor{keyword}{const} \textcolor{keywordtype}{int} n = len + decimal\_exponent;}
\DoxyCodeLine{988 }
\DoxyCodeLine{989     \textcolor{comment}{// v = buf * 10\string^(n-\/k)}}
\DoxyCodeLine{990     \textcolor{comment}{// k is the length of the buffer (number of decimal digits)}}
\DoxyCodeLine{991     \textcolor{comment}{// n is the position of the decimal point relative to the start of the buffer.}}
\DoxyCodeLine{992 }
\DoxyCodeLine{993     \textcolor{keywordflow}{if} (k <= n \&\& n <= max\_exp)}
\DoxyCodeLine{994     \{}
\DoxyCodeLine{995         \textcolor{comment}{// digits[000]}}
\DoxyCodeLine{996         \textcolor{comment}{// len <= max\_exp + 2}}
\DoxyCodeLine{997 }
\DoxyCodeLine{998         std::memset(buf + k, \textcolor{charliteral}{'0'}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n) -\/ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k));}
\DoxyCodeLine{999         \textcolor{comment}{// Make it look like a floating-\/point number (\#362, \#378)}}
\DoxyCodeLine{1000         buf[n + 0] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{1001         buf[n + 1] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{1002         \textcolor{keywordflow}{return} buf + (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n) + 2);}
\DoxyCodeLine{1003     \}}
\DoxyCodeLine{1004 }
\DoxyCodeLine{1005     \textcolor{keywordflow}{if} (0 < n \&\& n <= max\_exp)}
\DoxyCodeLine{1006     \{}
\DoxyCodeLine{1007         \textcolor{comment}{// dig.its}}
\DoxyCodeLine{1008         \textcolor{comment}{// len <= max\_digits10 + 1}}
\DoxyCodeLine{1009 }
\DoxyCodeLine{1010         JSON\_ASSERT(k > n);}
\DoxyCodeLine{1011 }
\DoxyCodeLine{1012         std::memmove(buf + (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n) + 1), buf + n, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k) -\/ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n));}
\DoxyCodeLine{1013         buf[n] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{1014         \textcolor{keywordflow}{return} buf + (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k) + 1U);}
\DoxyCodeLine{1015     \}}
\DoxyCodeLine{1016 }
\DoxyCodeLine{1017     \textcolor{keywordflow}{if} (min\_exp < n \&\& n <= 0)}
\DoxyCodeLine{1018     \{}
\DoxyCodeLine{1019         \textcolor{comment}{// 0.[000]digits}}
\DoxyCodeLine{1020         \textcolor{comment}{// len <= 2 + (-\/min\_exp -\/ 1) + max\_digits10}}
\DoxyCodeLine{1021 }
\DoxyCodeLine{1022         std::memmove(buf + (2 + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/n)), buf, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k));}
\DoxyCodeLine{1023         buf[0] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{1024         buf[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{1025         std::memset(buf + 2, \textcolor{charliteral}{'0'}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/n));}
\DoxyCodeLine{1026         \textcolor{keywordflow}{return} buf + (2U + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/n) + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k));}
\DoxyCodeLine{1027     \}}
\DoxyCodeLine{1028 }
\DoxyCodeLine{1029     \textcolor{keywordflow}{if} (k == 1)}
\DoxyCodeLine{1030     \{}
\DoxyCodeLine{1031         \textcolor{comment}{// dE+123}}
\DoxyCodeLine{1032         \textcolor{comment}{// len <= 1 + 5}}
\DoxyCodeLine{1033 }
\DoxyCodeLine{1034         buf += 1;}
\DoxyCodeLine{1035     \}}
\DoxyCodeLine{1036     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1037     \{}
\DoxyCodeLine{1038         \textcolor{comment}{// d.igitsE+123}}
\DoxyCodeLine{1039         \textcolor{comment}{// len <= max\_digits10 + 1 + 5}}
\DoxyCodeLine{1040 }
\DoxyCodeLine{1041         std::memmove(buf + 2, buf + 1, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k) -\/ 1);}
\DoxyCodeLine{1042         buf[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{1043         buf += 1 + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k);}
\DoxyCodeLine{1044     \}}
\DoxyCodeLine{1045 }
\DoxyCodeLine{1046     *buf++ = \textcolor{charliteral}{'e'};}
\DoxyCodeLine{1047     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_aec9f6655c3b629aeb0e8c887aea5da87}{append\_exponent}}(buf, n -\/ 1);}
\DoxyCodeLine{1048 \}}
\DoxyCodeLine{1049 }
\DoxyCodeLine{1050 \}  \textcolor{comment}{// namespace dtoa\_impl}}
\DoxyCodeLine{1051 }
\DoxyCodeLine{1062 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{1063 JSON\_HEDLEY\_NON\_NULL(1, 2)}
\DoxyCodeLine{1064 JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{1065 \textcolor{keywordtype}{char}* \mbox{\hyperlink{namespacedetail_a3f0588f1a546b169113e6e1e293168f4}{to\_chars}}(\textcolor{keywordtype}{char}* first, const \textcolor{keywordtype}{char}* last, FloatType value)}
\DoxyCodeLine{1066 \{}
\DoxyCodeLine{1067     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(last); \textcolor{comment}{// maybe unused -\/ fix warning}}
\DoxyCodeLine{1068     JSON\_ASSERT(std::isfinite(value));}
\DoxyCodeLine{1069 }
\DoxyCodeLine{1070     \textcolor{comment}{// Use signbit(value) instead of (value < 0) since signbit works for -\/0.}}
\DoxyCodeLine{1071     \textcolor{keywordflow}{if} (std::signbit(value))}
\DoxyCodeLine{1072     \{}
\DoxyCodeLine{1073         value = -\/\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}};}
\DoxyCodeLine{1074         *first++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{1075     \}}
\DoxyCodeLine{1076 }
\DoxyCodeLine{1077 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{1078 \textcolor{preprocessor}{\#pragma GCC diagnostic push}}
\DoxyCodeLine{1079 \textcolor{preprocessor}{\#pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}}}
\DoxyCodeLine{1080 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1081     \textcolor{keywordflow}{if} (value == 0) \textcolor{comment}{// +-\/0}}
\DoxyCodeLine{1082     \{}
\DoxyCodeLine{1083         *first++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{1084         \textcolor{comment}{// Make it look like a floating-\/point number (\#362, \#378)}}
\DoxyCodeLine{1085         *first++ = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{1086         *first++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{1087         \textcolor{keywordflow}{return} first;}
\DoxyCodeLine{1088     \}}
\DoxyCodeLine{1089 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{1090 \textcolor{preprocessor}{\#pragma GCC diagnostic pop}}
\DoxyCodeLine{1091 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1092 }
\DoxyCodeLine{1093     JSON\_ASSERT(last -\/ first >= std::numeric\_limits<FloatType>::max\_digits10);}
\DoxyCodeLine{1094 }
\DoxyCodeLine{1095     \textcolor{comment}{// Compute v = buffer * 10\string^decimal\_exponent.}}
\DoxyCodeLine{1096     \textcolor{comment}{// The decimal digits are stored in the buffer, which needs to be interpreted}}
\DoxyCodeLine{1097     \textcolor{comment}{// as an unsigned decimal integer.}}
\DoxyCodeLine{1098     \textcolor{comment}{// len is the length of the buffer, i.e. the number of decimal digits.}}
\DoxyCodeLine{1099     \textcolor{keywordtype}{int} len = 0;}
\DoxyCodeLine{1100     \textcolor{keywordtype}{int} decimal\_exponent = 0;}
\DoxyCodeLine{1101     \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ad549352ed1a9676a092d143a2daa3dee}{dtoa\_impl::grisu2}}(first, len, decimal\_exponent, value);}
\DoxyCodeLine{1102 }
\DoxyCodeLine{1103     JSON\_ASSERT(len <= std::numeric\_limits<FloatType>::max\_digits10);}
\DoxyCodeLine{1104 }
\DoxyCodeLine{1105     \textcolor{comment}{// Format the buffer like printf("{}\%.*g"{}, prec, value)}}
\DoxyCodeLine{1106     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kMinExp = -\/4;}
\DoxyCodeLine{1107     \textcolor{comment}{// Use digits10 here to increase compatibility with version 2.}}
\DoxyCodeLine{1108     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kMaxExp = std::numeric\_limits<FloatType>::digits10;}
\DoxyCodeLine{1109 }
\DoxyCodeLine{1110     JSON\_ASSERT(last -\/ first >= kMaxExp + 2);}
\DoxyCodeLine{1111     JSON\_ASSERT(last -\/ first >= 2 + (-\/kMinExp -\/ 1) + std::numeric\_limits<FloatType>::max\_digits10);}
\DoxyCodeLine{1112     JSON\_ASSERT(last -\/ first >= std::numeric\_limits<FloatType>::max\_digits10 + 6);}
\DoxyCodeLine{1113 }
\DoxyCodeLine{1114     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_afab91abfdd1cdf43cc2fcd5b9c4a7456}{dtoa\_impl::format\_buffer}}(first, len, decimal\_exponent, kMinExp, kMaxExp);}
\DoxyCodeLine{1115 \}}
\DoxyCodeLine{1116 }
\DoxyCodeLine{1117 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{1118 NLOHMANN\_JSON\_NAMESPACE\_END}

\end{DoxyCode}
