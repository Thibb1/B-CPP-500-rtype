\hypertarget{input__adapters_8hpp_source}{}\doxysection{input\+\_\+adapters.\+hpp}
\label{input__adapters_8hpp_source}\index{build/\_deps/json-\/src/include/nlohmann/detail/input/input\_adapters.hpp@{build/\_deps/json-\/src/include/nlohmann/detail/input/input\_adapters.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{2 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{7 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <cstring>} \textcolor{comment}{// strlen}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// begin, end, iterator\_traits, random\_access\_iterator\_tag, distance, next}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <memory>} \textcolor{comment}{// shared\_ptr, make\_shared, addressof}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <numeric>} \textcolor{comment}{// accumulate}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string, char\_traits}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// enable\_if, is\_base\_of, is\_pointer, is\_integral, remove\_pointer}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// pair, declval}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{22 \textcolor{preprocessor}{    \#include <cstdio>}   \textcolor{comment}{// FILE *}}
\DoxyCodeLine{23 \textcolor{preprocessor}{    \#include <istream>}  \textcolor{comment}{// istream}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#endif                  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <nlohmann/detail/iterators/iterator\_traits.hpp>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{30 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{31 \{}
\DoxyCodeLine{32 }
\DoxyCodeLine{34 \textcolor{keyword}{enum class} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} \{ json, cbor, msgpack, ubjson, bson, bjdata \};}
\DoxyCodeLine{35 }
\DoxyCodeLine{37 \textcolor{comment}{// input adapters //}}
\DoxyCodeLine{39 \textcolor{comment}{}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{45 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}}
\DoxyCodeLine{46 \{}
\DoxyCodeLine{47   \textcolor{keyword}{public}:}
\DoxyCodeLine{48     \textcolor{keyword}{using }char\_type = char;}
\DoxyCodeLine{49 }
\DoxyCodeLine{50     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{51     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}(std::FILE* f) noexcept}
\DoxyCodeLine{52         : m\_file(f)}
\DoxyCodeLine{53     \{}
\DoxyCodeLine{54         JSON\_ASSERT(m\_file != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{55     \}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57     \textcolor{comment}{// make class move-\/only}}
\DoxyCodeLine{58     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{59     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}(\mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\&\&) \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{60     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{61     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\& operator=(\mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{62     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{\string~file\_input\_adapter}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{63 }
\DoxyCodeLine{64     std::char\_traits<char>::int\_type get\_character() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{65     \{}
\DoxyCodeLine{66         \textcolor{keywordflow}{return} std::fgetc(m\_file);}
\DoxyCodeLine{67     \}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69   \textcolor{keyword}{private}:}
\DoxyCodeLine{71     std::FILE* m\_file;}
\DoxyCodeLine{72 \};}
\DoxyCodeLine{73 }
\DoxyCodeLine{74 }
\DoxyCodeLine{84 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}}
\DoxyCodeLine{85 \{}
\DoxyCodeLine{86   \textcolor{keyword}{public}:}
\DoxyCodeLine{87     \textcolor{keyword}{using }char\_type = char;}
\DoxyCodeLine{88 }
\DoxyCodeLine{89     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{\string~input\_stream\_adapter}}()}
\DoxyCodeLine{90     \{}
\DoxyCodeLine{91         \textcolor{comment}{// clear stream flags; we use underlying streambuf I/O, do not}}
\DoxyCodeLine{92         \textcolor{comment}{// maintain ifstream flags, except eof}}
\DoxyCodeLine{93         \textcolor{keywordflow}{if} (is != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{94         \{}
\DoxyCodeLine{95             is-\/>clear(is-\/>rdstate() \& std::ios::eofbit);}
\DoxyCodeLine{96         \}}
\DoxyCodeLine{97     \}}
\DoxyCodeLine{98 }
\DoxyCodeLine{99     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}(std::istream\& i)}
\DoxyCodeLine{100         : is(\&i), sb(i.rdbuf())}
\DoxyCodeLine{101     \{\}}
\DoxyCodeLine{102 }
\DoxyCodeLine{103     \textcolor{comment}{// delete because of pointer members}}
\DoxyCodeLine{104     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{105     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\& operator=(\mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{106     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\& operator=(\mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{107 }
\DoxyCodeLine{108     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}(\mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\&\& rhs) noexcept}
\DoxyCodeLine{109         : is(rhs.is), sb(rhs.sb)}
\DoxyCodeLine{110     \{}
\DoxyCodeLine{111         rhs.is = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{112         rhs.sb = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115     \textcolor{comment}{// std::istream/std::streambuf use std::char\_traits<char>::to\_int\_type, to}}
\DoxyCodeLine{116     \textcolor{comment}{// ensure that std::char\_traits<char>::eof() and the character 0xFF do not}}
\DoxyCodeLine{117     \textcolor{comment}{// end up as the same value, e.g. 0xFFFFFFFF.}}
\DoxyCodeLine{118     std::char\_traits<char>::int\_type get\_character()}
\DoxyCodeLine{119     \{}
\DoxyCodeLine{120         \textcolor{keyword}{auto} res = sb-\/>sbumpc();}
\DoxyCodeLine{121         \textcolor{comment}{// set eof manually, as we don't use the istream interface.}}
\DoxyCodeLine{122         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(res == std::char\_traits<char>::eof()))}
\DoxyCodeLine{123         \{}
\DoxyCodeLine{124             is-\/>clear(is-\/>rdstate() | std::ios::eofbit);}
\DoxyCodeLine{125         \}}
\DoxyCodeLine{126         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{127     \}}
\DoxyCodeLine{128 }
\DoxyCodeLine{129   \textcolor{keyword}{private}:}
\DoxyCodeLine{131     std::istream* is = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{132     std::streambuf* sb = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{133 \};}
\DoxyCodeLine{134 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \textcolor{comment}{// General-\/purpose iterator-\/based adapter. It might not be as fast as}}
\DoxyCodeLine{137 \textcolor{comment}{// theoretically possible for some containers, but it is extremely versatile.}}
\DoxyCodeLine{138 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{139 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter}}}
\DoxyCodeLine{140 \{}
\DoxyCodeLine{141   \textcolor{keyword}{public}:}
\DoxyCodeLine{142     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} std::iterator\_traits<IteratorType>::value\_type;}
\DoxyCodeLine{143 }
\DoxyCodeLine{144     \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter}}(IteratorType first, IteratorType last)}
\DoxyCodeLine{145         : current(std::move(first)), end(std::move(last))}
\DoxyCodeLine{146     \{\}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148     \textcolor{keyword}{typename} std::char\_traits<char\_type>::int\_type get\_character()}
\DoxyCodeLine{149     \{}
\DoxyCodeLine{150         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(current != end))}
\DoxyCodeLine{151         \{}
\DoxyCodeLine{152             \textcolor{keyword}{auto} result = std::char\_traits<char\_type>::to\_int\_type(*current);}
\DoxyCodeLine{153             std::advance(current, 1);}
\DoxyCodeLine{154             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{155         \}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157         \textcolor{keywordflow}{return} std::char\_traits<char\_type>::eof();}
\DoxyCodeLine{158     \}}
\DoxyCodeLine{159 }
\DoxyCodeLine{160   \textcolor{keyword}{private}:}
\DoxyCodeLine{161     IteratorType current;}
\DoxyCodeLine{162     IteratorType end;}
\DoxyCodeLine{163 }
\DoxyCodeLine{164     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter, \textcolor{keywordtype}{size\_t} T>}
\DoxyCodeLine{165     \textcolor{keyword}{friend} \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper}};}
\DoxyCodeLine{166 }
\DoxyCodeLine{167     \textcolor{keywordtype}{bool} empty()\textcolor{keyword}{ const}}
\DoxyCodeLine{168 \textcolor{keyword}{    }\{}
\DoxyCodeLine{169         \textcolor{keywordflow}{return} current == end;}
\DoxyCodeLine{170     \}}
\DoxyCodeLine{171 \};}
\DoxyCodeLine{172 }
\DoxyCodeLine{173 }
\DoxyCodeLine{174 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter, \textcolor{keywordtype}{size\_t} T>}
\DoxyCodeLine{175 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper}};}
\DoxyCodeLine{176 }
\DoxyCodeLine{177 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter>}
\DoxyCodeLine{178 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper}}<BaseInputAdapter, 4>}
\DoxyCodeLine{179 \{}
\DoxyCodeLine{180     \textcolor{comment}{// UTF-\/32}}
\DoxyCodeLine{181     \textcolor{keyword}{static} \textcolor{keywordtype}{void} fill\_buffer(BaseInputAdapter\& input,}
\DoxyCodeLine{182                             std::array<std::char\_traits<char>::int\_type, 4>\& utf8\_bytes,}
\DoxyCodeLine{183                             \textcolor{keywordtype}{size\_t}\& utf8\_bytes\_index,}
\DoxyCodeLine{184                             \textcolor{keywordtype}{size\_t}\& utf8\_bytes\_filled)}
\DoxyCodeLine{185     \{}
\DoxyCodeLine{186         utf8\_bytes\_index = 0;}
\DoxyCodeLine{187 }
\DoxyCodeLine{188         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(input.empty()))}
\DoxyCodeLine{189         \{}
\DoxyCodeLine{190             utf8\_bytes[0] = std::char\_traits<char>::eof();}
\DoxyCodeLine{191             utf8\_bytes\_filled = 1;}
\DoxyCodeLine{192         \}}
\DoxyCodeLine{193         \textcolor{keywordflow}{else}}
\DoxyCodeLine{194         \{}
\DoxyCodeLine{195             \textcolor{comment}{// get the current character}}
\DoxyCodeLine{196             \textcolor{keyword}{const} \textcolor{keyword}{auto} wc = input.get\_character();}
\DoxyCodeLine{197 }
\DoxyCodeLine{198             \textcolor{comment}{// UTF-\/32 to UTF-\/8 encoding}}
\DoxyCodeLine{199             \textcolor{keywordflow}{if} (wc < 0x80)}
\DoxyCodeLine{200             \{}
\DoxyCodeLine{201                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(wc);}
\DoxyCodeLine{202                 utf8\_bytes\_filled = 1;}
\DoxyCodeLine{203             \}}
\DoxyCodeLine{204             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (wc <= 0x7FF)}
\DoxyCodeLine{205             \{}
\DoxyCodeLine{206                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xC0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u) \& 0x1Fu));}
\DoxyCodeLine{207                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{208                 utf8\_bytes\_filled = 2;}
\DoxyCodeLine{209             \}}
\DoxyCodeLine{210             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (wc <= 0xFFFF)}
\DoxyCodeLine{211             \{}
\DoxyCodeLine{212                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xE0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 12u) \& 0x0Fu));}
\DoxyCodeLine{213                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u) \& 0x3Fu));}
\DoxyCodeLine{214                 utf8\_bytes[2] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{215                 utf8\_bytes\_filled = 3;}
\DoxyCodeLine{216             \}}
\DoxyCodeLine{217             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (wc <= 0x10FFFF)}
\DoxyCodeLine{218             \{}
\DoxyCodeLine{219                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xF0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 18u) \& 0x07u));}
\DoxyCodeLine{220                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 12u) \& 0x3Fu));}
\DoxyCodeLine{221                 utf8\_bytes[2] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u) \& 0x3Fu));}
\DoxyCodeLine{222                 utf8\_bytes[3] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{223                 utf8\_bytes\_filled = 4;}
\DoxyCodeLine{224             \}}
\DoxyCodeLine{225             \textcolor{keywordflow}{else}}
\DoxyCodeLine{226             \{}
\DoxyCodeLine{227                 \textcolor{comment}{// unknown character}}
\DoxyCodeLine{228                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(wc);}
\DoxyCodeLine{229                 utf8\_bytes\_filled = 1;}
\DoxyCodeLine{230             \}}
\DoxyCodeLine{231         \}}
\DoxyCodeLine{232     \}}
\DoxyCodeLine{233 \};}
\DoxyCodeLine{234 }
\DoxyCodeLine{235 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter>}
\DoxyCodeLine{236 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper}}<BaseInputAdapter, 2>}
\DoxyCodeLine{237 \{}
\DoxyCodeLine{238     \textcolor{comment}{// UTF-\/16}}
\DoxyCodeLine{239     \textcolor{keyword}{static} \textcolor{keywordtype}{void} fill\_buffer(BaseInputAdapter\& input,}
\DoxyCodeLine{240                             std::array<std::char\_traits<char>::int\_type, 4>\& utf8\_bytes,}
\DoxyCodeLine{241                             \textcolor{keywordtype}{size\_t}\& utf8\_bytes\_index,}
\DoxyCodeLine{242                             \textcolor{keywordtype}{size\_t}\& utf8\_bytes\_filled)}
\DoxyCodeLine{243     \{}
\DoxyCodeLine{244         utf8\_bytes\_index = 0;}
\DoxyCodeLine{245 }
\DoxyCodeLine{246         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(input.empty()))}
\DoxyCodeLine{247         \{}
\DoxyCodeLine{248             utf8\_bytes[0] = std::char\_traits<char>::eof();}
\DoxyCodeLine{249             utf8\_bytes\_filled = 1;}
\DoxyCodeLine{250         \}}
\DoxyCodeLine{251         \textcolor{keywordflow}{else}}
\DoxyCodeLine{252         \{}
\DoxyCodeLine{253             \textcolor{comment}{// get the current character}}
\DoxyCodeLine{254             \textcolor{keyword}{const} \textcolor{keyword}{auto} wc = input.get\_character();}
\DoxyCodeLine{255 }
\DoxyCodeLine{256             \textcolor{comment}{// UTF-\/16 to UTF-\/8 encoding}}
\DoxyCodeLine{257             \textcolor{keywordflow}{if} (wc < 0x80)}
\DoxyCodeLine{258             \{}
\DoxyCodeLine{259                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(wc);}
\DoxyCodeLine{260                 utf8\_bytes\_filled = 1;}
\DoxyCodeLine{261             \}}
\DoxyCodeLine{262             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (wc <= 0x7FF)}
\DoxyCodeLine{263             \{}
\DoxyCodeLine{264                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xC0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u)));}
\DoxyCodeLine{265                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{266                 utf8\_bytes\_filled = 2;}
\DoxyCodeLine{267             \}}
\DoxyCodeLine{268             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (0xD800 > wc || wc >= 0xE000)}
\DoxyCodeLine{269             \{}
\DoxyCodeLine{270                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xE0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 12u)));}
\DoxyCodeLine{271                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u) \& 0x3Fu));}
\DoxyCodeLine{272                 utf8\_bytes[2] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{273                 utf8\_bytes\_filled = 3;}
\DoxyCodeLine{274             \}}
\DoxyCodeLine{275             \textcolor{keywordflow}{else}}
\DoxyCodeLine{276             \{}
\DoxyCodeLine{277                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!input.empty()))}
\DoxyCodeLine{278                 \{}
\DoxyCodeLine{279                     \textcolor{keyword}{const} \textcolor{keyword}{auto} wc2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(input.get\_character());}
\DoxyCodeLine{280                     \textcolor{keyword}{const} \textcolor{keyword}{auto} charcode = 0x10000u + (((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3FFu) << 10u) | (wc2 \& 0x3FFu));}
\DoxyCodeLine{281                     utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xF0u | (charcode >> 18u));}
\DoxyCodeLine{282                     utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((charcode >> 12u) \& 0x3Fu));}
\DoxyCodeLine{283                     utf8\_bytes[2] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((charcode >> 6u) \& 0x3Fu));}
\DoxyCodeLine{284                     utf8\_bytes[3] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (charcode \& 0x3Fu));}
\DoxyCodeLine{285                     utf8\_bytes\_filled = 4;}
\DoxyCodeLine{286                 \}}
\DoxyCodeLine{287                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{288                 \{}
\DoxyCodeLine{289                     utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(wc);}
\DoxyCodeLine{290                     utf8\_bytes\_filled = 1;}
\DoxyCodeLine{291                 \}}
\DoxyCodeLine{292             \}}
\DoxyCodeLine{293         \}}
\DoxyCodeLine{294     \}}
\DoxyCodeLine{295 \};}
\DoxyCodeLine{296 }
\DoxyCodeLine{297 \textcolor{comment}{// Wraps another input apdater to convert wide character types into individual bytes.}}
\DoxyCodeLine{298 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter, \textcolor{keyword}{typename} W\textcolor{keywordtype}{id}eCharType>}
\DoxyCodeLine{299 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{wide\_string\_input\_adapter}}}
\DoxyCodeLine{300 \{}
\DoxyCodeLine{301   \textcolor{keyword}{public}:}
\DoxyCodeLine{302     \textcolor{keyword}{using }char\_type = char;}
\DoxyCodeLine{303 }
\DoxyCodeLine{304     \mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{wide\_string\_input\_adapter}}(BaseInputAdapter base)}
\DoxyCodeLine{305         : base\_adapter(base) \{\}}
\DoxyCodeLine{306 }
\DoxyCodeLine{307     \textcolor{keyword}{typename} std::char\_traits<char>::int\_type get\_character() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{308     \{}
\DoxyCodeLine{309         \textcolor{comment}{// check if buffer needs to be filled}}
\DoxyCodeLine{310         \textcolor{keywordflow}{if} (utf8\_bytes\_index == utf8\_bytes\_filled)}
\DoxyCodeLine{311         \{}
\DoxyCodeLine{312             fill\_buffer<sizeof(WideCharType)>();}
\DoxyCodeLine{313 }
\DoxyCodeLine{314             JSON\_ASSERT(utf8\_bytes\_filled > 0);}
\DoxyCodeLine{315             JSON\_ASSERT(utf8\_bytes\_index == 0);}
\DoxyCodeLine{316         \}}
\DoxyCodeLine{317 }
\DoxyCodeLine{318         \textcolor{comment}{// use buffer}}
\DoxyCodeLine{319         JSON\_ASSERT(utf8\_bytes\_filled > 0);}
\DoxyCodeLine{320         JSON\_ASSERT(utf8\_bytes\_index < utf8\_bytes\_filled);}
\DoxyCodeLine{321         \textcolor{keywordflow}{return} utf8\_bytes[utf8\_bytes\_index++];}
\DoxyCodeLine{322     \}}
\DoxyCodeLine{323 }
\DoxyCodeLine{324   \textcolor{keyword}{private}:}
\DoxyCodeLine{325     BaseInputAdapter base\_adapter;}
\DoxyCodeLine{326 }
\DoxyCodeLine{327     \textcolor{keyword}{template}<\textcolor{keywordtype}{size\_t} T>}
\DoxyCodeLine{328     \textcolor{keywordtype}{void} fill\_buffer()}
\DoxyCodeLine{329     \{}
\DoxyCodeLine{330         \mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper<BaseInputAdapter, T>::fill\_buffer}}(base\_adapter, utf8\_bytes, utf8\_bytes\_index, utf8\_bytes\_filled);}
\DoxyCodeLine{331     \}}
\DoxyCodeLine{332 }
\DoxyCodeLine{334     std::array<std::char\_traits<char>::int\_type, 4> utf8\_bytes = \{\{0, 0, 0, 0\}\};}
\DoxyCodeLine{335 }
\DoxyCodeLine{337     std::size\_t utf8\_bytes\_index = 0;}
\DoxyCodeLine{339     std::size\_t utf8\_bytes\_filled = 0;}
\DoxyCodeLine{340 \};}
\DoxyCodeLine{341 }
\DoxyCodeLine{342 }
\DoxyCodeLine{343 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{344 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__input__adapter__factory}{iterator\_input\_adapter\_factory}}}
\DoxyCodeLine{345 \{}
\DoxyCodeLine{346     \textcolor{keyword}{using }iterator\_type = IteratorType;}
\DoxyCodeLine{347     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} std::iterator\_traits<iterator\_type>::value\_type;}
\DoxyCodeLine{348     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{adapter\_type}} = \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter<iterator\_type>}};}
\DoxyCodeLine{349 }
\DoxyCodeLine{350     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{adapter\_type}} create(IteratorType first, IteratorType last)}
\DoxyCodeLine{351     \{}
\DoxyCodeLine{352         \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{adapter\_type}}(std::move(first), std::move(last));}
\DoxyCodeLine{353     \}}
\DoxyCodeLine{354 \};}
\DoxyCodeLine{355 }
\DoxyCodeLine{356 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{357 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__iterator__of__multibyte}{is\_iterator\_of\_multibyte}}}
\DoxyCodeLine{358 \{}
\DoxyCodeLine{359     \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} std::iterator\_traits<T>::value\_type;}
\DoxyCodeLine{360     \textcolor{keyword}{enum}}
\DoxyCodeLine{361     \{}
\DoxyCodeLine{362         value = \textcolor{keyword}{sizeof}(value\_type) > 1}
\DoxyCodeLine{363     \};}
\DoxyCodeLine{364 \};}
\DoxyCodeLine{365 }
\DoxyCodeLine{366 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{367 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__input__adapter__factory}{iterator\_input\_adapter\_factory}}<IteratorType, enable\_if\_t<\mbox{\hyperlink{structdetail_1_1is__iterator__of__multibyte}{is\_iterator\_of\_multibyte}}<IteratorType>::value>>}
\DoxyCodeLine{368 \{}
\DoxyCodeLine{369     \textcolor{keyword}{using }iterator\_type = IteratorType;}
\DoxyCodeLine{370     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} std::iterator\_traits<iterator\_type>::value\_type;}
\DoxyCodeLine{371     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{base\_adapter\_type}} = \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter<iterator\_type>}};}
\DoxyCodeLine{372     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{adapter\_type}} = \mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{wide\_string\_input\_adapter<base\_adapter\_type, char\_type>}};}
\DoxyCodeLine{373 }
\DoxyCodeLine{374     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{adapter\_type}} create(IteratorType first, IteratorType last)}
\DoxyCodeLine{375     \{}
\DoxyCodeLine{376         \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{adapter\_type}}(\mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{base\_adapter\_type}}(std::move(first), std::move(last)));}
\DoxyCodeLine{377     \}}
\DoxyCodeLine{378 \};}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 \textcolor{comment}{// General purpose iterator-\/based input}}
\DoxyCodeLine{381 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{382 \textcolor{keyword}{typename} \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter\_factory<IteratorType>::adapter\_type}} input\_adapter(IteratorType first, IteratorType last)}
\DoxyCodeLine{383 \{}
\DoxyCodeLine{384     \textcolor{keyword}{using }factory\_type = \mbox{\hyperlink{structdetail_1_1iterator__input__adapter__factory}{iterator\_input\_adapter\_factory<IteratorType>}};}
\DoxyCodeLine{385     \textcolor{keywordflow}{return} factory\_type::create(first, last);}
\DoxyCodeLine{386 \}}
\DoxyCodeLine{387 }
\DoxyCodeLine{388 \textcolor{comment}{// Convenience shorthand from container to iterator}}
\DoxyCodeLine{389 \textcolor{comment}{// Enables ADL on begin(container) and end(container)}}
\DoxyCodeLine{390 \textcolor{comment}{// Encloses the using declarations in namespace for not to leak them to outside scope}}
\DoxyCodeLine{391 }
\DoxyCodeLine{392 \textcolor{keyword}{namespace }container\_input\_adapter\_factory\_impl}
\DoxyCodeLine{393 \{}
\DoxyCodeLine{394 }
\DoxyCodeLine{395 \textcolor{keyword}{using }std::begin;}
\DoxyCodeLine{396 \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{397 }
\DoxyCodeLine{398 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ContainerType, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{399 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1container__input__adapter__factory__impl_1_1container__input__adapter__factory}{container\_input\_adapter\_factory}} \{\};}
\DoxyCodeLine{400 }
\DoxyCodeLine{401 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ContainerType>}
\DoxyCodeLine{402 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1container__input__adapter__factory__impl_1_1container__input__adapter__factory}{container\_input\_adapter\_factory}}< ContainerType,}
\DoxyCodeLine{403        void\_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>}
\DoxyCodeLine{404        \{}
\DoxyCodeLine{405            \textcolor{keyword}{using }adapter\_type = \textcolor{keyword}{decltype}(input\_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));}
\DoxyCodeLine{406 }
\DoxyCodeLine{407            \textcolor{keyword}{static} adapter\_type create(\textcolor{keyword}{const} ContainerType\& container)}
\DoxyCodeLine{408 \{}
\DoxyCodeLine{409     \textcolor{keywordflow}{return} input\_adapter(begin(container), end(container));}
\DoxyCodeLine{410 \}}
\DoxyCodeLine{411        \};}
\DoxyCodeLine{412 }
\DoxyCodeLine{413 \}  \textcolor{comment}{// namespace container\_input\_adapter\_factory\_impl}}
\DoxyCodeLine{414 }
\DoxyCodeLine{415 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ContainerType>}
\DoxyCodeLine{416 \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1container__input__adapter__factory__impl_1_1container__input__adapter__factory}{container\_input\_adapter\_factory\_impl::container\_input\_adapter\_factory<ContainerType>::adapter\_type}} input\_adapter(\textcolor{keyword}{const} ContainerType\& container)}
\DoxyCodeLine{417 \{}
\DoxyCodeLine{418     \textcolor{keywordflow}{return} \mbox{\hyperlink{structdetail_1_1container__input__adapter__factory__impl_1_1container__input__adapter__factory}{container\_input\_adapter\_factory\_impl::container\_input\_adapter\_factory<ContainerType>::create}}(container);}
\DoxyCodeLine{419 \}}
\DoxyCodeLine{420 }
\DoxyCodeLine{421 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{422 \textcolor{comment}{// Special cases with fast paths}}
\DoxyCodeLine{423 \textcolor{keyword}{inline} file\_input\_adapter input\_adapter(std::FILE* file)}
\DoxyCodeLine{424 \{}
\DoxyCodeLine{425     \textcolor{keywordflow}{return} file\_input\_adapter(file);}
\DoxyCodeLine{426 \}}
\DoxyCodeLine{427 }
\DoxyCodeLine{428 \textcolor{keyword}{inline} input\_stream\_adapter input\_adapter(std::istream\& stream)}
\DoxyCodeLine{429 \{}
\DoxyCodeLine{430     \textcolor{keywordflow}{return} input\_stream\_adapter(stream);}
\DoxyCodeLine{431 \}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433 \textcolor{keyword}{inline} input\_stream\_adapter input\_adapter(std::istream\&\& stream)}
\DoxyCodeLine{434 \{}
\DoxyCodeLine{435     \textcolor{keywordflow}{return} input\_stream\_adapter(stream);}
\DoxyCodeLine{436 \}}
\DoxyCodeLine{437 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{438 }
\DoxyCodeLine{439 \textcolor{keyword}{using }contiguous\_bytes\_input\_adapter = \textcolor{keyword}{decltype}(input\_adapter(std::declval<const char*>(), std::declval<const char*>()));}
\DoxyCodeLine{440 }
\DoxyCodeLine{441 \textcolor{comment}{// Null-\/delimited strings, and the like.}}
\DoxyCodeLine{442 \textcolor{keyword}{template} < \textcolor{keyword}{typename} CharT,}
\DoxyCodeLine{443            \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{444                std::is\_pointer<CharT>::value\&\&}
\DoxyCodeLine{445                !std::is\_array<CharT>::value\&\&}
\DoxyCodeLine{446                std::is\_integral<typename std::remove\_pointer<CharT>::type>::value\&\&}
\DoxyCodeLine{447                \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename} std::remove\_pointer<CharT>::type) == 1,}
\DoxyCodeLine{448                \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{449 contiguous\_bytes\_input\_adapter input\_adapter(CharT b)}
\DoxyCodeLine{450 \{}
\DoxyCodeLine{451     \textcolor{keyword}{auto} length = std::strlen(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(b));}
\DoxyCodeLine{452     \textcolor{keyword}{const} \textcolor{keyword}{auto}* ptr = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(b);}
\DoxyCodeLine{453     \textcolor{keywordflow}{return} input\_adapter(ptr, ptr + length);}
\DoxyCodeLine{454 \}}
\DoxyCodeLine{455 }
\DoxyCodeLine{456 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{457 \textcolor{keyword}{auto} input\_adapter(T (\&\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}})[N]) -\/> \textcolor{keyword}{decltype}(input\_adapter(\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}}, \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}} + N)) \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{458 \{}
\DoxyCodeLine{459     \textcolor{keywordflow}{return} input\_adapter(\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}}, \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}} + N);}
\DoxyCodeLine{460 \}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462 \textcolor{comment}{// This class only handles inputs of input\_buffer\_adapter type.}}
\DoxyCodeLine{463 \textcolor{comment}{// It's required so that expressions like \{ptr, len\} can be implicitly cast}}
\DoxyCodeLine{464 \textcolor{comment}{// to the correct adapter.}}
\DoxyCodeLine{465 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1span__input__adapter}{span\_input\_adapter}}}
\DoxyCodeLine{466 \{}
\DoxyCodeLine{467   \textcolor{keyword}{public}:}
\DoxyCodeLine{468     \textcolor{keyword}{template} < \textcolor{keyword}{typename} CharT,}
\DoxyCodeLine{469                \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{470                    std::is\_pointer<CharT>::value\&\&}
\DoxyCodeLine{471                    std::is\_integral<typename std::remove\_pointer<CharT>::type>::value\&\&}
\DoxyCodeLine{472                    \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename} std::remove\_pointer<CharT>::type) == 1,}
\DoxyCodeLine{473                    \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{474     \mbox{\hyperlink{classdetail_1_1span__input__adapter}{span\_input\_adapter}}(CharT b, std::size\_t l)}
\DoxyCodeLine{475         : ia(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(b), \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(b) + l) \{\}}
\DoxyCodeLine{476 }
\DoxyCodeLine{477     \textcolor{keyword}{template}<\textcolor{keyword}{class }IteratorType,}
\DoxyCodeLine{478              \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{479                  std::is\_same<typename iterator\_traits<IteratorType>::iterator\_category, std::random\_access\_iterator\_tag>\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{::value}},}
\DoxyCodeLine{480                  \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{481     \mbox{\hyperlink{classdetail_1_1span__input__adapter}{span\_input\_adapter}}(IteratorType first, IteratorType last)}
\DoxyCodeLine{482         : ia(input\_adapter(first, last)) \{\}}
\DoxyCodeLine{483 }
\DoxyCodeLine{484     contiguous\_bytes\_input\_adapter\&\& get()}
\DoxyCodeLine{485     \{}
\DoxyCodeLine{486         \textcolor{keywordflow}{return} std::move(ia); \textcolor{comment}{// NOLINT(hicpp-\/move-\/const-\/arg,performance-\/move-\/const-\/arg)}}
\DoxyCodeLine{487     \}}
\DoxyCodeLine{488 }
\DoxyCodeLine{489   \textcolor{keyword}{private}:}
\DoxyCodeLine{490     contiguous\_bytes\_input\_adapter ia;}
\DoxyCodeLine{491 \};}
\DoxyCodeLine{492 }
\DoxyCodeLine{493 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{494 NLOHMANN\_JSON\_NAMESPACE\_END}

\end{DoxyCode}
